
msgid ""
msgstr ""
"Project-Id-Version: The Starknet Book\n"
"POT-Creation-Date: 2023-10-13T09:44:00+09:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
#: src/title-page.md:1
msgid "The Starknet Book"
msgstr ""

#: src/SUMMARY.md:4
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:8
#: src/ch01-00-getting-started.md:1
#: src/ch02-07-starknet-js.md:29
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:10
msgid "Tooling"
msgstr ""

#: src/SUMMARY.md:13
msgid "Basic Installation"
msgstr ""

#: src/SUMMARY.md:14
msgid "Compile, Deploy, Interact"
msgstr ""

#: src/SUMMARY.md:15
#: src/ch02-03-scarb.md:1
msgid "Scarb: The Package Manager"
msgstr ""

#: src/SUMMARY.md:16
#: src/ch02-04-starkli.md:1
msgid "Starkli: A CLI interface 🚧"
msgstr ""

#: src/SUMMARY.md:17
#: src/ch02-05-katana.md:1
msgid "Katana: A Local Node"
msgstr ""

#: src/SUMMARY.md:18
#: src/ch02-06-starknet-devnet.md:1
msgid "Starknet Devnet 🚧"
msgstr ""

#: src/SUMMARY.md:19
#: src/ch02-07-starknet-js.md:1
msgid "Starknet-js: Javascript SDK"
msgstr ""

#: src/SUMMARY.md:20
#: src/SUMMARY.md:46
#: src/ch02-07-01-examples.md:1
#: src/ch04-04-examples.md:1
msgid "Examples"
msgstr ""

#: src/SUMMARY.md:21
msgid "Beginner - ERC-20 UI"
msgstr ""

#: src/SUMMARY.md:22
msgid "Intermediate - Million Dollar Homepage"
msgstr ""

#: src/SUMMARY.md:23
#: src/ch02-08-starknet-react.md:1
msgid "Starknet-React: React Integration"
msgstr ""

#: src/SUMMARY.md:24
#: src/ch02-09-starknet-py.md:1
msgid "Starknet-py: Python SDK 🚧"
msgstr ""

#: src/SUMMARY.md:25
#: src/ch02-10-starknet-rs.md:1
msgid "Starknet-rs: Rust SDK 🚧"
msgstr ""

#: src/SUMMARY.md:26
#: src/ch02-11-foundry-forge.md:1
msgid "Foundry Forge: Testing 🚧"
msgstr ""

#: src/SUMMARY.md:27
#: src/ch02-12-foundry-cast.md:1
msgid "Foundry Cast: Interacting with Starknet 🚧"
msgstr ""

#: src/SUMMARY.md:29
#: src/ch03-00-architecture.md:1
msgid "Architecture"
msgstr ""

#: src/SUMMARY.md:32
#: src/ch03-01-transactions.md:1
msgid "Transactions"
msgstr ""

#: src/SUMMARY.md:33
#: src/ch03-00-architecture.md:53
#: src/ch03-02-sequencers.md:1
msgid "Sequencers"
msgstr ""

#: src/SUMMARY.md:34
msgid "Provers 🚧"
msgstr ""

#: src/SUMMARY.md:35
msgid "Nodes 🚧"
msgstr ""

#: src/SUMMARY.md:36
msgid "Layer 3 and App Chains 🚧 "
msgstr ""

#: src/SUMMARY.md:37
#: src/ch03-06-solidity-verifier.md:1
msgid "Solidity Verifier 🚧"
msgstr ""

#: src/SUMMARY.md:38
#: src/ch03-07-decentralization.md:1
msgid "Decentralization 🚧"
msgstr ""

#: src/SUMMARY.md:40
#: src/ch04-00-account-abstraction.md:1
msgid "Account Abstraction"
msgstr ""

#: src/SUMMARY.md:43
msgid "Accounts"
msgstr ""

#: src/SUMMARY.md:44
msgid "Hello, Account! 🚧"
msgstr ""

#: src/SUMMARY.md:45
msgid "Standard AccounT 🚧"
msgstr ""

#: src/SUMMARY.md:47
msgid "Multicaller 🚧"
msgstr ""

#: src/SUMMARY.md:48
msgid "Multisig 🚧"
msgstr ""

#: src/SUMMARY.md:49
#: src/ch04-04-03-auto-payments.md:1
msgid "Auto-Payments 🚧"
msgstr ""

#: src/SUMMARY.md:50
#: src/ch04-04-04-alternative-signature-schemes.md:1
msgid "Alternative Signature Schemes 🚧"
msgstr ""

#: src/SUMMARY.md:54
msgid "STARKs 🚧"
msgstr ""

#: src/SUMMARY.md:55
msgid "Basics 🚧"
msgstr ""

#: src/SUMMARY.md:56
msgid "Math Primer 🚧"
msgstr ""

#: src/SUMMARY.md:57
msgid "Number Theory 🚧"
msgstr ""

#: src/SUMMARY.md:58
msgid "Geometry 🚧"
msgstr ""

#: src/SUMMARY.md:59
msgid "Cryptographic Primitives 🚧"
msgstr ""

#: src/SUMMARY.md:60
msgid "Arithimization 🚧"
msgstr ""

#: src/SUMMARY.md:61
msgid "Low Degree Testing 🚧"
msgstr ""

#: src/SUMMARY.md:62
msgid "FRI Protocol 🚧"
msgstr ""

#: src/SUMMARY.md:63
msgid "Efficient STARKs"
msgstr ""

#: src/SUMMARY.md:64
msgid "STARKs Protocol (Python) 🚧"
msgstr ""

#: src/SUMMARY.md:65
#: src/SUMMARY.md:70
msgid "Trace/Low Degree Extension 🚧"
msgstr ""

#: src/SUMMARY.md:66
#: src/SUMMARY.md:71
msgid "Constraints 🚧"
msgstr ""

#: src/SUMMARY.md:67
#: src/SUMMARY.md:72
msgid "FRI Commitments 🚧"
msgstr ""

#: src/SUMMARY.md:68
#: src/SUMMARY.md:73
msgid "Query Phase 🚧"
msgstr ""

#: src/SUMMARY.md:69
msgid "STARKs Protocol (Rust) 🚧"
msgstr ""

#: src/title-page.md:3
msgid ""
"The Starknet Book is a work in progress, shaped by ongoing community input. "
"Some sections may be incomplete or still under review and are marked under a "
"🚧 emoji. We welcome your suggestions, feedback, and content contributions to "
"make this book a reliable guide for everyone."
msgstr ""

#: src/title-page.md:8
msgid ""
"The Starknet Book is a step-by-step guide aimed at teaching you the "
"essentials of Starknet development. It’s a community effort, with each "
"chapter guiding you through the Starknet ecosystem."
msgstr ""

#: src/title-page.md:12
msgid ""
"Understanding Cairo, the key programming language for Starknet smart "
"contracts, is crucial. That’s why this book works hand-in-hand with the "
"Cairo Book, another community resource. You can access the Cairo Book "
"[**here**](https://book.cairo-lang.org/)."
msgstr ""

#: src/title-page.md:17
msgid ""
"In short, the Cairo Book helps you master Cairo, while The Starknet Book "
"focuses on Starknet’s specific features. For a well-rounded understanding, "
"we recommend exploring both. This book will introduce you to tools, "
"architecture, account setups, STARKs, and Starknet-specific apps."
msgstr ""

#: src/title-page.md:23
msgid "Table of Contents"
msgstr ""

#: src/title-page.md:25
msgid "**Chapter Titles**"
msgstr ""

#: src/title-page.md:27
msgid "Chapter"
msgstr ""

#: src/title-page.md:27
msgid "Description"
msgstr ""

#: src/title-page.md:29
msgid "1: Starknet Introduction"
msgstr ""

#: src/title-page.md:29
msgid ""
"Delve into the fundamental concepts of Starknet and acquaint yourself with "
"the deployment of smart contracts."
msgstr ""

#: src/title-page.md:30
msgid "2: Starknet Tooling"
msgstr ""

#: src/title-page.md:30
msgid ""
"Familiarize yourself with vital tools, such as Starknet-Foundry and Hardhat, and "
"explore how languages like Javascript, Python, and Rust can be leveraged for "
"Starknet interactions."
msgstr ""

#: src/title-page.md:31
msgid "3: Starknet Architecture"
msgstr ""

#: src/title-page.md:31
msgid ""
"Uncover Starknet’s core structure, gaining insights into the transaction "
"lifecycle and the interplay between the Sequencer, Prover, and Nodes."
msgstr ""

#: src/title-page.md:32
msgid "4: Account Abstraction"
msgstr ""

#: src/title-page.md:32
msgid ""
"Delve deep into Starknet’s unique approach to user accounts, and master the "
"art of crafting custom accounts."
msgstr ""

#: src/title-page.md:33
msgid "5: STARKs"
msgstr ""

#: src/title-page.md:33
msgid ""
"Dive into the intricacies of STARKs and their pivotal role in shaping "
"Starknet’s landscape."
msgstr ""

#: src/title-page.md:35
msgid "Where to Start?"
msgstr ""

#: src/title-page.md:37
msgid ""
"Depending on your goals and interests, you can choose different paths "
"through the Starknet Book. Here are some recommendations based on various "
"objectives:"
msgstr ""

#: src/title-page.md:41
msgid ""
"If you’re a **complete beginner** and want to start learning about Cairo and "
"Starknet from scratch, follow the book in its entirety, starting with "
"**Introduction to Starknet**."
msgstr ""

#: src/title-page.md:45
msgid ""
"If you’re an **experienced developer** looking to quickly dive into writing "
"scalable and decentralized smart contracts, focus on the Cairo Book, "
"particularly **chapter 12: Starknet Smart Contracts** "
"([link](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html))."
msgstr ""

#: src/title-page.md:50
msgid ""
"If you’re a **frontend developer** wanting to integrate Starknet with a "
"React frontend using Javascript, prioritize the **starknet-js** and "
"**starknet-react** subchapters in **Starknet Tooling**"
msgstr ""

#: src/title-page.md:55
msgid ""
"If you’re a **DevOps engineer** or **node operator** interested in running a "
"Starknet node and indexer, head straight to **Starknet Architecture**."
msgstr ""

#: src/title-page.md:59
msgid ""
"If you’re a **security researcher** or **smart contract auditor** wanting to "
"learn about the Account Abstraction feature and its implications, go for "
"**Account Abstraction**."
msgstr ""

#: src/title-page.md:63
msgid ""
"If you’re a **blockchain enthusiast** curious about the underlying "
"architecture and mechanics of Starknet and Cairo, explore **Starknet "
"Architecture**."
msgstr ""

#: src/title-page.md:67
msgid ""
"If you’re a **cryptography expert** or **researcher** eager to understand "
"the fundamentals of STARKs and their connection to the Starknet ecosystem, "
"delve into **STARKs**."
msgstr ""

#: src/title-page.md:71
msgid ""
"Feel free to mix and match these paths based on your unique interests and "
"requirements."
msgstr ""

#: src/title-page.md:74
msgid "Your Contributions Matter"
msgstr ""

#: src/title-page.md:76
msgid ""
"Welcome aboard! By contributing to the Starknet Book, you’re doing more than "
"sharing expertise—you’re shaping the future of decentralized tech. Let’s "
"build a guide that helps developers unlock Starknet’s potential."
msgstr ""

#: src/title-page.md:80
msgid ""
"For detailed contribution guidelines, visit the [Contributors "
"Guide](https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc). "
"Every contribution counts. Your skills and passion will help make this book "
"an invaluable tool."
msgstr ""

#: src/title-page.md:85
msgid "How You Can Help"
msgstr ""

#: src/title-page.md:87
msgid "Found an empty section? Fill it in!"
msgstr ""

#: src/title-page.md:89
msgid "Think we need a new section? Suggest one."
msgstr ""

#: src/title-page.md:91
msgid "See room for improvement? Go ahead and tweak it."
msgstr ""

#: src/title-page.md:93
msgid "Want to add code in a new programming language? Go for it."
msgstr ""

#: src/title-page.md:95
msgid "Found a bug? Fix it."
msgstr ""

#: src/title-page.md:97
msgid "Exercises unclear? Add explanations."
msgstr ""

#: src/title-page.md:99
msgid "Show off your favorite Cairo features through new exercises."
msgstr ""

#: src/title-page.md:101
msgid "Additional Key Educational Resources"
msgstr ""

#: src/title-page.md:103
msgid ""
"We’ve compiled a list of valuable educational resources that will help "
"deepen your understanding and enhance your skills in coding with Cairo and "
"staying abreast with Starknet developments:"
msgstr ""

#: src/title-page.md:107
msgid ""
"**Cairo Book**: A comprehensive guide to Cairo, the programming language for "
"Starknet smart contracts. You can access it "
"[here](https://book.cairo-lang.org/)."
msgstr ""

#: src/title-page.md:111
msgid ""
"**Starklings**: A resource specifically designed to guide you through "
"learning Cairo programming, ensuring that you reach a proficient level. You "
"can access it [here](https://github.com/shramee/starklings-cairo1)."
msgstr ""

#: src/title-page.md:116
msgid ""
"**Starknet Community Forum**: An online platform where you can engage in "
"discussions about the latest developments in Starknet. Join the conversation "
"[here](https://community.starknet.io/)."
msgstr ""

#: src/title-page.md:120
msgid ""
"**Starknet Documentation**: You can browse through the documentation "
"[here](https://docs.starknet.io/)."
msgstr ""

#: src/title-page.md:123
msgid ""
"**Cairo Documentation**: Explore it [here](https://www.cairo-lang.org/docs)."
msgstr ""

#: src/title-page.md:126
msgid ""
"**Starknet Developer Telegram (English)**: A community for English-speaking "
"Starknet developers. This is a great platform for networking, sharing ideas, "
"and troubleshooting together. Join us on Telegram "
"[here](https://t.me/starknetna)."
msgstr ""

#: src/ch00-00-introduction.md:1
msgid "The Starknet Network"
msgstr ""

#: src/ch00-00-introduction.md:3
msgid "Preamble"
msgstr ""

#: src/ch00-00-introduction.md:5
msgid ""
"Historically, societal roles like currency, property rights, and social "
"status titles have been governed by _protocols_ and _registries_. Their "
"value stems from a widely accepted understanding of their integrity. These "
"functions have predominantly been overseen by centralized entities prone to "
"challenges such as corruption, agency conflicts, and exclusion ([Eli "
"Ben-Sasson, Bareli, Brandt, Volokh, "
"2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""

#: src/ch00-00-introduction.md:7
msgid ""
"Satoshi's creation, Bitcoin, introduced a novel approach for these "
"functions, termed an _integrity web_. This is an infrastructure for societal "
"roles that:"
msgstr ""

#: src/ch00-00-introduction.md:9
msgid "Is openly described by a public protocol."
msgstr ""

#: src/ch00-00-introduction.md:10
msgid "Operates over a wide, inclusive, peer-to-peer network."
msgstr ""

#: src/ch00-00-introduction.md:11
msgid ""
"Distributes value fairly and extensively to maintain societal consensus on "
"its integrity."
msgstr ""

#: src/ch00-00-introduction.md:13
msgid ""
"While Bitcoin addressed monetary functions, Ethereum expanded this to "
"include any function that can be defined by computer programming. Both faced "
"the challenge of balancing scalability with decentralization. These "
"integrity webs have often favored inclusivity over capacity, ensuring even "
"those with limited resources can authenticate the system's integrity. Yet, "
"this means they struggle to meet global demand."
msgstr ""

#: src/ch00-00-introduction.md:15
msgid "Defining \"Blockchain\""
msgstr ""

#: src/ch00-00-introduction.md:17
msgid ""
"In the ever-evolving realm of technology, defining a term as multifaceted as "
"\"Blockchain\" can be challenging. Based on current understandings and "
"applications, a Blockchain can be characterized by the following three "
"properties ([Eli Ben-Sasson, "
"2023](https://twitter.com/EliBenSasson/status/1709272086504485265)):"
msgstr ""

#: src/ch00-00-introduction.md:19
msgid ""
"**Public Protocol:** The foundation of a Blockchain rests upon a protocol "
"that is openly available. This transparency ensures that any interested "
"party can understand its workings, fostering trust and enabling wider "
"adoption."
msgstr ""

#: src/ch00-00-introduction.md:20
msgid ""
"**Open P2P Network:** Instead of relying on a centralized entity, a "
"Blockchain operates over a peer-to-peer (P2P) network. This decentralized "
"approach ensures that operations are distributed across various participants "
"or nodes, making the system more resilient to failures and censorship."
msgstr ""

#: src/ch00-00-introduction.md:21
msgid ""
"**Value Distribution:** Central to the Blockchain's operation is the way it "
"rewards its operators. The system autonomously distributes value in a manner "
"that is wide-ranging and equitable. This incentivization not only motivates "
"participants to maintain the system's integrity but also ensures a broader "
"societal consensus."
msgstr ""

#: src/ch00-00-introduction.md:23
msgid ""
"While these properties capture the essence of many Blockchains, the term's "
"definition might need refinement as the technology matures and finds new "
"applications. Engaging in continuous dialogue and revisiting definitions "
"will be crucial in this dynamic landscape."
msgstr ""

#: src/ch00-00-introduction.md:25
msgid "Starknet Definition"
msgstr ""

#: src/ch00-00-introduction.md:27
msgid ""
"Starknet is a Layer-2 network that makes Ethereum transactions faster, "
"cheaper, and more secure using zk-STARKs technology. Think of it as a "
"boosted layer on top of Ethereum, optimized for speed and cost."
msgstr ""

#: src/ch00-00-introduction.md:29
msgid ""
"Starknet bridges the gap between scalability and broad consensus. It "
"integrates a mathematical framework to navigate the balance between capacity "
"and inclusivity. Its integrity hinges on the robustness of succinct, "
"transparent proofs of computational integrity. This method lets powerful "
"operators enhance Starknet's capacity, ensuring everyone can authenticate "
"Starknet's integrity using universally accessible tools ([Eli Ben-Sasson, "
"Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""

#: src/ch00-00-introduction.md:31
msgid "Starknet’s Mission"
msgstr ""

#: src/ch00-00-introduction.md:33
msgid ""
"_Starknet’s mission is to allow individuals to freely implement and use any "
"social function they desire._"
msgstr ""

#: src/ch00-00-introduction.md:35
msgid "Starknet’s Values"
msgstr ""

#: src/ch00-00-introduction.md:37
msgid ""
"Starknet's ethos is anchored in core principles ([Eli Ben-Sasson, Bareli, "
"Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp)):"
msgstr ""

#: src/ch00-00-introduction.md:39
msgid ""
"**Lasting Broadness.** Starknet continuously resists power consolidation. "
"Key points include:"
msgstr ""

#: src/ch00-00-introduction.md:41
msgid ""
"Broad power distribution underpins Starknet's legitimacy and must persist "
"across operations and decision-making. While centralized operation may be "
"necessary at times, it should be short-lived."
msgstr ""

#: src/ch00-00-introduction.md:42
msgid "Starknet's protocol and governance should always be open and transparent."
msgstr ""

#: src/ch00-00-introduction.md:43
msgid ""
"Governance should bolster inclusivity, with a flexible structure that can "
"evolve to ensure enduring inclusivity."
msgstr ""

#: src/ch00-00-introduction.md:45
msgid ""
"**Neutrality.** Starknet remains impartial to the societal functions it "
"supports."
msgstr ""

#: src/ch00-00-introduction.md:47
msgid ""
"The objectives and ethos of functions on Starknet lie with their creators."
msgstr ""

#: src/ch00-00-introduction.md:48
msgid ""
"**Censorship resistance:** Starknet remains agnostic to the nature and "
"meaning of user transactions."
msgstr ""

#: src/ch00-00-introduction.md:50
msgid ""
"**Individual Empowerment.** At its core, Starknet thrives on a well-informed "
"and autonomous user base. This is achieved by fostering a culture rooted in "
"its core mission and values, with a strong emphasis on education."
msgstr ""

#: src/ch00-00-introduction.md:52
msgid "Key Features"
msgstr ""

#: src/ch00-00-introduction.md:54
msgid "These are some key features of Starknet:"
msgstr ""

#: src/ch00-00-introduction.md:56
msgid ""
"Low Costs: Transactions on Starknet cost less than on Ethereum. Future "
"updates like Volition and EIP 4844 will make it even cheaper."
msgstr ""

#: src/ch00-00-introduction.md:59
msgid ""
"Developer-Friendly: Starknet lets developers easily build decentralized apps "
"using its native language, Cairo."
msgstr ""

#: src/ch00-00-introduction.md:62
msgid ""
"Speed and Efficiency: Upcoming releases aim to make transactions even faster "
"and cheaper."
msgstr ""

#: src/ch00-00-introduction.md:65
msgid ""
"CVM: Thanks to Cairo, Starknet runs on it´s own VM, called Cairo VM (CVM), "
"that allow us to innovate beyond the Ethereum Virtual Machine (EVM) and "
"create a new paradigm for decentralized applications."
msgstr ""

#: src/ch00-00-introduction.md:69
msgid "Here some of them:"
msgstr ""

#: src/ch00-00-introduction.md:71
msgid ""
"Account Abstraction: Implemented at the protocol level, this facilitates "
"diverse signing schemes while ensuring user security and self-custody of "
"assets."
msgstr ""

#: src/ch00-00-introduction.md:75
msgid ""
"Volition: Will be implemented on testnet during Q4 2023 will allow "
"developers to regulate data availability on Ethereum (L1) or on Starknet "
"(L2). Reducing L1 onchain data can radically reduce costs."
msgstr ""

#: src/ch00-00-introduction.md:79
msgid ""
"Paymaster: StarkNet will allow users to choose how to pay for transaction "
"fee, follows the guidelines laid out in EIP 4337 and allows the transaction "
"to specify a specific contract, a **Paymaster**, to pay for their "
"transaction. Supports gasless transactions, enhancing user accessibility."
msgstr ""

#: src/ch00-00-introduction.md:85
msgid "Cairo: The Language of Starknet"
msgstr ""

#: src/ch00-00-introduction.md:87
msgid ""
"Cairo is tailor-made for creating STARK-based smart contracts. As Starknet’s "
"native language, it’s central to building scalable and secure decentralized "
"apps. To start learning now, check out the [Cairo "
"Book](https://cairo-book.github.io/) and "
"[Starklings](https://github.com/shramee/starklings-cairo1)."
msgstr ""

#: src/ch00-00-introduction.md:93
msgid "Inspired by Rust, Cairo lets you write contracts safely and conveniently."
msgstr ""

#: src/ch00-00-introduction.md:96
msgid "Why Choose Cairo?"
msgstr ""

#: src/ch00-00-introduction.md:98
msgid ""
"Cairo is designed for _Provable Computation,_ a new paradigm that lets "
"programs prove their correctness without re-running them. Here’s why it "
"stands out:"
msgstr ""

#: src/ch00-00-introduction.md:102
msgid "Purpose-Built: Designed specifically for smart contracts."
msgstr ""

#: src/ch00-00-introduction.md:104
msgid "No EVM Limits: Goes beyond what the Ethereum Virtual Machine can do."
msgstr ""

#: src/ch00-00-introduction.md:106
msgid "Flexibility: Uses traits for more flexibility than inheritance."
msgstr ""

#: src/ch00-00-introduction.md:108
msgid "Governance"
msgstr ""

#: src/ch00-00-introduction.md:110
msgid ""
"The Starknet Foundation oversees Starknet’s governance. Its duties include:"
msgstr ""

#: src/ch00-00-introduction.md:113
msgid "Managing Starknet’s development and operations"
msgstr ""

#: src/ch00-00-introduction.md:115
msgid "Overseeing the Starknet DAO, which enables community involvement"
msgstr ""

#: src/ch00-00-introduction.md:117
msgid "Setting rules to maintain network integrity"
msgstr ""

#: src/ch00-00-introduction.md:119
msgid ""
"Our focus is on technical input and debate for improving the protocol. While "
"we value all perspectives, it’s often the technical insights that steer us "
"forward."
msgstr ""

#: src/ch00-00-introduction.md:123
msgid ""
"Members can influence Starknet by voting on changes. Here’s the process: A "
"new version is tested on the Goerli Testnet. Members then have six days to "
"review it. A Snapshot proposal is made, and the community votes. A majority "
"of _YES_ votes means an upgrade to the Mainnet."
msgstr ""

#: src/ch00-00-introduction.md:128
msgid "In short, governance is key to Starknet’s evolution."
msgstr ""

#: src/ch00-00-introduction.md:130
msgid "To propose an improvement, create a SNIP."
msgstr ""

#: src/ch00-00-introduction.md:132
msgid "SNIP: StarkNet Improvement Proposals"
msgstr ""

#: src/ch00-00-introduction.md:134
msgid ""
"SNIP is short for StarkNet Improvement Proposal. It’s essentially a "
"blueprint that details proposed enhancements or changes to the StarkNet "
"ecosystem. A well-crafted SNIP includes both the technical specifications of "
"the change and the reasons behind it. If you’re proposing a SNIP, it’s your "
"job to rally community support and document any objections (more details "
"[here](https://community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2)). "
"Once a SNIP is approved, it becomes a part of the Starknet protocol. All the "
"SNIPs can be found in [this "
"repository](https://github.com/starknet-io/SNIPs)."
msgstr ""

#: src/ch00-00-introduction.md:145
msgid "SNIPs serve three crucial roles:"
msgstr ""

#: src/ch00-00-introduction.md:147
msgid "They are the main avenue for proposing new features or changes."
msgstr ""

#: src/ch00-00-introduction.md:149
msgid "They act as a platform for technical discussions within the community."
msgstr ""

#: src/ch00-00-introduction.md:152
msgid ""
"They document the decision-making process, offering a historical view of how "
"StarkNet has evolved."
msgstr ""

#: src/ch00-00-introduction.md:155
msgid ""
"Because SNIPs are stored as text files in a [version-controlled "
"repository](https://github.com/starknet-io/SNIPs), you can easily track "
"changes and understand the history of proposals."
msgstr ""

#: src/ch00-00-introduction.md:159
msgid ""
"For those who are building on Starknet, SNIPs aren’t just "
"suggestions—they’re a roadmap. It’s beneficial for implementers to keep a "
"list of the SNIPs they’ve executed. This transparency helps users gauge the "
"state of a particular implementation or software library."
msgstr ""

#: src/ch00-00-introduction.md:164
msgid "Learning Resources"
msgstr ""

#: src/ch00-00-introduction.md:166
msgid "For deeper insights into Starknet and Cairo:"
msgstr ""

#: src/ch00-00-introduction.md:168
msgid "[The Starknet Book](https://book.starknet.io): For mastering Starknet"
msgstr ""

#: src/ch00-00-introduction.md:171
msgid "[The Cairo Book](https://cairo-book.github.io/): For mastering Cairo"
msgstr ""

#: src/ch00-00-introduction.md:173
msgid ""
"[Starklings](https://github.com/shramee/starklings-cairo1): Practical "
"tutorials and examples"
msgstr ""

#: src/ch00-00-introduction.md:176
#: src/ch02-08-starknet-react.md:361
#: src/ch03-00-architecture.md:251
#: src/ch03-02-sequencers.md:216
#: src/ch03-03-provers.md:243
#: src/ch04-00-account-abstraction.md:242
msgid "Conclusion"
msgstr ""

#: src/ch00-00-introduction.md:178
msgid ""
"In decentralized technology, Starknet offers a solution to challenges that "
"previous systems encountered. It's based on established _protocols_ and "
"_registries_, following the initial concepts introduced by figures such as "
"Satoshi. Through a specific mathematical method, Starknet seeks a balance "
"between scalability and consensus. As this technology progresses, Starknet "
"adheres to principles of inclusivity, neutrality, and user empowerment. It's "
"poised for continuous adaptation and improvement in the field."
msgstr ""

#: src/ch01-00-getting-started.md:3
msgid ""
"Starknet is a scalable Layer-2 solution on Ethereum. This guide will walk "
"you through the process of deploying and interacting with your first "
"Starknet smart contract using the Cairo programming language, a language "
"tailored for creating validity proofs and that Starknet uses. For seasoned "
"developers looking to understand the core concepts and get hands-on "
"experience, this guide offers step-by-step instructions and essential "
"details."
msgstr ""

#: src/ch01-00-getting-started.md:5
msgid ""
"We will use the Starknet Remix Plugin to compile, deploy and interact with "
"our smart contract. It is a great tool to get started with Starknet "
"development."
msgstr ""

#: src/ch01-00-getting-started.md:7
msgid "Visit [The Remix Project](https://remix.ethereum.org/)."
msgstr ""

#: src/ch01-00-getting-started.md:8
msgid "Navigate to the ‘Plugins’ section in the bottom left corner."
msgstr ""

#: src/ch01-00-getting-started.md:9
msgid "Enable the “Starknet” plugin."
msgstr ""

#: src/ch01-00-getting-started.md:13
msgid "Activate the Starknet Plugin"
msgstr ""

#: src/ch01-00-getting-started.md:15
msgid ""
"After enabling, the Starknet logo appears on the left sidebar. Click it to "
"interact with opened Cairo files."
msgstr ""

#: src/ch01-00-getting-started.md:17
msgid "Introduction to Starknet Smart Contracts"
msgstr ""

#: src/ch01-00-getting-started.md:19
msgid ""
"The script below is a simple `Ownable` contract pattern written in Cairo for "
"Starknet. It features:"
msgstr ""

#: src/ch01-00-getting-started.md:21
msgid "An ownership system."
msgstr ""

#: src/ch01-00-getting-started.md:22
msgid "A method to transfer ownership."
msgstr ""

#: src/ch01-00-getting-started.md:23
msgid "A method to check the current owner."
msgstr ""

#: src/ch01-00-getting-started.md:24
msgid "An event notification for ownership changes."
msgstr ""

#: src/ch01-00-getting-started.md:91
msgid "Components Breakdown"
msgstr ""

#: src/ch01-00-getting-started.md:93
msgid ""
"The following is a brief description of the components in the contract. We "
"will get into more details when we get deeper into Cairo so feel free to "
"skip this section for now if you are not familiar with smart contract "
"development."
msgstr ""

#: src/ch01-00-getting-started.md:95
msgid "**Dependencies and Interface**:"
msgstr ""

#: src/ch01-00-getting-started.md:96
msgid "**`starknet::ContractAddress`**: Represents a Starknet contract address."
msgstr ""

#: src/ch01-00-getting-started.md:97
msgid ""
"**`OwnableTrait`**: Specifies functions for transferring and getting "
"ownership."
msgstr ""

#: src/ch01-00-getting-started.md:98
msgid "**Events**:"
msgstr ""

#: src/ch01-00-getting-started.md:99
msgid ""
"**`OwnershipTransferred1`**: Indicates ownership change with previous and "
"new owner details."
msgstr ""

#: src/ch01-00-getting-started.md:100
msgid "**Storage**:"
msgstr ""

#: src/ch01-00-getting-started.md:101
msgid ""
"**`Storage`**: Holds the contract's state with the current owner's address."
msgstr ""

#: src/ch01-00-getting-started.md:102
msgid "**Constructor**:"
msgstr ""

#: src/ch01-00-getting-started.md:103
msgid "Initializes the contract with a starting owner."
msgstr ""

#: src/ch01-00-getting-started.md:104
msgid "**External Functions**:"
msgstr ""

#: src/ch01-00-getting-started.md:105
msgid ""
"Functions for transferring ownership and retrieving the current owner's "
"details."
msgstr ""

#: src/ch01-00-getting-started.md:106
msgid "**Private Methods**:"
msgstr ""

#: src/ch01-00-getting-started.md:107
msgid "**`only_owner`**: Validates if the caller is the current owner."
msgstr ""

#: src/ch01-00-getting-started.md:109
msgid "Compilation Process"
msgstr ""

#: src/ch01-00-getting-started.md:111
msgid "To compile using Remix:"
msgstr ""

#: src/ch01-00-getting-started.md:113
msgid "**File Creation**"
msgstr ""

#: src/ch01-00-getting-started.md:115
msgid "Navigate to the \"File Explorer\" tab in Remix."
msgstr ""

#: src/ch01-00-getting-started.md:116
msgid "Create a new file named `Ownable.cairo` and input the previous code."
msgstr ""

#: src/ch01-00-getting-started.md:118
msgid "**Compilation**"
msgstr ""

#: src/ch01-00-getting-started.md:120
msgid "Choose the `Ownable.cairo` file."
msgstr ""

#: src/ch01-00-getting-started.md:121
msgid "In the \"Starknet\" tab, select \"Compile Ownable.cairo\"."
msgstr ""

#: src/ch01-00-getting-started.md:122
msgid ""
"Post-compilation, an \"artifacts\" folder emerges containing the compiled "
"contract in two distinct formats: Sierra (JSON file) and CASM. For Starknet "
"deployment, Remix will use the Sierra file. Do not worry about this process "
"for now; we will cover it in detail in a later chapter. For now, Remix will "
"handle the compilation and deployment for us."
msgstr ""

#: src/ch01-00-getting-started.md:126
msgid "Artifacts folder after compilation"
msgstr ""

#: src/ch01-00-getting-started.md:128
msgid "Deployment on the Development Network"
msgstr ""

#: src/ch01-00-getting-started.md:130
msgid ""
"To set your smart contract in motion, an initial owner must be defined. The "
"Constructor function needs this information."
msgstr ""

#: src/ch01-00-getting-started.md:132
msgid ""
"Here's a step-by-step guide to deploying your smart contract on the "
"development network:"
msgstr ""

#: src/ch01-00-getting-started.md:134
msgid "**Select the Appropriate Network**"
msgstr ""

#: src/ch01-00-getting-started.md:136
msgid "Go to the Environment selection tab."
msgstr ""

#: src/ch01-00-getting-started.md:137
msgid ""
"Choose \"Remote Devnet\" for deploying your inaugural contract on a "
"development network."
msgstr ""

#: src/ch01-00-getting-started.md:139
msgid "**Choose a Devnet Account**"
msgstr ""

#: src/ch01-00-getting-started.md:141
msgid ""
"Under \"Devnet account selection\", a list of accounts specific to the "
"chosen devnet is presented."
msgstr ""

#: src/ch01-00-getting-started.md:142
msgid "Pick any account and copy its address."
msgstr ""

#: src/ch01-00-getting-started.md:144
msgid "**Initiating Deployment**"
msgstr ""

#: src/ch01-00-getting-started.md:146
#: src/ch01-00-getting-started.md:176
msgid "Navigate to the \"Starknet\" tab."
msgstr ""

#: src/ch01-00-getting-started.md:147
msgid "Input the copied address into the `init_owner` variable."
msgstr ""

#: src/ch01-00-getting-started.md:148
msgid "Click on \"Deploy ownable.cairo\"."
msgstr ""

#: src/ch01-00-getting-started.md:150
msgid ""
"Post-deployment, Remix's terminal will send various logs. These logs provide "
"crucial details, including:"
msgstr ""

#: src/ch01-00-getting-started.md:152
msgid ""
"`transaction_hash`: The unique hash of the transaction. This hash can be "
"used to track the transaction's status."
msgstr ""

#: src/ch01-00-getting-started.md:153
msgid ""
"`contract_address`: The address of the deployed contract. Use this address "
"to interact with your contract."
msgstr ""

#: src/ch01-00-getting-started.md:154
msgid "`calldata`: Contains the `init_owner` address fed to the constructor."
msgstr ""

#: src/ch01-00-getting-started.md:156
msgid ""
"```bash\n"
"{\n"
"  \"transaction_hash\": "
"\"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": "
"\"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"
msgstr ""

#: src/ch01-00-getting-started.md:168
msgid ""
"By following the above process, you successfully deploy your smart contract "
"on the development network."
msgstr ""

#: src/ch01-00-getting-started.md:170
msgid "Interaction with the Contract"
msgstr ""

#: src/ch01-00-getting-started.md:172
msgid ""
"With the contract now active on the development network, interaction becomes "
"possible. Here's a guide to effectively interact with your contract on "
"Starknet:"
msgstr ""

#: src/ch01-00-getting-started.md:174
msgid "**Initiating Interaction**"
msgstr ""

#: src/ch01-00-getting-started.md:177
msgid "Select the \"Interact\" option."
msgstr ""

#: src/ch01-00-getting-started.md:179
msgid "**Calling the `get_owner` Function**"
msgstr ""

#: src/ch01-00-getting-started.md:181
msgid ""
"Choose the `get_owner` function. Since this function doesn't require "
"arguments, the calldata field remains blank. (This is a read function, hence "
"calling it is termed as a \"call\".)"
msgstr ""

#: src/ch01-00-getting-started.md:182
msgid ""
"Press the \"get_owner\" button. Your terminal will display the result, "
"revealing the owner's address provided during the contract's deployment as "
"calldata for the constructor:"
msgstr ""

#: src/ch01-00-getting-started.md:184
msgid ""
"```bash\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""

#: src/ch01-00-getting-started.md:196
msgid ""
"This call currently doesn't spend gas because the function does not change "
"the state of the contract."
msgstr ""

#: src/ch01-00-getting-started.md:198
msgid "**Invoking the `transfer_ownership` Function**"
msgstr ""

#: src/ch01-00-getting-started.md:200
msgid ""
"Now, for the **`transfer_ownership`** function, which requires the new "
"owner's address as input."
msgstr ""

#: src/ch01-00-getting-started.md:201
msgid ""
"Enter this address into the calldata field. (For this, use any address from "
"the \"Devnet account selection\" listed in the Environment tab.)"
msgstr ""

#: src/ch01-00-getting-started.md:202
msgid ""
"Click the \"transfer_ownership\" button. The terminal then showcases the "
"transaction hash indicating the contract's state alteration. Since we are "
"altering the contract's state this typo of interaction is called an "
"\"invoke\" and needs to be signed by the account that is calling the "
"function."
msgstr ""

#: src/ch01-00-getting-started.md:204
msgid ""
"For these transactions, the terminal logs will exhibit a \"status\" "
"variable, indicating the transaction's fate. If the status reads "
"\"ACCEPTED_ON_L2\", the Sequencer has accepted the transaction, pending "
"block inclusion. However, a \"REJECTED\" status signifies the Sequencer's "
"disapproval, and the transaction won't feature in the upcoming block. More "
"often than not, this transaction gains acceptance, leading to a contract "
"state modification. On calling the **`get_owner`** function again we get "
"this:"
msgstr ""

#: src/ch01-00-getting-started.md:206
msgid ""
"```bash\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""

#: src/ch01-00-getting-started.md:218
msgid ""
"You've now adeptly compiled, deployed, and interacted with your inaugural "
"Starknet smart contract. Well done!"
msgstr ""

#: src/ch01-00-getting-started.md:220
msgid "Deploying on Starknet Testnet"
msgstr ""

#: src/ch01-00-getting-started.md:222
msgid ""
"After testing your smart contract on a development network, it's time to "
"deploy it to the Starknet Testnet. Starknet Testnet is a public platform "
"available for everyone, ideal for testing smart contracts and collaborating "
"with fellow developers."
msgstr ""

#: src/ch01-00-getting-started.md:224
msgid "First you need to create a Starknet account."
msgstr ""

#: src/ch01-00-getting-started.md:226
#: src/ch02-02-compile-deploy-interact.md:62
msgid "Smart Wallet Setup"
msgstr ""

#: src/ch01-00-getting-started.md:228
msgid ""
"Before deploying your smart contract to Starknet, you must handle the "
"transaction cost. While deploying to the Starknet Goerli Testnet is free, a "
"smart wallet account is essential. You can set up a smart wallet using "
"either:"
msgstr ""

#: src/ch01-00-getting-started.md:230
msgid "[Braavos](https://braavos.app/)"
msgstr ""

#: src/ch01-00-getting-started.md:231
msgid "[Argent](https://www.argent.xyz/argent-x/)"
msgstr ""

#: src/ch01-00-getting-started.md:233
msgid ""
"Both are reliable Starknet wallets offering enhanced security and "
"accessibility features thanks to the possibilities that the Cairo VM brings, "
"such as Account Abstraction (keep reading the Book for more on this)."
msgstr ""

#: src/ch01-00-getting-started.md:235
msgid "Install the recommended chrome/brave extension for your chosen wallet."
msgstr ""

#: src/ch01-00-getting-started.md:236
msgid "Follow your wallet provider's instructions to deploy your account."
msgstr ""

#: src/ch01-00-getting-started.md:237
msgid ""
"Use the [Starknet Faucet](https://faucet.goerli.starknet.io/) to fund your "
"account."
msgstr ""

#: src/ch01-00-getting-started.md:238
msgid "Deploy the account to the network. This usually takes around 10 seconds."
msgstr ""

#: src/ch01-00-getting-started.md:240
msgid ""
"Once set up, you're ready to deploy your smart contracts to the Starknet "
"Testnet."
msgstr ""

#: src/ch01-00-getting-started.md:242
msgid "Deployment and Interaction"
msgstr ""

#: src/ch01-00-getting-started.md:244
msgid "Follow the previous deployment steps."
msgstr ""

#: src/ch01-00-getting-started.md:245
msgid "In the 'Environment selection' tab, choose 'Wallet Selection'."
msgstr ""

#: src/ch01-00-getting-started.md:246
msgid ""
"Select your Starknet account and continue with deploying and interacting "
"with your contract."
msgstr ""

#: src/ch01-00-getting-started.md:248
msgid ""
"You can monitor transaction hashes and addresses using any Starknet block "
"explorers like:"
msgstr ""

#: src/ch01-00-getting-started.md:250
msgid "[Starkscan](https://testnet.starkscan.co/)"
msgstr ""

#: src/ch01-00-getting-started.md:251
msgid "[Voyager](https://goerli.voyager.online/)"
msgstr ""

#: src/ch01-00-getting-started.md:253
msgid ""
"These tools provide a visual representation of transactions and contract "
"state alterations. Notably, when you alter the contract ownership using the "
"`transfer_ownership` function, the event emitted by the contract appears in "
"the block explorer. It's an effective method to track contract events."
msgstr ""

#: src/ch01-00-getting-started.md:255
msgid "Your Next Steps"
msgstr ""

#: src/ch01-00-getting-started.md:257
msgid "Decide your direction from the following choices:"
msgstr ""

#: src/ch01-00-getting-started.md:259
msgid ""
"**Deepen Your Starknet Knowledge**: For an extensive grasp of Starknet's "
"inner workings and potential use cases, delve into Chapter 3 of the Starknet "
"Book. This chapter details Starknet’s architectural nuances. Then go ahead "
"from there."
msgstr ""

#: src/ch01-00-getting-started.md:261
msgid ""
"**Dive into Cairo**: If you're more attuned to coding and wish to craft "
"Starknet contracts, then Cairo is essential. It stands as Starknet's core "
"contract language. Begin with Chapters 1-6 of the [Cairo "
"Book](https://book.cairo-lang.org/title-page.html), ranging from basics in "
"_Getting Started_ to more advanced aspects such as _Enums and Pattern "
"Matching_. Conclude by navigating to the [Starknet Smart Contracts "
"chapter](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html), "
"ensuring you have a well-rounded understanding."
msgstr ""

#: src/ch02-00-starknet-tooling.md:1
msgid "Starknet Tooling"
msgstr ""

#: src/ch02-00-starknet-tooling.md:3
#: src/ch02-03-scarb.md:3
msgid ""
"To make the most of this chapter, a basic grasp of the Cairo programming "
"language is advised. We suggest reading chapters 1-6 of the [Cairo "
"Book](https://book.cairo-lang.org/title-page.html), covering topics from "
"_Getting Started_ to _Enums and Pattern Matching._ Follow this by studying "
"the [Starknet Smart Contracts "
"chapter](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html) "
"in the same book. With this background, you’ll be well-equipped to "
"understand the examples presented here."
msgstr ""

#: src/ch02-00-starknet-tooling.md:12
msgid ""
"Today, Starknet provides all essential tools for building decentralized "
"applications (dApps), compatible with multiple languages like JavaScript, "
"Rust, and Python. You can use the Starknet SDK for development. Front-end "
"developers can use Starknet.js with React, while Rust and Python work well "
"for back-end tasks."
msgstr ""

#: src/ch02-00-starknet-tooling.md:18
msgid ""
"We welcome contributors to enhance existing tools or develop new solutions."
msgstr ""

#: src/ch02-00-starknet-tooling.md:21
msgid "In this chapter, you’ll explore:"
msgstr ""

#: src/ch02-00-starknet-tooling.md:23
msgid "Frameworks: Build using Starknet-Foundry or Hardhat"
msgstr ""

#: src/ch02-00-starknet-tooling.md:25
msgid ""
"SDKs: Discover multi-language support through Starknet.js, Starknet-rs, "
"Starknet_py, and Caigo"
msgstr ""

#: src/ch02-00-starknet-tooling.md:28
msgid "Front-end Development: Use Starknet.js and React"
msgstr ""

#: src/ch02-00-starknet-tooling.md:30
msgid "Testing: Understand testing methods with Starknet-Foundry and the Devnet"
msgstr ""

#: src/ch02-00-starknet-tooling.md:32
msgid ""
"By chapter’s end, you’ll have a complete grasp of Starknet’s toolset, "
"enabling efficient dApp development."
msgstr ""

#: src/ch02-00-starknet-tooling.md:35
msgid ""
"Here’s a quick rundown of the tools that could be used for Starknet "
"development and that we’ll cover in this chapter:"
msgstr ""

#: src/ch02-00-starknet-tooling.md:38
msgid "Scarb: A package manager that compiles your contracts."
msgstr ""

#: src/ch02-00-starknet-tooling.md:40
msgid "Starkli: A CLI tool for interacting with the Starknet network."
msgstr ""

#: src/ch02-00-starknet-tooling.md:42
msgid "Foundry: For contract testing."
msgstr ""

#: src/ch02-00-starknet-tooling.md:44
msgid "Katana: Creates a local test node."
msgstr ""

#: src/ch02-00-starknet-tooling.md:46
msgid ""
"SDKs: starknet.js, Starknet.py, and starknet.rs interface with Starknet "
"using common programming languages."
msgstr ""

#: src/ch02-00-starknet-tooling.md:49
msgid "Starknet-react: Builds front-end apps using React."
msgstr ""

#: src/ch02-01-basic-installation.md:1
#: src/ch02-03-scarb.md:34
#: src/ch02-07-starknet-js.md:13
msgid "Installation"
msgstr ""

#: src/ch02-01-basic-installation.md:3
msgid ""
"This chapter walks you through setting up your Starknet development tools."
msgstr ""

#: src/ch02-01-basic-installation.md:6
msgid "Essential tools to install:"
msgstr ""

#: src/ch02-01-basic-installation.md:8
msgid ""
"[Starkli](https://github.com/xJonathanLEI/starkli) - A CLI tool for "
"interacting with Starknet. More tools are discussed in Chapter 2."
msgstr ""

#: src/ch02-01-basic-installation.md:11
msgid ""
"[Scarb](https://github.com/software-mansion/scarb) - Cairo’s package manager "
"that compiles code to Sierra, a mid-level language between Cairo and CASM."
msgstr ""

#: src/ch02-01-basic-installation.md:15
msgid ""
"For support or queries, visit our [GitHub "
"Issues](https://github.com/starknet-edu/starknetbook/issues) or contact "
"espejelomar on Telegram."
msgstr ""

#: src/ch02-01-basic-installation.md:19
msgid "Starkli Installation"
msgstr ""

#: src/ch02-01-basic-installation.md:21
msgid ""
"Easily install Starkli using Starkliup, an installer invoked through the "
"command line."
msgstr ""

#: src/ch02-01-basic-installation.md:24
msgid ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"
msgstr ""

#: src/ch02-01-basic-installation.md:29
msgid "Restart your terminal and confirm installation:"
msgstr ""

#: src/ch02-01-basic-installation.md:35
msgid "To upgrade Starkli, simply repeat the steps."
msgstr ""

#: src/ch02-01-basic-installation.md:37
msgid "Scarb Package Manager Installation"
msgstr ""

#: src/ch02-01-basic-installation.md:39
msgid ""
"We will get deeper into Scarb later in this chapter. For now, we will go "
"over the installation process."
msgstr ""

#: src/ch02-01-basic-installation.md:41
msgid "For macOS and Linux:"
msgstr ""

#: src/ch02-01-basic-installation.md:43
msgid ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf "
"https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""

#: src/ch02-01-basic-installation.md:47
msgid ""
"For Windows, follow manual setup in the [Scarb "
"documentation](https://docs.swmansion.com/scarb/download.html#windows)."
msgstr ""

#: src/ch02-01-basic-installation.md:50
msgid "Restart the terminal and run:"
msgstr ""

#: src/ch02-01-basic-installation.md:56
msgid "To upgrade Scarb, rerun the installation command."
msgstr ""

#: src/ch02-01-basic-installation.md:58
msgid "You are now set to code in Cairo and deploy to Starknet."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:1
msgid "Hello, World!"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:3
msgid ""
"In this chapter, you’ll learn how to compile, deploy, and interact with a "
"Starknet smart contract written in Cairo."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:6
msgid ""
"First, confirm that the following commands work on your system. If they "
"don’t, refer to Basic Installation in this chapter."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:14
msgid "Find the compiler versions supported"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:16
msgid ""
"We have to make sure that our Starkli compiler version match Scarb compiler "
"version"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:19
msgid "To find the compiler versions supported by Starkli, execute:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:25
msgid ""
"You’ll see a list of possible compiler versions under the "
"`--compiler-version` flag."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:35
msgid ""
"Note that the Scarb compiler version might not align with Starkli’s "
"supported versions. To check Scarb’s version:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:42
msgid "You’ll see a list that contains scarb, cairo and sierra version."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:50
msgid ""
"If there’s a mismatch, it is suggested that you install the version of Scarb "
"that uses the compiler version that Starkli supports. You can find previous "
"releases on [Scarb](https://github.com/software-mansion/scarb/releases)'s "
"GitHub repo."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:56
msgid "To install a specific version, such as `0.6.1`, run:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:58
msgid ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf "
"https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 0.6.1\n"
"```"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:64
msgid ""
"A smart wallet comprises a Signer and an Account Descriptor. The Signer is a "
"smart contract with a private key for signing transactions, while the "
"Account Descriptor is a JSON file detailing the wallet’s address and public "
"key."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:69
msgid "Use Braavos or Argent X browser extensions to create your smart wallet."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:72
msgid ""
"Follow the provided instructions for your chosen wallet (Argent or Braavos)."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:75
msgid ""
"Fund your wallet with ETH. Use [Starknet Goerli "
"Faucet](https://faucet.goerli.starknet.io/) as needed."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:78
msgid "Now you’re ready to interact with Starknet smart contracts."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:80
msgid "Creating a Signer"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:82
msgid ""
"The Signer is an essential smart contract capable of signing transactions in "
"Starknet. You’ll need the private key from your smart wallet to create one, "
"from which the public key can be derived."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:86
msgid ""
"Starkli enables secure storage of your private key through a keystore file. "
"This encrypted file can be accessed using a password and is generally stored "
"in the default Starkli directory."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:90
msgid "First, create the default directory:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:96
msgid ""
"Then generate the keystore file. The signer command contains subcommands for "
"creating a keystore file from a private key or completely create a new one. "
"In this tutorial, we’ll use the private key option which is the most common "
"use case. You need to provide the path to the keystore file you want to "
"create. You can give any name to the keystore file, you will likely have "
"several wallets. In this tutorial, we will use the name `my_keystore_ "
"1.json`."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:110
msgid ""
"In the private key prompt, paste the private key of your smart wallet. In "
"the password prompt, enter a password of your choice. You will need this "
"password to sign transactions using Starkli."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:114
msgid ""
"Export the private key from your Braavos or Argent wallet. For Argent X, you "
"can find it in the \"Settings\" section → Select your Account → \"Export "
"Private Key\". For Braavos, you can find it in the \"Settings\" section → "
"\"Privacy and Security\" → \"Export Private Key\"."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:119
msgid ""
"While knowing the private key of a smart wallet is necessary to sign "
"transactions, it’s not sufficient. We also need to inform Starkli about the "
"signing mechanism employed by our smart wallet created by Braavos or Argent "
"X. Does it use an elliptic curve? If yes, which one? This is the reason why "
"we need an account descriptor file."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:125
msgid "\\[OPTIONAL\\] The Architecture of the Starknet Signer"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:127
msgid ""
"The Starknet Signer plays an instrumental role in securing your "
"transactions. Let’s demystify what goes on under the hood."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:130
msgid "Key Components:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:132
msgid ""
"**Private Key**: A 256-bit/32-byte/64-character (ignoring the _0x_ prefix) "
"hexadecimal key that is the cornerstone of your wallet’s security."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:136
msgid ""
"**Public Key**: Derived from the private key, it’s also a "
"256-bit/32-byte/64-character hexadecimal key."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:139
msgid ""
"**Smart Wallet Address**: Unlike Ethereum, the address here is influenced by "
"the public key, class hash, and a salt. **[Learn more in Starknet "
"Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/)**."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:144
msgid "To view the details of the previously created keystore file:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:150
msgid "Anatomy of the `keystore.json` File:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:152
msgid ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": "
"\"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": "
"\"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": "
"\"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:175
msgid "**`version`**: The version of the smart wallet implementation."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:177
msgid "**`id`**: A randomly generated identification string."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:179
msgid "**`crypto`**: Houses all encryption details."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:181
msgid "Inside **`crypto`**:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:183
msgid ""
"**`cipher`**: Specifies the encryption algorithm used, which in this case is "
"AES-128-CTR."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:186
msgid ""
"**AES (Advanced Encryption Standard)**: A globally accepted encryption "
"standard."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:189
msgid "**128**: Refers to the key size in bits, making it a 128-bit key."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:192
msgid "**CTR (Counter Mode)**: A specific mode of operation for the AES cipher."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:195
msgid ""
"**`cipherparams`**: Contains an Initialization Vector (IV), which ensures "
"that encrypting the same plaintext with the same key will produce different "
"ciphertexts."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:199
msgid ""
"**`iv` (Initialization Vector)**: A 16-byte hex string that serves as a "
"random and unique starting point for each encryption operation."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:203
msgid ""
"**`ciphertext`**: This is the private key after encryption, securely stored "
"so that only the correct password can reveal it."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:206
msgid ""
"**`kdf` and `kdfparams`**: KDF stands for Key Derivation Function. This adds "
"a layer of security by requiring computational work, making brute-force "
"attacks harder."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:210
msgid ""
"**`dklen`**: The length (in bytes) of the derived key. Typically 32 bytes."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:213
msgid ""
"**`n`**: A cost factor representing CPU/memory usage. A higher value means "
"more computational work is needed, thus increasing security."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:217
msgid "**`p`**: Parallelization factor, affecting the computational complexity."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:220
msgid ""
"**`r`**: Block size for the hash function, again affecting computational "
"requirements."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:223
msgid ""
"**`salt`**: A random value that is combined with the password to deter "
"dictionary attacks."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:226
msgid ""
"**`mac` (Message Authentication Code)**: This is a cryptographic code that "
"ensures the integrity of the message (the encrypted private key in this "
"case). It is generated using a hash of both the ciphertext and a portion of "
"the derived key."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:231
msgid "Creating an Account Descriptor"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:233
msgid ""
"An Account Descriptor informs Starkli about your smart wallet’s unique "
"features, such as its signing mechanism. You can generate this descriptor "
"using Starkli’s `fetch` subcommand under the `account` command. The `fetch` "
"subcommand takes your on-chain wallet address as input and generates the "
"account descriptor file. The account descriptor file is a JSON file that "
"contains the details of your smart wallet."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:244
msgid ""
"After running the command, you’ll see a message like the one below. We’re "
"using a Braavos wallet as an example, but the steps are the same for an "
"Argent wallet."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:254
msgid "To see the details of your Account Descriptor, run:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:260
msgid "Here’s what a typical descriptor might look like:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:262
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": "
"\"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": "
"\"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": "
"\"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": "
"\"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:287
msgid "Note: The structure will differ if you use an Argent wallet."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:289
msgid "Setting up Environment Variables"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:291
msgid ""
"To simplify Starkli commands, you can set environment variables. Two key "
"variables are crucial: one for the Signer’s keystore file location and "
"another for the Account Descriptor file."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:300
msgid ""
"Setting these variables makes running Starkli commands easier and more "
"efficient."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:303
msgid "Declaring Smart Contracts in Starknet"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:305
msgid "Deploying a smart contract on Starknet involves two steps:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:307
msgid "Declare your contract’s code."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:309
msgid "Deploy an instance of the declared code."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:311
msgid ""
"To get started, navigate to the `contracts/` directory in the [first "
"chapter](https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/contracts) "
"of the Starknet Book repo. The `src/lib.cairo` file contains a basic "
"contract to practice with."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:316
msgid ""
"First, compile the contract using the Scarb compiler. If you haven’t "
"installed Scarb, follow the installation guide in the [Setting up your "
"Environment](https://book.starknet.io/chapter_1/environment_setup.html) "
"section."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:325
msgid ""
"This creates a compiled contract in `target/dev/` as "
"\"contracts_Ownable.sierra.json\" (in Chapter 2 of the book we will learn "
"more details about Scarb)."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:329
msgid ""
"With the smart contract compiled, we’re ready to declare it using Starkli. "
"Before declaring your contract, decide on an RPC provider."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:332
msgid "Choosing an RPC Provider"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:334
msgid "There are three main options for RPC providers, sorted by ease of use:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:336
msgid ""
"**Starknet Sequencer’s Gateway**: The quickest option and it’s the default "
"for Starkli for now. The sequencer gateway is deprecated and will be "
"disabled by StarkWare soon. You’re strongly recommended to use a third-party "
"JSON-RPC API provider like Infura, Alchemy, or Chainstack."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:342
msgid ""
"**Infura or Alchemy**: A step up in complexity. You’ll need to set up an API "
"key and choose an endpoint. For Infura, it would look like "
"`https://starknet-goerli.infura.io/v3/<API_KEY>`. Learn more in the [Infura "
"documentation](https://docs.infura.io/networks/starknet/how-to/choose-a-network)."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:348
msgid ""
"**Your Own Node**: For those who want full control. It’s the most complex "
"but offers the most freedom. Check out [Chapter 4 of the Starknet "
"Book](https://book.starknet.io/chapter_4/node.html) or "
"[Kasar](https://www.kasar.io/) for setup guides."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:353
msgid ""
"In this tutorial, we will use Alchemy. We can set the STARKNET_RPC "
"environment variable to make command invocations easier:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:356
msgid ""
"```bash\n"
"    export "
"STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/<API_KEY>\"\n"
"```"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:360
msgid "Declaring Your Contract"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:362
msgid ""
"Run this command to declare your contract using the default Starknet "
"Sequencer’s Gateway:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:369
msgid ""
"According to the `STARKNET_RPC` url, starkli can recognize the target "
"blockchain network, in this case \"goerli\", so it is not necessary "
"explicitly specify it."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:373
msgid ""
"Unless you’re working with custom networks where it’s infeasible for Starkli "
"to detect the right compiler version, you shouldn’t need to manually choose "
"a version with `--network` and `--compiler-version`."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:377
msgid ""
"If you encounter an \"Error: Invalid contract class,\" it likely means your "
"Scarb’s compiler version is incompatible with Starkli. Follow the steps "
"above to align the versions. Starkli usually supports compiler versions "
"accepted by mainnet, even if Scarb’s latest version is not yet compatible."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:383
msgid ""
"After running the command, you’ll receive a contract class hash. This unique "
"hash serves as the identifier for your contract class within Starknet. For "
"example:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:391
msgid ""
"You can think of this hash as the contract class’s _address._ Use a block "
"explorer like "
"[StarkScan](https://testnet.starkscan.co/class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) "
"to verify this hash on the blockchain."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:396
msgid ""
"If the contract class you’re attempting to declare already exists, it is ok "
"we can continue. You’ll receive a message like:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:404
msgid "Deploying Smart Contracts on Starknet"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:406
msgid ""
"To deploy a smart contract, you’ll need to instantiate it on Starknet’s "
"testnet. This process involves executing a command that requires two main "
"components:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:410
msgid "The class hash of your smart contract."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:412
msgid "Any constructor arguments that the contract expects."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:414
msgid ""
"In our example, the constructor expects an _owner_ address. You can learn "
"more about constructors in \\[Chapter 12 of The Cairo "
"Book\\](<https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-constructors>)."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:418
msgid "The command would look like this:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:426
msgid ""
"Here’s a specific example with an actual class hash and constructor inputs "
"(as the owner address use the address of your smart wallet so you can invoke "
"the transfer_ownership function later):"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:436
msgid ""
"After executing the command and entering your password, you should see "
"output like the following:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:447
msgid ""
"The contract is now live on the Starknet testnet. You can verify its status "
"using a block explorer like "
"[StarkScan](https://testnet.starkscan.co/contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012). "
"On the \"Read/Write Contract\" tab, you’ll see the contract’s external "
"functions."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:453
msgid "Interacting with the Starknet Contract"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:455
msgid ""
"Starkli enables interaction with smart contracts via two primary methods: "
"`call` for read-only functions and `invoke` for write functions that modify "
"the state."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:459
msgid "Calling a Read Function"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:461
msgid ""
"The `call` command enables you to query a smart contract function without "
"sending a transaction. For instance, to find out who the current owner of "
"the contract is, you can use the `get_owner` function, which requires no "
"arguments."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:472
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of your contract. The command "
"will return the owner’s address, which was initially set during the "
"contract’s deployment:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:476
msgid ""
"```bash\n"
"    [\n"
"        "
"\"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:482
msgid "Invoking a Write Function"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:484
msgid ""
"You can modify the contract’s state using the `invoke` command. For example, "
"let’s transfer the contract’s ownership with the `transfer_ownership` "
"function."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:495
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of the contract and "
"`<NEW_OWNER_ADDRESS>` with the address you want to transfer ownership to. If "
"the smart wallet you’re using isn’t the contract’s owner, an error will "
"appear. Note that the initial owner was set when deploying the contract:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:505
msgid ""
"The failure reason is encoded as a felt. o decode it, use the starkli’s "
"`parse-cairo-string` command."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:512
msgid ""
"For example, if you see `0x43616c6c6572206973206e6f7420746865206f776e6572`, "
"decoding it will yield \"Caller is not the owner.\""
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:516
msgid ""
"After a successful transaction on L2, use a block explorer like StarkScan or "
"Voyager to confirm the transaction status using the hash provided by the "
"`invoke` command."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:520
msgid ""
"To verify that the ownership has successfully transferred, you can call the "
"`get_owner` function again:"
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:529
msgid ""
"If the function returns the new owner’s address, the transfer was successful."
msgstr ""

#: src/ch02-02-compile-deploy-interact.md:532
msgid ""
"Congratulations! You’ve successfully deployed and interacted with a Starknet "
"contract."
msgstr ""

#: src/ch02-03-scarb.md:12
msgid ""
"Scarb is Cairo’s package manager designed for both Cairo and Starknet "
"projects. It handles dependencies, compiles projects, and integrates with "
"tools like Foundry. It is built by the same team that created Foundry for "
"Starknet."
msgstr ""

#: src/ch02-03-scarb.md:17
msgid "Scarb Workflow"
msgstr ""

#: src/ch02-03-scarb.md:19
msgid "Follow these steps to develop a Starknet contract using Scarb:"
msgstr ""

#: src/ch02-03-scarb.md:21
msgid ""
"**Initialize:** Use `scarb new` to set up a new project, generating a "
"`Scarb.toml` file and initial `src/lib.cairo`."
msgstr ""

#: src/ch02-03-scarb.md:24
msgid "**Code:** Add your Cairo code in the `src` directory."
msgstr ""

#: src/ch02-03-scarb.md:26
msgid "**Dependencies:** Add external libraries using `scarb add`."
msgstr ""

#: src/ch02-03-scarb.md:28
msgid ""
"**Compile:** Execute `scarb build` to convert your contract into Sierra code."
msgstr ""

#: src/ch02-03-scarb.md:31
msgid ""
"Scarb simplifies your development workflow, making it efficient and "
"streamlined."
msgstr ""

#: src/ch02-03-scarb.md:36
msgid ""
"Scarb is cross-platform, supporting macOS, Linux, and Windows. For "
"installation, refer to the [Chapter 1 setup "
"guide](https://book.starknet.io/chapter_1/environment_setup.html#the_scarb_package_manager_installation)."
msgstr ""

#: src/ch02-03-scarb.md:40
msgid "Cairo Project Structure"
msgstr ""

#: src/ch02-03-scarb.md:42
msgid "Next, we’ll dive into the key components that make up a Cairo project."
msgstr ""

#: src/ch02-03-scarb.md:44
msgid "Cairo Packages"
msgstr ""

#: src/ch02-03-scarb.md:46
msgid ""
"Cairo packages, also referred to as \"crates\" in some contexts, are the "
"building blocks of a Cairo project. Each package must follow several rules:"
msgstr ""

#: src/ch02-03-scarb.md:50
msgid ""
"A package must include a `Scarb.toml` file, which is Scarb’s manifest file. "
"It contains the dependencies for your package."
msgstr ""

#: src/ch02-03-scarb.md:53
msgid ""
"A package must include a `src/lib.cairo` file, which is the root of the "
"package tree. It allows you to define functions and declare used modules."
msgstr ""

#: src/ch02-03-scarb.md:57
msgid ""
"Package structures might look like the following case where we have a "
"package named `my_package`, which includes a `src` directory with the "
"`lib.cairo` file inside, a `snips` directory which in itself a package we "
"can use, and a `Scarb.toml` file in the top-level directory."
msgstr ""

#: src/ch02-03-scarb.md:73
msgid "Within the `Scarb.toml` file, you might have:"
msgstr ""

#: src/ch02-03-scarb.md:75
msgid ""
"```\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.0.1\"\n"
"snips = { path = \"snips\" }\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:83
msgid ""
"Here starknet and snips are the dependencies of the package. The `starknet` "
"dependency is hosted on the Scarb registry (we do not need to download it), "
"while the `snips` dependency is located in the `snips` directory."
msgstr ""

#: src/ch02-03-scarb.md:88
msgid "Setting Up a Project with Scarb"
msgstr ""

#: src/ch02-03-scarb.md:90
msgid ""
"To create a new project using Scarb, navigate to your desired project "
"directory and execute the following command:"
msgstr ""

#: src/ch02-03-scarb.md:95
msgid ""
"This command will create a new project directory named `hello_scarb`, "
"including a `Scarb.toml` file, a `src` directory with a `lib.cairo` file "
"inside, and initialize a new Git repository with a `.gitignore` file."
msgstr ""

#: src/ch02-03-scarb.md:104
msgid ""
"Upon opening `Scarb.toml` in a text editor, you should see something similar "
"to the code snippet below:"
msgstr ""

#: src/ch02-03-scarb.md:107
msgid ""
"```\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at "
"https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:115
msgid "Building a Scarb Project"
msgstr ""

#: src/ch02-03-scarb.md:117
msgid "Clear all content in `src/lib.cairo` and replace with the following:"
msgstr ""

#: src/ch02-03-scarb.md:119
msgid ""
"```\n"
"// src/lib.cairo\n"
"mod hello_scarb;\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:122
msgid ""
"Next, create a new file titled `src/hello_scarb.cairo` and add the following:"
msgstr ""

#: src/ch02-03-scarb.md:125
msgid ""
"```\n"
"// src/hello_scarb.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:131
msgid ""
"In this instance, the `lib.cairo` file contains a module declaration "
"referencing _hello_scarb_, which includes the _hello_scarb.cairo_ file’s "
"implementation. For more on modules, imports, and the `lib.cairo` file, "
"please refer to the subchapter on [imports in Chapter "
"2](https://book.starknet.io/chapter_2/imports.html)."
msgstr ""

#: src/ch02-03-scarb.md:137
msgid ""
"Scarb mandates that your source files be located within the `src` directory."
msgstr ""

#: src/ch02-03-scarb.md:140
msgid ""
"To build (compile) your project from your `hello_scarb` directory, use the "
"following command:"
msgstr ""

#: src/ch02-03-scarb.md:145
msgid ""
"This command compiles your project and produces the Sierra code in the "
"`target/dev/hello_scarb.sierra` file. Sierra serves as an intermediate layer "
"between high-level Cairo and compilation targets such as Cairo Assembly "
"(CASM). To understand more about Sierra, check out this "
"[article](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)."
msgstr ""

#: src/ch02-03-scarb.md:151
msgid ""
"To remove the build artifacts and delete the target directory, use the "
"`scarb clean` command."
msgstr ""

#: src/ch02-03-scarb.md:154
msgid "Adding Dependencies"
msgstr ""

#: src/ch02-03-scarb.md:156
msgid ""
"Scarb facilitates the seamless management of dependencies for your Cairo "
"packages. Here are two methods to add dependencies to your project:"
msgstr ""

#: src/ch02-03-scarb.md:159
msgid "Edit Scarb.toml File"
msgstr ""

#: src/ch02-03-scarb.md:161
msgid ""
"Open the Scarb.toml file in your project directory and locate the "
"`[dependencies]` section. If it doesn’t exist, add it. To include a "
"dependency hosted on a Git repository, use the following format:"
msgstr ""

#: src/ch02-03-scarb.md:165
msgid ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = "
"\"https://github.com/keep-starknet-strange/alexandria.git\" }\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:168
msgid ""
"For consistency, it’s recommended to pin Git dependencies to specific "
"commits. This can be done by adding the `rev` field with the commit hash:"
msgstr ""

#: src/ch02-03-scarb.md:172
msgid ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = "
"\"https://github.com/keep-starknet-strange/alexandria.git\", rev = "
"\"81bb93c\" }\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:175
msgid "After adding the dependency, remember to save the file."
msgstr ""

#: src/ch02-03-scarb.md:177
msgid "Use the scarb add Command"
msgstr ""

#: src/ch02-03-scarb.md:179
msgid ""
"Alternatively, you can use the `scarb add` command to add dependencies to "
"your project. Open your terminal and execute the following command:"
msgstr ""

#: src/ch02-03-scarb.md:182
msgid ""
"```\n"
"$ scarb add alexandria_math --git "
"https://github.com/keep-starknet-strange/alexandria.git\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:184
msgid ""
"This command will add the alexandria_math dependency from the specified Git "
"repository to your project."
msgstr ""

#: src/ch02-03-scarb.md:187
msgid "To remove a dependency, you can use the `scarb rm` command."
msgstr ""

#: src/ch02-03-scarb.md:189
msgid ""
"Once a dependency is added, the Scarb.toml file will be automatically "
"updated with the new dependency information."
msgstr ""

#: src/ch02-03-scarb.md:192
msgid "Using Dependencies in Your Code"
msgstr ""

#: src/ch02-03-scarb.md:194
msgid ""
"After dependencies are added to your project, you can start utilizing them "
"in your Cairo code."
msgstr ""

#: src/ch02-03-scarb.md:197
msgid ""
"For example, let’s assume you have added the alexandria_math dependency. "
"Now, you can import and utilize functions from the alexandria_math library "
"in your `src/hello_scarb.cairo` file:"
msgstr ""

#: src/ch02-03-scarb.md:201
msgid ""
"```\n"
"// src/hello_scarb.cairo\n"
"use alexandria_math::fibonacci;\n"
"\n"
"fn main() -> felt252 {\n"
"    fibonacci::fib(0, 1, 10)\n"
"}\n"
"```"
msgstr ""

#: src/ch02-03-scarb.md:208
msgid ""
"In the above example, we import the fibonacci function from the "
"alexandria_math library and utilize it in the main function."
msgstr ""

#: src/ch02-03-scarb.md:211
msgid "Scarb Cheat Sheet"
msgstr ""

#: src/ch02-03-scarb.md:213
msgid ""
"Here’s a quick cheat sheet of some of the most commonly used Scarb commands:"
msgstr ""

#: src/ch02-03-scarb.md:216
msgid ""
"`scarb new <project_name>`: Initialize a new project with the given project "
"name."
msgstr ""

#: src/ch02-03-scarb.md:219
msgid "`scarb build`: Compile your Cairo code into Sierra code."
msgstr ""

#: src/ch02-03-scarb.md:221
msgid ""
"`scarb add <dependency> --git <repository>`: Add a dependency to your "
"project from a specified Git repository."
msgstr ""

#: src/ch02-03-scarb.md:224
msgid "`scarb rm <dependency>`: Remove a dependency from your project."
msgstr ""

#: src/ch02-03-scarb.md:226
msgid ""
"`scarb run <script>`: Run a custom script defined in your `Scarb.toml` file."
msgstr ""

#: src/ch02-03-scarb.md:229
msgid ""
"Scarb is a versatile tool, and this is just the beginning of what you can "
"achieve with it. As you gain more experience in the Cairo language and the "
"Starknet platform, you’ll discover how much more you can do with Scarb."
msgstr ""

#: src/ch02-03-scarb.md:234
msgid ""
"To stay updated on Scarb and its features, be sure to check the [official "
"Scarb documentation](https://docs.swmansion.com/scarb/docs.html) regularly. "
"Happy coding!"
msgstr ""

#: src/ch02-03-scarb.md:239
#: src/ch02-07-starknet-js.md:174
#: src/ch02-08-starknet-react.md:395
#: src/ch03-00-architecture.md:264
#: src/ch03-02-sequencers.md:254
#: src/ch03-03-provers.md:233
#: src/ch03-04-nodes.md:439
#: src/ch04-00-account-abstraction.md:297
#: src/ch04-01-accounts.md:116
#: src/ch04-02-hello-account.md:199
#: src/ch04-03-standard-account.md:370
#: src/ch04-04-01-multicaller.md:91
#: src/ch04-04-02-multisig.md:412
msgid "The Book is a community-driven effort created for the community."
msgstr ""

#: src/ch02-03-scarb.md:241
#: src/ch02-07-starknet-js.md:176
#: src/ch02-08-starknet-react.md:397
#: src/ch03-00-architecture.md:266
#: src/ch03-02-sequencers.md:256
#: src/ch03-03-provers.md:235
#: src/ch03-04-nodes.md:441
#: src/ch04-00-account-abstraction.md:299
#: src/ch04-01-accounts.md:118
#: src/ch04-02-hello-account.md:201
#: src/ch04-03-standard-account.md:372
#: src/ch04-04-01-multicaller.md:93
#: src/ch04-04-02-multisig.md:414
msgid ""
"If you’ve learned something, or not, please take a moment to provide "
"feedback through [this 3-question "
"survey](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=)."
msgstr ""

#: src/ch02-03-scarb.md:245
#: src/ch02-07-starknet-js.md:180
#: src/ch02-08-starknet-react.md:401
#: src/ch03-00-architecture.md:270
#: src/ch03-02-sequencers.md:260
#: src/ch03-03-provers.md:239
#: src/ch03-04-nodes.md:445
#: src/ch04-00-account-abstraction.md:303
#: src/ch04-01-accounts.md:122
#: src/ch04-02-hello-account.md:205
#: src/ch04-03-standard-account.md:376
#: src/ch04-04-01-multicaller.md:97
#: src/ch04-04-02-multisig.md:418
msgid ""
"If you discover any errors or have additional suggestions, don’t hesitate to "
"open an [issue on our GitHub "
"repository](https://github.com/starknet-edu/starknetbook/issues)."
msgstr ""

#: src/ch02-05-katana.md:3
msgid ""
"`Katana` is an indispensable tool designed to aid in local development. This "
"creation by the [Dojo "
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md) "
"enables you to perform all Starknet-related activities in a local "
"environment, thus serving as an efficient platform for development and "
"testing."
msgstr ""

#: src/ch02-05-katana.md:10
msgid ""
"We suggest employing either `katana` or `starknet-devnet` for testing your "
"contracts, with the latter discussed in detail in the following subchapter. "
"The `starknet-devnet` is a public testnet, maintained by the [Shard Labs "
"team](https://github.com/Shard-Labs/starknet-devnet). Both these tools offer "
"an effective environment for development and testing."
msgstr ""

#: src/ch02-05-katana.md:16
msgid ""
"For an example of how to use `katana` to deploy and interact with a "
"contract, see [Chapter 2’s Voting contract "
"example](https://book.starknet.io/chapter_2/deploy_call_invoke.html)."
msgstr ""

#: src/ch02-05-katana.md:20
msgid "Understanding RPC in Starknet"
msgstr ""

#: src/ch02-05-katana.md:22
msgid ""
"Remote Procedure Call (RPC) establishes the communication between nodes in "
"the Starknet network. Essentially, it allows us to interact with a node in "
"the Starknet network. The RPC server is responsible for receiving these "
"calls."
msgstr ""

#: src/ch02-05-katana.md:27
msgid ""
"RPC can be obtained from various sources: . To support the decentralization "
"of the Network, you can use your own local Starknet node. Consult [Chapter "
"4](https://book.starknet.io/chapter_4/node.html) for guidelines on setting "
"up your node. . For ease of access, consider using a provider such as "
"[Infura](https://docs.infura.io/networks/starknet/how-to) or "
"[Alchemy](https://www.alchemy.com/starknet) to get an RPC client. . For "
"development and testing, a temporary local node such as `katana` can be used."
msgstr ""

#: src/ch02-05-katana.md:37
msgid "Getting Started with Katana"
msgstr ""

#: src/ch02-05-katana.md:39
msgid "To install `katana` from its source code, run the following commands:"
msgstr ""

#: src/ch02-05-katana.md:41
msgid ""
"```\n"
"mkdir ~/.dojo && cd ~/.dojo\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""

#: src/ch02-05-katana.md:46
msgid "Once installed, confirm it with the version command:"
msgstr ""

#: src/ch02-05-katana.md:50
msgid ""
"Updating `katana` to its latest version involves going back to the `dojo` "
"directory and running the following commands:"
msgstr ""

#: src/ch02-05-katana.md:59
msgid "To initialize a local Starknet node, execute the following command:"
msgstr ""

#: src/ch02-05-katana.md:63
msgid ""
"The `--accounts` flag determines the number of accounts to be created, while "
"the `--seed` flag sets the seed for the private keys of these accounts. This "
"ensures that initializing the node with the same seed will always yield the "
"same accounts. Lastly, the `--gas-price` flag specifies the transaction gas "
"price."
msgstr ""

#: src/ch02-05-katana.md:69
msgid "Running the command produces output similar to this:"
msgstr ""

#: src/ch02-05-katana.md:71
msgid ""
"```\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x0300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"| Account address |  "
"0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"| Private key     |  "
"0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"| Public key      |  "
"0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://0.0.0.0:5050\n"
"```"
msgstr ""

#: src/ch02-05-katana.md:102
msgid ""
"The output includes the addresses, private keys, and public keys of the "
"created accounts. It also contains the seed used to generate the accounts. "
"This seed can be reused to create identical accounts in future runs. "
"Additionally, the output provides the URL of the JSON-RPC server. This URL "
"can be used to establish a connection to the local Starknet node."
msgstr ""

#: src/ch02-05-katana.md:109
msgid "To stop the local Starknet node, simply press `Ctrl+C`."
msgstr ""

#: src/ch02-05-katana.md:111
msgid ""
"The local Starknet node does not persist data. Hence, once it’s stopped, all "
"data will be erased."
msgstr ""

#: src/ch02-05-katana.md:114
msgid ""
"For a practical demonstration of `katana` to deploy and interact with a "
"contract, see [Chapter 2’s Voting contract "
"example](https://book.starknet.io/chapter_2/deploy_call_invoke.html)."
msgstr ""

#: src/ch02-07-starknet-js.md:3
msgid ""
"Starknet.js is a JavaScript/TypeScript library designed to connect your "
"website or decentralized application (D-App) to Starknet. It aims to mimic "
"the architecture of [ethers.js](https://docs.ethers.org/v5/), so if you are "
"familiar with ethers, you should find Starknet.js easy to work with."
msgstr ""

#: src/ch02-07-starknet-js.md:11
msgid "Starknet-js in your dapp"
msgstr ""

#: src/ch02-07-starknet-js.md:15
msgid "To install Starknet.js, follow these steps:"
msgstr ""

#: src/ch02-07-starknet-js.md:17
msgid "For the latest official release (main branch):"
msgstr ""

#: src/ch02-07-starknet-js.md:23
msgid "To use the latest features (merges in develop branch):"
msgstr ""

#: src/ch02-07-starknet-js.md:31
msgid ""
"To build an app that users are able to connect to and interact with "
"Starknet, we recommend adding the "
"[get-starknet](https://github.com/starknet-io/get-starknet) library, which "
"allows you to manage wallet connections."
msgstr ""

#: src/ch02-07-starknet-js.md:36
msgid ""
"With these tools ready, there are basically 3 main concepts to know on the "
"frontend: Account, Provider, and Contracts."
msgstr ""

#: src/ch02-07-starknet-js.md:39
msgid "Account"
msgstr ""

#: src/ch02-07-starknet-js.md:41
msgid ""
"We can generally think of the account as the \"end user\" of a dapp, and "
"some user interaction will be involved to gain access to it."
msgstr ""

#: src/ch02-07-starknet-js.md:44
msgid ""
"Think of a dapp where the user connects their browser extension wallet (such "
"as ArgentX or Braavos) - if the user accepts the connection, that gives us "
"access to the account and signer, which can sign transactions and messages."
msgstr ""

#: src/ch02-07-starknet-js.md:49
msgid ""
"Unlike Ethereum, where user accounts are Externally Owned Accounts, Starknet "
"**accounts are contracts**. This might not necessarily impact your dapp’s "
"frontend, but you should definitely be aware of this difference."
msgstr ""

#: src/ch02-07-starknet-js.md:64
msgid ""
"The snippet above uses the `connect` function provided by `get-starknet` to "
"establish a connection to the user wallet. Once connected, we are able to "
"access account methods, such as `signMessage` or `execute`."
msgstr ""

#: src/ch02-07-starknet-js.md:66
msgid "Provider"
msgstr ""

#: src/ch02-07-starknet-js.md:68
msgid ""
"The provider allows you to interact with the Starknet network. You can think "
"of it as a \"read\" connection to the blockchain, as it doesn’t allow "
"signing transactions or messages. Just like in Ethereum, you can use a "
"default provider, or use services such as Infura or Alchemy, both of which "
"support Starknet, to create an RPC provider."
msgstr ""

#: src/ch02-07-starknet-js.md:74
msgid "By default, the Provider is a sequencer provider."
msgstr ""

#: src/ch02-07-starknet-js.md:76
msgid ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"
msgstr ""

#: src/ch02-07-starknet-js.md:90
msgid "Contracts"
msgstr ""

#: src/ch02-07-starknet-js.md:92
msgid ""
"Your frontend will likely be interacting with deployed contracts. For each "
"contract, there should be a counterpart on the frontend. To create these "
"instances, you will need the contract’s address and ABI, and either a "
"provider or signer."
msgstr ""

#: src/ch02-07-starknet-js.md:97
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, "
"starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, "
"amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, "
"amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"
msgstr ""

#: src/ch02-07-starknet-js.md:107
msgid ""
"If you create a contract instance with a provider, you’ll be limited to "
"calling read functions on the contract - only with a signer can you change "
"the state of the blockchain. However, you are able to connect a previously "
"created `Contract` instance with a new account:"
msgstr ""

#: src/ch02-07-starknet-js.md:118
msgid ""
"In the snippet above, after calling the `connect` method, it would be "
"possible to call read functions on the contract, but not before."
msgstr ""

#: src/ch02-07-starknet-js.md:122
msgid "Units"
msgstr ""

#: src/ch02-07-starknet-js.md:124
msgid ""
"If you have previous experience with web3, you know dealing with units "
"requires care, and Starknet is no exception. Once again, the docs are very "
"useful here, in particular [this section on data "
"transformation](https://www.starknetjs.com/docs/guides/define_call_message/)."
msgstr ""

#: src/ch02-07-starknet-js.md:129
msgid ""
"Very often you will need to convert Cairo structs (such as Uint256) that are "
"returned from contracts into numbers:"
msgstr ""

#: src/ch02-07-starknet-js.md:132
msgid ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"
msgstr ""

#: src/ch02-07-starknet-js.md:145
msgid "And vice versa:"
msgstr ""

#: src/ch02-07-starknet-js.md:147
msgid ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"
msgstr ""

#: src/ch02-07-starknet-js.md:156
msgid ""
"There are other helpful utils, besides `bnToUint256` and `uint256ToBN`, "
"provided by Starknet.js."
msgstr ""

#: src/ch02-07-starknet-js.md:159
msgid ""
"We now have a solid foundation to build a Starknet dapp. However, there are "
"framework specific tools that help us build Starknet dapps, which are "
"covered in chaper 5."
msgstr ""

#: src/ch02-07-starknet-js.md:163
msgid "Additional Resources"
msgstr ""

#: src/ch02-07-starknet-js.md:165
msgid "Starknet.js GitHub Repository: <https://github.com/0xs34n/starknet.js>"
msgstr ""

#: src/ch02-07-starknet-js.md:168
msgid ""
"Official Starknet.js Website and documentation: <https://www.starknetjs.com/>"
msgstr ""

#: src/ch02-07-starknet-js.md:171
msgid ""
"Stay tuned for more updates on Starknet.js, including detailed guides, "
"examples, and comprehensive documentation."
msgstr ""

#: src/ch02-07-01-examples.md:3
msgid ""
"In this subchapter, readers will find practical examples demonstrating the "
"usage of both `starknet-js` and `starknet-react`. It provides insight into "
"real-world applications and serves as a guide for developers to understand "
"and implement these tools effectively."
msgstr ""

#: src/ch02-07-01-examples.md:5
msgid "We value the contribution of our developer community:"
msgstr ""

#: src/ch02-07-01-examples.md:7
msgid "We encourage developers to contribute additional examples."
msgstr ""

#: src/ch02-07-01-examples.md:8
msgid "Please inform us if you identify any mistakes or inaccuracies."
msgstr ""

#: src/ch02-07-01-examples.md:10
msgid ""
"Your insights and feedback are instrumental in making this resource more "
"comprehensive and accurate."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:1
msgid "ERC-20 UI"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:3
msgid ""
"This guide offers steps to build an ERC20 smart contract using Cairo and to "
"incorporate it within a React web application with Starknet React. Readers "
"will:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:5
msgid "Understand how to implement the ERC20 interface"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:6
msgid "Learn how to deploy contracts on the Starknet network"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:7
msgid "Discover ways to engage with contracts within a React application"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:8
msgid "Design their own ERC20 token and initiate it on Starknet"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:10
msgid ""
"A prerequisite for this guide is a foundational understanding of both the "
"Cairo programming language and ReactJS. Additionally, ensure Node.js and NPM "
"are installed on the system."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:12
msgid ""
"The example will walk through creating an ERC20 token named MKT and crafting "
"a web3 interface for functionalities such as balance verification and token "
"transfer."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:17
msgid ""
"Throughout this guide, the following tools and libraries will be utilized:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:19
msgid "Scarb 0.7.0 with Cairo 2.2.0"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:20
msgid "Starkli 0.1.9"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:21
msgid "Oppenzeppelin libraries v0.7.0"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:22
msgid "Starknet React v1.0.4"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:23
msgid "NodeJS v19.6.1"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:24
msgid "Next.js 13.1.6"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:25
msgid "Visual Studio Code"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:26
msgid "Vercel"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:28
msgid "Initiating a New Starknet Project"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:30
msgid "Begin by establishing a new Starknet project named \"erc20\" using Scarb:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:38
msgid ""
"Subsequently, update the Scarb.toml to include the essential OpenZeppelin "
"libraries. Post edits, the Scarb.toml should appear as:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:40
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit "
"https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin-contracts.git\", "
"tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:54
msgid "Implementing the ERC20 Token"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:56
msgid ""
"Begin by creating a new file named `src/erc20.cairo`. In this file, the "
"ERC20 token named MKT, along with its associated functions, will be defined:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:99
msgid "Upon completing your contract, proceed to compile it using Scarb:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:105
msgid ""
"Subsequent to the compilation, declare the smart contract on the Starknet "
"testnet:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:112
#: src/ch02-07-01-00-erc20-ui.md:139
msgid "The output should appear similar to:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:121
msgid ""
"In cases where no modifications have been made to the provided contract, a "
"notification will indicate that the contract has previously been declared on "
"Starknet:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:128
msgid "Deploying the ERC20 Contract"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:130
msgid ""
"Proceed to deploy the MKT Token using Starkli. Provide these arguments for "
"successful deployment:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:132
msgid ""
"`Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 "
"decimals (a standard of OpenZeppelin), the input required is 1,000,000 * "
"10^18 or 0xd3c21bcecceda1000000. Due to the contract's expectation of a u256 "
"mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 "
"respectively."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:133
msgid ""
"`Receiver address`: Use a preferred address. In this example: "
"0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:147
msgid ""
"NOTE: The deployed address received will differ for every user. Retain this "
"address, as it will replace instances in subsequent TypeScript files to "
"match the specific contract address."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:149
msgid ""
"Well done! The Cairo ERC20 smart contract has been deployed successfully on "
"Starknet."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:151
msgid "Installing the Starknet React Library"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:153
msgid ""
"With the contract in place, initiate the development of the web application. "
"Begin by incorporating the Starknet React library:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:159
msgid "Post-installation, confirm the version of the Starknet React library:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:165
msgid ""
"The output should display the installed version, such as "
"`@starknet-react/core@1.0.4`."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:167
msgid "Setting Up a New React Project"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:169
msgid ""
"Starknet React library provides the `create-starknet` script that "
"streamlines the setup of a Starknet application using TypeScript:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:175
msgid ""
"Once set up, make modifications to `erc20_web/index.tsx` by replacing its "
"content with the following code:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:177
msgid ""
"```typescript\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from '../components/WalletBar'\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" "
"/>\n"
"        <meta name=\"viewport\" content=\"width=device-width, "
"initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:214
msgid "To launch the web3 application:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:221
msgid ""
"NOTE: Observe the server port that appears during launch. This will be "
"useful for subsequent testing."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:224
msgid "Enhancing Your React Application with Additional Features"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:226
msgid ""
"To enhance the app's functionality, create two components for balance and "
"transfer. Subsequently, update the `Wallet.tsx` file to incorporate the new "
"features:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:231
msgid "Balance Component"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:232
msgid ""
"Design a balance component inside `components/Balance.tsx` and integrate the "
"following code:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:234
msgid ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../assets/erc20.json';\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: "
"'0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address],\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={refetch}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"  \n"
"export default Balance;\n"
"```"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:264
msgid "NOTE: Replace the address with the address of your deployed contract."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:266
msgid "Transfer Component"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:268
msgid ""
"Craft a transfer component in `components/Transfer.tsx` and embed the "
"subsequent code:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:270
msgid ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"  \n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: "
"'0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"  \n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => "
"setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => "
"setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:311
msgid "NOTE: Replace contractAddress with the address of your deployed contract."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:314
msgid "Updating the Wallet Component"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:316
msgid ""
"Proceed to modify the `components/Wallet.tsx` file. Replace any existing "
"content with the following enhanced code:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:368
msgid ""
"This updated code refines the Wallet component to offer a more interactive "
"experience for users intending to connect or manage their wallets."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:371
msgid "Finalizing the MKT Token Application"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:373
msgid ""
"To finalize the application setup, we need the ABI file for the MKT token. "
"Follow the steps below to generate and integrate it:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:375
msgid "At the root of your project, create a new directory named `assets/`."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:376
msgid ""
"Inside the `assets/` directory, create an empty JSON file named `erc20.json`."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:377
msgid ""
"Go back to your ERC20 Cairo project folder and locate the "
"`erc20/target/erc20_erc20_sierra.json` file."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:381
msgid ""
"Extract the ABI definition (ensuring you include the square brackets) and "
"integrate it into the previously created `assets/erc20.json` file."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:385
msgid ""
"Well done! The basic MKT token application is now operational locally. "
"Access it via `http://localhost:3000` or the port noted from earlier server "
"setup. The app allows users to connect their wallets, review their balances, "
"and perform token transfers."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:390
msgid "Deploying Your Project Online"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:392
msgid ""
"To share your application with friends and allow them to check their "
"balances and transfer tokens, publish your app online. Vercel offers a "
"straightforward way to do this:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:394
msgid "Set Up Vercel"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:396
msgid "Register for an account at [Vercel Signup](https://vercel.com/signup)."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:397
msgid "Install Vercel in your web application folder (`erc20_web`):"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:405
msgid "Authenticate your Vercel account:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:411
msgid ""
"After entering your email, check your inbox and click on the \"Verify\" "
"button."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:418
msgid "On successful verification, you'll receive a confirmation in the console."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:420
msgid "Link your project to Vercel:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:426
msgid "Upload it:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:432
msgid "Publish your project:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:438
msgid ""
"Congratulations! Your MKT token web3 application is now accessible to "
"everyone."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:442
msgid "Engage with your app by:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:444
msgid "Connecting your wallet:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:448
msgid "Checking your balance:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:452
msgid "Transferring tokens:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:456
msgid "Wrapping Up"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:458
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 "
"application using React and Starknet Cairo. This application, complete with "
"an ERC20 smart contract, offers a modern web interface for user interaction. "
"Here's a snapshot of your achievements:"
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:460
msgid ""
"**Project Initialization**: Set up a Starknet project with Scarb and "
"incorporated OpenZeppelin libraries."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:462
msgid ""
"**Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, "
"enriched with functionalities like balance checks and token transfers. This "
"was then compiled and launched on the Starknet network."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:464
msgid ""
"**React Application**: Built a React application powered by Starknet React, "
"featuring components dedicated to balance inquiries and token transactions."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:466
msgid ""
"**ABI Creation**: Produced the ABI for the MKT token, a critical component "
"to liaise with the contract."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:468
msgid ""
"**Online Deployment**: Brought your application to a wider audience by "
"deploying it on Vercel. This empowered users to connect their wallets, "
"scrutinize their balances, and execute token transactions."
msgstr ""

#: src/ch02-07-01-00-erc20-ui.md:470
msgid ""
"The insights you've gathered from this tutorial lay a solid groundwork for "
"creating intricate web3 applications. You're now equipped with the prowess "
"to craft more intricate decentralized applications and smart contracts. The "
"vast expanse of decentralized finance and blockchain is ripe for your "
"innovative inputs. Dive in and happy coding!"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:1
msgid "Million Dollar Homepage"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:3
msgid ""
"[Starknet Homepage](https://github.com/dbejarano820/starknet_homepage) is a "
"decentralized application on the Starknet blockchain. It provides a virtual "
"space where users can claim and personalize sections of a 100x100 grid, "
"known as \"Starknet Homepage\". Each section is a 10x10 pixel area. Users "
"can acquire these sections by minting non-fungible tokens (NFTs) and then "
"personalizing them with images and other content."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:5
msgid ""
"View the live app on testnet "
"[here](https://starknet-homepage-kappa.vercel.app/)."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:9
msgid ""
"This initiative is an adaptation of the renowned Million Dollar Homepage and "
"was conceived at the Starknet Summit 2023 Hacker House in Palo Alto, "
"California. The following is a guide to understanding how this project was "
"developed using the available tools in the ecosystem."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:11
msgid "Tools Utilized:"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:13
msgid "[Starknet-react](https://github.com/apibara/starknet-react)"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:14
msgid "[Starknet.js](https://github.com/0xs34n/starknet.js)"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:15
msgid ""
"[OpenZeppelin Cairo "
"Contracts](https://github.com/OpenZeppelin/cairo-contracts)"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:16
msgid "[MaterialUI](https://mui.com/material-ui/)"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:18
msgid "Initial Setup"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:20
msgid ""
"The `Starknet-react` app offers a command to initialize a Starknet app. This "
"command sets up the foundational structure needed for a NextJS application."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:26
msgid ""
"The `StarknetConfig` component accepts a `connectors` prop, which defines "
"wallet connection options for the user. Additionally, it can take a "
"`defaultProvider` to set the network the application should connect to by "
"default."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:28
msgid ""
"```javascript\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
"});\n"
"return (\n"
"  <StarknetConfig\n"
"    autoConnect\n"
"    defaultProvider={provider}\n"
"    connectors={connectors}\n"
"  >\n"
"    <CacheProvider value={emotionCache}>\n"
"      <ThemeProvider theme={theme}>\n"
"        <Component {...pageProps} />\n"
"      </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:51
msgid ""
"Both `CacheProvider` and `ThemeProvider` are components that facilitate the "
"seamless integration of MaterialUI with NextJS. For a comprehensive setup "
"guide on these components, please refer to [this "
"link](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:53
msgid "Main Functionality"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:55
msgid ""
"The core functionality of the Starknet Homepage centers around selecting a "
"4-sided region on a matrix, representing the desired 10x10 cells, and "
"minting a token based on those cells. The responsibility of the smart "
"contract is to validate whether the selected cells are available for "
"minting. If a user owns Starknet Homepage tokens, they can access a dropdown "
"to modify the token's content, including the associated image and link on "
"the grid."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:57
msgid "The app's primary requirements are:"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:59
msgid "Wallet connectivity"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:60
msgid "Grid for displaying existing tokens"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:61
msgid "Cell selection capability"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:62
msgid "Multicall function for token approval and minting"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:63
msgid "Dropdown to view owned tokens"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:64
msgid "On-chain representation of the entire 1 million pixel grid"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:66
msgid ""
"A significant aspect to consider is the string limitation in Cairo "
"contracts. To store links of varying sizes, they are stored as arrays of "
"`felt252`s. The contract uses the following logic for this purpose:"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:68
msgid ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> "
"SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: "
"Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"        // Read the stored array's length. If the length is superior to 255, "
"the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, "
"offset)\n"
"            .expect('Storage Span too large');\n"
"\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the "
"array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, "
"base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut "
"value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot. 255 "
"of elements is max\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too "
"large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, "
"offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None => {\n"
"                    break Result::Ok(());\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -> u8 {\n"
"        255 / Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:126
msgid "The storage method for links in the contract state is structured as:"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:140
msgid ""
"The OpenZeppelin Cairo Contracts library played a crucial role in speeding "
"up the development of the ERC721 contract for Starknet Homepage. You can "
"find the contract for review "
"[here](https://github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo). "
"Once you have installed the library, you can refer to the following example "
"for typical usage:"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:170
msgid "Component Logic"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:172
msgid "Grid"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:174
msgid ""
"The Grid component represents a 100x100 matrix, with each cell being 100 "
"pixels. This layout corresponds to the data structure found in the smart "
"contract. To showcase the tokens already minted on the Homepage, the app "
"employs a React Hook from `starknet-react` to invoke the `getAllTokens` "
"function from the contract."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:176
msgid ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:194
msgid ""
"Deserialization ensures the data from the Starknet contract is aptly "
"transformed for frontend use. This process involves decoding the array of "
"`felt252`s into extensive strings."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:196
msgid ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:211
msgid ""
"Furthermore, the Grid component manages the cell selection process, leading "
"to the minting of a corresponding token. Once an area is chosen, a modal "
"appears displaying the mint details and other necessary inputs for the call "
"data. The intricacies of the multicall will be addressed subsequently."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:215
msgid "Modals"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:217
msgid ""
"Modals offer a convenient means to present varied functionalities within the "
"app, such as wallet connection, token minting, and token editing."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:221
msgid ""
"A recognized best practice is to invoke the React hook for shared "
"information at a top-level, ensuring components like the `WalletBar` remain "
"streamlined and focused."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:233
msgid ""
"Below, the `WalletConnected` function displays the connected wallet's "
"address, while the `ConnectWallet` function allows users to select and "
"connect their wallet. The `WalletBar` function renders the appropriate modal "
"based on the connection status."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:235
msgid ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" "
"gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet "
"/>;\n"
"}\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:317
msgid "Token Dropdown"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:319
msgid ""
"The dropdown component is dedicated to showcasing the tokens associated with "
"the currently connected wallet. To retrieve these tokens, a transaction like "
"the one shown below can be executed. The sole argument for this function is "
"the contract address of the intended owner."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:321
msgid ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:335
msgid "Multicall Contract Interaction"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:337
msgid ""
"The provided code offers an illustration of a multicall, specifically to "
"approve a transaction for the mint price transfer followed by the actual "
"minting action. Notably, the `shortString` module from `starknet.js` plays a "
"pivotal role; it encodes and segments a lengthy string into an array of "
"`felt252`s, the expected argument type for the contract on Starknet."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:339
msgid ""
"The `useContractWrite` is a Hook dedicated to executing a Starknet "
"multicall, which can be employed for a singular transaction or multiple ones."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:341
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:372
msgid ""
"Another crucial aspect to point out is the `calldata` of the approve "
"function for the ether transfer: calldata: "
"`[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`. The amount "
"argument is split into two parts because it's a `u256`, which is composed of "
"two separate `felt252` values."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:374
msgid ""
"Once the multicall is prepared, the next step is to initiate the function "
"and sign the transaction using the connected wallet."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:376
msgid ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:394
msgid "Conditional Multicall for Token Editing"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:396
msgid ""
"Another instructive illustration of a conditional multicall setup is the "
"modal used to modify the data associated with a token."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:400
msgid ""
"There are scenarios where the user may wish to alter just one attribute of "
"the token, rather than both. Consequently, a conditional multicall "
"configuration becomes necessary. It's essential to recall that the token id "
"in the Cairo contract is defined as a `u256`, implying it comprises two "
"`felt252` values."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:402
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:430
msgid "Starknet Homepage Overview"
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:432
msgid ""
"**Grid Component**: Represents a 100x100 matrix, allowing users to select "
"cells and mint corresponding tokens. It fetches existing tokens using the "
"`getAllTokens` function from the contract and displays them."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:433
msgid ""
"**Modals**: Serve as the user interface for actions like wallet connection, "
"token minting, and token editing."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:434
msgid ""
"**Token Dropdown**: Displays tokens associated with a connected wallet. It "
"retrieves these tokens using the `getTokensByOwner` function."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:435
msgid ""
"**Multicall Contract Interaction**: Enables token minting and editing. This "
"process utilizes conditional multicalls based on user preferences, "
"especially for editing token attributes."
msgstr ""

#: src/ch02-07-01-01-million-dollar-homepage.md:437
msgid ""
"Throughout the platform, string limitations in Cairo contracts require "
"encoding lengthy strings into arrays of `felt252`s. The OpenZeppelin Cairo "
"Contracts library significantly expedites the development of the ERC721 "
"contract for the Starknet Homepage."
msgstr ""

#: src/ch02-08-starknet-react.md:3
msgid ""
"Several tools exist in the starknet ecosystem to build the front-end for "
"your application. The most popular ones are:"
msgstr ""

#: src/ch02-08-starknet-react.md:6
msgid ""
"[starknet-react](https://github.com/apibara/starknet-react) "
"([documentation](https://apibara.github.io/starknet-react)): Collection of "
"React hooks for Starknet. It is inspired by "
"[wagmi](https://github.com/tmm/wagmi), powered by "
"[starknet.js](https://github.com/0xs34n/starknet.js)."
msgstr ""

#: src/ch02-08-starknet-react.md:12
msgid ""
"[starknet.js](https://github.com/0xs34n/starknet.js): A JavaScript library "
"for interacting with Starknet contracts. It would be the equivalent of "
"[web3.js](https://web3js.org/) for Ethereum."
msgstr ""

#: src/ch02-08-starknet-react.md:16
msgid ""
"For Vue developers, vue-stark-boil, created by the team at [Don’t Panic "
"DAO](https://github.com/dontpanicdao), is a great option. For a deeper "
"understanding of Vue, visit their [website](https://vuejs.org/). The "
"vue-stark-boil boilerplate enables various functionalities, such as "
"connecting to a wallet, listening for account changes, and calling a "
"contract."
msgstr ""

#: src/ch02-08-starknet-react.md:23
msgid ""
"Authored by the [Apibara](https://github.com/apibara/) team, [Starknet "
"React](https://github.com/apibara/starknet-react/) is an open-source "
"collection of React providers and hooks meticulously designed for Starknet."
msgstr ""

#: src/ch02-08-starknet-react.md:28
msgid ""
"To immerse in the real-world application of Starknet React, we recommend "
"exploring the comprehensive example dApp project at "
"[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)."
msgstr ""

#: src/ch02-08-starknet-react.md:32
msgid "Integrating Starknet React"
msgstr ""

#: src/ch02-08-starknet-react.md:34
msgid ""
"Embarking on your Starknet React journey necessitates the incorporation of "
"vital dependencies. Let’s start by adding them to your project."
msgstr ""

#: src/ch02-08-starknet-react.md:39
msgid ""
"[Starknet.js](https://www.starknetjs.com/) is an essential SDK facilitating "
"interactions with Starknet. In contrast, "
"[get-starknet](https://github.com/starknet-io/get-starknet/) is a package "
"adept at managing wallet connections."
msgstr ""

#: src/ch02-08-starknet-react.md:44
msgid ""
"Proceed by swaddling your app within the `StarknetConfig` component. This "
"enveloping action offers a degree of configuration, while simultaneously "
"providing a React Context for the application beneath to utilize shared data "
"and hooks. The `StarknetConfig` component accepts a connectors prop, "
"allowing the definition of wallet connection options available to the user."
msgstr ""

#: src/ch02-08-starknet-react.md:51
msgid ""
"```\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"\n"
"return (\n"
"    <StarknetConfig\n"
"      connectors={connectors}\n"
"      autoConnect\n"
"    >\n"
"      <App />\n"
"    </StarknetConfig>\n"
")\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:65
msgid "Establishing Connection and Managing Account"
msgstr ""

#: src/ch02-08-starknet-react.md:67
msgid ""
"Once the connectors are defined in the config, the stage is set to use a "
"hook to access these connectors, enabling users to connect their wallets:"
msgstr ""

#: src/ch02-08-starknet-react.md:89
msgid ""
"Observe the `disconnect` function that terminates the connection when "
"invoked. Post connection, access to the connected account is provided "
"through the `useAccount` hook, offering insight into the current state of "
"connection:"
msgstr ""

#: src/ch02-08-starknet-react.md:106
msgid ""
"The state values, such as `isConnected` and `isReconnecting`, receive "
"automatic updates, simplifying UI conditional updates. This convenient "
"pattern shines when dealing with asynchronous processes, as it eliminates "
"the need to manually manage the state within your components."
msgstr ""

#: src/ch02-08-starknet-react.md:111
msgid ""
"Having established a connection, signing messages becomes a breeze using the "
"account value returned from the `useAccount` hook. For a more streamlined "
"experience, the `useSignTypedData` hook is at your disposal."
msgstr ""

#: src/ch02-08-starknet-react.md:126
msgid ""
"Starknet React supports signing an array of `BigNumberish` values or an "
"object. While signing an object, it is crucial to ensure that the data "
"conforms to the EIP712 type. For a more comprehensive guide on signing, "
"refer to the Starknet.js documentation: "
"[here](https://www.starknetjs.com/docs/guides/signature/)."
msgstr ""

#: src/ch02-08-starknet-react.md:132
msgid "Displaying StarkName"
msgstr ""

#: src/ch02-08-starknet-react.md:134
msgid ""
"After an account has been connected, the `useStarkName` hook can be used to "
"retrieve the StarkName of this connected account. Related to "
"[Starknet.id](https://www.starknet.id/) it permits to display the user "
"address in a more user friendly way."
msgstr ""

#: src/ch02-08-starknet-react.md:139
msgid ""
"```\n"
"const { data, isError, isLoading, status } = useStarkName({ address });\n"
"// You can track the status of the request with the status variable ('idle' "
"| 'error' | 'loading' | 'success')\n"
"\n"
"if (isLoading) return <p>Loading...</p>\n"
"return <p>Account: {isError ? address : data}</p>\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:145
msgid ""
"You also have additional information you can get from this hook → **error**, "
"**isIdle**, **isFetching**, **isSuccess**, **isFetched**, "
"**isFetchedAfterMount**, **isRefetching**, **refetch** which can give you "
"more precise information on what is happening."
msgstr ""

#: src/ch02-08-starknet-react.md:150
msgid "Fetching address from StarkName"
msgstr ""

#: src/ch02-08-starknet-react.md:152
msgid ""
"You could also want to retrieve an address corresponding to a StarkName. For "
"this purpose, you can use the `useAddressFromStarkName` hook."
msgstr ""

#: src/ch02-08-starknet-react.md:161
msgid ""
"If the provided name does not have an associated address, it will return "
"**\"0x0\"**"
msgstr ""

#: src/ch02-08-starknet-react.md:164
msgid "Navigating the Network"
msgstr ""

#: src/ch02-08-starknet-react.md:166
msgid ""
"In addition to wallet and account management, Starknet React equips "
"developers with hooks for network interactions. For instance, useBlock "
"enables the retrieval of the latest block:"
msgstr ""

#: src/ch02-08-starknet-react.md:170
msgid ""
"```\n"
"const { data, isError, isFetching } = useBlock({\n"
"    refetchInterval: 10_000,\n"
"    blockIdentifier: \"latest\",\n"
"});\n"
"\n"
"if (isError) {\n"
"  return (\n"
"    <p>Something went wrong</p>\n"
"  )\n"
"}\n"
"\n"
"return (\n"
"    <p>Current block: {isFetching ? \"Loading...\" : data?.block_number}<p>\n"
")\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:185
msgid ""
"In the aforementioned code, refetchInterval controls the frequency of data "
"refetching. Behind the scenes, Starknet React harnesses "
"[react-query](https://github.com/TanStack/query/) for managing state and "
"queries. In addition to useBlock, Starknet React offers other hooks like "
"useContractRead and useWaitForTransaction, which can be configured to update "
"at regular intervals."
msgstr ""

#: src/ch02-08-starknet-react.md:192
msgid "The useStarknet hook provides direct access to the ProviderInterface:"
msgstr ""

#: src/ch02-08-starknet-react.md:194
msgid ""
"```\n"
"const { library } = useStarknet();\n"
"\n"
"// library.getClassByHash(...)\n"
"// library.getTransaction(...)\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:199
msgid "Tracking Wallet changes"
msgstr ""

#: src/ch02-08-starknet-react.md:201
msgid ""
"To improve your dApp User Experience, you can track the user wallet changes, "
"especially when the user changes the wallet account (or "
"connects/disconnects). But also when the user changes the network. You could "
"want to reload correct balances when the user changes the account, or to "
"reset the state of your dApp when the user changes the network. To do so, "
"you can use a previous hook we already looked at: `useAccount` and a new one "
"`useNetwork`."
msgstr ""

#: src/ch02-08-starknet-react.md:209
msgid ""
"The `useNetwork` hook can provide you with the network chain currently in "
"use."
msgstr ""

#: src/ch02-08-starknet-react.md:221
msgid ""
"You also have additional information you can get from this hook → "
"**blockExplorer**, **testnet** which can give you more precise information "
"about the current network being used."
msgstr ""

#: src/ch02-08-starknet-react.md:225
msgid ""
"After knowing this you have all you need to track user interaction on the "
"using account and network. You can use the `useEffect` hook to do some work "
"on changes."
msgstr ""

#: src/ch02-08-starknet-react.md:229
msgid ""
"```\n"
"const { chain } = useNetwork();\n"
"const { address } = useAccount();\n"
"\n"
"useEffect(() => {\n"
"    if(address) {\n"
"        // Do some work when the user changes the account on the wallet\n"
"        // Like reloading the balances\n"
"    }else{\n"
"        // Do some work when the user disconnects the wallet\n"
"        // Like reseting the state of your dApp\n"
"    }\n"
"}, [address]);\n"
"\n"
"useEffect(() => {\n"
"    // Do some work when the user changes the network on the wallet\n"
"    // Like reseting the state of your dApp\n"
"}, [chain]);\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:247
msgid "Contract Interactions"
msgstr ""

#: src/ch02-08-starknet-react.md:249
msgid "Read Functions"
msgstr ""

#: src/ch02-08-starknet-react.md:251
msgid ""
"Starknet React presents useContractRead, a specialized hook for invoking "
"read functions on contracts, akin to wagmi. This hook functions "
"independently of the user’s connection status, as read operations do not "
"necessitate a signer."
msgstr ""

#: src/ch02-08-starknet-react.md:256
msgid ""
"```\n"
"const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
"    abi: abi_erc20,\n"
"    address: CONTRACT_ADDRESS,\n"
"    functionName: \"allowance\",\n"
"    args: [owner, spender],\n"
"    // watch: true <- refresh at every block\n"
"});\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:264
msgid ""
"For ERC20 operations, Starknet React offers a convenient useBalance hook. "
"This hook exempts you from passing an ABI and returns a suitably formatted "
"balance value."
msgstr ""

#: src/ch02-08-starknet-react.md:268
msgid ""
"```\n"
"  const { data, isLoading } = useBalance({\n"
"    address,\n"
"    token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
"    // watch: true <- refresh at every block\n"
"  });\n"
"\n"
"  return (\n"
"    <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
"  )\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:278
msgid "Write Functions"
msgstr ""

#: src/ch02-08-starknet-react.md:280
msgid ""
"The useContractWrite hook, designed for write operations, deviates slightly "
"from wagmi. The unique architecture of Starknet facilitates multicall "
"transactions natively at the account level. This feature enhances the user "
"experience when executing multiple transactions, eliminating the need to "
"approve each transaction individually. Starknet React capitalizes on this "
"functionality through the useContractWrite hook. Below is a demonstration of "
"its usage:"
msgstr ""

#: src/ch02-08-starknet-react.md:288
msgid ""
"```\n"
"const calls = useMemo(() => {\n"
"    // compile the calldata to send\n"
"    const calldata = stark.compileCalldata({\n"
"      argName: argValue,\n"
"    });\n"
"\n"
"    // return a single object for single transaction,\n"
"    // or an array of objects for multicall**\n"
"    return {\n"
"      contractAddress: CONTRACT_ADDRESS,\n"
"      entrypoint: functionName,\n"
"      calldata,\n"
"    };\n"
"}, [argValue]);\n"
"\n"
"\n"
"// Returns a function to trigger the transaction\n"
"// and state of tx after being sent\n"
"const { write, isLoading, data } = useContractWrite({\n"
"    calls,\n"
"});\n"
"\n"
"function execute() {\n"
"  // trigger the transaction\n"
"  write();\n"
"}\n"
"\n"
"return (\n"
"  <button type=\"button\" onClick={execute}>\n"
"    Make a transaction\n"
"  </button>\n"
")\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:321
msgid ""
"The code snippet begins by compiling the calldata using the compileCalldata "
"utility provided by Starknet.js. This calldata, along with the contract "
"address and entry point, are passed to the useContractWrite hook. The hook "
"returns a write function that is subsequently used to execute the "
"transaction. The hook also provides the transaction’s hash and state."
msgstr ""

#: src/ch02-08-starknet-react.md:328
msgid "A Single Contract Instance"
msgstr ""

#: src/ch02-08-starknet-react.md:330
msgid ""
"In certain use cases, working with a single contract instance may be "
"preferable to specifying the contract address and ABI in each hook. Starknet "
"React accommodates this requirement with the useContract hook:"
msgstr ""

#: src/ch02-08-starknet-react.md:334
msgid ""
"```\n"
"const { contract } = useContract({\n"
"    address: CONTRACT_ADDRESS,\n"
"    abi: abi_erc20,\n"
"});\n"
"\n"
"// Call functions directly on contract\n"
"// contract.transfer(...);\n"
"// contract.balanceOf(...);\n"
"```"
msgstr ""

#: src/ch02-08-starknet-react.md:343
msgid "Tracking Transactions"
msgstr ""

#: src/ch02-08-starknet-react.md:345
msgid ""
"The useTransaction hook allows for the tracking of transaction states given "
"a transaction hash. This hook maintains a cache of all transactions, thereby "
"minimizing redundant network requests."
msgstr ""

#: src/ch02-08-starknet-react.md:357
msgid ""
"The full array of available hooks can be discovered in the Starknet React "
"documentation, accessible here: <https://apibara.github.io/starknet-react/>."
msgstr ""

#: src/ch02-08-starknet-react.md:363
msgid ""
"The Starknet React library offers a comprehensive suite of React hooks and "
"providers, purpose-built for Starknet and the Starknet.js SDK. By taking "
"advantage of these well-crafted tools, developers can build robust "
"decentralized applications that harness the power of the Starknet network."
msgstr ""

#: src/ch02-08-starknet-react.md:369
msgid ""
"Through the diligent work of dedicated developers and contributors, Starknet "
"React continues to evolve. New features and optimizations are regularly "
"added, fostering a dynamic and growing ecosystem of decentralized "
"applications."
msgstr ""

#: src/ch02-08-starknet-react.md:374
msgid ""
"It’s a fascinating journey, filled with innovative technology, endless "
"opportunities, and a growing community of passionate individuals. As a "
"developer, you’re not only building applications, but contributing to the "
"advancement of a global, decentralized network."
msgstr ""

#: src/ch02-08-starknet-react.md:379
msgid ""
"Have questions or need help? The Starknet community is always ready to "
"assist. Join the [Starknet Discord](https://discord.gg/starknet) or explore "
"the [StarknetBook’s GitHub "
"repository](https://github.com/starknet-edu/starknetbook) for resources and "
"support."
msgstr ""

#: src/ch02-08-starknet-react.md:385
msgid "Further Reading"
msgstr ""

#: src/ch02-08-starknet-react.md:387
msgid "[Starknet.js](https://starknet.js.org)"
msgstr ""

#: src/ch02-08-starknet-react.md:389
msgid "[Starknet React Docs](https://www.apibara.com/starknet-react-docs)"
msgstr ""

#: src/ch02-08-starknet-react.md:391
msgid "[Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)"
msgstr ""

#: src/ch02-08-starknet-react.md:393
msgid "[Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"
msgstr ""

#: src/ch02-11-foundry-forge.md:3
msgid ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) is a tool "
"designed for testing and developing Starknet contracts. It is an adaptation "
"of the Ethereum Foundry for Starknet, aiming to expedite the development "
"process."
msgstr ""

#: src/ch02-11-foundry-forge.md:5
msgid "The project consists of two primary components:"
msgstr ""

#: src/ch02-11-foundry-forge.md:7
msgid ""
"**Forge**: A testing tool specifically for Cairo contracts. This tool acts "
"as a test runner and boasts features designed to enhance your testing "
"process. Tests are written directly in Cairo, eliminating the need for other "
"programming languages. Additionally, the Forge implementation uses Rust, "
"mirroring Ethereum Foundry's choice of language."
msgstr ""

#: src/ch02-11-foundry-forge.md:8
msgid ""
"**Cast**: This serves as a DevOps tool for StarkNet, initially supporting a "
"series of commands to interface with StarkNet. In the future, Cast aims to "
"offer deployment scripts for contracts and other DevOps functions."
msgstr ""

#: src/ch02-11-foundry-forge.md:10
msgid "Forge"
msgstr ""

#: src/ch02-11-foundry-forge.md:12
msgid ""
"Merely deploying contracts is not the end game. Many tools have offered this "
"capability in the past. Forge sets itself apart by hosting a Cairo VM "
"instance, enabling the sequential execution of tests. It employs Scarb for "
"contract compilation."
msgstr ""

#: src/ch02-11-foundry-forge.md:14
msgid ""
"To utilize Forge, define test functions and label them with test attributes. "
"Users can either test standalone Cairo functions or integrate contracts, "
"dispatchers, and test contract interactions on-chain."
msgstr ""

#: src/ch02-12-foundry-cast.md:3
msgid ""
"While Forge handles testing, Cast focuses on the Command Line Interface "
"(CLI) for StarkNet. This straightforward tool, written in Rust, leverages "
"StarkNet Rust for its operations and is also integrated with Scarb. This "
"integration permits the specification of arguments in Scarb Toml, "
"simplifying the overall process."
msgstr ""

#: src/ch03-00-architecture.md:3
msgid ""
"This is an introduction to Starknet’s Layer 2 architecture, designed for "
"both beginners and experienced users. It focuses on the key components: "
"Sequencers, Provers, and nodes."
msgstr ""

#: src/ch03-00-architecture.md:7
msgid ""
"Starknet is a coordinated system, with each component—Sequencers, Provers, "
"and nodes—playing a specific yet interconnected role. Although Starknet "
"hasn’t fully decentralized yet, it’s actively moving toward that goal. This "
"understanding of the roles and interactions within the system will help you "
"better grasp the intricacies of the Starknet ecosystem."
msgstr ""

#: src/ch03-00-architecture.md:14
msgid "High-Level Overview"
msgstr ""

#: src/ch03-00-architecture.md:16
msgid ""
"Starknet’s operation begins when a transaction is received by a gateway, "
"which serves as the Mempool. This stage could also be managed by the "
"Sequencer. The transaction is initially marked as \"RECEIVED.\" The "
"Sequencer then incorporates the transaction into the network state and tags "
"it as \"ACCEPTED_ON_L2.\" The final step involves the Prover, which executes "
"the operating system on the new block, calculates its proof, and submits it "
"to the Layer 1 (L1) for verification."
msgstr ""

#: src/ch03-00-architecture.md:26
msgid "Starknet architecture"
msgstr ""

#: src/ch03-00-architecture.md:28
msgid "In essence, Starknet’s architecture involves multiple components:"
msgstr ""

#: src/ch03-00-architecture.md:30
msgid ""
"The Sequencer is responsible for receiving transactions, ordering them, and "
"producing blocks. It operates similarly to validators in Ethereum or Bitcoin."
msgstr ""

#: src/ch03-00-architecture.md:34
msgid ""
"The Prover is tasked with generating proofs for the created blocks and "
"transactions. It uses Cairo’s Virtual Machine to run provable programs, "
"thereby creating execution traces necessary for generating STARK proofs."
msgstr ""

#: src/ch03-00-architecture.md:39
msgid ""
"Layer 1 (L1), in this case Ethereum, hosts a smart contract capable of "
"verifying these STARK proofs. If the proofs are valid, Starknet’s state root "
"on L1 is updated."
msgstr ""

#: src/ch03-00-architecture.md:43
msgid ""
"Starknet’s state is a comprehensive snapshot maintained through Merkle "
"trees, much like in Ethereum. This establishes the architecture of the "
"validity roll-up and the roles of each component."
msgstr ""

#: src/ch03-00-architecture.md:47
msgid "For a more in-depth look at each component, read on."
msgstr ""

#: src/ch03-00-architecture.md:49
msgid ""
"After exploring the introductory overview of the different components, delve "
"deeper into their specific roles by referring to their dedicated subchapters "
"in this Chapter."
msgstr ""

#: src/ch03-00-architecture.md:55
msgid ""
"Sequencers are the backbone of the Starknet network, akin to Ethereum’s "
"validators. They usher transactions into the system."
msgstr ""

#: src/ch03-00-architecture.md:58
msgid ""
"Validity rollups excel at offloading some network chores, like bundling and "
"processing transactions, to specialized players. This setup is somewhat like "
"how Ethereum and Bitcoin delegate security to miners. Sequencing, like "
"mining, demands hefty resources."
msgstr ""

#: src/ch03-00-architecture.md:63
msgid ""
"For networks like Starknet and other platforms utilizing Validity rollups, a "
"similar parallel is drawn. These networks outsource transaction processing "
"to specialized entities and then verify their work. These specialized "
"entities in the context of Validity rollups are known as \"Sequencers.\""
msgstr ""

#: src/ch03-00-architecture.md:69
msgid ""
"Instead of providing security, as miners do, Sequencers provide transaction "
"capacity. They order (sequence) multiple transactions into a single batch, "
"executes them, and produce a block that will later be proved by the Prover "
"and submmited to the Layer 1 network as a single, compact proof, known as a "
"\"rollup.\" In other words, just as validators in Ethereum and miners in "
"Bitcoin are specialized actors securing the network, Sequencers in Validity "
"rollup-based networks are specialized actors that provide transaction "
"capacity."
msgstr ""

#: src/ch03-00-architecture.md:78
msgid ""
"This mechanism allows Validity (or ZK) rollups to handle a higher volume of "
"transactions while maintaining the security of the underlying Ethereum "
"network. It enhances scalability without compromising on security."
msgstr ""

#: src/ch03-00-architecture.md:83
msgid "Sequencers follow a systematic method for transaction processing:"
msgstr ""

#: src/ch03-00-architecture.md:85
msgid ""
"Sequencing: They collect transactions from users and order (sequence) them."
msgstr ""

#: src/ch03-00-architecture.md:88
msgid "Executing: Sequencers then process these transactions."
msgstr ""

#: src/ch03-00-architecture.md:90
msgid ""
"Batching: Transactions are grouped together in batches or blocks for "
"efficiency."
msgstr ""

#: src/ch03-00-architecture.md:93
msgid ""
"Block Production: Sequencers produce blocks that contain batches of "
"processed transactions."
msgstr ""

#: src/ch03-00-architecture.md:96
msgid ""
"Sequencers must be reliable and highly available, as their role is critical "
"to the network’s smooth functioning. They need powerful and well-connected "
"machines to perform their role effectively, as they must process "
"transactions rapidly and continuously."
msgstr ""

#: src/ch03-00-architecture.md:101
msgid ""
"The current roadmap for Starknet includes decentralizing the Sequencer role. "
"This shift towards decentralization will allow more participants to become "
"Sequencers, contributing to the robustness of the network."
msgstr ""

#: src/ch03-00-architecture.md:105
msgid ""
"For more details in the Sequencer role, refer to the dedicated subchapter in "
"this Chapter."
msgstr ""

#: src/ch03-00-architecture.md:108
#: src/ch03-03-provers.md:1
msgid "Provers"
msgstr ""

#: src/ch03-00-architecture.md:110
msgid ""
"Provers serve as the second line of verification in the Starknet network. "
"Their main task is to validate the work of the Sequencers (when they receive "
"the block produced by the Sequencer) and to generate proofs that these "
"processes were correctly performed."
msgstr ""

#: src/ch03-00-architecture.md:115
msgid "The duties of a Prover include:"
msgstr ""

#: src/ch03-00-architecture.md:117
msgid ""
"Receiving Blocks: Provers obtain blocks of processed transactions from "
"Sequencers."
msgstr ""

#: src/ch03-00-architecture.md:120
msgid ""
"Processing: Provers process these blocks a second time, ensuring that all "
"transactions within the block have been correctly handled."
msgstr ""

#: src/ch03-00-architecture.md:123
msgid ""
"Proof Generation: After processing, Provers generate a proof of correct "
"transaction processing."
msgstr ""

#: src/ch03-00-architecture.md:126
msgid ""
"Sending Proof to Ethereum: Finally, the proof is sent to the Ethereum "
"network for validation. If the proof is correct, the Ethereum network "
"accepts the block of transactions."
msgstr ""

#: src/ch03-00-architecture.md:130
msgid ""
"Provers need even more computational power than Sequencers because they have "
"to calculate and generate proofs, a process that is computationally heavy. "
"However, the work of Provers can be split into multiple parts, allowing for "
"parallelism and efficient proof generation. The proof generation process is "
"asynchronous, meaning it doesn’t have to occur immediately or in real-time. "
"This flexibility allows for the workload to be distributed among multiple "
"Provers. Each Prover can work on a different block, allowing for parallelism "
"and efficient proof generation."
msgstr ""

#: src/ch03-00-architecture.md:140
msgid ""
"The design of Starknet relies on these two types of actors — Sequencers and "
"Provers — working in tandem to ensure efficient processing and secure "
"verification of transactions."
msgstr ""

#: src/ch03-00-architecture.md:144
msgid ""
"For more details in the Prover role, refer to the dedicated subchapter in "
"this Chapter."
msgstr ""

#: src/ch03-00-architecture.md:147
msgid "Optimizing Sequencers and Provers: Debunking Common Misconceptions"
msgstr ""

#: src/ch03-00-architecture.md:149
msgid ""
"The relationship between Sequencers and Provers in blockchain technology "
"often sparks debate. A common misunderstanding suggests that either the "
"Prover or the Sequencer is the main bottleneck. To set the record straight, "
"let’s discuss the optimization of both components."
msgstr ""

#: src/ch03-00-architecture.md:154
msgid ""
"Starknet, utilizing the Cairo programming language, currently supports only "
"sequential transactions. Plans are in place to introduce parallel "
"transactions in the future. However, as of now, the Sequencer operates one "
"transaction at a time, making it the bottleneck in the system."
msgstr ""

#: src/ch03-00-architecture.md:159
msgid ""
"In contrast, Provers operate asynchronously and can execute multiple tasks "
"in parallel. The use of proof recursion allows for task distribution across "
"multiple machines, making scalability less of an issue for Provers."
msgstr ""

#: src/ch03-00-architecture.md:164
msgid ""
"Given the asynchronous and scalable nature of Provers, focus in Starknet has "
"shifted to enhancing the Sequencer’s efficiency. This explains why current "
"development efforts are primarily aimed at the sequencing side of the "
"equation."
msgstr ""

#: src/ch03-00-architecture.md:169
#: src/ch03-04-nodes.md:1
msgid "Nodes"
msgstr ""

#: src/ch03-00-architecture.md:171
msgid ""
"When it comes to defining what nodes do in Bitcoin or Ethereum, people often "
"misinterpret their role as keeping track of every transaction within the "
"network. This, however, is not entirely accurate."
msgstr ""

#: src/ch03-00-architecture.md:175
msgid ""
"Nodes serve as auditors of the network, maintaining the state of the "
"network, such as how much Bitcoin each participant owns or the current state "
"of a specific smart contract. They accomplish this by processing "
"transactions and preserving a record of all transactions, but that’s a means "
"to an end, not the end itself."
msgstr ""

#: src/ch03-00-architecture.md:181
msgid ""
"In Validity rollups and specifically within Starknet, this concept is "
"somewhat reversed. Nodes don’t necessarily have to process transactions to "
"get the state. In contrast to Ethereum or Bitcoin, Starknet nodes aren’t "
"required to process all transactions to maintain the state of the network."
msgstr ""

#: src/ch03-00-architecture.md:187
msgid ""
"There are two main ways to access network state data: via an API gateway or "
"using the RPC protocol to communicate with a node. Operating your own node "
"is typically faster than using a shared architecture, like the gateway. Over "
"time, Starknet plans to deprecate APIs and replace them with a JSON RPC "
"standard, making it even more beneficial to operate your own node."
msgstr ""

#: src/ch03-00-architecture.md:194
msgid ""
"It’s worth noting that encouraging more people to run nodes increases the "
"resilience of the network and prevents server flooding, which has been an "
"issue in networks in other L2s."
msgstr ""

#: src/ch03-00-architecture.md:198
msgid ""
"Currently, there are primarily three methods for a node to keep track of the "
"network’s state and we can have nodes implement any of these methods:"
msgstr ""

#: src/ch03-00-architecture.md:202
msgid ""
"**Replaying Old Transactions**: Like Ethereum or Bitcoin, a node can take "
"all the transactions and re-execute them. Although this approach is "
"accurate, it isn’t scalable unless you have a powerful machine that’s "
"capable of handling the load. If you can replay all transactions, you can "
"become a Sequencer."
msgstr ""

#: src/ch03-00-architecture.md:208
msgid ""
"**Relying on L2 Consensus**: Nodes can trust the Sequencer(s) to execute the "
"network correctly. When the Sequencer updates the state and adds a new "
"block, nodes accept the update as accurate."
msgstr ""

#: src/ch03-00-architecture.md:212
msgid ""
"**Checking Proof Validation on L1**: Nodes can monitor the state of the "
"network by observing L1 and ensuring that every time a proof is sent, they "
"receive the updated state. This way, they don’t have to trust anyone and "
"only need to keep track of the latest valid transaction for Starknet."
msgstr ""

#: src/ch03-00-architecture.md:218
msgid ""
"Each type of node setup comes with its own set of hardware requirements and "
"trust assumptions."
msgstr ""

#: src/ch03-00-architecture.md:221
msgid "Nodes That Replay Transactions"
msgstr ""

#: src/ch03-00-architecture.md:223
msgid ""
"Nodes that replay transactions require powerful machines to track and "
"execute all transactions. These nodes don’t have trust assumptions; they "
"rely solely on the transactions they execute, guaranteeing that the state at "
"any given point is valid."
msgstr ""

#: src/ch03-00-architecture.md:228
msgid "Nodes That Rely on L2 Consensus"
msgstr ""

#: src/ch03-00-architecture.md:230
msgid ""
"Nodes relying on L2 consensus require less computational power. They need "
"sufficient storage to keep the state but don’t need to process a lot of "
"transactions. The trade-off here is a trust assumption. Currently, Starknet "
"revolves around one Sequencer, so these nodes are trusting Starkware not to "
"disrupt the network. However, once a consensus mechanism and leader election "
"amongst Sequencers are in place, these nodes will only need to trust that a "
"Sequencer who staked their stake to produce a block is not willing to lose "
"it."
msgstr ""

#: src/ch03-00-architecture.md:239
msgid "Nodes That Check Proof Validation on L1"
msgstr ""

#: src/ch03-00-architecture.md:241
msgid ""
"Nodes that only update their state based on proof validation on L1 require "
"the least hardware. They have the same requirements as an Ethereum node, and "
"once Ethereum light nodes become a reality, maintaining such a node could be "
"as simple as using a smartphone. The only trade-off is latency. Proofs are "
"not sent to Ethereum every block but intermittently, resulting in delayed "
"state updates. Plans are in place to produce proofs more frequently, even if "
"they are not sent to Ethereum immediately, allowing these nodes to reduce "
"their latency. However, this development is still a way off in the Starknet "
"roadmap."
msgstr ""

#: src/ch03-00-architecture.md:253
msgid ""
"Through this chapter, we delve into Starknet’s structure, uncovering the "
"importance of Sequencers, Provers, and nodes. Each plays a unique role, but "
"together, they create a highly scalable, efficient, and secure network that "
"marks a significant step forward in Layer 2 solutions. As Starknet evolves "
"towards decentralization, understanding these roles will provide valuable "
"insight into the inner workings of this network."
msgstr ""

#: src/ch03-00-architecture.md:260
msgid ""
"As we venture further into the Starknet universe, our next stop will be an "
"exploration of the transaction lifecycle before we dive into the heart of "
"coding with Cairo."
msgstr ""

#: src/ch03-01-transactions.md:3
msgid ""
"A transaction's journey in Starknet, from its inception to finality, "
"comprises a series of carefully orchestrated steps. Each stage plays a "
"crucial role in ensuring data is accurately transmitted, processed, and "
"stored within the network. In this chapter, we explore the lifecycle of a "
"Starknet transaction."
msgstr ""

#: src/ch03-01-transactions.md:5
msgid "Preparing the Groundwork: Transaction Creation"
msgstr ""

#: src/ch03-01-transactions.md:7
msgid ""
"Every transaction's journey commences with its preparation. The sender "
"queries the nonce of their account, serving as a unique identifier for each "
"transaction, signs the transaction, and dispatches it to their Node. It's "
"critical to understand the sender must be online during this process to "
"access real-time data."
msgstr ""

#: src/ch03-01-transactions.md:17
msgid ""
"The Node, analogous to a post office, receives the transaction and "
"broadcasts it on the Starknet network, primarily to the Sequencer. As the "
"network evolves, the transaction will be broadcasted to multiple Sequencers."
msgstr ""

#: src/ch03-01-transactions.md:19
msgid ""
"It is worth mentioning that before broadcasting the transaction to the "
"Sequencer, the gateways perform some validations, such as checking that the "
"max fee exceeds a minimum fee and the account's balance is greater than the "
"max fee. The transaction will be saved in the storage if the validation "
"function passes."
msgstr ""

#: src/ch03-01-transactions.md:21
msgid "Reception and Processing: The Sequencer's Role"
msgstr ""

#: src/ch03-01-transactions.md:23
msgid ""
"On receiving the transaction, the Sequencer acknowledges its receipt but "
"hasn't processed it yet—similar to Ethereum's mempool state."
msgstr ""

#: src/ch03-01-transactions.md:34
msgid ""
"It's crucial to remember the sequentiality of transaction processing in "
"Starknet: the nonce won't update until the Sequencer processes your "
"transaction. This aspect could become a hurdle when building backend "
"applications, as sending multiple transactions consecutively may result in "
"confusion or errors."
msgstr ""

#: src/ch03-01-transactions.md:36
msgid "Acceptance on Layer-2 (L2)"
msgstr ""

#: src/ch03-01-transactions.md:38
msgid ""
"When the Sequencer validates and executes a transaction, it immediately "
"updates the state without waiting for the block emission. The transaction "
"status changes from 'received' to 'accepted on L2' at this stage."
msgstr ""

#: src/ch03-01-transactions.md:40
msgid ""
"Following the state update, the transaction is included in a block. However, "
"the block isn't emitted immediately. The Sequencer decides the opportune "
"moment to emit the block, either when there are enough transactions to form "
"a block or after a certain time has passed. When the block is emitted, the "
"block becomes available for other Nodes to query."
msgstr ""

#: src/ch03-01-transactions.md:48
msgid ""
"If a transaction fails during execution, it will be included in the block "
"with the status 'reverted'."
msgstr ""

#: src/ch03-01-transactions.md:50
msgid ""
"It's essential to remember that at this stage, no proof has been generated, "
"and the transaction relies on L2 consensus for security against censorship. "
"There remains a slim possibility of transaction reversal if all Sequencers "
"collude. Therefore, these stages should be seen as different layers of "
"transaction finality."
msgstr ""

#: src/ch03-01-transactions.md:52
msgid "Acceptance on Layer-1 (L1)"
msgstr ""

#: src/ch03-01-transactions.md:54
msgid ""
"The final step in the transaction's lifecycle is its acceptance on Layer-1 "
"(L1). A Prover receives the block containing the transaction, re-executes "
"the block, generates a proof, and sends it to Ethereum. Specifically, the "
"proof is sent to a smart contract on Ethereum called the Verifier smart "
"contract, which checks the proof's validity. If valid, the transaction's "
"status changes to 'accepted on L1', signifying the transaction's security by "
"Ethereum consensus."
msgstr ""

#: src/ch03-01-transactions.md:62
msgid "\\[Optional\\] Transaction Finality in Starknet"
msgstr ""

#: src/ch03-01-transactions.md:64
msgid ""
"Transaction finality refers to the point at which a transaction is "
"considered irreversible and is no longer susceptible to being reversed or "
"undone. It's the assurance that once a transaction is committed, it can't be "
"altered or rolled back, hence securing the integrity of the transaction and "
"the system as a whole."
msgstr ""

#: src/ch03-01-transactions.md:66
msgid ""
"Let's dive into the transaction finality in both Starknet and Ethereum, and "
"how they compare."
msgstr ""

#: src/ch03-01-transactions.md:68
msgid "Ethereum Transaction Finality"
msgstr ""

#: src/ch03-01-transactions.md:70
msgid ""
"Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A "
"transaction has the finality status when it is part of a block that can't "
"change without a significant amount of ETH getting burned. The number of "
"blocks required to ensure that a transaction won't be rolled back is called "
"'blocks to finality', and the time to create those blocks is called 'time to "
"finality'."
msgstr ""

#: src/ch03-01-transactions.md:72
msgid ""
"It is considered to be an average of 6 blocks to reach the finality status; "
"given that a new block is validated each 12 seconds, the average time to "
"finality for a transaction is 75 seconds."
msgstr ""

#: src/ch03-01-transactions.md:74
msgid "Starknet Transaction Finality"
msgstr ""

#: src/ch03-01-transactions.md:76
msgid ""
"Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction "
"finality process. The first step is when the transaction gets accepted on "
"Layer-2 (Starknet), and the second step is when the transaction gets "
"accepted on Layer-1 (Ethereum)."
msgstr ""

#: src/ch03-01-transactions.md:78
msgid ""
"Accepted on L2: When a transaction is processed by the Sequencer and "
"included in a block on Starknet, it reaches L2 finality. However, this "
"finality relies on the L2 consensus and comes with a slight risk of "
"collusion among Sequencers leading to transaction reversal."
msgstr ""

#: src/ch03-01-transactions.md:79
msgid ""
"Accepted on L1: The absolute finality comes when the block containing the "
"transaction gets a proof generated, the proof is validated by the Verifier "
"contract on Ethereum, and the state is updated on Ethereum. At this point, "
"the transaction is as secure as the Ethereum's PoW consensus can provide, "
"meaning it becomes computationally infeasible to alter or reverse."
msgstr ""

#: src/ch03-01-transactions.md:81
msgid "Comparison"
msgstr ""

#: src/ch03-01-transactions.md:83
msgid ""
"The main difference between Ethereum and Starknet's transaction finality "
"lies in the stages of finality and their reliance on consensus mechanisms."
msgstr ""

#: src/ch03-01-transactions.md:85
msgid ""
"Ethereum's transaction finality becomes increasingly unlikely to be reversed "
"as more blocks are added."
msgstr ""

#: src/ch03-01-transactions.md:86
msgid ""
"Starknet's finality process is two-fold. The initial finality (L2) is "
"quicker but relies on L2 consensus"
msgstr ""

#: src/ch03-02-sequencers.md:3
msgid ""
"Before diving in, make sure to check out the [\"Understanding Starknet: "
"Sequencers, Provers, and "
"Nodes\"](https://book.starknet.io/chapter_3/topology.html) chapter for a "
"quick rundown of Starknet’s architecture."
msgstr ""

#: src/ch03-02-sequencers.md:8
msgid ""
"Three main layers exist in blockchain: data availability, ordering, and "
"execution. Sequencers have evolved within this evolving modular landscape of "
"blockchain technology. Most L1 blockchains, like Ethereum, handle all these "
"tasks. Initially, blockchains served as distributed virtual machines focused "
"on organizing and executing transactions. Even roll-ups running on Ethereum "
"today often centralize sequencing (ordering) and execution while relying on "
"Ethereum for data availability. This is the current state of Starknet, which "
"uses Ethereum for data availability and a centralized Sequencer for ordering "
"and execution. However, it is possible to decentralize sequencing and "
"execution, as Starknet is doing."
msgstr ""

#: src/ch03-02-sequencers.md:20
msgid ""
"Each of these layers plays a crucial role in achieving consensus. First, the "
"data must be available. Second, it needs to be put in a specific order. "
"That’s the main job of a Sequencer, whether run by a single computer or a "
"decentralized protocol. Lastly, you execute transactions in the order "
"they’ve been sequenced. This final step, done by the Sequencer too, "
"determines the system’s current state and keeps all connected clients on the "
"same page."
msgstr ""

#: src/ch03-02-sequencers.md:28
msgid "Introduction to Sequencers"
msgstr ""

#: src/ch03-02-sequencers.md:30
msgid ""
"The advent of Layer Two (L2) solutions like Roll-Ups has altered the "
"blockchain landscape, improving scalability and efficiency. But what about "
"transaction order? Is it still managed by the base layer (L1), or is an "
"external system involved? Enter Sequencers. They ensure transactions are in "
"the correct order, regardless of whether they’re managed by L1 or another "
"system."
msgstr ""

#: src/ch03-02-sequencers.md:37
msgid ""
"In essence, sequencing has two core tasks: sequencing (ordering) and "
"executing (validation). First, it orders transactions, determining the "
"canonical sequence of blocks for a given chain fork. It then appends new "
"blocks to this sequence. Second, it executes these transactions, updating "
"the system’s state based on a given function."
msgstr ""

#: src/ch03-02-sequencers.md:43
msgid ""
"To clarify, we see sequencing as the act of taking a group of unordered "
"transactions and producing an ordered block. Sequencers also confirm the "
"resulting state of the machine. However, the approach explained here "
"separates these tasks. While some systems handle both ordering and state "
"validation simultaneously, we advocate for treating them as distinct steps."
msgstr ""

#: src/ch03-02-sequencers.md:52
msgid "Sequencer role in the Starknet network"
msgstr ""

#: src/ch03-02-sequencers.md:54
msgid "Sequencers in Starknet"
msgstr ""

#: src/ch03-02-sequencers.md:56
msgid ""
"Let’s delve into Sequencers by focusing on "
"[Madara](https://github.com/keep-starknet-strange/madara) and "
"[Kraken](https://github.com/lambdaclass/starknet_stack/tree/main/sequencer), "
"two high-performance Starknet Sequencers. A Sequencer must, at least, do two "
"things: order and execute transactions."
msgstr ""

#: src/ch03-02-sequencers.md:62
msgid ""
"**Ordering**: Madara handles the sequencing process, supporting methods from "
"simple FCFS and PGA to complex ones like Narwhall & Bullshark. It also "
"manages the mempool, a critical data structure that holds unconfirmed "
"transactions. Developers can choose the consensus protocol through Madara’s "
"use of Substrate, which offers multiple built-in options."
msgstr ""

#: src/ch03-02-sequencers.md:69
msgid ""
"**Execution**: Madara lets you choose between two execution crates: "
"[Blockifier](https://github.com/starkware-libs/blockifier/tree/main) and "
"[Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust). Both "
"use the [Cairo VM](https://github.com/lambdaclass/cairo-vm) for their "
"framework."
msgstr ""

#: src/ch03-02-sequencers.md:76
msgid "We also have the Kraken Sequencer as another option."
msgstr ""

#: src/ch03-02-sequencers.md:78
msgid ""
"**Ordering**: It employs Narwhall & Bullshark for mempool management. You "
"can choose from multiple consensus methods, like Bullshark, Tendermint, or "
"Hotstuff."
msgstr ""

#: src/ch03-02-sequencers.md:82
msgid ""
"**Execution**: Runs on Starknet_in_Rust. Execution can be deferred to either "
"[Cairo Native](https://github.com/lambdaclass/cairo_native) or [Cairo "
"VM](https://github.com/lambdaclass/cairo-vm)."
msgstr ""

#: src/ch03-02-sequencers.md:145
msgid "Understanding the Execution Layer"
msgstr ""

#: src/ch03-02-sequencers.md:147
msgid ""
"[Blockifier](https://github.com/starkware-libs/blockifier/tree/main), a Rust "
"component in Starknet Sequencers, generates state diffs and blocks. It uses "
"[Cairo VM](https://github.com/lambdaclass/cairo-vm). Its goal is to become a "
"full Starknet Sequencer."
msgstr ""

#: src/ch03-02-sequencers.md:152
msgid ""
"Starknet_in_Rust is another Rust component for Starknet that also generates "
"state diffs and blocks. It uses [Cairo "
"VM](https://github.com/lambdaclass/cairo-vm)."
msgstr ""

#: src/ch03-02-sequencers.md:156
msgid ""
"[Cairo Native](https://github.com/lambdaclass/cairo_native) stands out by "
"converting Cairo’s Sierra code to MLIR. See an example "
"[here](https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)."
msgstr ""

#: src/ch03-02-sequencers.md:160
msgid "The Need for Decentralized Sequencers"
msgstr ""

#: src/ch03-02-sequencers.md:162
msgid ""
"For more details on the Decentralization of Starknet, refer to the dedicated "
"subchapter in this Chapter."
msgstr ""

#: src/ch03-02-sequencers.md:165
msgid ""
"Proving transactions doesn’t required to be decentralized (although in the "
"near future Starknet will operate with decentralized provers). Once the "
"order is set, anyone can submit a proof; it’s either correct or not. "
"However, the process that determines this order should be decentralized to "
"maintain a blockchain’s original qualities."
msgstr ""

#: src/ch03-02-sequencers.md:171
msgid ""
"In the context of Ethereum’s Layer 1 (L1), Sequencers can be likened to "
"Ethereum validators. They are responsible for creating and broadcasting "
"blocks. This role is divided under the concept of \"Proposer-Builder "
"Separation\" (PBS) ([Hasu, "
"2023](https://www.youtube.com/watch?v=6xS0xMzh9Tc)). Block builders form "
"blocks (order the transactions), while block proposers, unaware of the "
"block’s content, choose the most profitable one. This separation prevents "
"transaction censorship at the protocol level. Currently, most Layer 2 (L2) "
"Sequencers, including Starknet, perform both roles, which can create issues."
msgstr ""

#: src/ch03-02-sequencers.md:182
msgid ""
"The drive toward centralized Sequencers mainly stems from performance issues "
"like high costs and poor user experience on Ethereum for both data storage "
"and transaction ordering. The challenge is scalability: how to expand "
"without sacrificing decentralization. Opting for centralization risks "
"turning the blockchain monopolistic, negating its unique advantages like "
"network-effect services without monopoly."
msgstr ""

#: src/ch03-02-sequencers.md:189
msgid ""
"With centralization, blockchain loses its core principles: credible "
"neutrality and resistance to monopolization. What’s wrong with a centralized "
"system? It raises the risks of censorship (via transaction reordering)."
msgstr ""

#: src/ch03-02-sequencers.md:194
msgid "A centralized validity roll-up looks like this:"
msgstr ""

#: src/ch03-02-sequencers.md:196
msgid ""
"User Interaction & Selection: Users send transactions to a centralized "
"Sequencer, which selects and orders them."
msgstr ""

#: src/ch03-02-sequencers.md:199
msgid ""
"Block Formation: The Sequencer packages these ordered transactions into a "
"block."
msgstr ""

#: src/ch03-02-sequencers.md:202
msgid ""
"Proof & Verification: The block is sent to a proving service, which "
"generates a proof and posts it to Layer 1 (L1) for verification."
msgstr ""

#: src/ch03-02-sequencers.md:205
msgid ""
"Verification: Once verified on L1, the transactions are considered finalized "
"and integrated into the L1 blockchain."
msgstr ""

#: src/ch03-02-sequencers.md:210
msgid "Centralized rollup"
msgstr ""

#: src/ch03-02-sequencers.md:212
msgid ""
"While centralized roll-ups can provide L1 security, they come with a "
"significant downside: the risk of censorship. Hence, the push for "
"decentralization in roll-ups."
msgstr ""

#: src/ch03-02-sequencers.md:218
msgid ""
"This chapter has dissected the role of Sequencers in the complex ecosystem "
"of blockchain technology, focusing on Starknet’s current state and future "
"directions. Sequencers essentially serve two main functions: ordering "
"transactions and executing them. While these tasks may seem straightforward, "
"they are pivotal in achieving network consensus and ensuring security."
msgstr ""

#: src/ch03-02-sequencers.md:225
msgid ""
"Given the evolving modular architecture of blockchain—with distinct layers "
"for data availability, transaction ordering, and execution—Sequencers "
"provide a crucial link. Their role gains more significance in the context of "
"Layer 2 solutions, where achieving scalability without sacrificing "
"decentralization is a pressing concern."
msgstr ""

#: src/ch03-02-sequencers.md:231
msgid ""
"In Starknet, Sequencers like Madara and Kraken demonstrate the potential of "
"high-performance, customizable solutions. These Sequencers allow for a range "
"of ordering methods and execution frameworks, proving that there’s room for "
"innovation even within seemingly rigid structures."
msgstr ""

#: src/ch03-02-sequencers.md:236
msgid ""
"The discussion on \"Proposer-Builder Separation\" (PBS) highlights the need "
"for role specialization to maintain a system’s integrity and thwart "
"transaction censorship. This becomes especially crucial when we recognize "
"that the current model of many L2 Sequencers, Starknet included, performs "
"both proposing and building, potentially exposing the network to "
"vulnerabilities."
msgstr ""

#: src/ch03-02-sequencers.md:243
msgid ""
"To reiterate, Sequencers aren’t just a mechanism for transaction ordering "
"and execution; they are a linchpin in blockchain’s decentralized ethos. "
"Whether centralized or decentralized, Sequencers must strike a delicate "
"balance between scalability, efficiency, and the overarching principle of "
"decentralization."
msgstr ""

#: src/ch03-02-sequencers.md:249
msgid ""
"As blockchain technology continues to mature, it’s worth keeping an eye on "
"how the role of Sequencers evolves. They hold the potential to either "
"strengthen or weaken the unique advantages that make blockchain technology "
"so revolutionary."
msgstr ""

#: src/ch03-03-provers.md:3
msgid ""
"SHARP is like public transportation for proofs on Starknet, aggregating "
"multiple Cairo programs to save costs and boost efficiency. It uses "
"recursive proofs, allowing parallelization and optimization, making it more "
"affordable for all users. Critical services like the gateway, validator, and "
"Prover work together with a stateless design for flexibility. SHARP’s "
"adoption by StarkEx, Starknet, and external users (through the Cairo "
"Playground) highlights its significance and potential for future "
"optimization."
msgstr ""

#: src/ch03-03-provers.md:12
msgid ""
"This chapter will discuss SHARP, how it has evolved to incorporate recursive "
"proofs, and its role in reducing costs and improving efficiency within the "
"Starknet network."
msgstr ""

#: src/ch03-03-provers.md:16
msgid "What is SHARP?"
msgstr ""

#: src/ch03-03-provers.md:18
msgid ""
"SHARP, which stands for \"Shared Prover\", is a mechanism used in Starknet "
"that aggregates multiple Cairo programs from different users, each "
"containing different logic. These Cairo programs are then executed together, "
"generating a single proof common to all the programs. Rather than sending "
"the proof directly to the Solidity Verifier in Ethereum, it is initially "
"sent to a STARK Verifier program written in Cairo. The STARK Verifier "
"generates a new proof to confirm that the initial proofs were verified, "
"which can be sent back into SHARP and the STARK Verifier. This recursive "
"proof process will be discussed in more detail later in this chapter. "
"Ultimately, the last proof in the series is sent to the Solidity Verifier on "
"Ethereum. In other words, there are many proofs generated until we reach "
"Ethereum and the Solidity Verifier."
msgstr ""

#: src/ch03-03-provers.md:31
msgid ""
"The primary benefit of SHARP system lies in its ability to decrease costs "
"and enhance efficiency within the Starknet network. It achieves this by "
"aggregating multiple Cairo jobs, which are individual sets of computations. "
"This aggregation allows the protocol to leverage the exponential "
"amortization offered by STARK proofs."
msgstr ""

#: src/ch03-03-provers.md:37
msgid ""
"Exponential amortization means that as the computational load of the proofs "
"increases, the cost of verifying those proofs rises at a slower logarithmic "
"rate than the computation increase. In other words, the computation itself "
"grows slower than the verification cost. As a result, the cost of each "
"transaction within the aggregated set is significantly reduced, making the "
"overall process more cost-effective and accessible for users."
msgstr ""

#: src/ch03-03-provers.md:45
msgid ""
"In SHARP and Cairo context, \"jobs\" refer to the individual Cairo programs "
"or tasks submitted by different users. These jobs contain specific logic or "
"computations that must be executed on the Starknet network."
msgstr ""

#: src/ch03-03-provers.md:50
msgid ""
"Additionally, SHARP allows smaller users with limited computation to benefit "
"from joining other jobs and share the cost of generating the proofs. This "
"collaborative approach is similar to using public transportation instead of "
"a private car, where the cost is distributed among all participants, making "
"it more affordable for everyone."
msgstr ""

#: src/ch03-03-provers.md:56
msgid "Recursive Proofs in SHARP"
msgstr ""

#: src/ch03-03-provers.md:58
msgid ""
"One of the most powerful features of SHARP is its use of recursive proofs. "
"Rather than directly sending the generated proofs to the Solidity Verifier, "
"they are first sent to a STARK Verifier program written in Cairo. This "
"Verifier, which is also a Cairo Program, receives the proof and creates a "
"new Cairo job that is sent to the Prover. The Prover then generates a new "
"proof to confirm that the initial proofs were verified. These new proofs can "
"be sent back into SHARP and the STARK Verifier, restarting the process."
msgstr ""

#: src/ch03-03-provers.md:67
msgid ""
"This process continues recursively, with each new proof being sent to the "
"Cairo Verifier until a trigger is reached. At this point, the last proof in "
"the series is sent to the Solidity Verifier on Ethereum. This approach "
"allows for greater parallelization of the computation and reduces the time "
"and cost associated with generating and verifying proofs."
msgstr ""

#: src/ch03-03-provers.md:97
msgid ""
"At first glance, recursive proofs may seem more complex and time-consuming. "
"However, there are several benefits to this approach:"
msgstr ""

#: src/ch03-03-provers.md:100
msgid ""
"**Parallelization**: Recursive proofs allow for work parallelization, "
"reducing user latency and improving SHARP efficiency."
msgstr ""

#: src/ch03-03-provers.md:104
msgid ""
"**Cheaper on-chain costs**: Parallelization enables SHARP to create larger "
"proofs, which would have previously been limited by the availability of "
"large cloud machines (which are rare and limited). As a result, on-chain "
"costs are reduced."
msgstr ""

#: src/ch03-03-provers.md:109
msgid ""
"**Lower cloud costs**: Since each job is shorter, the required memory for "
"processing is reduced, resulting in lower cloud costs."
msgstr ""

#: src/ch03-03-provers.md:112
msgid ""
"**Optimization**: Recursive proofs enable SHARP to optimize for various "
"factors, including latency, on-chain costs, and time to proof."
msgstr ""

#: src/ch03-03-provers.md:116
msgid ""
"**Cairo support**: Recursive proofs only require support in Cairo, without "
"the need to add support in the Solidity Verifier."
msgstr ""

#: src/ch03-03-provers.md:119
msgid ""
"Latency in Starknet encompasses the time taken for processing, confirming, "
"and including transactions in a block. It is affected by factors like "
"network congestion, transaction fees, and system efficiency. Minimizing "
"latency ensures faster transaction processing and user feedback."
msgstr ""

#: src/ch03-03-provers.md:125
msgid ""
"Time to proof, however, specifically pertains to the duration required to "
"generate and verify cryptographic proofs for transactions or operations."
msgstr ""

#: src/ch03-03-provers.md:129
msgid "SHARP Backend Architecture and Data Pipeline"
msgstr ""

#: src/ch03-03-provers.md:131
msgid ""
"SHARP back end architecture consists of several services that work together "
"to process Cairo jobs and generate proofs. These services include:"
msgstr ""

#: src/ch03-03-provers.md:135
msgid "**Gateway**: Cairo jobs enter SHARP through the gateway."
msgstr ""

#: src/ch03-03-provers.md:137
msgid ""
"**Job Creator**: It prevents job duplication and ensures that the system "
"operates consistently, regardless of multiple identical requests."
msgstr ""

#: src/ch03-03-provers.md:141
msgid ""
"**Validator**: This is the first important step. The validator service runs "
"validation checks on each job, ensuring they meet the requirements and can "
"fit within the prover machines. Invalid jobs are tagged as such and do not "
"proceed to the Prover."
msgstr ""

#: src/ch03-03-provers.md:146
msgid ""
"**Scheduler**: The scheduler service creates \"trains\" that aggregate jobs "
"and send them to the Prover. Recursive jobs are paired and sent to the "
"Prover together."
msgstr ""

#: src/ch03-03-provers.md:150
msgid ""
"**Cairo Runner**: This service runs Cairo for the Prover’s needs. The Cairo "
"Runner service runs Cairo programs, executing the necessary computations and "
"generating the execution trace as an intermediate result. The Prover then "
"uses this execution trace."
msgstr ""

#: src/ch03-03-provers.md:155
msgid ""
"**Prover**: The Prover computes the proofs for each train (that contains a "
"few jobs)."
msgstr ""

#: src/ch03-03-provers.md:158
msgid "**Dispatcher**: The Dispatcher serves two functions in the SHARP system."
msgstr ""

#: src/ch03-03-provers.md:161
msgid ""
"In the case of a recursive proof, the Dispatcher runs the Cairo Verifier "
"program on the proof it has received from the Prover, resulting in a new "
"Cairo job that goes back to the Validator."
msgstr ""

#: src/ch03-03-provers.md:165
msgid ""
"In the case of a proof that needs to go on chain (e.g., to Ethereum), the "
"Dispatcher creates \"packages\" from the proof, which can then be sent to "
"the Blockchain Writer."
msgstr ""

#: src/ch03-03-provers.md:169
msgid ""
"**Blockchain Writer**: Once the packages have been created by the "
"Dispatcher, they are sent to the Blockchain Writer. The Blockchain Writer is "
"responsible for sending the packages to the appropriate blockchain (e.g., "
"Ethereum) for verification. This is an important step in the SHARP system, "
"as it ensures that the proofs are properly verified and that the "
"transactions are securely recorded on the blockchain."
msgstr ""

#: src/ch03-03-provers.md:177
msgid ""
"**Catcher**: The Catcher monitors blockchain (e.g., Ethereum) transactions "
"to ensure that they have been accepted. While the Catcher is relevant for "
"internal monitoring purposes, it is important to note that if a transaction "
"fails, the fact won’t be registered on-chain in the fact registry. As a "
"result, the soundness of the system is still preserved even without the "
"catcher."
msgstr ""

#: src/ch03-03-provers.md:184
msgid ""
"SHARP is designed to be stateless (each Cairo job is executed in its own "
"context and has no dependency on other jobs), allowing for greater "
"flexibility in processing jobs."
msgstr ""

#: src/ch03-03-provers.md:188
msgid "Current SHARP Users"
msgstr ""

#: src/ch03-03-provers.md:190
msgid "Currently, the primary users of SHARP include:"
msgstr ""

#: src/ch03-03-provers.md:192
msgid "StarkEx"
msgstr ""

#: src/ch03-03-provers.md:194
msgid "Starknet"
msgstr ""

#: src/ch03-03-provers.md:196
msgid "External users who use the Cairo Playground"
msgstr ""

#: src/ch03-03-provers.md:198
msgid "Challenges and Optimization"
msgstr ""

#: src/ch03-03-provers.md:200
msgid ""
"Optimizing the Prover involves numerous challenges and potential projects on "
"which the Starkware team and the community are currently working:"
msgstr ""

#: src/ch03-03-provers.md:204
msgid ""
"Exploring more efficient hash functions: SHARP is constantly exploring more "
"efficient hash functions for Cairo, the Prover, and Solidity."
msgstr ""

#: src/ch03-03-provers.md:208
msgid ""
"Investigating smaller fields: Investigating smaller fields for recursive "
"proof steps could lead to more efficient computations."
msgstr ""

#: src/ch03-03-provers.md:211
msgid ""
"Adjusting various parameters: SHARP is continually adjusting various "
"parameters of the STARK protocol, such as FRI parameters and block factors."
msgstr ""

#: src/ch03-03-provers.md:215
msgid ""
"Optimizing the Cairo code: SHARP is optimizing the Cairo code to make it "
"faster, resulting in a faster recursive prover."
msgstr ""

#: src/ch03-03-provers.md:218
msgid ""
"Developing dynamic layouts: This will allow Cairo programs to scale "
"resources depending on their needs."
msgstr ""

#: src/ch03-03-provers.md:221
msgid ""
"Improving scheduling algorithm: This is another optimization path that can "
"be taken. It is not within the Prover itself."
msgstr ""

#: src/ch03-03-provers.md:224
msgid ""
"In particular, dynamic layouts (you can learn more about layouts here "
"(TODO)) will allow Cairo programs to scale resources depending on their "
"needs. This can lead to more efficient computation and better utilization of "
"resources. Dynamic layouts allow SHARP to determine the required resources "
"for a specific job and adjust the layout accordingly instead of relying on "
"predefined layouts with fixed resources. This approach can provide tailored "
"solutions for each job, improving overall efficiency."
msgstr ""

#: src/ch03-03-provers.md:245
msgid ""
"In conclusion, SHARP is a critical component of Starknet’s architecture, "
"providing a more efficient and cost-effective solution for processing Cairo "
"programs and verifying their proofs. By leveraging the power of STARK "
"technology and incorporating recursive proofs, SHARP plays a vital role in "
"improving the overall performance and scalability of the Starknet network. "
"The stateless nature of SHARP and the reliance on the cryptographic "
"soundness of the STARK proving system make it an innovative and valuable "
"addition to the blockchain ecosystem."
msgstr ""

#: src/ch03-04-nodes.md:3
msgid ""
"This chapter will guide you through setting up and running a Starknet node, "
"illustrating the layered tech stack concept, and explaining how to operate "
"these protocols locally. Starknet, as a Layer 2 Validity Rollup, operates on "
"top of Ethereum Layer 1, creating a protocol stack that each addresses "
"different functionalities, similar to the OSI model for internet "
"connections. This chapter is an edit of "
"[drspacemn](https://medium.com/starknet-edu/the-starknet-stack-7b0d70a7e1d4)'s "
"blog."
msgstr ""

#: src/ch03-04-nodes.md:12
msgid ""
"CONTRIBUTE: This guide shows how to run a Starknet node locally with a "
"particular setup. You can contribute to this guide by adding more options "
"for hardware and software, as well as other ways to run a Starknet nod (for "
"example using [Beerus](https://github.com/keep-starknet-strange/beerus)). "
"You can also contribute by adding more information about the Starknet stack "
"and the different layers. Feel free to [open a "
"PR](https://github.com/starknet-edu/starknetbook)."
msgstr ""

#: src/ch03-04-nodes.md:21
msgid "What is a Node in the Context of Ethereum and Blockchain?"
msgstr ""

#: src/ch03-04-nodes.md:23
msgid ""
"In the context of Ethereum and blockchain, a node is an integral part of the "
"network that validates and relays transactions. Nodes download a copy of the "
"entire blockchain and are interconnected with other nodes to maintain and "
"update the blockchain state. There are different types of nodes, such as "
"full nodes, light nodes, and mining nodes, each having different roles and "
"responsibilities within the network."
msgstr ""

#: src/ch03-04-nodes.md:30
msgid "Overview of Starknet Technology"
msgstr ""

#: src/ch03-04-nodes.md:32
msgid ""
"Starknet is a permissionless, zk-STARK-based Layer-2 network, aiming for "
"full decentralization. It enables developers to build scalable decentralized "
"applications (dApps) and utilizes Ethereum’s Layer 1 for proof verification "
"and data availability. Key aspects of Starknet include:"
msgstr ""

#: src/ch03-04-nodes.md:38
msgid ""
"**Cairo execution environment**: Cairo, the execution environment of "
"Starknet, facilitates writing and execution of complex smart contracts."
msgstr ""

#: src/ch03-04-nodes.md:42
msgid ""
"**Scalability**: Starknet achieves scalability through zk-STARK proofs, "
"minimizing the data needed to be posted on-chain."
msgstr ""

#: src/ch03-04-nodes.md:45
msgid ""
"**Node network**: The Starknet network comprises nodes that synchronize and "
"process transactions, contributing to the network’s overall security and "
"decentralization."
msgstr ""

#: src/ch03-04-nodes.md:49
msgid "Starknet Stack"
msgstr ""

#: src/ch03-04-nodes.md:51
msgid ""
"The Starknet stack can be divided into various layers, similar to OSI or "
"TCP/IP models. The most appropriate model depends on your understanding and "
"requirements. A simplified version of the modular blockchain stack might "
"look like this:"
msgstr ""

#: src/ch03-04-nodes.md:56
#: src/ch03-04-nodes.md:118
msgid "Layer 1: Data Layer"
msgstr ""

#: src/ch03-04-nodes.md:58
#: src/ch03-04-nodes.md:203
msgid "Layer 2: Execution Layer"
msgstr ""

#: src/ch03-04-nodes.md:60
#: src/ch03-04-nodes.md:270
msgid "Layer 3: Application Layer"
msgstr ""

#: src/ch03-04-nodes.md:62
#: src/ch03-04-nodes.md:296
msgid "Layer 4: Transport Layer"
msgstr ""

#: src/ch03-04-nodes.md:66
msgid "Modular blockchain layers"
msgstr ""

#: src/ch03-04-nodes.md:68
msgid "Setup"
msgstr ""

#: src/ch03-04-nodes.md:70
msgid ""
"There are various hardware specifications, including packaged options, that "
"will enable you to run an Ethereum node from home. The goal here is to build "
"the most cost-efficient Starknet stack possible ([see here more "
"options](https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md))."
msgstr ""

#: src/ch03-04-nodes.md:75
msgid "**Minimum Requirements:**"
msgstr ""

#: src/ch03-04-nodes.md:77
msgid "CPU: 2+ cores"
msgstr ""

#: src/ch03-04-nodes.md:79
msgid "RAM: 4 GB"
msgstr ""

#: src/ch03-04-nodes.md:81
msgid "Disk: 600 GB"
msgstr ""

#: src/ch03-04-nodes.md:83
msgid "Connection Speed: 8 mbps/sec"
msgstr ""

#: src/ch03-04-nodes.md:85
msgid "**Recommended Specifications:**"
msgstr ""

#: src/ch03-04-nodes.md:87
msgid "CPU: 4+ cores"
msgstr ""

#: src/ch03-04-nodes.md:89
msgid "RAM: 16 GB+"
msgstr ""

#: src/ch03-04-nodes.md:91
msgid "Disk 2 TB"
msgstr ""

#: src/ch03-04-nodes.md:93
msgid "Connection Speed: 25+ mbps/sec"
msgstr ""

#: src/ch03-04-nodes.md:95
msgid "**You can refer to these links for the hardware:**"
msgstr ""

#: src/ch03-04-nodes.md:97
msgid "[CPU](https://a.co/d/iAWpTzQ) — $193"
msgstr ""

#: src/ch03-04-nodes.md:99
msgid "[Board](https://a.co/d/cTUk9Kd) (can attempt w/ Raspberry Pi) — $110"
msgstr ""

#: src/ch03-04-nodes.md:101
msgid "[Disk](https://a.co/d/0US61Y5) — $100"
msgstr ""

#: src/ch03-04-nodes.md:103
msgid "[RAM](https://a.co/d/br867sk) — $60"
msgstr ""

#: src/ch03-04-nodes.md:105
msgid "[PSU](https://a.co/d/2k3Gn40) — $40"
msgstr ""

#: src/ch03-04-nodes.md:107
msgid "[Case](https://a.co/d/apCBGwF) — $50"
msgstr ""

#: src/ch03-04-nodes.md:109
msgid "Total — $553"
msgstr ""

#: src/ch03-04-nodes.md:111
msgid ""
"Recommended operating system and software: Ubuntu LTS, "
"[Docker](https://docs.docker.com/engine/install/ubuntu), and [Docker "
"Compose](https://docs.docker.com/compose/install/linux). Ensure you have the "
"necessary tools installed with:"
msgstr ""

#: src/ch03-04-nodes.md:120
msgid ""
"The bottom-most layer of the stack is the data layer. Here, Starknet’s L2 "
"leverages Ethereum’s L1 for proof verification and data availability. "
"Starknet utilizes Ethereum as its L1, so the first step is setting up an "
"Ethereum Full Node. As this is the data layer, the hardware bottleneck is "
"usually the disk storage. It’s crucial to have a high capacity I/O SSD over "
"an HDD because Ethereum Nodes require both an Execution Client and a "
"Consensus Client for communication."
msgstr ""

#: src/ch03-04-nodes.md:128
msgid ""
"Ethereum provides several options for Execution and Consensus clients. "
"Execution clients include Geth, Erigon, Besu (used here), Nethermind, and "
"Akula. Consensus clients include Prysm, Lighthouse (used here), Lodestar, "
"Nimbus, and Teku."
msgstr ""

#: src/ch03-04-nodes.md:133
msgid ""
"Your Besu/Lighthouse node will take approximately 600 GB of disk space. "
"Navigate to a partition on your machine with sufficient capacity and run the "
"following commands:"
msgstr ""

#: src/ch03-04-nodes.md:137
msgid ""
"```\n"
"git clone https://github.com/starknet-edu/starknet-stack.git\n"
"cd starknet-stack\n"
"docker-compose -f dc-l1.yaml up -d\n"
"```"
msgstr ""

#: src/ch03-04-nodes.md:141
msgid ""
"This will begin the fairly long process of spinning up our Consensus Client, "
"Execution Client, and syncing them to the current state of the Goerli "
"Testnet. If you would like to see the logs from either process you can run:"
msgstr ""

#: src/ch03-04-nodes.md:152
msgid "Lets make sure that everything that should be listening is listening:"
msgstr ""

#: src/ch03-04-nodes.md:162
msgid ""
"We’ve used docker to abstract a lot of the nuance of running an Eth L1 node, "
"but the important things to note are how the two processes EL/CL point to "
"each other and communicate via JSON-RPC:"
msgstr ""

#: src/ch03-04-nodes.md:166
msgid ""
"```\n"
"services:\n"
"  lighthouse:\n"
"      image: sigp/lighthouse:latest\n"
"      container_name: lighthouse\n"
"      volumes:\n"
"        - ./l1_consensus/data:/root/.lighthouse\n"
"        - ./secret:/root/secret\n"
"      network_mode: \"host\"\n"
"      command:\n"
"        - lighthouse\n"
"        - beacon\n"
"        - --network=goerli\n"
"        - --metrics\n"
"        - --checkpoint-sync-url=https://goerli.beaconstate.info\n"
"        - --execution-endpoint=http://127.0.0.1:8551\n"
"        - --execution-jwt=/root/secret/jwt.hex\n"
"\n"
"  besu:\n"
"    image: hyperledger/besu:latest\n"
"    container_name: besu\n"
"    volumes:\n"
"      - ./l1_execution/data:/var/lib/besu\n"
"      - ./secret:/var/lib/besu/secret\n"
"    network_mode: \"host\"\n"
"    command:\n"
"      - --network=goerli\n"
"      - --rpc-http-enabled=true\n"
"      - --data-path=/var/lib/besu\n"
"      - --data-storage-format=BONSAI\n"
"      - --sync-mode=X_SNAP\n"
"      - --engine-rpc-enabled=true\n"
"      - --engine-jwt-enabled=true\n"
"      - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex\n"
"```"
msgstr ""

#: src/ch03-04-nodes.md:200
msgid ""
"Once this is done, your Ethereum node should be up and running, and it will "
"start syncing with the Ethereum network."
msgstr ""

#: src/ch03-04-nodes.md:205
msgid ""
"The next layer in our Starknet stack is the Execution Layer. This layer is "
"responsible for running the Cairo VM, which executes Starknet smart "
"contracts. The Cairo VM is a deterministic virtual machine that allows "
"developers to write complex smart contracts in the Cairo language. Starknet "
"uses a similar [JSON-RPC "
"spec](https://github.com/starkware-libs/starknet-specs) as "
"[Ethereum](https://ethereum.org/en/developers/docs/apis/json-rpc) in order "
"to interact with the execution layer."
msgstr ""

#: src/ch03-04-nodes.md:214
msgid ""
"In order to stay current with the propagation of the Starknet blockchain we "
"need a client similar to Besu that we are using for L1. The efforts to "
"provide full nodes for the Starknet ecosystem are: "
"[Pathfinder](https://github.com/eqlabs/pathfinder) (used here), "
"[Papyrus](https://github.com/starkware-libs/papyrus), and "
"[Juno](https://github.com/NethermindEth/juno). However, different "
"implementations are still in development and not yet ready for production."
msgstr ""

#: src/ch03-04-nodes.md:223
msgid "Check that your L1 has completed its sync:"
msgstr ""

#: src/ch03-04-nodes.md:225
msgid ""
"```\n"
"# check goerli etherscan to make sure you have the latest block "
"https://goerli.etherscan.io\n"
"\n"
"curl --location --request POST 'http://localhost:8545' \\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
"    \"jsonrpc\":\"2.0\",\n"
"    \"method\":\"eth_blockNumber\",\n"
"    \"params\":[],\n"
"    \"id\":83\n"
"}'\n"
"\n"
"# Convert the result, which is hex (remove 0x) to decimal. Example:\n"
"echo $(( 16#246918 ))\n"
"```"
msgstr ""

#: src/ch03-04-nodes.md:239
msgid ""
"Start your L2 Execution Client and note that we are syncing Starknet’s state "
"from our LOCAL ETH L1 NODE!"
msgstr ""

#: src/ch03-04-nodes.md:242
msgid "PATHFINDER_ETHEREUM_API_URL=http://127.0.0.1:8545"
msgstr ""

#: src/ch03-04-nodes.md:247
msgid "To follow the sync:"
msgstr ""

#: src/ch03-04-nodes.md:251
msgid ""
"Starknet [Testnet_1](https://testnet.starkscan.co) currently comprises "
"800,000+ blocks so this will take some time (days) to sync fully. To check "
"L2 sync:"
msgstr ""

#: src/ch03-04-nodes.md:255
msgid ""
"```\n"
"# compare `current_block_num` with `highest_block_num`\n"
"\n"
"curl --location --request POST 'http://localhost:9545' \\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
" \"jsonrpc\":\"2.0\",\n"
" \"method\":\"starknet_syncing\",\n"
" \"params\":[],\n"
" \"id\":1\n"
"}'\n"
"```"
msgstr ""

#: src/ch03-04-nodes.md:266
msgid "To check data sizes:"
msgstr ""

#: src/ch03-04-nodes.md:272
msgid ""
"We see the same need for data refinement as we did in the OSI model. On L1 "
"packets come over the wire in a raw stream of bytes and are then processed "
"and filtered by higher-level protocols. When designing a decentralized "
"application Bob will need to be cognizant of interactions with his contract "
"on chain, but doesn’t need to be aware of all the information occurring on "
"Starknet."
msgstr ""

#: src/ch03-04-nodes.md:279
msgid ""
"This is the role of an indexer. To process and filter useful information for "
"an application. Information that an application MUST be opinionated about "
"and the underlying layer MUST NOT be opinionated about."
msgstr ""

#: src/ch03-04-nodes.md:283
msgid ""
"Indexers provide applications flexibility as they can be written in any "
"programming language and have any data layout that suits the application."
msgstr ""

#: src/ch03-04-nodes.md:287
msgid ""
"To start our toy "
"[indexer](https://github.com/starknet-edu/starknet-stack/blob/main/indexer/indexer.sh) "
"run:"
msgstr ""

#: src/ch03-04-nodes.md:293
msgid ""
"Again notice that we don’t need to leave our local setup for these "
"interactions (<http://localhost:9545>)."
msgstr ""

#: src/ch03-04-nodes.md:298
msgid ""
"The transport layer comes into play when the application has parsed and "
"indexed critical information, often leading to some state change based on "
"this information. This is where the application communicates the desired "
"state change to the Layer 2 sequencer to get that change into a block. This "
"is achieved using the same full-node/RPC spec implementation, in our case, "
"Pathfinder."
msgstr ""

#: src/ch03-04-nodes.md:305
msgid ""
"When working with our local Starknet stack, invoking a transaction locally "
"might look like this:"
msgstr ""

#: src/ch03-04-nodes.md:308
msgid ""
"```\n"
"curl --location --request POST 'http://localhost:9545' \\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
"    \"jsonrpc\": \"2.0\",\n"
"    \"method\": \"starknet_addInvokeTransaction\",\n"
"    \"params\": {\n"
"        \"invoke_transaction\": {\n"
"            \"type\": \"INVOKE\",\n"
"            \"max_fee\": \"0x4f388496839\",\n"
"            \"version\": \"0x0\",\n"
"            \"signature\": [\n"
"                "
"\"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
"                "
"\"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
"            ],\n"
"            \"contract_address\": "
"\"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
"            \"calldata\": [\n"
"                \"0x1\",\n"
"                "
"\"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
"                "
"\"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
"                \"0x0\",\n"
"                \"0x1\",\n"
"                \"0x1\",\n"
"                \"0x2b\",\n"
"                \"0x0\"\n"
"            ],\n"
"            \"entry_point_selector\": "
"\"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
"        }\n"
"    },\n"
"    \"id\": 0\n"
"}'\n"
"```"
msgstr ""

#: src/ch03-04-nodes.md:339
msgid ""
"However, this process involves setting up a local wallet and signing the "
"transaction. For simplicity, we will use a browser wallet and StarkScan."
msgstr ""

#: src/ch03-04-nodes.md:342
msgid "Steps:"
msgstr ""

#: src/ch03-04-nodes.md:344
msgid "Navigate to the contract on StarkScan and connect to your wallet."
msgstr ""

#: src/ch03-04-nodes.md:346
msgid "Enter a new value and write the transaction:"
msgstr ""

#: src/ch03-04-nodes.md:350
msgid "Starkscan block explorer"
msgstr ""

#: src/ch03-04-nodes.md:352
msgid ""
"Once the transaction is accepted on the Layer 2 execution layer, the event "
"data should come through our application layer indexer."
msgstr ""

#: src/ch03-04-nodes.md:355
msgid "Example Indexer Output:"
msgstr ""

#: src/ch03-04-nodes.md:357
msgid ""
"```\n"
"Pulled Block #: 638703\n"
"Found transaction: "
"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
"Events to Index:\n"
"[\n"
"  {\n"
"    \"from_address\": "
"\"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
"    \"keys\": [\n"
"      \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
"    ],\n"
"    \"data\": [\n"
"      \"0xa\"\n"
"    ]\n"
"  },\n"
"  {\n"
"    \"from_address\": "
"\"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"    \"keys\": [\n"
"      \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
"    ],\n"
"    \"data\": [\n"
"      "
"\"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
"      \"0x0\"\n"
"    ]\n"
"  },\n"
"  {\n"
"    \"from_address\": "
"\"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
"    \"keys\": [\n"
"      \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
"    ],\n"
"    \"data\": [\n"
"      "
"\"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"      "
"\"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
"      \"0x17c1e31c270\",\n"
"      \"0x0\"\n"
"    ]\n"
"  }\n"
"]\n"
"```"
msgstr ""

#: src/ch03-04-nodes.md:394
msgid ""
"Once the transaction is accepted on Layer 1, we can query the Starknet Core "
"Contracts from our Layer 1 node to see the storage keys that have been "
"updated on our data layer!"
msgstr ""

#: src/ch03-04-nodes.md:398
msgid ""
"You have successfully navigated through the entire Starknet stack, from "
"setting up your node, through executing and monitoring a transaction, to "
"inspecting its effects on the data layer. This journey has equipped you with "
"the understanding and the skills to interact with Starknet on a deeper level."
msgstr ""

#: src/ch03-04-nodes.md:404
msgid "Conclusion: Understanding the Modular Nature of Starknet"
msgstr ""

#: src/ch03-04-nodes.md:406
msgid ""
"Conceptual models, such as the ones used in this guide, are incredibly "
"useful in helping us understand complex systems. They can be refactored, "
"reformed, and nested to provide a clear and comprehensive view of how a "
"platform like Starknet operates. For instance, the OSI Model, a foundational "
"model for understanding network interactions, underpins our modular stack."
msgstr ""

#: src/ch03-04-nodes.md:413
msgid ""
"A key concept to grasp is _Fractal Scaling._ This concept allows us to "
"extend our model to include additional layers beyond Layer 2, such as Layer "
"3. In this extended model, the entire stack recurs above our existing stack, "
"as shown in the following diagram:"
msgstr ""

#: src/ch03-04-nodes.md:420
msgid "Fractal scaling in a modular blockchain environment"
msgstr ""

#: src/ch03-04-nodes.md:422
msgid ""
"Just as Layer 2 compresses its transaction throughput into a proof and state "
"change that is written to Layer 1, we can apply the same compression "
"principle at Layer 3, proving and writing to Layer 2. This not only gives us "
"more control over the protocol rules but also allows us to achieve higher "
"compression ratios, enhancing the scalability of our applications."
msgstr ""

#: src/ch03-04-nodes.md:429
msgid ""
"In essence, Starknet’s modular and layered design, combined with the power "
"of Fractal Scaling, offers a robust and scalable framework for building "
"decentralized applications. Understanding this structure is fundamental to "
"effectively leveraging Starknet’s capabilities and contributing to its "
"ecosystem."
msgstr ""

#: src/ch03-04-nodes.md:435
msgid ""
"This concludes our journey into running a Starknet node and traversing its "
"layered architecture. We hope that you now feel equipped to explore, "
"experiment with, and innovate within the Starknet ecosystem."
msgstr ""

#: src/ch03-05-layer-3.md:1
msgid "Layer 3 (App Chains)"
msgstr ""

#: src/ch03-05-layer-3.md:3
msgid ""
"Appchains let you create a blockchain designed precisely for your "
"application’s needs. These specialized blockchains allow customization in "
"various aspects, such as hash functions and consensus algorithms. Moreover, "
"they inherit the security features of the Layer 1 or Layer 2 blockchains "
"they are built upon."
msgstr ""

#: src/ch03-05-layer-3.md:9
msgid "Example:"
msgstr ""

#: src/ch03-05-layer-3.md:11
msgid ""
"Layer 3 blockchains can exist on top of Layer 2 blockchains. You can even "
"build additional layers (Layer 4 and so on) on top of Layer 3 for more "
"complex solutions. A sample layout is shown in the following diagram."
msgstr ""

#: src/ch03-05-layer-3.md:18
msgid "Example of an environment with a Layers 3 and 4"
msgstr ""

#: src/ch03-05-layer-3.md:20
msgid "In this example ecosystem, Layer 3 options include:"
msgstr ""

#: src/ch03-05-layer-3.md:22
msgid ""
"The Public Starknet (L2), which is a general-purpose blockchain for "
"decentralized applications."
msgstr ""

#: src/ch03-05-layer-3.md:25
msgid "A L3 Starknet optimized for cost-sensitive applications."
msgstr ""

#: src/ch03-05-layer-3.md:27
msgid ""
"Customized L3 Starknet systems designed for enhanced performance, using "
"specific storage structures or data compression techniques."
msgstr ""

#: src/ch03-05-layer-3.md:30
msgid ""
"StarkEx systems used by platforms like dYdX and Sorare, offering proven "
"scalability through data availability solutions like Validium or Rollup."
msgstr ""

#: src/ch03-05-layer-3.md:34
msgid ""
"Privacy-focused Starknet instances, which could also function as a Layer 4, "
"for conducting transactions without including them in public Starknets."
msgstr ""

#: src/ch03-05-layer-3.md:38
msgid "Benefits of Layer 3"
msgstr ""

#: src/ch03-05-layer-3.md:40
msgid ""
"Layer 3 app chains (with "
"[Madara](https://github.com/keep-starknet-strange/madara) as an apt "
"sequencer or other option), offer a variety of advantages due to its "
"modularity and flexibility. Here’s an overview of the key benefits:"
msgstr ""

#: src/ch03-05-layer-3.md:45
msgid ""
"**Quick Iteration**: App chains enable rapid protocol changes, freeing you "
"from the constraints of the public Layer 2 roadmap. For example, you could "
"rapidly deploy new DeFi algorithms tailored to your user base."
msgstr ""

#: src/ch03-05-layer-3.md:50
msgid ""
"**Governance Independence**: You maintain complete control over feature "
"development and improvements, avoiding the need for decentralized governance "
"consensus. This enables, for example, quick implementation of user-suggested "
"features."
msgstr ""

#: src/ch03-05-layer-3.md:55
msgid ""
"**Cost Efficiency**: Layer 3 offers substantial cost reductions, potentially "
"up to 1 million times compared to Layer 1, making it economically feasible "
"to run more complex applications."
msgstr ""

#: src/ch03-05-layer-3.md:59
msgid ""
"**Security**: While there may be some trade-offs, such as reduced censorship "
"resistance, the core security mechanisms remain strong."
msgstr ""

#: src/ch03-05-layer-3.md:62
msgid ""
"**Congestion Avoidance**: App chains are shielded from network congestion, "
"providing a more stable transaction environment, crucial for real-time "
"applications like gaming."
msgstr ""

#: src/ch03-05-layer-3.md:66
msgid ""
"**Privacy Enhancements**: Layer 3 can serve as a testing ground for "
"privacy-centric features, which could include anonymous transactions or "
"encrypted messaging services."
msgstr ""

#: src/ch03-05-layer-3.md:70
msgid ""
"**Innovation Platform**: App chains act as experimental fields where novel "
"features can be developed and tested. For instance, they could serve as a "
"testbed for new consensus algorithms before these are considered for Layer 2."
msgstr ""

#: src/ch03-05-layer-3.md:75
msgid ""
"In summary, Layer 3 provides the flexibility, cost-efficiency, and "
"environment conducive for innovation, without significant compromise on "
"security."
msgstr ""

#: src/ch03-05-layer-3.md:79
msgid "Madara as a Sequencer for Layer 3 App Chains"
msgstr ""

#: src/ch03-05-layer-3.md:81
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a specialized "
"sequencer developed to execute transactions and group them into batches. "
"Created by the StarkWare Exploration Team, it functions as a starting point "
"for building Layer 3 Starknet appchains. This expands the possibilities for "
"innovation within the Starknet ecosystem."
msgstr ""

#: src/ch03-05-layer-3.md:87
msgid ""
"Madara’s flexibility allows for the creation of Layer 3 appchains optimized "
"for various needs, foe example:"
msgstr ""

#: src/ch03-05-layer-3.md:90
msgid ""
"Cost-Efficiency: Create an appchain for running a decentralized exchange "
"(DEX) with lower fees compared to the public Starknet."
msgstr ""

#: src/ch03-05-layer-3.md:93
msgid ""
"Performance: Build an appchain to operate a DEX with faster transaction "
"times."
msgstr ""

#: src/ch03-05-layer-3.md:96
msgid ""
"Privacy: Design an appchain to facilitate anonymous transactions or "
"encrypted messaging services."
msgstr ""

#: src/ch03-05-layer-3.md:99
msgid ""
"For more information on Madara, refer to the subchapter with the same title."
msgstr ""

#: src/ch04-00-account-abstraction.md:3
msgid ""
"Account Abstraction (AA) is a paradigm shift in how accounts and "
"transactions are managed in blockchain networks. To break it down, AA refers "
"to two intertwined notions:"
msgstr ""

#: src/ch04-00-account-abstraction.md:7
msgid ""
"Transaction Flexibility: This gives the power to each smart contract to "
"validate its transactions, rather than enforcing a one-size-fits-all "
"validation process. This can lead to a variety of potential benefits such as "
"enabling smart contracts to pay for gas fees, allowing multiple signers for "
"a single account, and even introducing advanced cryptographic signatures."
msgstr ""

#: src/ch04-00-account-abstraction.md:14
msgid ""
"User Experience Optimization: AA provides a more intuitive experience for "
"end-users. It allows developers to create a more flexible security model, "
"for instance, allowing different keys for everyday use and high-value "
"transactions. Additionally, it eliminates, if wished, the need for seed "
"phrases, instead opting for easier recovery methods."
msgstr ""

#: src/ch04-00-account-abstraction.md:21
msgid ""
"At a technical level, AA replaces Externally Owned Accounts (EOA) with a "
"generalized concept of accounts. Under this model, accounts can be "
"represented by a smart contract that dictates their specific rules and "
"behaviors. This means the user or contract account could dictate rules about "
"transaction ordering, signatures, access controls, and more, providing a "
"high level of customization."
msgstr ""

#: src/ch04-00-account-abstraction.md:28
msgid "Here are two commonly cited definitions of AA:"
msgstr ""

#: src/ch04-00-account-abstraction.md:30
msgid ""
"Definition 1: Account Abstraction (AA) is when a **smart contract can pay "
"for its own transactions** (Martin Triay, Devcon 6)\\[1\\]. In other words, "
"abstract contracts (or account smart contracts) can pay for transactions. "
"This is a departure from the traditional Externally Owned Accounts or Smart "
"Wallets."
msgstr ""

#: src/ch04-00-account-abstraction.md:36
msgid ""
"Definition 2: AA is **validation abstraction**. Instead of relying on a "
"single method of transaction validation, as with Ethereum’s Layer 1, AA "
"enables an abstraction of the validation process. This implies the "
"possibility of using different types of signatures, cryptographic "
"primitives, execution processes, etc. (lightclient, Devcon 6)\\[3\\]."
msgstr ""

#: src/ch04-00-account-abstraction.md:42
msgid ""
"AA is positioned as the cornerstone of the next generation blockchain "
"technologies, with significant improvements in scalability, user experience, "
"and security. It is currently being pioneered by Layer 2 solutions, "
"including Starknet, as they aim to revolutionize the way we approach "
"security, user experience, and self-custody in the crypto space."
msgstr ""

#: src/ch04-00-account-abstraction.md:49
msgid "Applications of Account Abstraction"
msgstr ""

#: src/ch04-00-account-abstraction.md:51
msgid ""
"Having defined Account Abstraction, let’s delve into its practical "
"applications. Account Abstraction aims to improve both the accessibility and "
"security of self-custody. Here are a few of the key features that AA enables:"
msgstr ""

#: src/ch04-00-account-abstraction.md:56
msgid ""
"**Hardware Signer:** With AA, you could sign transactions using a key "
"generated and safeguarded by your smartphone’s secure enclave. This use of "
"biometric identity makes the process more secure and user-friendly "
"(Starkware)\\[4\\], (Braavos)\\[7\\]."
msgstr ""

#: src/ch04-00-account-abstraction.md:61
msgid ""
"**Social recovery:** With the integration of AA, if you lose or compromise "
"your key, you could securely replace it, thus eliminating the need for seed "
"phrases. This change not only enhances security but also simplifies the user "
"experience (Julien Niset, 2022)\\[5\\]."
msgstr ""

#: src/ch04-00-account-abstraction.md:66
msgid ""
"**Key rotation:** If a key controlling your account is compromised, you can "
"easily replace it, negating the need to transfer your assets."
msgstr ""

#: src/ch04-00-account-abstraction.md:70
msgid ""
"**Session keys:** AA can enhance the usability of web3 applications by "
"allowing a _sign in once_ feature. This would enable websites to execute "
"transactions on your behalf, reducing the need for continuous approvals."
msgstr ""

#: src/ch04-00-account-abstraction.md:75
msgid ""
"**Custom transaction validation schemes:** AA enables the use of various "
"signature schemes, multisignatures, and other security rules. This "
"flexibility allows for customizable security measures to meet individual "
"user’s needs (Martin Triay, Devcon 6)\\[1\\], (Julien Niset, 2022)\\[5\\], "
"(Motty Lavie)\\[7\\]."
msgstr ""

#: src/ch04-00-account-abstraction.md:81
msgid "Moreover, AA provides enhanced security in several ways:"
msgstr ""

#: src/ch04-00-account-abstraction.md:83
msgid ""
"**Improved key management:** With AA, you can associate multiple devices "
"with your wallet, so if one device is lost, you still have access to your "
"account."
msgstr ""

#: src/ch04-00-account-abstraction.md:87
msgid ""
"**Various signature and validation schemes:** AA supports additional "
"security measures, like two-factor authentication for large transactions, "
"providing a more secure environment that adapts to individual user’s needs."
msgstr ""

#: src/ch04-00-account-abstraction.md:92
msgid ""
"**Custom security policies:** Tailor security schemes to suit different "
"types of users or devices and adapt good practices from the banking and web2 "
"sectors."
msgstr ""

#: src/ch04-00-account-abstraction.md:96
msgid ""
"AA opens up new possibilities for both developers and users in the Ethereum "
"ecosystem. It offers a promising pathway for a more secure, user-friendly "
"experience and lays the groundwork for widespread adoption."
msgstr ""

#: src/ch04-00-account-abstraction.md:101
msgid "Ethereum Account System"
msgstr ""

#: src/ch04-00-account-abstraction.md:103
msgid ""
"To fully understand the benefits of Account Abstraction (AA), let’s delve "
"into Ethereum’s current account system. The system is split into two types "
"of accounts:"
msgstr ""

#: src/ch04-00-account-abstraction.md:107
msgid "**Externally Owned Accounts** (EOAs)"
msgstr ""

#: src/ch04-00-account-abstraction.md:109
msgid "**Contract Accounts** (CAs)."
msgstr ""

#: src/ch04-00-account-abstraction.md:111
msgid ""
"EOAs are the accounts used by individuals, wallets, or any entity external "
"to the Ethereum network. These accounts are identified by their address, "
"which is derived from the public key of an associated cryptographic object "
"called a signer. This signer, or keypair, consists of a private key and a "
"public key."
msgstr ""

#: src/ch04-00-account-abstraction.md:117
msgid ""
"The private key, also known as the secret key, is used to digitally sign "
"transactions or messages, establishing proof of ownership. The corresponding "
"public key is used to verify this signature, ensuring it was indeed signed "
"by the respective private key."
msgstr ""

#: src/ch04-00-account-abstraction.md:122
msgid ""
"This means, in order to modify the state of an account, a transaction must "
"be initiated and signed by the corresponding private key of the account’s "
"EOA. This design choice ensures security by associating each account with a "
"unique cryptographic identity."
msgstr ""

#: src/ch04-00-account-abstraction.md:127
msgid ""
"On the other hand, CAs are smart contracts living on the Ethereum "
"blockchain. Unlike EOAs, they do not have a private key. They are triggered "
"through transactions or messages initiated by EOAs, and their behavior is "
"determined by their associated code."
msgstr ""

#: src/ch04-00-account-abstraction.md:132
msgid "However, the current account model presents some challenges:"
msgstr ""

#: src/ch04-00-account-abstraction.md:134
msgid ""
"**Key Management:** The loss of a private key is catastrophic. Given that "
"the private key represents the ownership of the account, if it is lost, all "
"the assets within the account are lost too. Similarly, if it gets stolen, "
"the perpetrator gains full control over the account and its assets."
msgstr ""

#: src/ch04-00-account-abstraction.md:140
msgid ""
"**User Experience:** Currently, the Ethereum account model lacks "
"user-friendly methods for key recovery or account recovery, which can "
"discourage non-technical users. Additionally, user interfaces, such as "
"crypto wallets, can be overwhelming and difficult to use, presenting "
"barriers for wider adoption."
msgstr ""

#: src/ch04-00-account-abstraction.md:146
msgid ""
"**Lack of Flexibility:** The traditional model doesn’t allow for custom "
"transaction validation schemes, limiting the possible security and access "
"control improvements."
msgstr ""

#: src/ch04-00-account-abstraction.md:150
msgid ""
"Account Abstraction proposes to improve upon these limitations, offering new "
"possibilities in terms of security, scalability, and user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:154
msgid "The Need for Account Abstraction"
msgstr ""

#: src/ch04-00-account-abstraction.md:156
msgid ""
"As the crypto ecosystem matures and attracts a broader user base, it faces "
"pivotal challenges that demand innovative solutions. Among these, the "
"question of Account Abstraction (AA) has taken center stage. Ethereum, one "
"of the leading platforms for smart contracts and Decentralized Applications "
"(dApps), is in a precarious position: it must embrace Account Abstraction or "
"risk its position in the crypto world."
msgstr ""

#: src/ch04-00-account-abstraction.md:163
msgid ""
"Without AA, Ethereum’s ability to provide a seamless, empowering, and secure "
"experience for its users is hampered. This could lead to users abandoning "
"the platform for centralized exchanges and wallets, a trend that would "
"undermine the very ethos of decentralization that cryptocurrency and "
"blockchain technology espouse."
msgstr ""

#: src/ch04-00-account-abstraction.md:169
msgid ""
"There are several compelling reasons why Ethereum, and the larger crypto "
"ecosystem, need Account Abstraction:"
msgstr ""

#: src/ch04-00-account-abstraction.md:172
msgid ""
"**Risk of Centralization:** The inefficiencies and limitations of the "
"current account model may push users towards centralized exchanges and "
"wallets. These entities defy the principles of decentralization, presenting "
"familiar risks such as censorship, discrimination, and potential abuse of "
"power. Account Abstraction, by enabling easier and more secure account "
"management, can help uphold the principles of decentralization."
msgstr ""

#: src/ch04-00-account-abstraction.md:180
msgid ""
"**Quantum Threat:** Quantum computing poses a potential threat to "
"cryptographic systems, with its ability to break traditional security "
"measures. Account Abstraction can address this by enabling the use of "
"different signature schemes, including quantum-resistant ones, enhancing the "
"security of assets on the blockchain."
msgstr ""

#: src/ch04-00-account-abstraction.md:186
msgid ""
"**Scaling Self-Custody:** As the next billion users approach the crypto "
"ecosystem, the importance of scaling self-custody becomes paramount. AA can "
"improve the scalability of self-custody, which is essential for onboarding "
"these new users."
msgstr ""

#: src/ch04-00-account-abstraction.md:191
msgid ""
"**User Experience:** Simplifying the onboarding process and user experience "
"is essential for widespread adoption. The complexity associated with current "
"wallets and key management systems can be daunting for newcomers. Account "
"Abstraction promises to simplify these aspects, paving the way for a more "
"intuitive user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:197
msgid ""
"Starknet is currently leading the efforts to implement Account Abstraction "
"at the protocol level. Many consider it to be the \"proving ground\" for the "
"future of AA. With numerous experts from different organizations "
"collaborating, Starknet aims to redefine the approach to security, user "
"experience, and self-custody in the crypto space."
msgstr ""

#: src/ch04-00-account-abstraction.md:203
msgid ""
"The stakes are high. The future of Ethereum, and by extension, the crypto "
"ecosystem, is deeply intertwined with the success of Account Abstraction. If "
"Ethereum cannot adapt, it risks losing its prominence to other, more "
"adaptable platforms."
msgstr ""

#: src/ch04-00-account-abstraction.md:208
msgid "Why Isn’t Account Abstraction Implemented in Ethereum’s Layer 1 Yet?"
msgstr ""

#: src/ch04-00-account-abstraction.md:210
msgid ""
"Ethereum’s Layer 1 (L1) doesn’t yet support Account Abstraction (AA) at a "
"protocol level, not due to lack of desire or understanding of its "
"importance, but rather due to the complexity of its implementation."
msgstr ""

#: src/ch04-00-account-abstraction.md:214
msgid ""
"The most prominent roadblock in integrating AA is the entrenched nature of "
"Externally Owned Accounts (EOAs) in Ethereum’s architecture. These accounts, "
"as fundamental elements of the Ethereum core protocol, would need "
"significant alteration to support AA, an undertaking that becomes more "
"daunting as the value secured by Ethereum continues to rise."
msgstr ""

#: src/ch04-00-account-abstraction.md:220
msgid ""
"One key aspect that complicates the integration of AA into Ethereum’s L1 is "
"the Ethereum Virtual Machine (EVM). The EVM, as the runtime environment for "
"smart contracts in Ethereum, has limitations that hinder the implementation "
"of AA. While there have been several proposals for AA since Ethereum’s "
"inception, they have been consistently delayed due to other pressing updates "
"and improvements to the Ethereum network."
msgstr ""

#: src/ch04-00-account-abstraction.md:227
msgid ""
"However, the emergence of Layer 2 (L2) solutions provides a new pathway for "
"the implementation of AA. With their focus on scalability and performance "
"enhancements, these new virtual machines can better accommodate AA. Starknet "
"and ZKSync are examples of platforms that have native AA inspired by EIP4337 "
"– a proposal deemed superior by industry experts like Argent’s Julien Niset."
msgstr ""

#: src/ch04-00-account-abstraction.md:234
msgid ""
"The repeated postponements and challenges in implementing AA on Ethereum’s "
"L1 have led many proponents, including Niset, to shift their focus. Instead "
"of hoping for EOAs to be phased out and AA integrated at Ethereum’s core, "
"they are now advocating for the broad adoption of AA through L2 solutions "
"like Starknet. This strategy could bring the benefits of AA to users sooner "
"and help the Ethereum network remain competitive in the rapidly evolving "
"crypto landscape."
msgstr ""

#: src/ch04-00-account-abstraction.md:244
msgid ""
"To bring it all home, imagine the Ethereum account system as a kind of "
"multifunctional Swiss Army knife, currently under renovation. What we’re "
"doing with Account Abstraction is swapping out a few tools - while it was "
"once a knife and a corkscrew, we’re making it into a magnifying glass and a "
"set of tweezers."
msgstr ""

#: src/ch04-00-account-abstraction.md:250
msgid ""
"Why the change? The original tools served us well, but they didn’t fit every "
"task we found ourselves up against. Some jobs required precision; others "
"needed a broader lens. That’s where Account Abstraction shines. It expands "
"Ethereum’s capabilities, adjusting and adapting to our ever-evolving "
"requirements."
msgstr ""

#: src/ch04-00-account-abstraction.md:256
msgid ""
"Remember the complications of Ethereum’s current account system? Account "
"Abstraction seeks to transform those by offering more flexible, "
"personalized, and safer solutions. It’s like tailoring the tools of your "
"Swiss Army knife to your unique needs."
msgstr ""

#: src/ch04-00-account-abstraction.md:261
msgid ""
"However, it’s not yet implemented into Ethereum’s Layer 1. And why? The "
"kitchen is bustling, and the chefs are wary of spilling the soup. The "
"implementation process has its challenges, it’s true. But the cook who never "
"dropped a pan never learned to make an omelette. That’s why research and "
"development continue relentlessly."
msgstr ""

#: src/ch04-00-account-abstraction.md:267
msgid ""
"Through the lens of Account Abstraction, we see Ethereum’s future—secure, "
"accessible, flexible. It’s an exciting, transformative prospect that’s "
"redefining what we thought possible. And though the path may be fraught with "
"complexities and risks, it’s a journey well worth taking."
msgstr ""

#: src/ch04-00-account-abstraction.md:273
msgid ""
"After all, the Swiss Army knife was once just a knife. Imagine what it could "
"become next."
msgstr ""

#: src/ch04-00-account-abstraction.md:276
msgid "References:"
msgstr ""

#: src/ch04-00-account-abstraction.md:278
msgid ""
"\\[1\\] Martin Triay, Devcon 6: <https://www.youtube.com/watch?v=Osc_gwNW3Fw>"
msgstr ""

#: src/ch04-00-account-abstraction.md:281
msgid "\\[2\\] Julien Niset: <https://www.youtube.com/watch?v=OwppworJGzs>"
msgstr ""

#: src/ch04-00-account-abstraction.md:283
msgid "\\[3\\] lightclient, Devcon 6: <https://app.devcon.org/schedule/9mvqce>"
msgstr ""

#: src/ch04-00-account-abstraction.md:286
msgid ""
"\\[4\\] Starkware: "
"<https://medium.com/@starkware/how-starknet-is-revolutionizing-crypto-signing-ba3724077a79>"
msgstr ""

#: src/ch04-00-account-abstraction.md:289
msgid ""
"\\[5\\] Julien Niset, 2022: "
"<https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/>"
msgstr ""

#: src/ch04-00-account-abstraction.md:292
msgid "\\[6\\] Yoav, Devcon 6: <https://app.devcon.org/schedule/9mvqce>"
msgstr ""

#: src/ch04-00-account-abstraction.md:294
msgid "\\[7\\] Motty Lavie, 2023: <https://www.youtube.com/watch?v=FrxAdJYhSY8>"
msgstr ""

#: src/ch04-01-accounts.md:1
msgid "Account Contracts"
msgstr ""

#: src/ch04-01-accounts.md:3
msgid ""
"Now that we know better the concept of AA, let’s actually code it in "
"Starknet."
msgstr ""

#: src/ch04-01-accounts.md:6
msgid "Account Contract Interface"
msgstr ""

#: src/ch04-01-accounts.md:8
msgid ""
"Account contracts, while essentially being smart contracts, differentiate "
"themselves through unique methods. A smart contract gains the status of an "
"account contract when it implements the interface as described by SNIP-6 "
"([StarkNet IMprovement Proposa-6: Standar Account "
"Interface](https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md)). "
"This standard borrows from SRC-6 and SRC-5, which are akin to Ethereum’s "
"ERCs, setting application-level conventions and contract standards."
msgstr ""

#: src/ch04-01-accounts.md:16
msgid ""
"To initiate, let’s formulate the `ISRC6` (SNIP-6: Standard Account "
"Interface) trait, which outlines the requisite functions for an account "
"contract:"
msgstr ""

#: src/ch04-01-accounts.md:28
msgid "The functions represented above serve the following purposes:"
msgstr ""

#: src/ch04-01-accounts.md:30
msgid ""
"`__validate__`: This function takes in the list of calls scheduled for "
"execution and validates them in line with the rules specified in the "
"contract. It returns a short string (e.g., VALID) encapsulated within a "
"`felt252` that signifies the validation outcome."
msgstr ""

#: src/ch04-01-accounts.md:35
msgid ""
"`is_valid_signature`: This function is tasked with validating the signature "
"of a transaction. It receives a hash of the transaction data and a "
"signature, which may be validated against a public key or through any other "
"method as specified by the contract creator. It returns a short string "
"(e.g., VALID) encapsulated within a `felt252` that signifies the validation "
"outcome."
msgstr ""

#: src/ch04-01-accounts.md:42
msgid ""
"`__execute__`: Post-validation, the `__execute__` function is responsible "
"for executing an array of contract calls (as `Call` structs). It returns an "
"array of `Span<felt252>` structs representing the return values of the "
"executed calls."
msgstr ""

#: src/ch04-01-accounts.md:47
msgid ""
"Moreover, the `SNIP-5` (Standard Interface Detection) trait needs to be "
"defined with a function called `supports_interface`. This function verifies "
"whether a contract supports a specific interface, receiving an interface ID "
"and returning a boolean."
msgstr ""

#: src/ch04-01-accounts.md:58
msgid ""
"Until now, we’ve mentioned contract calls without explicitly defining them. "
"Let’s remedy that."
msgstr ""

#: src/ch04-01-accounts.md:61
msgid "The `Call` struct represents a single contract call:"
msgstr ""

#: src/ch04-01-accounts.md:71
msgid "Here’s what each field signifies:"
msgstr ""

#: src/ch04-01-accounts.md:73
msgid "`to`: The address of the target contract."
msgstr ""

#: src/ch04-01-accounts.md:75
msgid "`selector`: The function’s selector to be invoked on the target contract."
msgstr ""

#: src/ch04-01-accounts.md:78
msgid "`calldata`: An array that encapsulates the function parameters."
msgstr ""

#: src/ch04-01-accounts.md:80
msgid ""
"The elements described above are foundational to defining an account "
"contract and sufficient to implement the SNIP-6 standard. Nevertheless, "
"there are additional components that can be incorporated to bolster the "
"account contract’s functionality. For instance, the `__validate_declare__` "
"function might be added if the contract is used to declare other contracts, "
"providing a mechanism to validate the contract declaration. Additionally, to "
"counterfactually deploy a smart contract (i.e., have it pay for its own "
"deployment), one can include the `__validate_deploy__` function. Detailed "
"implementations of these functions will be covered in the subsequent "
"chapters."
msgstr ""

#: src/ch04-01-accounts.md:91
#: src/ch04-02-hello-account.md:183
#: src/ch04-03-standard-account.md:363
msgid "Summary"
msgstr ""

#: src/ch04-01-accounts.md:93
msgid ""
"We elucidated the unique aspects of account contracts and their derivation "
"from basic smart contracts by adhering to specific methods outlined in "
"SNIP-6."
msgstr ""

#: src/ch04-01-accounts.md:97
msgid ""
"We defined the `ISRC6` trait, detailing the critical functions, namely, "
"`__validate__`, `is_valid_signature`, and `__execute__`. These functions "
"carry out tasks such as transaction validation, signature verification, and "
"contract call execution, respectively. We further introduced the `ISRC5` "
"trait, emphasizing the `supports_interface` function for verifying interface "
"support in contracts."
msgstr ""

#: src/ch04-01-accounts.md:104
msgid ""
"Furthermore, we defined a single contract call using the `Call` struct, "
"explaining its fields— `to`, `selector`, and `calldata`. We also discussed "
"potential enhancements to account contracts using `__validate_declare__` and "
"`__validate_deploy__` functions. These additional features, along with "
"detailed function implementations, will be explored in the chapters ahead."
msgstr ""

#: src/ch04-01-accounts.md:111
msgid ""
"In the next subchapter, we will implement a simple account contract and "
"learn how to deploy it on Starknet. This will provide a practical "
"understanding of how account contracts work and how to interact with them."
msgstr ""

#: src/ch04-02-hello-account.md:1
msgid "Hello World Account Contract"
msgstr ""

#: src/ch04-02-hello-account.md:3
#: src/ch04-03-standard-account.md:3
#: src/ch04-04-01-multicaller.md:3
#: src/ch04-04-02-multisig.md:3
msgid ""
"**NOTE:** **THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR "
"ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS "
"NOTE IS REMOVED.**"
msgstr ""

#: src/ch04-02-hello-account.md:6
#: src/ch04-03-standard-account.md:6
#: src/ch04-04-01-multicaller.md:6
#: src/ch04-04-02-multisig.md:6
msgid ""
"**CONTRIBUTE: This subchapter is missing an example of declaration, "
"deployment and interaction with the contract. We would love to see your "
"contribution! Please submit a PR.**"
msgstr ""

#: src/ch04-02-hello-account.md:8
msgid ""
"In this chapter, we will explore the fundamentals of account contracts in "
"Starknet using an example \"Hello World\" account contract written in Cairo "
"language. You can find it in the contracts directory of this chapter in the "
"Book’s repository (TODO: add link)."
msgstr ""

#: src/ch04-02-hello-account.md:13
msgid ""
"```rust\n"
"    // Import necessary modules\n"
"    #[account_contract]\n"
"    mod HelloAccount {\n"
"        use starknet::ContractAddress;\n"
"        use core::felt252;\n"
"        use array::ArrayTrait;\n"
"        use array::SpanTrait;\n"
"\n"
"        // Validate deployment of the contract.\n"
"        // Returns starknet::VALIDATED to confirm successful validation.\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, "
"public_key_: felt252\n"
"        ) -> felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // Validate declaration of transactions using this Account.\n"
"        // This function enforces that transactions now require accounts to "
"pay fees.\n"
"        // Returns starknet::VALIDATED to confirm successful validation.\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // Validate transaction before execution.\n"
"        // This function is called by the account contract upon receiving a "
"transaction.\n"
"        // If the validation is successful, it returns starknet::VALIDATED.\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: "
"felt252, calldata: Array::<felt252>\n"
"        ) -> felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // Execute transaction.\n"
"        // If the '__validate__' function is successful, this '__execute__' "
"function will be called.\n"
"        // It forwards the call to the target contract using "
"starknet::call_contract_syscall.\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: "
"felt252, calldata: Array::<felt252>\n"
"        ) -> Span::<felt252> {\n"
"            starknet::call_contract_syscall(\n"
"                address: contract_address,\n"
"                entry_point_selector: entry_point_selector,\n"
"                calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:66
msgid "External Functions"
msgstr ""

#: src/ch04-02-hello-account.md:68
msgid ""
"The account contract includes several external functions to handle the "
"validation and execution of transactions. These functions are:"
msgstr ""

#: src/ch04-02-hello-account.md:71
msgid "`__validate_deploy__`: Validates the deployment of the contract."
msgstr ""

#: src/ch04-02-hello-account.md:73
msgid ""
"`__validate_declare__`: Validates the declaration of transactions using the "
"account."
msgstr ""

#: src/ch04-02-hello-account.md:76
msgid "`__validate__`: Validates a transaction before execution."
msgstr ""

#: src/ch04-02-hello-account.md:78
msgid "`__execute__`: Executes a transaction after successful validation."
msgstr ""

#: src/ch04-02-hello-account.md:80
msgid "_validate_deploy_"
msgstr ""

#: src/ch04-02-hello-account.md:82
msgid ""
"This function is responsible for validating the deployment of the account "
"contract. It returns `starknet::VALIDATED` to confirm successful validation."
msgstr ""

#: src/ch04-02-hello-account.md:95
msgid "_validate_declare_"
msgstr ""

#: src/ch04-02-hello-account.md:97
msgid ""
"This function enforces that transactions now require accounts to pay fees. "
"It returns `starknet::VALIDATED` to confirm successful validation."
msgstr ""

#: src/ch04-02-hello-account.md:107
msgid "_validate_"
msgstr ""

#: src/ch04-02-hello-account.md:109
msgid ""
"This function is called by the account contract upon receiving a "
"transaction. If the validation is successful, it returns "
"`starknet::VALIDATED`."
msgstr ""

#: src/ch04-02-hello-account.md:122
msgid "_execute_"
msgstr ""

#: src/ch04-02-hello-account.md:124
msgid ""
"If the `__validate__` function is successful, this `__execute__` function "
"will be called. It forwards the call to the target contract using "
"`starknet::call_contract_syscall`."
msgstr ""

#: src/ch04-02-hello-account.md:142
#: src/ch04-03-standard-account.md:295
msgid "Declaring and Deploying the Hello World Account Contract"
msgstr ""

#: src/ch04-02-hello-account.md:144
msgid ""
"The declaring and deploying process is the same as with other contracts. "
"Before declaring and deploying the Hello World account contract, you must "
"first have an account contract set up to manage the deployment process. To "
"learn more about deploying an account contract, refer to the subchapter on "
"deploying in Chapter 2 of the Book."
msgstr ""

#: src/ch04-02-hello-account.md:150
msgid ""
"Remember to compile using `scarb build` (refer to the Scarb subchapter in "
"Chapter 2 of the Book). Then follow the steps below to declare and deploy "
"the Hello World account contract:"
msgstr ""

#: src/ch04-02-hello-account.md:154
#: src/ch04-03-standard-account.md:303
msgid "Export the required environment variables:"
msgstr ""

#: src/ch04-02-hello-account.md:161
#: src/ch04-03-standard-account.md:310
msgid ""
"Declare the contract (since the contract is already declared, you can skip "
"this step. If you want to declare it anyway, run the following command but "
"you will receive an error):"
msgstr ""

#: src/ch04-02-hello-account.md:169
msgid ""
"The class hash is: "
"0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe"
msgstr ""

#: src/ch04-02-hello-account.md:172
#: src/ch04-03-standard-account.md:321
msgid "Deploy the contract:"
msgstr ""

#: src/ch04-02-hello-account.md:178
msgid ""
"After completing these steps, you will have successfully declared and "
"deployed the Hello World account contract on Starknet. [Here is a deployed "
"version](https://testnet.starkscan.co/contract/0x01e6d7698ca76788c8f9c1091ec3d6d3f7167a9effe520402d832ca9894eba4a#overview)."
msgstr ""

#: src/ch04-02-hello-account.md:185
msgid ""
"In this subchapter, we delved into the details of a basic account contract "
"in Starknet using a \"Hello World\" example."
msgstr ""

#: src/ch04-02-hello-account.md:188
msgid ""
"We also outlined the steps to declare and deploy the Hello World account "
"contract on the Starknet network. The deployment process involves exporting "
"the required environment variables, declaring the contract, and deploying it "
"using the class hash."
msgstr ""

#: src/ch04-02-hello-account.md:193
msgid ""
"As we progress in our exploration of Starknet account contracts, the next "
"subchapter will introduce a standard account contract, drawing parallels "
"with the standard account contract defined by Open Zeppelin and Starkware. "
"This will further strengthen our understanding of how account contracts "
"operate within the Starknet ecosystem."
msgstr ""

#: src/ch04-03-standard-account.md:1
msgid "Standard Account Contract"
msgstr ""

#: src/ch04-03-standard-account.md:8
msgid ""
"In this chapter, we build upon our exploration of account contracts in "
"Starknet by introducing a more complex account contract. This Standard "
"Account Contract includes additional features such as signature validation, "
"providing a more robust example of an account contract in Cairo language. "
"You can find the full code for this contract in the Book repository (todo: "
"add link). You can interact and compile the contract using Scarb (review the "
"Scarb subchapter in Chapter 2 of the Book for more information)."
msgstr ""

#: src/ch04-03-standard-account.md:17
msgid ""
"```rust\n"
"    // Import necessary modules and traits\n"
"    use serde::Serde;\n"
"    use starknet::ContractAddress;\n"
"    use array::ArrayTrait;\n"
"    use array::SpanTrait;\n"
"    use option::OptionTrait;\n"
"\n"
"    // Define the Account contract\n"
"    #[account_contract]\n"
"    mod Account {\n"
"        use array::ArrayTrait;\n"
"        use array::SpanTrait;\n"
"        use box::BoxTrait;\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use option::OptionTrait;\n"
"        use super::Call;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use serde::ArraySerde;\n"
"\n"
"        // Define the contract's storage variables\n"
"        struct Storage {\n"
"            public_key: felt252\n"
"        }\n"
"\n"
"        // Constructor function for initializing the contract\n"
"        #[constructor]\n"
"        fn constructor(public_key_: felt252) {\n"
"            public_key::write(public_key_);\n"
"        }\n"
"\n"
"        // Internal function to validate the transaction signature\n"
"        fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // "
"Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"\n"
"        // Validate contract deployment\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, "
"public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract declaration\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract execution\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: "
"felt252, calldata: Array<felt252>\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Execute a contract call\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // "
"Only single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: "
"calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"\n"
"    // Define the Call struct\n"
"    #[derive(Drop, Serde)]\n"
"    struct Call {\n"
"        to: ContractAddress,\n"
"        selector: felt252,\n"
"        calldata: Array<felt252>\n"
"    }\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:120
msgid "Grasping ECDSA Signature"
msgstr ""

#: src/ch04-03-standard-account.md:122
msgid ""
"Elliptic Curve Digital Signature Algorithm (ECDSA) is a cryptographic "
"protocol extensively utilized across various blockchains to ensure data "
"integrity and verify the sender’s authenticity. As a variant of the Digital "
"Signature Algorithm (DSA), ECDSA leverages elliptic curve cryptography, "
"offering superior security with shorter keys than the traditional DSA."
msgstr ""

#: src/ch04-03-standard-account.md:129
msgid ""
"An ECDSA signature comprises two components, commonly referred to as _r_ and "
"_s_. These two values, generated using the signer’s private key and the hash "
"of the message (or transaction) being signed, collectively form the "
"signature for a given input."
msgstr ""

#: src/ch04-03-standard-account.md:134
msgid "Deciphering signature_r and signature_s"
msgstr ""

#: src/ch04-03-standard-account.md:136
msgid ""
"Within the context of the Standard Account Contract, _signature_r_ and "
"_signature_s_ represent the two constituents of the ECDSA signature. These "
"are utilized in the _check_ecdsa_signature_ function to authenticate the "
"transaction’s legitimacy."
msgstr ""

#: src/ch04-03-standard-account.md:141
msgid ""
"`signature_r (r)`: A random number generated during the signing process, "
"unique for each signature. Reusing _r_ across different messages may lead to "
"private key exposure."
msgstr ""

#: src/ch04-03-standard-account.md:145
msgid ""
"`signature_s (s)`: This is computed using _r_, the private key, and the hash "
"of the message. Like _r_, _s_ is also unique for each signature."
msgstr ""

#: src/ch04-03-standard-account.md:149
msgid ""
"The function _check_ecdsa_signature_ takes these two values, the public key "
"of the signer, and the hash of the message to authenticate the signature. A "
"valid signature indicates that the message was indeed signed by the private "
"key owner and remains unaltered."
msgstr ""

#: src/ch04-03-standard-account.md:166
msgid ""
"The above code snippet employs _check_ecdsa_signature_ function to assert "
"the legitimacy of the transaction signature. If the signature is not valid, "
"the assertion fails, returning _INVALID_SIGNATURE_."
msgstr ""

#: src/ch04-03-standard-account.md:170
msgid "Contract Anatomy"
msgstr ""

#: src/ch04-03-standard-account.md:172
msgid "Storage"
msgstr ""

#: src/ch04-03-standard-account.md:174
msgid ""
"In the standard account contract, we declare a single storage variable: "
"_public_key_. This assists in transaction signature validation. The public "
"key, stored as a _felt252_ (a 252-bit unsigned integer), is written to the "
"storage in the constructor function and is accessed from the storage in the "
"_validate_transaction_ function."
msgstr ""

#: src/ch04-03-standard-account.md:186
msgid "Constructor"
msgstr ""

#: src/ch04-03-standard-account.md:188
msgid ""
"The constructor function serves to initialize the contract, storing the "
"supplied public key in the contract’s storage."
msgstr ""

#: src/ch04-03-standard-account.md:198
msgid "`validate_transaction`"
msgstr ""

#: src/ch04-03-standard-account.md:200
msgid ""
"This internal function validates the transaction signature. It retrieves the "
"signature from the transaction info, checks its length, and verifies the "
"ECDSA signature. If the signature is legitimate, it returns "
"starknet::VALIDATED, otherwise an error. This function is invoked by "
"**validate_deploy**, **validate_declare**, and **validate** functions."
msgstr ""

#: src/ch04-03-standard-account.md:206
msgid ""
"The inclusion of this function is optional. If transaction signature "
"validation is not required, it can be omitted. However, its inclusion in "
"your account contract is advised to ensure transaction validity and to "
"facilitate its reuse in all three validation functions."
msgstr ""

#: src/ch04-03-standard-account.md:211
msgid ""
"```rust\n"
"    fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // "
"Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:232
msgid "Call Struct"
msgstr ""

#: src/ch04-03-standard-account.md:234
msgid ""
"The Call struct outlines the parameters required for a contract call. These "
"parameters comprise the target contract address (to), the function to be "
"called (selector), and the function’s arguments (calldata). The Call struct "
"is utilized in the _execute_ function."
msgstr ""

#: src/ch04-03-standard-account.md:248
msgid "execute"
msgstr ""

#: src/ch04-03-standard-account.md:250
msgid ""
"This external function triggers a transaction post successful validation. It "
"ensures the caller’s validity, checks for a non-zero transaction version, "
"and supports only single calls. Post validation, it forwards the call to the "
"target contract. The contract creator can incorporate multiple calls to "
"different contracts or the same contract (multicall) within this function. "
"The function returns the output from the target contract."
msgstr ""

#: src/ch04-03-standard-account.md:258
msgid ""
"```rust\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // "
"Only single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: "
"calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:278
msgid "Improvements to the Standard Account Contract"
msgstr ""

#: src/ch04-03-standard-account.md:280
msgid ""
"The implementation of the Standard Account Contract has a few limitations:"
msgstr ""

#: src/ch04-03-standard-account.md:283
msgid ""
"It currently supports only single calls. We could support multicalls to "
"improve the flexibility and utility of the contract."
msgstr ""

#: src/ch04-03-standard-account.md:286
msgid ""
"The ECDSA signature algorithm, while secure, can be computationally "
"intensive. Future versions could explore using more efficient signature "
"algorithms, such as Schnorr or BLS. Or quantum-resistant signature "
"algorithms, such as the STARKs."
msgstr ""

#: src/ch04-03-standard-account.md:291
msgid ""
"Despite these limitations, the Standard Account Contract provides a robust "
"and secure foundation for creating and interacting with smart contracts on "
"Starknet."
msgstr ""

#: src/ch04-03-standard-account.md:297
msgid ""
"This time we have a constructor function that takes the public key as an "
"argument. We need to generate a private key with the corresponding public "
"key."
msgstr ""

#: src/ch04-03-standard-account.md:301
msgid "TODO: add section on how to generate a private key and public key."
msgstr ""

#: src/ch04-03-standard-account.md:318
msgid ""
"The class hash is: "
"0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1"
msgstr ""

#: src/ch04-03-standard-account.md:323
msgid "TODO: add section on how to deploy the contract."
msgstr ""

#: src/ch04-03-standard-account.md:325
msgid ""
"Elliptic Curve Digital Signature Algorithm (ECDSA) is a popular choice for "
"ensuring data integrity and sender authenticity in blockchain networks, but "
"it’s not the only option. Other alternatives include:"
msgstr ""

#: src/ch04-03-standard-account.md:329
msgid ""
"EdDSA (Edwards-curve Digital Signature Algorithm): EdDSA is another form of "
"elliptic curve cryptography that is designed to be faster and more secure "
"than ECDSA. EdDSA uses twisted Edwards curves, which have strong security "
"properties and allow for more efficient computations. An example of EdDSA in "
"use is Monero."
msgstr ""

#: src/ch04-03-standard-account.md:335
msgid ""
"Schnorr Signatures: Schnorr signatures offer a level of security similar to "
"ECDSA but with shorter signatures. They have the additional property of "
"being linear, which allows for signature aggregation and multi-signatures. "
"This can lead to increased efficiency and privacy. Bitcoin developers have "
"proposed adding Schnorr signatures to the Bitcoin protocol with the Taproot "
"upgrade."
msgstr ""

#: src/ch04-03-standard-account.md:342
msgid ""
"RSA (Rivest–Shamir–Adleman): RSA is an older cryptographic algorithm that is "
"widely used for secure data transmission. However, RSA requires larger key "
"sizes for equivalent security levels, making it less efficient than elliptic "
"curve techniques. RSA is not commonly used in modern blockchain systems, but "
"it is still used in many traditional secure communication protocols."
msgstr ""

#: src/ch04-03-standard-account.md:349
msgid ""
"BLS (Boneh-Lynn-Shacham) Signatures: BLS signatures, like Schnorr, allow for "
"signature aggregation, making them useful in systems that require a large "
"number of signatures. This property makes BLS signatures particularly useful "
"for consensus algorithms in distributed systems and blockchains, such as "
"Ethereum 2.0."
msgstr ""

#: src/ch04-03-standard-account.md:355
msgid ""
"Post-Quantum Cryptography: With the advent of quantum computing, researchers "
"are developing new cryptographic algorithms that are resistant to quantum "
"attacks. One example are the STARKs used in Starknet."
msgstr ""

#: src/ch04-03-standard-account.md:360
msgid ""
"Each of these alternatives has its strengths and weaknesses in terms of "
"security, efficiency, complexity, and mathematical properties."
msgstr ""

#: src/ch04-03-standard-account.md:365
msgid ""
"In this chapter, we expanded on our understanding of account contracts in "
"Starknet by examining a more complex \"Standard Account Contract\". We dove "
"into the various components of the contract and learned how they work "
"together to validate and execute transactions."
msgstr ""

#: src/ch04-04-examples.md:3
msgid ""
"Here, we will explore numerous examples, elucidating the principles and "
"techniques to effectively design and implement Account contracts."
msgstr ""

#: src/ch04-04-examples.md:6
msgid ""
"Before delving into the examples, we would like to issue a disclaimer: the "
"contracts discussed in this chapter are for illustrative and educational "
"purposes, and they have not undergone formal auditing. This signifies that, "
"while we strive to provide accurate and informative content, the "
"implementation of these contracts in a live environment should be approached "
"with due diligence. We encourage users to thoroughly test and validate these "
"contracts before their deployment on the mainnet."
msgstr ""

#: src/ch04-04-examples.md:15
msgid ""
"The goal of this chapter is not only to furnish a library of contract "
"examples but also to foster collaboration and knowledge sharing among the "
"Starknet community. We believe that the exchange of ideas and constructive "
"feedback is instrumental in advancing our collective understanding and "
"expertise."
msgstr ""

#: src/ch04-04-examples.md:21
msgid ""
"If you’ve developed or come across an innovative contract that could serve "
"as a valuable learning resource for others, we invite you to contribute. "
"Here are a few guidelines for your contribution:"
msgstr ""

#: src/ch04-04-examples.md:25
msgid ""
"**Open a PR:** To submit a contract example or suggest changes to existing "
"ones, simply open a Pull Request. Ensure that your PR contains a thorough "
"explanation of the contract, its use cases, and its functionality."
msgstr ""

#: src/ch04-04-examples.md:30
msgid ""
"**Code Standards:** Please ensure that the submitted code is well-documented "
"and adheres to the standard code conventions of Starknet. This will "
"facilitate the review process and enhance the readability and "
"comprehensibility of the contract."
msgstr ""

#: src/ch04-04-examples.md:35
msgid ""
"**Detailed Explanation:** Accompany your code with a detailed explanation of "
"the contract logic. Wherever possible, use diagrams, flowcharts, or "
"pseudocode to illustrate complex mechanisms or workflows."
msgstr ""

#: src/ch04-04-examples.md:40
msgid ""
"As we expand this repertoire of contract examples, we hope to equip the "
"Starknet community with a robust toolset and inspire further exploration and "
"innovation in the realm of custom account contracts."
msgstr ""

#: src/ch04-04-01-multicaller.md:1
msgid "MultiCaller Account"
msgstr ""

#: src/ch04-04-01-multicaller.md:8
msgid ""
"[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme) is a "
"powerful technique that allows multiple constant smart contract function "
"calls to be aggregated into a single call, resulting in a consolidated "
"output. With Starknet’s account abstraction feature, multicalls can be "
"seamlessly integrated into account contracts."
msgstr ""

#: src/ch04-04-01-multicaller.md:14
msgid "Why Multicalls?"
msgstr ""

#: src/ch04-04-01-multicaller.md:16
msgid "Multicalls come handy in several scenarios. Here are some examples:"
msgstr ""

#: src/ch04-04-01-multicaller.md:18
msgid ""
"**Token Swapping on Decentralized Exchanges**: In a typical token swap "
"operation on a decentralized exchange (DEX), you first need to approve the "
"spending of the tokens and then initiate the swap. Executing these "
"operations separately could be cumbersome from a user experience "
"perspective. With multicall, these calls can be combined into a single "
"transaction, simplifying the user’s task."
msgstr ""

#: src/ch04-04-01-multicaller.md:25
msgid ""
"**Fetching Blockchain Data**: When you want to query the prices of two "
"different tokens from the blockchain, it’s beneficial to have them both come "
"from the same block for consistency. Multicall returns the latest block "
"number along with the aggregated results, providing this consistency."
msgstr ""

#: src/ch04-04-01-multicaller.md:31
msgid ""
"The benefits of multicall transactions can be realized more in the context "
"of account abstraction."
msgstr ""

#: src/ch04-04-01-multicaller.md:34
msgid "Multicall Functionality in Account Contracts"
msgstr ""

#: src/ch04-04-01-multicaller.md:36
msgid ""
"To facilitate multicalls, we can introduce specific functions in the account "
"contract. Here are two core functions:"
msgstr ""

#: src/ch04-04-01-multicaller.md:39
msgid "`_execute_calls` Function"
msgstr ""

#: src/ch04-04-01-multicaller.md:41
msgid ""
"The `_execute_calls` function is responsible for executing the multicalls. "
"It iterates over an array of calls, executes them, and aggregates the "
"results."
msgstr ""

#: src/ch04-04-01-multicaller.md:60
msgid ""
"Apart from the traditional **`execute`** function, adding the "
"**`_execute_calls`** function to your account contract can ensure that you "
"can make a multicall using your smart contract account."
msgstr ""

#: src/ch04-04-01-multicaller.md:64
msgid ""
"The above code is a simple example snippet where the \\*\\*\"return "
"_execute_calls(calls, res);\"_ statement makes recursive calls to the "
"**`_execute_calls`** function thereby bundling the calls together. The final "
"result will be aggregated and returned in the \\*\\*\\*res\\*\\*\\* variable."
msgstr ""

#: src/ch04-04-01-multicaller.md:70
msgid "`_call_contract` Function"
msgstr ""

#: src/ch04-04-01-multicaller.md:72
msgid ""
"The `_call_contract` function is a helper function used to make individual "
"contract calls."
msgstr ""

#: src/ch04-04-01-multicaller.md:83
msgid "Considerations"
msgstr ""

#: src/ch04-04-01-multicaller.md:85
msgid ""
"While multicall provides significant benefits in terms of UX and data "
"consistency, it’s important to note that it may not significantly reduce gas "
"fees compared to individual calls. However, the primary advantage of using "
"multicall is that it ensures results are derived from the same block, "
"providing a much-improved user experience."
msgstr ""

#: src/ch04-04-02-multisig.md:1
msgid "Multi-Signature Accounts"
msgstr ""

#: src/ch04-04-02-multisig.md:8
msgid ""
"Multisignature (multisig) technology is an integral part of the modern "
"blockchain landscape. It enhances security by requiring multiple signatures "
"to confirm a transaction, hence reducing the risk of fraudulent transactions "
"and increasing control over asset management."
msgstr ""

#: src/ch04-04-02-multisig.md:13
msgid ""
"In Starknet, the concept of multisig accounts is abstracted at the protocol "
"level, allowing developers to implement custom account contracts that embody "
"this concept. In this chapter, we’ll delve into the workings of a multisig "
"account and see how it’s created in Starknet using an account contract."
msgstr ""

#: src/ch04-04-02-multisig.md:19
msgid "What is a Multisig Account?"
msgstr ""

#: src/ch04-04-02-multisig.md:21
msgid ""
"A multisig account is an account that requires more than one signature to "
"authorize transactions. This significantly enhances security, requiring "
"multiple entities' consent to transact funds or perform critical actions."
msgstr ""

#: src/ch04-04-02-multisig.md:26
msgid "Key specifications of a multisig account include:"
msgstr ""

#: src/ch04-04-02-multisig.md:28
msgid "Public keys that form the account"
msgstr ""

#: src/ch04-04-02-multisig.md:30
msgid "Threshold number of signatures required"
msgstr ""

#: src/ch04-04-02-multisig.md:32
msgid ""
"A transaction signed by a multisig account must be individually signed by "
"the different keys specified for the account. If fewer than the threshold "
"number of signatures needed are present, the resultant multisignature is "
"considered invalid."
msgstr ""

#: src/ch04-04-02-multisig.md:37
msgid ""
"In Starknet, accounts are abstractions provided at the protocol level. "
"Therefore, to create a multisig account, one needs to code the logic into an "
"account contract and deploy it."
msgstr ""

#: src/ch04-04-02-multisig.md:41
msgid ""
"The contract below serves as an example of a multisig account contract. When "
"deployed, it can create a native multisig account using the concept of "
"account abstraction. Please note that this is a simplified example and lacks "
"comprehensive checks and validations found in a production-grade multisig "
"contract."
msgstr ""

#: src/ch04-04-02-multisig.md:47
msgid "Multisig Account Contract"
msgstr ""

#: src/ch04-04-02-multisig.md:49
msgid "This is the Rust code for a multisig account contract:"
msgstr ""

#: src/ch04-04-02-multisig.md:51
msgid ""
"```rust\n"
"    #[account_contract]\n"
"    mod MultisigAccount {\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use array::ArrayTrait;\n"
"        use starknet::get_caller_address;\n"
"        use box::BoxTrait;\n"
"        use array::SpanTrait;\n"
"\n"
"        struct Storage {\n"
"            index_to_owner: LegacyMap::<u32, felt252>,\n"
"            owner_to_index: LegacyMap::<felt252, u32>,\n"
"            num_owners: usize,\n"
"            threshold: usize,\n"
"            curr_tx_index: felt252,\n"
"            //Mapping between tx_index and num of confirmations\n"
"            tx_confirms: LegacyMap<felt252, usize>,\n"
"            //Mapping between tx_index and its execution state\n"
"            tx_is_executed: LegacyMap<felt252, bool>,\n"
"            //Mapping between a transaction index and its hash\n"
"            transactions: LegacyMap<felt252, felt252>,\n"
"            has_confirmed: LegacyMap::<(ContractAddress, felt252), bool>,\n"
"        }\n"
"\n"
"        #[constructor]\n"
"        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
"            assert(public_keys.len() <= 3_usize, 'public_keys.len <= 3');\n"
"            num_owners::write(public_keys.len());\n"
"            threshold::write(_threshold);\n"
"            _set_owners(public_keys.len(), public_keys);\n"
"        }\n"
"\n"
"        //GETTERS\n"
"        //Get number of confirmations for a given transaction index\n"
"        #[view]\n"
"        fn get_confirmations(tx_index : felt252) -> usize {\n"
"            tx_confirms::read(tx_index)\n"
"        }\n"
"\n"
"        //Get the number of owners of this account\n"
"        #[view]\n"
"        fn get_num_owners() -> usize {\n"
"            num_owners::read()\n"
"        }\n"
"\n"
"\n"
"        //Get the public key of the owners\n"
"        //TODO - Recursively add the owners into an array and return, maybe "
"wait for loops to be enabled\n"
"\n"
"\n"
"        //EXTERNAL FUNCTIONS\n"
"\n"
"        #[external]\n"
"        fn submit_tx(public_key: felt252) {\n"
"\n"
"            //Need to check if caller is one of the owners.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //Updating the transaction index\n"
"            let tx_index = curr_tx_index::read();\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            transactions::write(tx_index, tx_info.transaction_hash);\n"
"            curr_tx_index::write(tx_index + 1);\n"
"\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"\n"
"\n"
"        }\n"
"\n"
"        //An example function to validate that there are at least two "
"signatures\n"
"        fn validate_transaction(public_key: felt252) -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        //INTERNAL FUNCTION\n"
"        //Function to add the public keys of the multisig in permanent "
"storage\n"
"        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"            if owners_len == 0_usize {\n"
"            }\n"
"\n"
"            index_to_owner::write(owners_len, *public_keys.at(owners_len - "
"1_usize));\n"
"            owner_to_index::write(*public_keys.at(owners_len - 1_usize), "
"owners_len);\n"
"            _set_owners(owners_len - 1_u32, public_keys);\n"
"        }\n"
"\n"
"\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, "
"public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252, public_key_: felt252) "
"-> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: "
"felt252, calldata: Array::<felt252>, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: "
"felt252, calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip "
"the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, "
"'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"
msgstr ""

#: src/ch04-04-02-multisig.md:248
msgid "Multisig Transaction Flow"
msgstr ""

#: src/ch04-04-02-multisig.md:250
msgid "The flow of a multisig transaction includes the following steps:"
msgstr ""

#: src/ch04-04-02-multisig.md:252
msgid ""
"Submitting a transaction: Any of the owners can submit a transaction from "
"the account."
msgstr ""

#: src/ch04-04-02-multisig.md:255
msgid ""
"Confirming the transaction: The owner who hasn’t submitted a transaction can "
"confirm the transaction."
msgstr ""

#: src/ch04-04-02-multisig.md:258
msgid ""
"The transaction will be successfully executed if the number of confirmations "
"(including the submitter’s signature) is greater than or equal to the "
"threshold number of signatures, else it fails. This mechanism of "
"confirmation ensures that no single party can unilaterally perform critical "
"actions, thereby enhancing the security of the account."
msgstr ""

#: src/ch04-04-02-multisig.md:264
msgid "Exploring Multisig Functions"
msgstr ""

#: src/ch04-04-02-multisig.md:266
msgid ""
"Let’s take a closer look at the various functions associated with multisig "
"functionality in the provided contract."
msgstr ""

#: src/ch04-04-02-multisig.md:269
msgid "`_set_owners` Function"
msgstr ""

#: src/ch04-04-02-multisig.md:271
msgid ""
"This is an internal function designed to add the public keys of the account "
"owners to a permanent storage. Ideally, a multisig account structure should "
"permit adding and deleting owners as per the agreement of the account "
"owners. However, each change should be a transaction requiring the threshold "
"number of signatures."
msgstr ""

#: src/ch04-04-02-multisig.md:277
msgid ""
"```rust\n"
"    //INTERNAL FUNCTION\n"
"    //Function to add the public keys of the multisig in permanent storage\n"
"    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"        if owners_len == 0_usize {\n"
"        }\n"
"\n"
"        index_to_owner::write(owners_len, *public_keys.at(owners_len - "
"1_usize));\n"
"        owner_to_index::write(*public_keys.at(owners_len - 1_usize), "
"owners_len);\n"
"        _set_owners(owners_len - 1_u32, public_keys);\n"
"    }\n"
"```"
msgstr ""

#: src/ch04-04-02-multisig.md:290
msgid "`submit_tx` Function"
msgstr ""

#: src/ch04-04-02-multisig.md:292
msgid ""
"This external function allows the owners of the account to submit "
"transactions. Upon submission, the function checks the validity of the "
"transaction, ensures the caller is one of the account owners, and adds the "
"transaction to the transactions map. It also increments the current "
"transaction index."
msgstr ""

#: src/ch04-04-02-multisig.md:298
msgid ""
"```rust\n"
"    #[external]\n"
"    fn submit_tx(public_key: felt252) {\n"
"\n"
"        //Need to check if caller is one of the owners.\n"
"        let tx_info = starknet::get_tx_info().unbox();\n"
"        let signature: Span<felt252> = tx_info.signature;\n"
"        let caller = get_caller_address();\n"
"        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"        //Updating the transaction index\n"
"        let tx_index = curr_tx_index::read();\n"
"\n"
"        //`true` if a signature is valid and `false` otherwise.\n"
"        assert(\n"
"            check_ecdsa_signature(\n"
"                message_hash: tx_info.transaction_hash,\n"
"                public_key: public_key,\n"
"                signature_r: *signature.at(0_u32),\n"
"                signature_s: *signature.at(1_u32),\n"
"            ),\n"
"            'INVALID_SIGNATURE',\n"
"        );\n"
"\n"
"        transactions::write(tx_index, tx_info.transaction_hash);\n"
"        curr_tx_index::write(tx_index + 1);\n"
"\n"
"    }\n"
"```"
msgstr ""

#: src/ch04-04-02-multisig.md:328
msgid "`confirm_tx` Function"
msgstr ""

#: src/ch04-04-02-multisig.md:330
msgid ""
"Similarly, the **_`confirm_tx`_** function provides a way to record "
"confirmations for each transaction. An account owner, who did not submit the "
"transaction, can confirm it, increasing its confirmation count."
msgstr ""

#: src/ch04-04-02-multisig.md:334
msgid ""
"```rust\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-04-02-multisig.md:368
msgid "_`execute`_ Function"
msgstr ""

#: src/ch04-04-02-multisig.md:370
msgid ""
"The _execute_ function serves as the final step in the transaction process. "
"It checks the validity of the transaction, whether it has been previously "
"executed, and if the threshold number of signatures has been reached. The "
"transaction is executed if all the checks pass."
msgstr ""

#: src/ch04-04-02-multisig.md:375
msgid ""
"```rust\n"
"    #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: "
"felt252, calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip "
"the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, "
"'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-04-02-multisig.md:404
msgid "Closing Thoughts"
msgstr ""

#: src/ch04-04-02-multisig.md:406
msgid ""
"This chapter has introduced you to the concept of multisig accounts in "
"Starknet and illustrated how they can be implemented using an account "
"contract. However, it’s important to note that this is a simplified example, "
"and a production-grade multisig contract should contain additional checks "
"and validations for robustness and security."
msgstr ""

