msgid ""
msgstr ""
"Project-Id-Version: The Starknet Book\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-11-11 20:20+0900\n"
"Last-Translator: StarknetAstro <cryptonerdcn@gmail.com>\n"
"Language-Team: Language zh-cn\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md:1
msgid "The Starknet Book"
msgstr "Starknet 之书"

#: src/SUMMARY.md:4
msgid "Introduction"
msgstr "介绍"

#: src/SUMMARY.md:8
msgid "Getting Started"
msgstr "入门"

#: src/SUMMARY.md:10
msgid "Tooling"
msgstr "工具"

#: src/SUMMARY.md:13
msgid "Basic Installation"
msgstr "基本安装"

#: src/SUMMARY.md:14
msgid "Introduction: Starkli, Scarb and Katana"
msgstr "Starkli, Scarb and Katana 的简介"

#: src/SUMMARY.md:15
msgid "Scarb: The Package Manager"
msgstr "Scarb：软件包管理器"

#: src/SUMMARY.md:16
msgid "Katana: A Local Node"
msgstr "Katana: 本地节点"

#: src/SUMMARY.md:17
msgid "Testnet Deployment"
msgstr "测试网部署"

#: src/SUMMARY.md:18
msgid "Foundry Cast: Interacting with Starknet"
msgstr "Foundry Cast: 与 Starknet 交互"

#: src/SUMMARY.md:19
msgid "Example - Deployment Script"
msgstr "示例 - 部署脚本"

#: src/SUMMARY.md:20
msgid "Starknet Devnet 🚧"
msgstr "Starknet Devnet 🚧"

#: src/SUMMARY.md:21
msgid "Starknet-js: Javascript SDK"
msgstr "Starknet-js：Javascript SDK"

#: src/SUMMARY.md:22 src/SUMMARY.md:26 src/SUMMARY.md:54
msgid "Examples"
msgstr "示例"

#: src/SUMMARY.md:23
msgid "Beginner - Counter UI"
msgstr "初学者 - 计数器 UI"

#: src/SUMMARY.md:24 src/SUMMARY.md:27
msgid "Beginner - ERC-20 UI"
msgstr "初学者 - ERC-20 UI"

#: src/SUMMARY.md:25
msgid "Starknet-React: React Integration"
msgstr "Starknet-React: React 集成"

#: src/SUMMARY.md:28
msgid "Intermediate - Million Dollar Homepage"
msgstr "中级 - 百万美元级别的主页"

#: src/SUMMARY.md:29
msgid "Starknet-py: Python SDK 🚧"
msgstr "Starknet-py: Python SDK 🚧"

#: src/SUMMARY.md:30
msgid "Starknet-rs: Rust SDK 🚧"
msgstr "Starknet-rs: Rust SDK 🚧"

#: src/SUMMARY.md:31
msgid "Starkli: Querying the Blockchain 🚧"
msgstr "Starkli: Querying the Blockchain 🚧"

#: src/SUMMARY.md:32
msgid "Foundry Forge: Testing"
msgstr "Foundry Forge: 测试工具"

#: src/SUMMARY.md:34
msgid "Architecture"
msgstr "结构"

#: src/SUMMARY.md:37
msgid "Transactions"
msgstr "交易"

#: src/SUMMARY.md:38
msgid "Transactions Lifecycle"
msgstr "交易生命周期"

#: src/SUMMARY.md:39
msgid "Fee Mechanism"
msgstr "费用机制"

#: src/SUMMARY.md:40
msgid "Sequencers"
msgstr "排序器"

#: src/SUMMARY.md:41
msgid "Provers 🚧"
msgstr "证明器 🚧"

#: src/SUMMARY.md:42
msgid "Nodes 🚧"
msgstr "节点 🚧"

#: src/SUMMARY.md:43
msgid "Layer 3 and App Chains 🚧 "
msgstr "Layer 3 和应用链 🚧  "

#: src/SUMMARY.md:44
msgid "Solidity Verifier"
msgstr "Solidity 验证器"

#: src/SUMMARY.md:45
msgid "Decentralization 🚧"
msgstr "去中心化 🚧"

#: src/SUMMARY.md:47
msgid "Account Abstraction"
msgstr "账户抽象"

#: src/SUMMARY.md:50
msgid "Accounts"
msgstr "账户"

#: src/SUMMARY.md:51
msgid "Hello, Account!"
msgstr "你好，账户！"

#: src/SUMMARY.md:52
msgid "Deploy Account"
msgstr "部署账户"

#: src/SUMMARY.md:53
msgid "Standard Account 🚧"
msgstr "标准账户 🚧"

#: src/SUMMARY.md:55
msgid "Multicaller 🚧"
msgstr "Multicaller 🚧"

#: src/SUMMARY.md:56
msgid "Multisig 🚧"
msgstr "多签 🚧"

#: src/SUMMARY.md:57
msgid "Auto-Payments 🚧"
msgstr "自动付款 🚧"

#: src/SUMMARY.md:58
msgid "Alternative Signature Schemes 🚧"
msgstr "替代签名方案 🚧"

#: src/SUMMARY.md:62
msgid "STARKs 🚧"
msgstr "STARKs 🚧"

#: src/SUMMARY.md:63
msgid "Basics 🚧"
msgstr "基础知识 🚧"

#: src/SUMMARY.md:64
msgid "Math Primer 🚧"
msgstr "数学入门 🚧"

#: src/SUMMARY.md:65
msgid "Number Theory 🚧"
msgstr "数论 🚧"

#: src/SUMMARY.md:66
msgid "Geometry 🚧"
msgstr "几何 🚧"

#: src/SUMMARY.md:67
msgid "Cryptographic Primitives 🚧"
msgstr "加密原语 🚧"

#: src/SUMMARY.md:68
msgid "Arithimization 🚧"
msgstr "拟真 🚧"

#: src/SUMMARY.md:69
msgid "Low Degree Testing 🚧"
msgstr "低度测试 🚧"

#: src/SUMMARY.md:70
msgid "FRI Protocol 🚧"
msgstr "FRI 协议 🚧"

#: src/SUMMARY.md:71
msgid "Efficient STARKs"
msgstr "高效 STARKs"

#: src/SUMMARY.md:72
msgid "STARKs Protocol (Python) 🚧"
msgstr "STARKs 协议（Python） 🚧"

#: src/SUMMARY.md:73 src/SUMMARY.md:78
msgid "Trace/Low Degree Extension 🚧"
msgstr "追迹/低度 扩展 🚧"

#: src/SUMMARY.md:74 src/SUMMARY.md:79
msgid "Constraints 🚧"
msgstr "约束 🚧"

#: src/SUMMARY.md:75 src/SUMMARY.md:80
msgid "FRI Commitments 🚧"
msgstr "FRI 承诺 🚧"

#: src/SUMMARY.md:76 src/SUMMARY.md:81
msgid "Query Phase 🚧"
msgstr "查询阶段 🚧"

#: src/SUMMARY.md:77
msgid "STARKs Protocol (Rust) 🚧"
msgstr "STARKs 协议（Rust） 🚧"

#: src/title-page.md:1
msgid "# The Starknet Book"
msgstr "# Starknet 之书"

#: src/title-page.md:3
msgid ""
"The Starknet Book is a work in progress, shaped by ongoing community\n"
"input. Some sections may be incomplete or still under review and are\n"
"marked under a 🚧 emoji. We welcome your suggestions, feedback, and\n"
"content contributions to make this book a reliable guide for everyone."
msgstr ""
"Starknet Book 是一个由社区的持续贡献的尚在撰写中的作品。某些部分可能不完整或仍在被审校中，这些部分会被用🚧表情符号进行标记。我们欢迎您的建议、反馈和内容贡献，来使得本书成为所有开发者的可靠指南。"

#: src/title-page.md:8
msgid ""
"The Starknet Book is a step-by-step guide aimed at teaching you the\n"
"essentials of Starknet development. It’s a community effort, with each\n"
"chapter guiding you through the Starknet ecosystem."
msgstr ""
"Starknet Book 是一本循序渐进的指南，旨在向你传授Starknet 开发的基本知识。这本书由社区的合力撰写，每一章都会引导你了解Starknet 的生态系统。中文版由[StarknetAstro](https://twitter.com/StarknetAstroCN)"
"翻译。"

#: src/title-page.md:12
msgid ""
"Understanding Cairo, the key programming language for Starknet smart\n"
"contracts, is crucial. That’s why this book works hand-in-hand with the\n"
"Cairo Book, another community resource. You can access the Cairo Book\n"
"[**here**](https://book.cairo-lang.org/)."
msgstr ""
"了解在Starknet 智能合约中处于关键位置的编程语言Cairo，是至关重要的。因此，本书与另一个由社区编写的《Cairo之书》（Cairo Book）携手合作。你可以从[**这里**](https://book.cairo-lang.org/)访问Cairo "
"Book。"

#: src/title-page.md:17
msgid ""
"In short, the Cairo Book helps you master Cairo, while The Starknet Book\n"
"focuses on Starknet’s specific features. For a well-rounded\n"
"understanding, we recommend exploring both. This book will introduce you\n"
"to tools, architecture, account setups, STARKs, and Starknet-specific\n"
"apps."
msgstr ""
"简而言之，Cairo Book 帮助您掌握Cairo语言，而Starknet Book则侧重于Starknet的具体功能。为了全面了解，我们建议您同时阅读这两本书。本书将向你介绍工具、架构、账户设置、STARK 和Starknet专用应用程序。"

#: src/title-page.md:23
msgid "## Table of Contents"
msgstr "## 内容目录"

#: src/title-page.md:25
msgid "**Chapter Titles**"
msgstr "**章节标题**"

#: src/title-page.md:27
msgid ""
"| Chapter                  | "
"Description                                                                                                                                                                                           "
"|\n"
"| ------------------------ | "
"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
"|\n"
"| 1: Starknet Introduction | Delve into the fundamental concepts of Starknet and acquaint yourself with the deployment of smart "
"contracts.                                                                                         |\n"
"| 2: Starknet Tooling      | Familiarize yourself with vital tools, such as Starkli, Katana, Scarb, Starknet-Foundry and more. Explore how languages like Javascript, Python, and Rust can be "
"leveraged for Starknet interactions. |\n"
"| 3: Starknet Architecture | Uncover Starknet’s core structure, gaining insights into the transaction lifecycle and the interplay between the Sequencer, Prover, and "
"Nodes.                                                        |\n"
"| 4: Account Abstraction   | Delve deep into Starknet’s unique approach to user accounts, and master the art of crafting custom "
"accounts.                                                                                          |\n"
"| 5: STARKs                | Dive into the intricacies of STARKs and their pivotal role in shaping Starknet’s "
"landscape.                                                                                                           |"
msgstr ""
"| 章节 | 说明\n"
"| ------------------------ | "
"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n"
"| 1: Starknet简介 | 深入了解Starknet的基本概念，熟悉智能合约的部署。                                                                 |\n"
"| 2: Starknet工具 | 熟悉 Starkli, Katana, Scarb, Starknet-Foundry等重要工具，探索如何利用 Javascript、Python 和 Rust 等语言进行Starknet交互。|\n"
"| 3: Starknet架构 | 探索Starknet的核心结构，深入了解事务生命周期以及排序器、证明器和节点之间的相互作用。                                |\n"
"| 4: 账户抽象 | 深入了解 Starknet 独特的用户账户方法，掌握创建自定义账户的艺术。                                                                  |\n"
"| 5: STARKs | 深入了解 STARKs 的复杂性及其在塑造Starknet格局中的关键作用。                                                                                   |"

#: src/title-page.md:35
msgid "# Where to Start?"
msgstr "从哪里开始？"

#: src/title-page.md:37
msgid ""
"Depending on your goals and interests, you can choose different paths\n"
"through the Starknet Book. Here are some recommendations based on\n"
"various objectives:"
msgstr "根据您的目标和兴趣，您可以在Starknet Book中选择不同的学习路径。下面是一些基于不同目标的建议："

#: src/title-page.md:41
msgid ""
"- If you’re a **complete beginner** and want to start learning about\n"
"  Cairo and Starknet from scratch, follow the book in its entirety,\n"
"  starting with **Introduction to Starknet**.\n"
"\n"
"- If you’re an **experienced developer** looking to quickly dive into\n"
"  writing scalable and decentralized smart contracts, focus on the\n"
"  Cairo Book, particularly **chapter 12: Starknet Smart Contracts**\n"
"  ([link](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)).\n"
"\n"
"- If you’re a **frontend developer** wanting to integrate Starknet\n"
"  with a React frontend using Javascript, prioritize the\n"
"  **starknet-js** and **starknet-react** subchapters in **Starknet\n"
"  Tooling**\n"
"\n"
"- If you’re a **DevOps engineer** or **node operator** interested in\n"
"  running a Starknet node and indexer, head straight to **Starknet\n"
"  Architecture**.\n"
"\n"
"- If you’re a **security researcher** or **smart contract auditor**\n"
"  wanting to learn about the Account Abstraction feature and its\n"
"  implications, go for **Account Abstraction**.\n"
"\n"
"- If you’re a **blockchain enthusiast** curious about the underlying\n"
"  architecture and mechanics of Starknet and Cairo, explore **Starknet\n"
"  Architecture**.\n"
"\n"
"- If you’re a **cryptography expert** or **researcher** eager to\n"
"  understand the fundamentals of STARKs and their connection to the\n"
"  Starknet ecosystem, delve into **STARKs**."
msgstr ""
"- 如果你是一个**完全的初学者**，想从头开始学习Cairo和Starknet，\n"
"  请从**Starknet入门开始**。\n"
"\n"
"- 如果你是一个**有经验的开发者**，希望快速开始\n"
"  编写可扩展的去中心化智能合约，请重点阅读\n"
"  《Cairo之书》，尤其是**第 12章：Starknet智能合约**\n"
"  ([link](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)).\n"
"\n"
"- 如果你是一名**前端开发者**，希望使用 JavaScript 将 Starknet\n"
"  与使用 Javascript 的 React 前端集成，请优先参考\n"
"  **Starknet工具**中的**starknet-js**和**starknet-react**子章节。\n"
"\n"
"- 如果您是一名**开发运维工程师**或**节点操作者**，有兴趣\n"
"  运行Starknet节点和索引器，请直接访问 **Starknet架构**。\n"
"\n"
"- 如果您是**安全研究员**或**智能合约审计员**\n"
"  想了解账户抽象功能及其影响，请查看**账户抽象**。\n"
"\n"
"- 如果您是**区块链爱好者**，对tarknet和Cairo的底层架构和机制感到好奇，\n"
"请浏览**Starknet架构**。\n"
"\n"
"- 如果您是**加密专家**或**研究人员**，渴望了解 STARK 的基本原理及其与Starknet生态系统的联系，请深入研究**Starknet架构**。"

#: src/title-page.md:71
msgid ""
"Feel free to mix and match these paths based on your unique interests\n"
"and requirements."
msgstr "您可以根据自己的独特兴趣和要求自由搭配这些学习路径。"

#: src/title-page.md:74
msgid "# Your Contributions Matter"
msgstr "# 您的贡献很重要"

#: src/title-page.md:76
msgid ""
"Welcome aboard! By contributing to the Starknet Book, you’re doing more\n"
"than sharing expertise—you’re shaping the future of decentralized tech.\n"
"Let’s build a guide that helps developers unlock Starknet’s potential."
msgstr "欢迎加入！通过为《Starknet Book》做出贡献，您所做的不仅仅是分享专业知识，您还在塑造去中心化技术的未来。让我们共同打造一本帮助开发者释放Starknet潜力的指南。"

#: src/title-page.md:80
msgid ""
"For detailed contribution guidelines, visit the [Contributors\n"
"Guide](https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc).\n"
"Every contribution counts. Your skills and passion will help make this\n"
"book an invaluable tool."
msgstr "有关详细的投稿指南，请访问 [Contributors Guide](https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc)。每一份贡献都很重要。您的技能和热情将帮助本书成为一本宝贵的工具书。"

#: src/title-page.md:85
msgid "## How You Can Help"
msgstr "## 您可以如何提供帮助"

#: src/title-page.md:87
msgid ""
"- Found an empty section? Fill it in!\n"
"\n"
"- Think we need a new section? Suggest one.\n"
"\n"
"- See room for improvement? Go ahead and tweak it.\n"
"\n"
"- Want to add code in a new programming language? Go for it.\n"
"\n"
"- Found a bug? Fix it.\n"
"\n"
"- Exercises unclear? Add explanations.\n"
"\n"
"- Show off your favorite Cairo features through new exercises."
msgstr ""
"- 发现空白区域？填满它！\n"
"\n"
"- 认为我们需要一个新栏目？请提出建议。\n"
"\n"
"- 认为有改进余地？请继续调整。\n"
"\n"
"- 想用新的编程语言添加代码？去做吧。\n"
"\n"
"- 发现一个错误？修复它。\n"
"\n"
"- 练习不清楚？添加解释。\n"
"\n"
"- 通过新练习展示你最喜欢的Cairo功能。"

#: src/title-page.md:101
msgid "# Additional Key Educational Resources"
msgstr "# 其他重要教育资源"

#: src/title-page.md:103
msgid ""
"We’ve compiled a list of valuable educational resources that will help\n"
"deepen your understanding and enhance your skills in coding with Cairo\n"
"and staying abreast with Starknet developments:"
msgstr "我们编撰了一份有价值的教育资源清单，这些资源将有助于加深您对Cairo语言的理解，提高您的技能，并紧跟Starknet发展的步伐："

#: src/title-page.md:107
msgid ""
"1.  **Starklings**: A resource specifically designed to guide you\n"
"    through learning Cairo programming, ensuring that you reach a\n"
"    proficient level. You can access it\n"
"    [here](https://github.com/shramee/starklings-cairo1).\n"
"\n"
"2.  **Starknet Community Forum**: An online platform where you can\n"
"    engage in discussions about the latest developments in Starknet.\n"
"    Join the conversation [here](https://community.starknet.io/).\n"
"\n"
"3.  **Starknet Documentation**: You can browse through the documentation\n"
"    [here](https://docs.starknet.io/).\n"
"\n"
"4.  **Cairo Documentation**: Explore it\n"
"    [here](https://www.cairo-lang.org/docs).\n"
"\n"
"5.  **Starknet Developer Telegram (English)**: A community for\n"
"    English-speaking Starknet developers. This is a great platform for\n"
"    networking, sharing ideas, and troubleshooting together. Join us on\n"
"    Telegram [here](https://t.me/starknetna)."
msgstr ""
"1.  **Starklings**：专为指导您学习Cairo编程而设计的资源，确保您达到熟练水平。\n"
"    您可以在[此处](https://github.com/shramee/starklings-cairo1)访问。\n"
"\n"
"2.  **Starknet社区论坛**：在线平台，您可以\n"
"    参与讨论Starknet的最新发展。\n"
"    在[此处](https://community.starknet.io/)加入对话。\n"
"\n"
"3.  **Starknet文档**：您可以在[此处](https://docs.starknet.io/)浏览文档。\n"
"\n"
"4.  **Cairo文档**：您可以在[此处](https://www.cairo-lang.org/docs)浏览文档。\n"
"\n"
"5.  **Starknet开发者电报（英文）**：一个英语Starknet开发人员的社区。这是一个交流、分享想法和共同排除故障的绝佳平台。\n"
"    在[这里](https://t.me/starknetna)加入我们的Telegram。\n"
"\n"
"6.  **Starknet开发者电报（中文）**：面向中文开发者的Starknet和Cairo开发者社区，由Starknet Astro进行维护，以及由Starknet Foundation支持。\n"
"    在[这里](https://t.me/StarknetAstro)加入我们的Telegram。如果你更习惯使用微信来交流也可在该群组内提出加入微信群的申请。"

#: src/ch00-00-introduction.md:1
msgid "# The Starknet Network"
msgstr "# Starknet网络"

#: src/ch00-00-introduction.md:3
msgid "## Preamble"
msgstr "## 序言"

#: src/ch00-00-introduction.md:5
msgid ""
"Historically, societal roles like currency, property rights, and social status titles have been governed by _protocols_ and _registries_. Their value stems from a widely accepted understanding of "
"their integrity. These functions have predominantly been overseen by centralized entities prone to challenges such as corruption, agency conflicts, and exclusion ([Eli Ben-Sasson, Bareli, Brandt, "
"Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"从历史上看，货币、财产权和社会地位称号等社会角色都是由 _协议_ 和 _登记机构_ 管理的。它们的价值源于人们对其完整性的广泛认可。这些功能主要由中央集权的实体来负责监督，容易出现腐败、机构冲突和排斥等问题"
"（[Eli Ben-Sasson、Bareli、Brandt、Volokh，2023](https://hackmd.io/@Elibensasson/ryMelVulp)）。"

#: src/ch00-00-introduction.md:7
msgid "Satoshi's creation, Bitcoin, introduced a novel approach for these functions, termed an _integrity web_. This is an infrastructure for societal roles that:"
msgstr "中本聪创造的比特币，为这些功能引入了一种新颖的方式，称为 _完整性网络_ 。这是一个针对社会角色的基础设施，具有以下特点："

#: src/ch00-00-introduction.md:9
msgid ""
"1. Is openly described by a public protocol.\n"
"2. Operates over a wide, inclusive, peer-to-peer network.\n"
"3. Distributes value fairly and extensively to maintain societal consensus on its integrity."
msgstr ""
"1.通过公共协议公开描述。\n"
"2.通过广泛、包容的点对点网络运行。\n"
"3.公平、广泛地分配价值，以保持社会对其完整性的共识。"

#: src/ch00-00-introduction.md:13
msgid ""
"While Bitcoin addressed monetary functions, Ethereum expanded this to include any function that can be defined by computer programming. Both faced the challenge of balancing scalability with "
"decentralization. These integrity webs have often favored inclusivity over capacity, ensuring even those with limited resources can authenticate the system's integrity. Yet, this means they "
"struggle to meet global demand."
msgstr ""
"比特币解决的是货币功能，而以太坊则将其扩展到包括任何可以通过计算机编程定义的功能。两者都面临着平衡可扩展性与去中心化的挑战。这些完整性网络通常倾向于包容性而非容量，以确保即使资源有限的人也能验证系统"
"的完整性。然而，这意味着它们很难满足全球级的需求。"

#: src/ch00-00-introduction.md:15
msgid "## Defining \"Blockchain\""
msgstr "## 定义 \"区块链\""

#: src/ch00-00-introduction.md:17
msgid ""
"In the ever-evolving realm of technology, defining a term as multifaceted as \"Blockchain\" can be challenging. Based on current understandings and applications, a Blockchain can be characterized "
"by the following three properties ([Eli Ben-Sasson, 2023](https://twitter.com/EliBenSasson/status/1709272086504485265)):"
msgstr ""
"在不断发展的技术领域，定义一个像 \"区块链 \"这样多层面的术语可能具有挑战性。根据目前的理解和应用，区块链可具有以下三个特性（[Eli Ben-Sasson，2023](https://twitter.com/EliBenSasson/"
"status/1709272086504485265)）："

#: src/ch00-00-introduction.md:19
msgid ""
"1. **Public Protocol:** The foundation of a Blockchain rests upon a protocol that is openly available. This transparency ensures that any interested party can understand its workings, fostering "
"trust and enabling wider adoption.\n"
"2. **Open P2P Network:** Instead of relying on a centralized entity, a Blockchain operates over a peer-to-peer (P2P) network. This decentralized approach ensures that operations are distributed "
"across various participants or nodes, making the system more resilient to failures and censorship.\n"
"3. **Value Distribution:** Central to the Blockchain's operation is the way it rewards its operators. The system autonomously distributes value in a manner that is wide-ranging and equitable. This "
"incentivization not only motivates participants to maintain the system's integrity but also ensures a broader societal consensus."
msgstr ""
"1. **公开协议：** 区块链的基础是公开可用的协议。这种透明度可确保任何感兴趣的人都能了解其工作原理，从而促进信任，使其得到更广泛的采用。\n"
"2. **开放的点对点网络：** 区块链通过点对点（P2P）网络运行，而不是依赖一个中央实体。这种去中心化的方法可确保操作分布在不同的参与者或节点上，使系统更能抵御故障和审查。\n"
"3. **价值分配：** 区块链运行的核心是其奖励操作者的方式。该系统以广泛和公平的方式自主分配价值。这种激励方式不仅能激励参与者维护系统的完整性，还能确保达成更广泛的社会共识。"

#: src/ch00-00-introduction.md:23
msgid ""
"While these properties capture the essence of many Blockchains, the term's definition might need refinement as the technology matures and finds new applications. Engaging in continuous dialogue and "
"revisiting definitions will be crucial in this dynamic landscape."
msgstr "虽然这些特性抓住了许多区块链的本质，但随着技术的成熟和新应用的出现，该术语的定义可能依然需要完善。在这一动态环境中，持续的对话和重新审视定义至关重要。"

#: src/ch00-00-introduction.md:25
msgid "## Starknet Definition"
msgstr "## Starknet的定义"

#: src/ch00-00-introduction.md:27
msgid ""
"Starknet is a Layer-2 network that makes Ethereum transactions faster, cheaper, and more secure using zk-STARKs technology. Think of it as a boosted layer on top of Ethereum, optimized for speed "
"and cost."
msgstr "Starknet 是一个二层网络，利用 zk-STARKs 技术使以太坊交易更快、更便宜、更安全。你可以将其视为以太坊之上的一个增强层，在速度和成本方面进行了优化。"

#: src/ch00-00-introduction.md:29
msgid ""
"Starknet bridges the gap between scalability and broad consensus. It integrates a mathematical framework to navigate the balance between capacity and inclusivity. Its integrity hinges on the "
"robustness of succinct, transparent proofs of computational integrity. This method lets powerful operators enhance Starknet's capacity, ensuring everyone can authenticate Starknet's integrity using "
"universally accessible tools ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"Starknet 弥补了可扩展性与广泛共识之间的差距。它整合了一个数学框架，在容量和包容性之间取得平衡。它的完整性取决于简洁、透明的计算完整性证明的稳健性。这种方法极大的提高Starknet的容量，确保每个用户都能"
"使用普遍可用的工具验证Starknet的完整性（[Eli Ben-Sasson、Bareli、Brandt、Volokh，2023](https://hackmd.io/@Elibensasson/ryMelVulp)）。"

#: src/ch00-00-introduction.md:31
msgid "## Starknet’s Mission"
msgstr "## Starknet的使命"

#: src/ch00-00-introduction.md:33
msgid "_Starknet’s mission is to allow individuals to freely implement and use any social function they desire._"
msgstr "_Starknet的使命是允许个人自由实现和使用他们所希望的任何社会机能。_"

#: src/ch00-00-introduction.md:35
msgid "## Starknet’s Values"
msgstr "## Starknet的价值观"

#: src/ch00-00-introduction.md:37
msgid "Starknet's ethos is anchored in core principles ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp)):"
msgstr "Starknet的精神是以核心原则为基础的（[Eli Ben-Sasson、Bareli、Brandt、Volokh，2023](https://hackmd.io/@Elibensasson/ryMelVulp)）："

#: src/ch00-00-introduction.md:39
msgid ""
"- **Lasting Broadness.** Starknet continuously resists power consolidation. Key points include:\n"
"\n"
"  - Broad power distribution underpins Starknet's legitimacy and must persist across operations and decision-making. While centralized operation may be necessary at times, it should be short-"
"lived.\n"
"  - Starknet's protocol and governance should always be open and transparent.\n"
"  - Governance should bolster inclusivity, with a flexible structure that can evolve to ensure enduring inclusivity.\n"
"\n"
"- **Neutrality.** Starknet remains impartial to the societal functions it supports.\n"
"\n"
"  - The objectives and ethos of functions on Starknet lie with their creators.\n"
"  - **Censorship resistance:** Starknet remains agnostic to the nature and meaning of user transactions.\n"
"\n"
"- **Individual Empowerment.** At its core, Starknet thrives on a well-informed and autonomous user base. This is achieved by fostering a culture rooted in its core mission and values, with a strong "
"emphasis on education."
msgstr ""
"- ** 持久的广泛性。** Starknet不断抵制权力整合。要点包括\n"
"\n"
"  - 广泛的权力分配是Starknet合法性的基础，必须在整个运营和决策过程中坚持下去。虽然集中运作有时是必要的，但应该是短暂的。\n"
"  - Starknet的协议和管理应始终公开透明。\n"
"  - 管理应促进包容性，其灵活的结构可以不断发展，以确保持久的包容性。\n"
"\n"
"- **中立性：**Starknet对其支持的社会功能保持中立。\n"
"\n"
"  - 在Starknet上被创建的功能的目标和精神在于其创建者。\n"
"  - **抵制审查：** Starknet对用户交易的性质和意义保持中立。\n"
"\n"
"- ** 个人赋权：** Starknet的核心是建立一个信息灵通、自主的用户群。这是通过培养植根于其核心使命和价值观的文化来实现的，同时也非常重视教育。"

#: src/ch00-00-introduction.md:52
msgid "## Key Features"
msgstr "## 关键特性"

#: src/ch00-00-introduction.md:54
msgid "These are some key features of Starknet:"
msgstr "这些是Starknet的一些关键特性："

#: src/ch00-00-introduction.md:56
msgid ""
"- Low Costs: Transactions on Starknet cost less than on Ethereum.\n"
"  Future updates like Volition and EIP 4844 will make it even cheaper.\n"
"\n"
"- Developer-Friendly: Starknet lets developers easily build\n"
"  decentralized apps using its native language, Cairo.\n"
"\n"
"- Speed and Efficiency: Upcoming releases aim to make transactions\n"
"  even faster and cheaper.\n"
"\n"
"- CVM: Thanks to Cairo, Starknet runs on it´s own VM, called Cairo VM\n"
"  (CVM), that allow us to innovate beyond the Ethereum Virtual Machine\n"
"  (EVM) and create a new paradigm for decentralized applications."
msgstr ""
"- 低成本：Starknet的交易成本低于以太坊。\n"
"  未来的更新（如 Volition 和 EIP 4844）将使其更加便宜。\n"
"\n"
"- 开发者友好：Starknet 可让开发者使用其本地语言Cairo（Cairo）轻松创建\n"
"  去中心化应用程序。\n"
"\n"
"- 速度与效率：即将发布的版本旨在使交易\n"
"  更快、更便宜。\n"
"\n"
"- CVM：得益于Cairo，Starknet运行在自己的虚拟机上，称为Cairo虚拟机（CVM)，\n"
"  它使得我们可以超越以太坊虚拟机（EVM），为去中心化应用创造新的范式。"

#: src/ch00-00-introduction.md:69
msgid "Here some of them:"
msgstr "这里有一些例子："

#: src/ch00-00-introduction.md:71
msgid ""
"- Account Abstraction: Implemented at the protocol level, this\n"
"  facilitates diverse signing schemes while ensuring user security and\n"
"  self-custody of assets.\n"
"\n"
"- Volition: Will be implemented on testnet during Q4 2023 will allow\n"
"  developers to regulate data availability on Ethereum (L1) or on\n"
"  Starknet (L2). Reducing L1 onchain data can radically reduce costs.\n"
"\n"
"- Paymaster: Starknet will allow users to choose how to pay for\n"
"  transaction fee, follows the guidelines laid out in EIP 4337 and\n"
"  allows the transaction to specify a specific contract, a\n"
"  **Paymaster**, to pay for their transaction. Supports gasless\n"
"  transactions, enhancing user accessibility."
msgstr ""
"- 账户抽象：在协议层面实施\n"
"  在确保用户安全和资产自我保管的同时，为各种签名方案提供便利。\n"
"\n"
"- Volition：将于 2023 年第四季度在测试网上实施，将允许\n"
"  开发者修改以太坊（L1）或Starknet（L2）上的数据可用性。减少 L1 的链上数据可以从根本上降低成本。\n"
"\n"
"- Paymaster：Starknet 将允许用户选择如何支付\n"
"  交易费，遵循 EIP 4337 中规定的准则，并\n"
"  允许交易指定一个特定的合约，即\n"
"  **Paymaster**，以支付交易费用。支持无gas\n"
"  交易，提高用户的使用便利性。"

#: src/ch00-00-introduction.md:85
msgid "## Cairo: The Language of Starknet"
msgstr "## Cairo： Starknet的语言"

#: src/ch00-00-introduction.md:87
msgid ""
"Cairo is tailor-made for creating STARK-based smart contracts. As\n"
"Starknet’s native language, it’s central to building scalable and secure\n"
"decentralized apps. To start learning now, check out the [Cairo\n"
"Book](https://cairo-book.github.io/) and\n"
"[Starklings](https://github.com/shramee/starklings-cairo1)."
msgstr ""
"Cairo是为创建基于 STARK 的智能合约而量身定制的。作为Starknet的母语，它是构建可扩展和安全的去中心化应用程序的核心。现在就开始学习吧，请查看 [Cairo Book](https://cairo-book.github.io/) 和  "
"[Starklings](https://github.com/shramee/starklings-cairo1)。"

#: src/ch00-00-introduction.md:93
msgid ""
"Inspired by Rust, Cairo lets you write contracts safely and\n"
"conveniently."
msgstr "Cairo受到 Rust 的启发， 并可以让你安全方便地编写合约。"

#: src/ch00-00-introduction.md:96
msgid "### Why Choose Cairo?"
msgstr "为什么选择Cairo？"

#: src/ch00-00-introduction.md:98
msgid ""
"Cairo is designed for _Provable Computation,_ a new paradigm that lets\n"
"programs prove their correctness without re-running them. Here’s why it\n"
"stands out:"
msgstr "Cairo 是专为 _可证明计算_ 而设计的， _可证明计算_ 是一种让程序无需重新运行就能证明其正确性的新模式。这就是它脱颖而出的原因："

#: src/ch00-00-introduction.md:102
msgid ""
"- Purpose-Built: Designed specifically for smart contracts.\n"
"\n"
"- No EVM Limits: Goes beyond what the Ethereum Virtual Machine can do.\n"
"\n"
"- Flexibility: Uses traits for more flexibility than inheritance."
msgstr ""
"- 专门设计：专为智能合约设计。\n"
"\n"
"- 无 EVM 限制：超越以太坊虚拟机的功能。\n"
"\n"
"- 灵活性：使用trait，比继承更灵活。"

#: src/ch00-00-introduction.md:108
msgid "## Governance"
msgstr "## 治理"

#: src/ch00-00-introduction.md:110
msgid ""
"The Starknet Foundation oversees Starknet’s governance. Its duties\n"
"include:"
msgstr "Starknet基金会负责监督Starknet的治理。其职责包括："

#: src/ch00-00-introduction.md:113
msgid ""
"- Managing Starknet’s development and operations\n"
"\n"
"- Overseeing the Starknet DAO, which enables community involvement\n"
"\n"
"- Setting rules to maintain network integrity"
msgstr ""
"- 管理Starknet的开发和运营\n"
"\n"
"- 监督Starknet DAO，让社区参与其中\n"
"\n"
"- 制定规则，维护网络完整性"

#: src/ch00-00-introduction.md:119
msgid ""
"Our focus is on technical input and debate for improving the protocol.\n"
"While we value all perspectives, it’s often the technical insights that\n"
"steer us forward."
msgstr "我们的工作重心是技术投入和改进协议的讨论。虽然我们重视所有的观点，但技术方面的见解往往是我们前进的方向。"

#: src/ch00-00-introduction.md:123
msgid ""
"Members can influence Starknet by voting on changes. Here’s the process:\n"
"A new version is tested on the Goerli Testnet. Members then have six\n"
"days to review it. A Snapshot proposal is made, and the community votes.\n"
"A majority of _YES_ votes means an upgrade to the Mainnet."
msgstr ""
"成员可以通过投票来影响Starknet的变化。具体过程如下：新版本在 Goerli 测试网上进行测试。然后，成员有六天的时间对其进行审查。Starknet会提出一个快照建议，然后社区会进行投票。多数投 _赞成_ 则表示着该升级"
"将会应用到主网。"

#: src/ch00-00-introduction.md:128
msgid "In short, governance is key to Starknet’s evolution."
msgstr "总之，治理是Starknet发展的关键。"

#: src/ch00-00-introduction.md:130
msgid "To propose an improvement, create a SNIP."
msgstr "要提出改进建议，请创建一个 SNIP。"

#: src/ch00-00-introduction.md:132
msgid "### SNIP: Starknet Improvement Proposals"
msgstr "### SNIP：Starknet改进提案"

#: src/ch00-00-introduction.md:134
msgid ""
"SNIP is short for Starknet Improvement Proposal. It’s essentially a\n"
"blueprint that details proposed enhancements or changes to the Starknet\n"
"ecosystem. A well-crafted SNIP includes both the technical\n"
"specifications of the change and the reasons behind it. If you’re\n"
"proposing a SNIP, it’s your job to rally community support and document\n"
"any objections (more details\n"
"[here](https://community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2)).\n"
"Once a SNIP is approved, it becomes a part of the Starknet protocol. All\n"
"the SNIPs can be found in [this\n"
"repository](https://github.com/starknet-io/SNIPs)."
msgstr ""
"SNIP 是 Starknet 改进提案的简称。它本质上是一个蓝图，详细描述了对 Starknet 生态系统提出的改进或变更建议。一份撰写良好的 SNIP 既应包括变更的技术规范，也应包括变更背后的原因。如果您要提出 SNIP，您的工"
"作就是争取社区的支持并记录任何反对意见（更多详情见 [此处](https://community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2)）。一旦 SNIP 获得批准，它将成为Starknet协议"
"的一部分。所有的 SNIP 都可以在 [这个仓库](https://github.com/starknet-io/SNIPs) 中找到。"

#: src/ch00-00-introduction.md:145
msgid "SNIPs serve three crucial roles:"
msgstr "SNIP 有三个重要作用："

#: src/ch00-00-introduction.md:147
msgid ""
"1.  They are the main avenue for proposing new features or changes.\n"
"\n"
"2.  They act as a platform for technical discussions within the\n"
"    community.\n"
"\n"
"3.  They document the decision-making process, offering a historical\n"
"    view of how Starknet has evolved."
msgstr ""
"1.  它们是提出新功能或变更的主要途径。\n"
"\n"
"2.  它们是社区内技术讨论的平台。\n"
"\n"
"3.  它们记录了决策过程，提供了Starknet 的发展历程。"

#: src/ch00-00-introduction.md:155
msgid ""
"Because SNIPs are stored as text files in a [version-controlled\n"
"repository](https://github.com/starknet-io/SNIPs), you can easily track\n"
"changes and understand the history of proposals."
msgstr "由于 SNIP 以文本文件的形式存储在[版本控制仓库](https://github.com/starknet-io/SNIPs)中，因此您可以轻松地跟踪更改并了解提案的历史。"

#: src/ch00-00-introduction.md:159
msgid ""
"For those who are building on Starknet, SNIPs aren’t just\n"
"suggestions—they’re a roadmap. It’s beneficial for implementers to keep\n"
"a list of the SNIPs they’ve executed. This transparency helps users\n"
"gauge the state of a particular implementation or software library."
msgstr ""
"对于在 Starknet 上进行开发的人员来说，SNIP 不仅仅是提案，更是路线图。对于实际的提案实现者来说，保存一份他们已经实现了的 SNIP 的清单是非常有益的。这种透明性有助于用户衡量特定的实现或软件库的状况。"

#: src/ch00-00-introduction.md:164 src/ch02-05-foundry-cast.md:511 src/ch02-08-starknet-react.md:361 src/ch03-00-architecture.md:251 src/ch03-01-transactions.md:63
#: src/ch03-01-01-transactions-lifecycle.md:175 src/ch03-02-sequencers.md:216 src/ch03-03-provers.md:243 src/ch03-06-solidity-verifier.md:139 src/ch04-00-account-abstraction.md:345
msgid "## Conclusion"
msgstr "## 总结"

#: src/ch00-00-introduction.md:166
msgid ""
"In decentralized technology, Starknet offers a solution to challenges that previous systems encountered. It's based on established _protocols_ and _registries_, following the initial concepts "
"introduced by figures such as Satoshi. Through a specific mathematical method, Starknet seeks a balance between scalability and consensus. As this technology progresses, Starknet adheres to "
"principles of inclusivity, neutrality, and user empowerment. It's poised for continuous adaptation and improvement in the field."
msgstr ""
"在去中心化技术中，Starknet为解决以往系统遇到的难题提供了解决方案。它基于既定的 _协议_ 和 _登记机构_ ，沿袭了中本聪等人提出的最初概念。通过特定的数学方法，Starknet寻求可扩展性和共识之间的平衡。随着技"
"术的进步，Starknet坚持包容性、中立性和用户授权的原则。它将在该领域不断适应和改进。"

#: src/ch01-00-getting-started.md:1
msgid "# Getting Started"
msgstr "# 入门"

#: src/ch01-00-getting-started.md:3
msgid ""
"Starknet is a scalable Layer-2 solution on Ethereum. This guide will walk you through the process of deploying and interacting with your first Starknet smart contract using the Cairo programming "
"language, a language tailored for creating validity proofs and that Starknet uses. For seasoned developers looking to understand the core concepts and get hands-on experience, this guide offers "
"step-by-step instructions and essential details."
msgstr ""
"Starknet 是以太坊上可扩展的第 2 层解决方案。本指南将指导你使用 Cairo 编程语言部署你的第一个 Starknet 智能合约并与之交互，Cairo 是专为创建有效性证明而定制的语言，Starknet 也使用这种语言。对于希望了解"
"核心概念并获得实践经验的经验丰富的开发人员来说，本指南提供了分步指导和基本细节。"

#: src/ch01-00-getting-started.md:5
msgid "We will use the Starknet Remix Plugin to compile, deploy and interact with our smart contract. It is a great tool to get started with Starknet development."
msgstr "我们将使用 Starknet Remix Plugin 来编译、部署和交互我们的智能合约。它是入门 Starknet 开发的绝佳工具。"

#: src/ch01-00-getting-started.md:7
msgid ""
"1. Visit [The Remix Project](https://remix.ethereum.org/).\n"
"2. Navigate to the ‘Plugins’ section in the bottom left corner.\n"
"3. Enable the “Starknet” plugin."
msgstr ""
"1.请访问 [The Remix Project](https://remix.ethereum.org/)。\n"
"2.导航至左下角的‘Plugins’部分。\n"
"3.启用 \"Starknet \"插件。"

#: src/ch01-00-getting-started.md:11
msgid "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch01-00-getting-started.md:13
msgid "<span class=\"caption\">Activate the Starknet Plugin</span>"
msgstr "<span class=\"caption\">激活Starknet插件</span>"

#: src/ch01-00-getting-started.md:15
msgid "4. After enabling, the Starknet logo appears on the left sidebar. Click it to interact with opened Cairo files."
msgstr "4.启用后，Starknet 徽标会出现在左侧边栏。点击它即可与打开的Cairo文件进行交互。"

#: src/ch01-00-getting-started.md:17
msgid "## Introduction to Starknet Smart Contracts"
msgstr "## Starknet智能合约简介"

#: src/ch01-00-getting-started.md:19
msgid "The script below is a simple `Ownable` contract pattern written in Cairo for Starknet. It features:"
msgstr "下面的脚本是用Cairo语言为Starknet编写的一个简单的 `Ownable` 合约模式。它的特点是："

#: src/ch01-00-getting-started.md:21
msgid ""
"- An ownership system.\n"
"- A method to transfer ownership.\n"
"- A method to check the current owner.\n"
"- An event notification for ownership changes."
msgstr ""
"- 所有权系统。\n"
"- 所有权转移方法。\n"
"- 检查当前所有者的方法。\n"
"- 所有权变更事件通知。"

#: src/ch01-00-getting-started.md:26
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait OwnableTrait<T> {\n"
"    fn transfer_ownership(ref self: T, new_owner: ContractAddress);\n"
"    fn get_owner(self: @T) -> ContractAddress;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Ownable {\n"
"    use super::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"      OwnershipTransferred1: OwnershipTransferred1,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred1 {\n"
"        #[key]\n"
"        prev_owner: ContractAddress,\n"
"        #[key]\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_owner: ContractAddress) {\n"
"        self.owner.write(init_owner);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl OwnableImpl of super::OwnableTrait<ContractState> {\n"
"        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {\n"
"            self.only_owner();\n"
"            let prev_owner = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {\n"
"                prev_owner: prev_owner,\n"
"                new_owner: new_owner,\n"
"            }));\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateMethods of PrivateMethodsTrait {\n"
"        fn only_owner(self: @ContractState) {\n"
"            let caller = get_caller_address();\n"
"            assert(caller == self.owner.read(), 'Caller is not the owner');\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait OwnableTrait<T> {\n"
"    fn transfer_ownership(ref self: T, new_owner: ContractAddress);\n"
"    fn get_owner(self: @T) -> ContractAddress;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Ownable {\n"
"    use super::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"      OwnershipTransferred1: OwnershipTransferred1,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred1 {\n"
"        #[key]\n"
"        prev_owner: ContractAddress,\n"
"        #[key]\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_owner: ContractAddress) {\n"
"        self.owner.write(init_owner);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl OwnableImpl of super::OwnableTrait<ContractState> {\n"
"        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {\n"
"            self.only_owner();\n"
"            let prev_owner = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {\n"
"                prev_owner: prev_owner,\n"
"                new_owner: new_owner,\n"
"            }));\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateMethods of PrivateMethodsTrait {\n"
"        fn only_owner(self: @ContractState) {\n"
"            let caller = get_caller_address();\n"
"            assert(caller == self.owner.read(), 'Caller is not the owner');\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:91
msgid "### Components Breakdown"
msgstr "### 组件细分"

#: src/ch01-00-getting-started.md:93
msgid ""
"The following is a brief description of the components in the contract. We will get into more details when we get deeper into Cairo so feel free to skip this section for now if you are not familiar "
"with smart contract development."
msgstr "下面将简要介绍合约中的组件。我们将在深入了解Cairo后介绍更多细节，所以如果你不熟悉智能合约开发，可以暂时跳过这一部分。"

#: src/ch01-00-getting-started.md:95
msgid ""
"1. **Dependencies and Interface**:\n"
"   - **`starknet::ContractAddress`**: Represents a Starknet contract address.\n"
"   - **`OwnableTrait`**: Specifies functions for transferring and getting ownership.\n"
"2. **Events**:\n"
"   - **`OwnershipTransferred1`**: Indicates ownership change with previous and new owner details.\n"
"3. **Storage**:\n"
"   - **`Storage`**: Holds the contract's state with the current owner's address.\n"
"4. **Constructor**:\n"
"   - Initializes the contract with a starting owner.\n"
"5. **External Functions**:\n"
"   - Functions for transferring ownership and retrieving the current owner's details.\n"
"6. **Private Methods**:\n"
"   - **`only_owner`**: Validates if the caller is the current owner."
msgstr ""
"1. **依赖关系和接口**：\n"
"   - **`starknet::ContractAddress`**：代表Starknet合约地址。\n"
"   - **`OwnableTrait`**：指定转移和获取所有权的函数。\n"
"2. **事件**：\n"
"   - **`OwnershipTransferred1`**：表示所有权变更，包含前所有者和新所有者的详细信息。\n"
"3. **存储**：\n"
"   - **`Storage`**：包含合约状态和当前所有者的地址。\n"
"4. **构造函数**：\n"
"   - 用起始所有者初始化合约。\n"
"5. **外部函数**：\n"
"   - 用于转移所有权和获取当前所有者详细信息的函数。\n"
"6. **私有方法**：\n"
"   - **`only_owner`**：验证调用者是否为当前所有者。"

#: src/ch01-00-getting-started.md:109
msgid "## Compilation Process"
msgstr "## 编译过程"

#: src/ch01-00-getting-started.md:111
msgid "To compile using Remix:"
msgstr "我们将使用 Remix 进行编译："

#: src/ch01-00-getting-started.md:113
msgid ""
"1. **File Creation**\n"
"\n"
"   - Navigate to the \"File Explorer\" tab in Remix.\n"
"   - Create a new file named `Ownable.cairo` and input the previous code.\n"
"\n"
"2. **Compilation**\n"
"\n"
"   - Choose the `Ownable.cairo` file.\n"
"   - In the \"Starknet\" tab, select \"Compile Ownable.cairo\".\n"
"   - Post-compilation, an \"artifacts\" folder emerges containing the compiled contract in two distinct formats: Sierra (JSON file) and CASM. For Starknet deployment, Remix will use the Sierra "
"file. Do not worry about this process for now; we will cover it in detail in a later chapter. For now, Remix will handle the compilation and deployment for us."
msgstr ""
"1. **文件创建**\n"
"\n"
"   - 进入 Remix 的 \"File Explorer\" 选项卡。\n"
"   - 创建一个名为 `Ownable.cairo` 的新文件，并输入之前的代码。\n"
"\n"
"2. **编译**\n"
"\n"
"   - 选择 `Ownable.cairo` 文件。\n"
"   - 在 \"Starknet \"选项卡中，选择 \"Compile Ownable.cairo\"。\n"
"   - 编译后，会出现一个\"artifacts\"文件夹，其中包含两种不同格式的编译合约：Sierra（JSON 文件）和 CASM。对于Starknet部署，Remix 将使用 Sierra 文件。现在不用担心这个过程，我们将在后面的章节中详细介"
"绍。现在，Remix 将为我们处理编译和部署工作。"

#: src/ch01-00-getting-started.md:124
msgid "<img alt=\"Artifacts folder after compilation\" src=\"img/ch01-remix-file.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Artifacts folder after compilation\" src=\"img/ch01-remix-file.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch01-00-getting-started.md:126
msgid "<span class=\"caption\">Artifacts folder after compilation</span>"
msgstr "<span class=\"caption\">Artifacts folder after compilation</span>"

#: src/ch01-00-getting-started.md:128
msgid "## Deployment on the Development Network"
msgstr "## 在开发网络上部署"

#: src/ch01-00-getting-started.md:130
msgid "To set your smart contract in motion, an initial owner must be defined. The Constructor function needs this information."
msgstr "要启动智能合约，必须定义初始所有者。构造函数需要这些信息。"

#: src/ch01-00-getting-started.md:132
msgid "Here's a step-by-step guide to deploying your smart contract on the development network:"
msgstr "以下是在开发网络上部署智能合约的分步指南："

#: src/ch01-00-getting-started.md:134
msgid ""
"1. **Select the Appropriate Network**\n"
"\n"
"   - Go to the Environment selection tab.\n"
"   - Choose \"Remote Devnet\" for deploying your inaugural contract on a development network.\n"
"\n"
"2. **Choose a Devnet Account**\n"
"\n"
"   - Under \"Devnet account selection\", a list of accounts specific to the chosen devnet is presented.\n"
"   - Pick any account and copy its address.\n"
"\n"
"3. **Initiating Deployment**\n"
"\n"
"   - Navigate to the \"Starknet\" tab.\n"
"   - Input the copied address into the `init_owner` variable.\n"
"   - Click on \"Deploy ownable.cairo\"."
msgstr ""
"1. **选择合适的网络**\n"
"\n"
"   - 转到 \"Environment selection\" 选项卡。\n"
"   - 选择 \"Remote Devnet\"（远程开发网络），以便在开发网络上部署你的第一个合约。\n"
"\n"
"2. **选择一个 Devnet 账户**\n"
"\n"
"   - 在 \"Devnet account selection\"下，将显示所选 Devnet 的专属帐户列表。\n"
"   - 选择任意账户并复制其地址。\n"
"\n"
"3. **启动部署**\n"
"\n"
"   - 导航至 \"Starknet \"选项卡。\n"
"   - 在 `init_owner` 变量中输入复制的地址。\n"
"   - 点击 \"Deploy ownable.cairo\"。"

#: src/ch01-00-getting-started.md:150
msgid "Post-deployment, Remix's terminal will send various logs. These logs provide crucial details, including:"
msgstr "部署后，Remix 的终端将打印出各种日志。这些日志提供了重要的详细信息，包括："

#: src/ch01-00-getting-started.md:152
msgid ""
"- `transaction_hash`: The unique hash of the transaction. This hash can be used to track the transaction's status.\n"
"- `contract_address`: The address of the deployed contract. Use this address to interact with your contract.\n"
"- `calldata`: Contains the `init_owner` address fed to the constructor."
msgstr ""
"- `transaction_hash`：交易的唯一哈希值。此哈希值可用于跟踪交易状态。\n"
"- `contract_address`：已部署合约的地址。使用此地址与您的合约进行交互。\n"
"- `calldata`：包含提供给构造函数的 `init_owner` 地址。"

#: src/ch01-00-getting-started.md:156
msgid ""
"```bash\n"
"{\n"
"  \"transaction_hash\": \"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": \"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"transaction_hash\": \"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": \"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:168
msgid "By following the above process, you successfully deploy your smart contract on the development network."
msgstr "按照上述流程操作，您就成功地在开发网络上部署了智能合约。"

#: src/ch01-00-getting-started.md:170
msgid "## Interaction with the Contract"
msgstr "## 与合约的交互"

#: src/ch01-00-getting-started.md:172
msgid "With the contract now active on the development network, interaction becomes possible. Here's a guide to effectively interact with your contract on Starknet:"
msgstr "现在，合约已在开发网络上激活，与之交互成为可能。以下是在Starknet与合约有效交互的指南："

#: src/ch01-00-getting-started.md:174
msgid ""
"1. **Initiating Interaction**\n"
"\n"
"   - Navigate to the \"Starknet\" tab.\n"
"   - Select the \"Interact\" option.\n"
"\n"
"2. **Calling the `get_owner` Function**\n"
"\n"
"   - Choose the `get_owner` function. Since this function doesn't require arguments, the calldata field remains blank. (This is a read function, hence calling it is termed as a \"call\".)\n"
"   - Press the \"get_owner\" button. Your terminal will display the result, revealing the owner's address provided during the contract's deployment as calldata for the constructor:"
msgstr ""
"1. **启动交互**\n"
"\n"
"   - 导航至 \"Starknet \"选项卡。\n"
"   - 选择 \"Interact\" 选项。\n"
"\n"
"2. **调用 `get_owner` 函数**\n"
"\n"
"   - 选择 `get_owner` 函数。由于该函数不需要参数，因此 calldata 字段保持空白。(这是一个只读函数，因此调用它被称为 \"call\"）。\n"
"   - 按下 \"get_owner \"按钮。您的终端将显示结果，揭示在部署合约时作为构造函数 calldata 提供的所有者地址："

#: src/ch01-00-getting-started.md:184
msgid ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:196
msgid "This call currently doesn't spend gas because the function does not change the state of the contract."
msgstr "由于该函数不会改变合约的状态，因此该调用目前不会消耗gas。"

#: src/ch01-00-getting-started.md:198
msgid "3. **Invoking the `transfer_ownership` Function**"
msgstr "3. **调用 `transfer_ownership` 函数**"

#: src/ch01-00-getting-started.md:200
msgid ""
"- Now, for the **`transfer_ownership`** function, which requires the new owner's address as input.\n"
"- Enter this address into the calldata field. (For this, use any address from the \"Devnet account selection\" listed in the Environment tab.)\n"
"- Click the \"transfer_ownership\" button. The terminal then showcases the transaction hash indicating the contract's state alteration. Since we are altering the contract's state this typo of "
"interaction is called an \"invoke\" and needs to be signed by the account that is calling the function."
msgstr ""
"- 现在，**`transfer_ownership`** 函数需要输入新所有者的地址。\n"
"- 在 calldata 字段中输入该地址。(为此，请使用环境选项卡中列出的 \"Devnet account selection\"中的任何地址）。\n"
"- 点击 \"transfer_ownership（转让所有权）\"按钮。然后，终端会显示交易哈希值，表明合约的状态已更改。由于我们正在改变合约的状态，因此这种不同于“call”的交互称为 \"invoke\"，需要由调用函数的账户签名。"

#: src/ch01-00-getting-started.md:204
msgid ""
"For these transactions, the terminal logs will exhibit a \"status\" variable, indicating the transaction's fate. If the status reads \"ACCEPTED_ON_L2\", the Sequencer has accepted the transaction, "
"pending block inclusion. However, a \"REJECTED\" status signifies the Sequencer's disapproval, and the transaction won't feature in the upcoming block. More often than not, this transaction gains "
"acceptance, leading to a contract state modification. On calling the **`get_owner`** function again we get this:"
msgstr ""
"对于这些交易，终端日志将显示一个\"status\"  变量，表明该交易的命运。如果状态显示为 \"ACCEPTED_ON_L2\"，则表示排序器已接受该交易，等待将其加入区块。但是，如果状态为 \"REJECTED\"，则表示排序器不接受该"
"交易，该交易将不会出现在即将到来的区块中。通常情况下，该交易会被接受，从而导致合约状态修改。再次调用**`get_owner`**函数时，我们会得到以下结果："

#: src/ch01-00-getting-started.md:206
msgid ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:218
msgid "You've now adeptly compiled, deployed, and interacted with your inaugural Starknet smart contract. Well done!"
msgstr "您现在已经能熟练地编译、部署并与您的首份Starknet智能合约进行交互了。干得不错！"

#: src/ch01-00-getting-started.md:220
msgid "## Deploying on Starknet Testnet"
msgstr "## 在Starknet测试网上部署"

#: src/ch01-00-getting-started.md:222
msgid ""
"After testing your smart contract on a development network, it's time to deploy it to the Starknet Testnet. Starknet Testnet is a public platform available for everyone, ideal for testing smart "
"contracts and collaborating with fellow developers."
msgstr "在开发网络上测试完智能合约后，就可以将其部署到Starknet测试网络上了。Starknet 测试网络是一个面向所有人的公共平台，是测试智能合约和与其他开发者合作的理想平台。"

#: src/ch01-00-getting-started.md:224
msgid "First you need to create a Starknet account."
msgstr "首先，您需要创建一个Starknet账户。"

#: src/ch01-00-getting-started.md:226
msgid "### Smart Wallet Setup"
msgstr "### 智能钱包设置"

#: src/ch01-00-getting-started.md:228
msgid ""
"Before deploying your smart contract to Starknet, you must handle the transaction cost. While deploying to the Starknet Goerli Testnet is free, a smart wallet account is essential. You can set up a "
"smart wallet using either:"
msgstr "在将智能合约部署到Starknet之前，您必须处理好交易成本相关的问题。虽然部署到Starknet Goerli Testnet 是免费的，但智能钱包账户却是必不可少的。你可以使用以下两种方法之一建立智能钱包："

#: src/ch01-00-getting-started.md:230
msgid ""
"- [Braavos](https://braavos.app/)\n"
"- [Argent](https://www.argent.xyz/argent-x/)"
msgstr ""
"- [Braavos](https://braavos.app/)\n"
"- [Argent](https://www.argent.xyz/argent-x/)"

#: src/ch01-00-getting-started.md:233
msgid ""
"Both are reliable Starknet wallets offering enhanced security and accessibility features thanks to the possibilities that the Cairo VM brings, such as Account Abstraction (keep reading the Book for "
"more on this)."
msgstr "两者皆是可靠的Starknet钱包，由于Cairo虚拟机带来了更多可能性，如账户抽象（请继续阅读本书了解更多相关信息），因此Starknet上的钱包比起EOA钱包具有更强的安全性和可访问性。"

#: src/ch01-00-getting-started.md:235
msgid ""
"1. Install the recommended chrome/brave extension for your chosen wallet.\n"
"2. Follow your wallet provider's instructions to deploy your account.\n"
"3. Use the [Starknet Faucet](https://faucet.goerli.starknet.io/) to fund your account.\n"
"4. Deploy the account to the network. This usually takes around 10 seconds."
msgstr ""
"1. 为所选钱包安装推荐的 chrome/brave 扩展程序。\n"
"2. 按照钱包提供商的说明部署账户。\n"
"3. 使用 [Starknet Faucet](https://faucet.goerli.starknet.io/) 为账户充值。\n"
"4. 将账户部署到网络。这通常需要 10 秒钟左右。"

#: src/ch01-00-getting-started.md:240
msgid "Once set up, you're ready to deploy your smart contracts to the Starknet Testnet."
msgstr "当设置完成后，您就可以将智能合约部署到Starknet测试网络了。"

#: src/ch01-00-getting-started.md:242
msgid "### Deployment and Interaction"
msgstr "### 部署和交互"

#: src/ch01-00-getting-started.md:244
msgid ""
"1. Follow the previous deployment steps.\n"
"2. In the 'Environment selection' tab, choose 'Wallet Selection'.\n"
"3. Select your Starknet account and continue with deploying and interacting with your contract."
msgstr ""
"1.按照之前的部署步骤进行。\n"
"2.在 'Environment selection' 选项卡中，选择 'Wallet Selection'。\n"
"3.选择您的Starknet账户，然后继续部署并与您的合约交互。"

#: src/ch01-00-getting-started.md:248
msgid "You can monitor transaction hashes and addresses using any Starknet block explorers like:"
msgstr "您可以使用任何 Starknet 区块浏览器监控交易哈希值和地址："

#: src/ch01-00-getting-started.md:250
msgid ""
"- [Starkscan](https://testnet.starkscan.co/)\n"
"- [Voyager](https://goerli.voyager.online/)"
msgstr ""
"- [Starkscan](https://testnet.starkscan.co/)\n"
"- [Voyager](https://goerli.voyager.online/)"

#: src/ch01-00-getting-started.md:253
msgid ""
"These tools provide a visual representation of transactions and contract state alterations. Notably, when you alter the contract ownership using the `transfer_ownership` function, the event emitted "
"by the contract appears in the block explorer. It's an effective method to track contract events."
msgstr "这些工具提供了事务和合约状态更改的可视化表示。值得注意的是，当你使用 `transfer_ownership` 函数更改合约所有权时，合约发出的事件就会出现在区块浏览器中。这是跟踪合约事件的有效方法。"

#: src/ch01-00-getting-started.md:255
msgid "## Your Next Steps"
msgstr "## 接下来的步骤"

#: src/ch01-00-getting-started.md:257
msgid "Decide your direction from the following choices:"
msgstr "你可以从以下选项中决定你的学习方向："

#: src/ch01-00-getting-started.md:259
msgid ""
"1. **Deepen Your Starknet Knowledge**: For an extensive grasp of Starknet's inner workings and potential use cases, delve into Chapter 3 of the Starknet Book. This chapter details Starknet’s "
"architectural nuances. Then go ahead from there.\n"
"\n"
"2. **Dive into Cairo**: If you're more attuned to coding and wish to craft Starknet contracts, then Cairo is essential. It stands as Starknet's core contract language. Begin with Chapters 1-6 of "
"the [Cairo Book](https://book.cairo-lang.org/title-page.html), ranging from basics in _Getting Started_ to more advanced aspects such as _Enums and Pattern Matching_. Conclude by navigating to the "
"[Starknet Smart Contracts chapter](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html), ensuring you have a well-rounded understanding."
msgstr ""
"1. **深化您的Starknet知识**：要广泛了解 Starknet 的内部运作和潜在用例，请深入阅读《Starknet 之书》第 3 章。本章详细介绍了Starknet架构的细微差别。然后继续学习。\n"
"\n"
"2. **深入了解Cairo**：如果你更擅长编码，并希望编写Starknet合约，那么Cairo是必不可少的。它是Starknet的核心合约语言。请从[Cairo Book](https://book.cairo-lang.org/title-page.html)的第1-6章开始，学习从 "
"_入门_ 的基础知识到 _枚举和模式匹配_ 等更高级的内容。最后，浏览[Starknet 智能合约章节](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)，确保您有一个全面的了解。"

#: src/ch02-00-starknet-tooling.md:1
msgid "# Starknet Tooling"
msgstr "# Starknet工具"

#: src/ch02-00-starknet-tooling.md:3 src/ch02-03-scarb.md:3
msgid ""
"To make the most of this chapter, a basic grasp of the Cairo programming\n"
"language is advised. We suggest reading chapters 1-6 of the [Cairo\n"
"Book](https://book.cairo-lang.org/title-page.html), covering topics from\n"
"_Getting Started_ to _Enums and Pattern Matching._ Follow this by\n"
"studying the [Starknet Smart Contracts\n"
"chapter](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)\n"
"in the same book. With this background, you’ll be well-equipped to\n"
"understand the examples presented here."
msgstr ""
"要充分理解本章内容，建议先掌握Cairo编程语言的基本知识。我们建议阅读[Cairo Book](https://book.cairo-lang.org/zh-cn/title-page.html)的第1-6章，内容包括从 _入门_ 章节的基础知识到 _枚举和模式匹配_。之"
"后，再学习同一本书中的[Starknet 智能合约](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.htmll)。有了这些背景知识，你就能很好地理解这里介绍的示例了。"

#: src/ch02-00-starknet-tooling.md:12
msgid ""
"Today, Starknet provides all essential tools for building decentralized\n"
"applications (dApps), compatible with multiple languages like\n"
"JavaScript, Rust, and Python. You can use the Starknet SDK for\n"
"development. Front-end developers can use Starknet.js with React, while\n"
"Rust and Python work well for back-end tasks."
msgstr ""
"如今，Starknet提供了构建去中心化应用程序（dApps）的所有基本工具，兼容 JavaScript、Rust 和 Python 等多种语言。您可以使用 Starknet SDK 进行开发。前端开发人员可以使用带有 React 的 Starknet.js，而 Rust "
"和 Python 则可以很好地完成后端任务。"

#: src/ch02-00-starknet-tooling.md:18
msgid ""
"We welcome contributors to enhance existing tools or develop new\n"
"solutions."
msgstr "我们欢迎贡献者改进现有工具或开发新的解决方案。"

#: src/ch02-00-starknet-tooling.md:21
msgid "In this chapter, you’ll explore:"
msgstr "在本章中，您将了解："

#: src/ch02-00-starknet-tooling.md:23
msgid ""
"- Frameworks: Build using Starknet-Foundry\n"
"\n"
"- SDKs: Discover multi-language support through Starknet.js,\n"
"  Starknet-rs, Starknet_py, and Caigo\n"
"\n"
"- Front-end Development: Use Starknet.js and React\n"
"\n"
"- Testing: Understand testing methods with Starknet-Foundry and the Devnet"
msgstr ""
"- 框架：使用 Starknet-Foundry 构建\n"
"\n"
"- SDK：通过 Starknet.js，Starknet-rs，Starknet_py 和 Caigo 提供多语言支持\n"
"\n"
"- 前端开发：使用 Starknet.js 和 React\n"
"\n"
"- 测试：了解使用 Starknet-Foundry 和 Devnet 的测试方法"

#: src/ch02-00-starknet-tooling.md:32
msgid ""
"By chapter’s end, you’ll have a complete grasp of Starknet’s toolset,\n"
"enabling efficient dApp development."
msgstr "本章结束时，您将能完全掌握 Starknet 的工具集，实现高效的 dApp 开发。"

#: src/ch02-00-starknet-tooling.md:35
msgid ""
"Here’s a quick rundown of the tools that could be used for Starknet\n"
"development and that we’ll cover in this chapter:"
msgstr "以下是可用于Starknet开发的工具的简要介绍，我们将在本章介绍这些工具："

#: src/ch02-00-starknet-tooling.md:38
msgid ""
"1.  Scarb: A package manager that compiles your contracts.\n"
"\n"
"2.  Starkli: A CLI tool for interacting with the Starknet network.\n"
"\n"
"3.  Starknet Foundry: For contract testing.\n"
"\n"
"4.  Katana: Creates a local test node.\n"
"\n"
"5.  SDKs: starknet.js, Starknet.py, and starknet.rs interface with\n"
"    Starknet using common programming languages.\n"
"\n"
"6.  Starknet-react: Builds front-end apps using React."
msgstr ""
"1.  Scarb：编译合约的软件包管理器\n"
"\n"
"2.  Starkli：用于与 Starknet 网络交互的 CLI 工具。\n"
"\n"
"3.  Foundry：用于合约测试。\n"
"\n"
"4.  Katana：创建本地测试节点。\n"
"\n"
"5.  SDK：starknet.js、Starknet.py 和 starknet.rs 。这些是使用普通编程语言与Starknet 交互的接口。\n"
"\n"
"6.  Starknet-react：使用 React 构建前端应用程序。"

#: src/ch02-01-basic-installation.md:1 src/ch02-03-scarb.md:34 src/ch02-07-starknet-js.md:13
msgid "# Installation"
msgstr "# 安装"

#: src/ch02-01-basic-installation.md:3
msgid ""
"This chapter walks you through setting up your Starknet development\n"
"tools."
msgstr "本章将指导您安装与设置 Starknet 开发工具。"

#: src/ch02-01-basic-installation.md:6
msgid "Essential tools to install:"
msgstr "安装必备工具："

#: src/ch02-01-basic-installation.md:8
msgid ""
"1.  [Starkli](https://github.com/xJonathanLEI/starkli) - A CLI tool for\n"
"    interacting with Starknet. More tools are discussed in Chapter 2.\n"
"\n"
"2.  [Scarb](https://github.com/software-mansion/scarb) - Cairo’s package\n"
"    manager that compiles code to Sierra, a mid-level language between\n"
"    Cairo and CASM.\n"
"\n"
"3.  [Katana](https://github.com/dojoengine/dojo) - Katana is a Starknet node, built for local development."
msgstr ""
"1.  [Starkli](https://github.com/xJonathanLEI/starkli) - 与Starknet交互的 CLI 工具。第 2 章将讨论更多工具。\n"
"\n"
"2.  [Scarb](https://github.com/software-mansion/scarb) - Cairo 的软件包管理器，可将代码编译为 Sierra，一种介于 Cairo 和 CASM 之间的中级语言。\n"
"3.  [Katana](https://github.com/dojoengine/dojo) - Katana 是一个 Starknet节点，用于本地开发。."

#: src/ch02-01-basic-installation.md:17
msgid ""
"For support or queries, visit our [GitHub\n"
"Issues](https://github.com/starknet-edu/starknetbook/issues) or contact\n"
"espejelomar on Telegram."
msgstr "有关支持或问题，请访问我们的 [GitHub Issues](https://github.com/starknet-edu/starknetbook/issues) 或在 Telegram 上联系 espejelomar。"

#: src/ch02-01-basic-installation.md:21
msgid "## Starkli Installation"
msgstr "## Starkli 安装"

#: src/ch02-01-basic-installation.md:23
msgid ""
"Easily install Starkli using Starkliup, an installer invoked through the\n"
"command line."
msgstr "使用通过命令行调用安装程序 Starkliup，可轻松安装 Starkli。"

#: src/ch02-01-basic-installation.md:26
msgid ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"
msgstr ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"

#: src/ch02-01-basic-installation.md:31
msgid "Restart your terminal and confirm installation:"
msgstr "重新启动终端并确认安装成功："

#: src/ch02-01-basic-installation.md:33
msgid ""
"```bash\n"
"starkli --version\n"
"```"
msgstr ""
"```bash\n"
"starkli --version\n"
"```"

#: src/ch02-01-basic-installation.md:37
msgid "To upgrade Starkli, simply repeat the steps."
msgstr "要升级 Starkli，只需重复上述步骤即可。"

#: src/ch02-01-basic-installation.md:39
msgid "## Scarb Package Manager Installation"
msgstr "## 安装 Scarb 软件包管理器"

#: src/ch02-01-basic-installation.md:41
msgid "We will get deeper into Scarb later in this chapter. For now, we will go over the installation process."
msgstr "本章稍后我们将深入介绍 Scarb。现在，我们将介绍安装过程。"

#: src/ch02-01-basic-installation.md:43
msgid "For macOS and Linux:"
msgstr "对于 macOS 和 Linux上："

#: src/ch02-01-basic-installation.md:45 src/ch04-02-hello-account.md:17
msgid ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"

#: src/ch02-01-basic-installation.md:49
msgid ""
"For Windows, follow manual setup in the [Scarb\n"
"documentation](https://docs.swmansion.com/scarb/download.html#windows)."
msgstr "对于 Windows，请按照 [Scarb 文档](https://docs.swmansion.com/scarb/download.html#windows)中的手册进行设置。"

#: src/ch02-01-basic-installation.md:52
msgid "Restart the terminal and run:"
msgstr "重启终端并运行："

#: src/ch02-01-basic-installation.md:54 src/ch04-02-hello-account.md:11
msgid ""
"```bash\n"
"scarb --version\n"
"```"
msgstr ""
"```bash\n"
"scarb --version\n"
"```"

#: src/ch02-01-basic-installation.md:58
msgid "To upgrade Scarb, rerun the installation command."
msgstr "要升级 Scarb，请重新运行安装命令。"

#: src/ch02-01-basic-installation.md:60
msgid "## Katana Node Installation"
msgstr "## Katana Node 安装"

#: src/ch02-01-basic-installation.md:62 src/ch02-04-katana.md:36
msgid "To install Katana, use the `dojoup` installer from the command line:"
msgstr "要安装 Katana，请使用命令行中的 `dojoup` 安装程序："

#: src/ch02-01-basic-installation.md:64 src/ch02-04-katana.md:38
msgid ""
"```bash\n"
"curl -L https://install.dojoengine.org | bash\n"
"dojoup\n"
"```"
msgstr ""
"```bash\n"
"curl -L https://install.dojoengine.org | bash\n"
"dojoup\n"
"```"

#: src/ch02-01-basic-installation.md:69 src/ch02-04-katana.md:43
msgid "After restarting your terminal, verify the installation with:"
msgstr "重启终端后，用以下命令验证安装："

#: src/ch02-01-basic-installation.md:71 src/ch02-04-katana.md:45
msgid ""
"```bash\n"
"katana --version\n"
"```"
msgstr ""
"```bash\n"
"katana --version\n"
"```"

#: src/ch02-01-basic-installation.md:75 src/ch02-04-katana.md:49
msgid "To upgrade Katana, rerun the installation command."
msgstr "要升级卡塔娜，请重新运行安装命令。"

#: src/ch02-01-basic-installation.md:77
msgid "You are now set to code in Cairo and deploy to Starknet."
msgstr "现在您已经将用Cairo编写代码并将其部署到Starknet所需的开发环境设置完成了。"

#: src/ch02-02-starkli-scarb-katana.md:1
msgid "# Introduction to Starkli, Scarb and Katana"
msgstr "# Starkli、Scarb 和 Katana 的简介"

#: src/ch02-02-starkli-scarb-katana.md:3
msgid ""
"In this chapter, you’ll learn how to compile, deploy, and interact with\n"
"a Starknet smart contract written in Cairo using starkli, scarb and katana."
msgstr "在本章中，你将学习如何使用starkli, scarb 和 katana来编译、部署用 Cairo 编写的 Starknet 智能合约，并与之交互。"

#: src/ch02-02-starkli-scarb-katana.md:6
msgid ""
"First, confirm that the following commands work on your system. If they\n"
"don’t, refer to Basic Installation in this chapter."
msgstr "首先，请确认以下命令在您的系统上是否有效。如果不行，请参阅本章的基本安装。"

#: src/ch02-02-starkli-scarb-katana.md:9
msgid ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"    katana --version # To declare and deploy on local development\n"
"```"
msgstr ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"    katana --version # To declare and deploy on local development\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:15
msgid "## [OPTIONAL] Checking Supported Compiler Versions"
msgstr "## [可选] 检查支持的编译器版本"

#: src/ch02-02-starkli-scarb-katana.md:17
msgid "If issues arise during the declare or deploy process, ensure that the Starkli compiler version aligns with the Scarb compiler version."
msgstr "如果在声明或部署过程中出现问题，请确保 Starkli 编译器版本与 Scarb 编译器版本一致。"

#: src/ch02-02-starkli-scarb-katana.md:19
msgid "To check the compiler versions Starkli supports, run:"
msgstr "要检查 Starkli 支持的编译器版本，请运行："

#: src/ch02-02-starkli-scarb-katana.md:21
msgid ""
"```bash\n"
"starkli declare --help\n"
"\n"
"```"
msgstr ""
"```bash\n"
"starkli declare --help\n"
"\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:26
msgid ""
"You’ll see a list of possible compiler versions under the\n"
"`--compiler-version` flag."
msgstr "你会在 `--compiler-version` 标志下看到可使用的编译器版本列表。"

#: src/ch02-02-starkli-scarb-katana.md:29
msgid ""
"```bash\n"
"    ...\n"
"    --compiler-version <COMPILER_VERSION>\n"
"              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]\n"
"    ...\n"
"```"
msgstr ""
"```bash\n"
"    ...\n"
"    --compiler-version <COMPILER_VERSION>\n"
"              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]\n"
"    ...\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:36
msgid "Be aware: Scarb's compiler version may not match Starkli’s. To verify Scarb's version:"
msgstr "请注意：Scarb 的编译器版本可能与 Starkli 的不一致。要验证 Scarb 的版本请允许："

#: src/ch02-02-starkli-scarb-katana.md:38
msgid ""
"```bash\n"
"    scarb --version\n"
"```"
msgstr ""
"```bash\n"
"    scarb --version\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:42
msgid "The output displays the versions for scarb, cairo, and sierra:"
msgstr "The output displays the versions for scarb, cairo, and sierra:"

#: src/ch02-02-starkli-scarb-katana.md:44
msgid ""
"```bash\n"
"    scarb <SCARB VERSION>\n"
"    cairo: <COMPILER VERSION>\n"
"    sierra: <SIERRA VERSION>\n"
"```"
msgstr ""
"```bash\n"
"    scarb <SCARB VERSION>\n"
"    cairo: <COMPILER VERSION>\n"
"    sierra: <SIERRA VERSION>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:50
msgid ""
"If the versions don't match, consider installing a version of Scarb compatible with Starkli. Browse [Scarb's GitHub](https://github.com/software-mansion/scarb/releases) repo for earlier releases."
msgstr "如果版本不匹配，请考虑安装与 Starkli 兼容的 Scarb 版本。请浏览 [Scarb's GitHub](https://github.com/software-mansion/scarb/releases) 仓库，查看早期版本。"

#: src/ch02-02-starkli-scarb-katana.md:52
msgid "To install a specific version, such as `2.3.0`, run:"
msgstr "要安装特定版本，如 `2.3.0`，请运行："

#: src/ch02-02-starkli-scarb-katana.md:54
msgid ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 2.3.0\n"
"```"
msgstr ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 2.3.0\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:58
msgid "## Crafting a Starknet Smart Contract"
msgstr "## 从头编写一个Starknet智能合约"

#: src/ch02-02-starkli-scarb-katana.md:60
msgid "Begin by initiating a Scarb project:"
msgstr "首先启动一个 Scarb 项目："

#: src/ch02-02-starkli-scarb-katana.md:62
msgid ""
"```bash\n"
"scarb new my_contract\n"
"```"
msgstr ""
"```bash\n"
"scarb new my_contract\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:66
msgid "## Configure Environment Variables and the `Scarb.toml` File"
msgstr "## 配置环境变量和 `Scarb.toml` 文件"

#: src/ch02-02-starkli-scarb-katana.md:68
msgid "Review the `my_contract` project. Its structure appears as:"
msgstr "查看 `my_contract` 项目。其结构如下："

#: src/ch02-02-starkli-scarb-katana.md:70
msgid ""
"```bash\n"
"    src/\n"
"      lib.cairo\n"
"    .gitignore\n"
"    Scarb.toml\n"
"```"
msgstr ""
"```bash\n"
"    src/\n"
"      lib.cairo\n"
"    .gitignore\n"
"    Scarb.toml\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:77
msgid "Amend the `Scarb.toml` file to integrate the `starknet` dependency and introduce the `starknet-contract` target:"
msgstr "修改 `Scarb.toml` 文件以整合 `starknet` 依赖关系，并引入 `starknet-contract` ："

#: src/ch02-02-starkli-scarb-katana.md:79
msgid ""
"```toml\n"
"    [dependencies]\n"
"    starknet = \">=2.3.0\"\n"
"\n"
"    [[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"    [dependencies]\n"
"    starknet = \">=2.3.0\"\n"
"\n"
"    [[target.starknet-contract]]\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:86
msgid "For streamlined Starkli command execution, establish environment variables. Two primary variables are essential:"
msgstr "为了简化 Starkli 命令的执行，需要建立环境变量。有两个主要变量必不可少："

#: src/ch02-02-starkli-scarb-katana.md:88
msgid ""
"- One for your account, a pre-funded account on the local development network\n"
"- Another for designating the network, specifically the local katana devnet"
msgstr ""
"- 一个用于您的账户，即本地开发网络上的预资助账户\n"
"- 另一个用于指定网络，特别是本地 katana 开发网络"

#: src/ch02-02-starkli-scarb-katana.md:91
msgid "In the `src/` directory, create a `.env` file with the following:"
msgstr "在 `src/` 目录中，创建包含以下内容的 `.env` 文件："

#: src/ch02-02-starkli-scarb-katana.md:93
msgid ""
"```bash\n"
"export STARKNET_ACCOUNT=katana-0\n"
"export STARKNET_RPC=http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"export STARKNET_ACCOUNT=katana-0\n"
"export STARKNET_RPC=http://0.0.0.0:5050\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:98
msgid "These settings streamline Starkli command operations."
msgstr "这些设置可简化 Starkli 命令操作。"

#: src/ch02-02-starkli-scarb-katana.md:100 src/ch02-05-testnet-deployment.md:257
msgid "## Declaring Smart Contracts in Starknet"
msgstr "## 在 Starknet 上声明智能合约"

#: src/ch02-02-starkli-scarb-katana.md:102
msgid "Deploying a Starknet smart contract requires two primary steps:"
msgstr "在 Starknet 上部署智能合约包括两个步骤："

#: src/ch02-02-starkli-scarb-katana.md:104
msgid ""
"- Declare the contract's code.\n"
"- Deploy an instance of that declared code."
msgstr ""
"- 声明您的合约代码。\n"
"- 部署已声明代码的实例。"

#: src/ch02-02-starkli-scarb-katana.md:107
msgid "Begin with the `src/lib.cairo` file, which provides a foundational template. Remove its contents and insert the following:"
msgstr "从提供基础模板的`src/lib.cairo`文件开始。删除其内容并插入以下内容："

#: src/ch02-02-starkli-scarb-katana.md:109
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod hello {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252) {\n"
"        self.name.write(name);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"    #[external(v0)]\n"
"        fn set_name(ref self: ContractState, name: felt252) {\n"
"            let previous = self.name.read();\n"
"            self.name.write(name);\n"
"        }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod hello {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252) {\n"
"        self.name.write(name);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"    #[external(v0)]\n"
"        fn set_name(ref self: ContractState, name: felt252) {\n"
"            let previous = self.name.read();\n"
"            self.name.write(name);\n"
"        }\n"
"}\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:134
msgid "This rudimentary smart contract serves as a starting point."
msgstr "这个初级智能合约只是一个起点。"

#: src/ch02-02-starkli-scarb-katana.md:136
msgid "Compile the contract with the Scarb compiler. If Scarb isn't installed, consult the [Installation](ch02-01-basic-installation.md) section."
msgstr "使用 Scarb 编译器编译合约。如果尚未安装 Scarb，请查阅 [安装](ch02-01-basic-installation.md) 部分。"

#: src/ch02-02-starkli-scarb-katana.md:138 src/ch02-07-01-01-erc20-ui.md:109 src/ch02-08-01-01-erc20-ui.md:108 src/ch04-02-hello-account.md:80
msgid ""
"```bash\n"
"scarb build\n"
"```"
msgstr ""
"```bash\n"
"scarb build\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:142
msgid "The above command results in a compiled contract under `target/dev/`, named \"`my_contract_hello.contract_class.json`\" (check Scarb's subchapter for more details)."
msgstr "上述命令会在 `target/dev/` 下生成一个编译后的合同，名为\"`my_contract_hello.contract_class.json`\"（更多详情请查看 Scarb 的子章节）。"

#: src/ch02-02-starkli-scarb-katana.md:144
msgid "Having compiled the smart contract, it's time to declare it with Starkli and katana. First, ensure your project acknowledges the environmental variables:"
msgstr "编译完智能合约后，就该用 Starkli 和 katana 声明它了。首先，确保你的项目配置好了环境变量："

#: src/ch02-02-starkli-scarb-katana.md:146
msgid ""
"```bash\n"
"source .env\n"
"```"
msgstr ""
"```bash\n"
"source .env\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:150
msgid "Next, launch Katana. In a separate terminal, run (more details in the Katan subchapter):"
msgstr "接下来，启动Katana。在一个单独的终端中运行（更多详情请参阅 Katana 子章节）："

#: src/ch02-02-starkli-scarb-katana.md:152
msgid ""
"```bash\n"
"katana\n"
"```"
msgstr ""
"```bash\n"
"katana\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:156
msgid "To declare your contract, execute:"
msgstr "要声明您的合约，请执行："

#: src/ch02-02-starkli-scarb-katana.md:158
msgid ""
"```bash\n"
"starkli declare target/dev/my_contract_hello.contract_class.json\n"
"```"
msgstr ""
"```bash\n"
"starkli declare target/dev/my_contract_hello.contract_class.json\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:162
msgid ""
"Facing an \"Error: Invalid contract class\"? It indicates a version mismatch between Scarb's compiler and Starkli. Refer to the earlier steps to sync the versions. Typically, Starkli supports "
"compiler versions approved by mainnet, even if the most recent Scarb version isn't compatible."
msgstr ""
"如果遇到 `\"Error: Invalid contract class\"`，这很可能意味着你的 Scarb 编译器版本与 Starkli 不兼容。请按照上面的步骤调整版本。Starkli 通常支持主网接受的编译器版本，即使 Scarb 的最新版本还不兼容。"

#: src/ch02-02-starkli-scarb-katana.md:164
msgid ""
"Upon successful command execution, you'll obtain a contract class hash: This\n"
"unique hash serves as the identifier for your contract class within\n"
"Starknet. For example:"
msgstr "运行该命令后，您将收到一个合约的class hash（类哈希）。这个唯一的哈希值是您的合约类在Starknet中的标识符。例如:"

#: src/ch02-02-starkli-scarb-katana.md:168
msgid ""
"```bash\n"
"Class hash declared: 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"
msgstr ""
"```bash\n"
"Class hash declared: 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:172
msgid "Consider this hash as the contract class's _address_."
msgstr "你可将此哈希值视为合约类的 _address_ 。"

#: src/ch02-02-starkli-scarb-katana.md:174
msgid "If you try to declare an already existing contract class, don't fret. Just proceed. You might see:"
msgstr "如果您尝试声明一个已经存在的合约类，请不要担心只管继续。你可能会看到："

#: src/ch02-02-starkli-scarb-katana.md:176
msgid ""
"```bash\n"
"Not declaring class as its already declared. Class hash:\n"
"0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"
msgstr ""
"```bash\n"
"Not declaring class as its already declared. Class hash:\n"
"0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:181
msgid "## Deploying Starknet Smart Contracts"
msgstr "## 部署Starknet智能合约"

#: src/ch02-02-starkli-scarb-katana.md:183
msgid "To deploy a smart contract on the katana local devnet, use the following command. It primarily requires:"
msgstr "要在 katana 本地开发网络上部署智能合约，请使用以下命令。它主要需要："

#: src/ch02-02-starkli-scarb-katana.md:185
msgid ""
"1. Your contract's class hash.\n"
"2. Constructor arguments your contract needs (in our example, a _name_ of type `felt252`)."
msgstr ""
"1.您合约的类哈希值。\n"
"2.合约所需的构造函数参数（在我们的例子中，是一个 名为  _name_  的`felt252` 类型）。"

#: src/ch02-02-starkli-scarb-katana.md:188
msgid "Here's the command structure:"
msgstr "这是命令的结构："

#: src/ch02-02-starkli-scarb-katana.md:190 src/ch02-05-testnet-deployment.md:374
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        <CLASS_HASH> \\\n"
"        <CONSTRUCTOR_INPUTS>\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        <CLASS_HASH> \\\n"
"        <CONSTRUCTOR_INPUTS>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:196
msgid "Notice the constructor inputs are in felt format. So we need to convert a short string to a felt252 format. We can use the `to-cairo-string` command for this:"
msgstr "请注意，构造函数使用的输入是 felt 格式。因此，我们需要将短字符串转换为 felt252 格式。为此，我们可以使用 `to-cairo-string` 命令："

#: src/ch02-02-starkli-scarb-katana.md:198
msgid ""
"```bash\n"
"    starkli to-cairo-string <STRING>\n"
"```"
msgstr ""
"```bash\n"
"    starkli to-cairo-string <STRING>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:202
msgid "In this case, we'll use the string \"starknetbook\" as the name:"
msgstr "在本例中，我们将使用字符串 \"starknetbook \"作为名称参数："

#: src/ch02-02-starkli-scarb-katana.md:204
msgid ""
"```bash\n"
"    starkli to-cairo-string starknetbook\n"
"```"
msgstr ""
"```bash\n"
"    starkli to-cairo-string starknetbook\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:208
msgid "The output:"
msgstr "输出结果："

#: src/ch02-02-starkli-scarb-katana.md:210
msgid ""
"```bash\n"
"    0x737461726b6e6574626f6f6b\n"
"```"
msgstr ""
"```bash\n"
"    0x737461726b6e6574626f6f6b\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:214
msgid "Now deploy using a class hash and constructor input:"
msgstr "现在使用类哈希值和构造函数参数进行部署："

#: src/ch02-02-starkli-scarb-katana.md:216
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
"        0x737461726b6e6574626f6f6b\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
"        0x737461726b6e6574626f6f6b\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:222
msgid "After running, expect an output similar to:"
msgstr "运行后，输出结果类似于："

#: src/ch02-02-starkli-scarb-katana.md:224
msgid ""
"```bash\n"
"    Deploying class 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 with salt 0x054645c0d1e766ddd927b3bde150c0a3dc0081af7fb82160c1582e05f6018794...\n"
"    The contract will be deployed at address 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"    Contract deployment transaction: 0x00413d9638fecb75eb07593b5c76d13a68e4af7962c368c5c2e810e7a310d54c\n"
"    Contract deployed: 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"```"
msgstr ""
"```bash\n"
"    Deploying class 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 with salt 0x054645c0d1e766ddd927b3bde150c0a3dc0081af7fb82160c1582e05f6018794...\n"
"    The contract will be deployed at address 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"    Contract deployment transaction: 0x00413d9638fecb75eb07593b5c76d13a68e4af7962c368c5c2e810e7a310d54c\n"
"    Contract deployed: 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:231
msgid "## Interacting with Starknet Contracts"
msgstr "## 与Starknet合约交互"

#: src/ch02-02-starkli-scarb-katana.md:233
msgid "Using Starkli, you can interact with smart contracts through two primary methods:"
msgstr "使用 Starkli，你可以通过两种主要方法与智能合约进行交互："

#: src/ch02-02-starkli-scarb-katana.md:235
msgid ""
"- `call`: For read-only functions.\n"
"- `invoke`: For functions that alter the state."
msgstr ""
"- `call`：用于只读函数。\n"
"- `invoke`：用于改变状态的函数。"

#: src/ch02-02-starkli-scarb-katana.md:238
msgid "### Reading Data with `call`"
msgstr "### 使用 `call` 读取数据"

#: src/ch02-02-starkli-scarb-katana.md:240
msgid ""
"The `call` command let's you query contract functions without transacting. For instance, if you want to determine the current contract owner using the `get_name` function, which\n"
"requires no arguments:"
msgstr "`call`命令使你可以在不发送交易的情况下查询智能合约函数。例如，要想知道谁是合约的当前所有者，可以使用`get_owner`函数，该函数不需要参数："

#: src/ch02-02-starkli-scarb-katana.md:243
msgid ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        get_name\n"
"```"
msgstr ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        get_name\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:249 src/ch02-05-testnet-deployment.md:426
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of your contract. The\n"
"command will return the owner’s address, which was initially set during\n"
"the contract’s deployment:"
msgstr "请将 `<CONTRACT_ADDRESS>` 替换为您的合约地址。该命令将返回所有者的地址，该地址最初是在部署合约时设置的："

#: src/ch02-02-starkli-scarb-katana.md:253
msgid ""
"```bash\n"
"    [\n"
"        \"0x0000000000000000000000000000000000000000737461726b6e6574626f6f6b\"\n"
"    ]\n"
"```"
msgstr ""
"```bash\n"
"    [\n"
"        \"0x0000000000000000000000000000000000000000737461726b6e6574626f6f6b\"\n"
"    ]\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:259
msgid "But what is this lengthy output? In Starknet, we use the `felt252` data type to represent strings. This can be decoded into its string representation:"
msgstr "但这个一长串输出是什么呢？在Starknet中，我们使用 `felt252` 数据类型来表示字符串。这可以解码成字符串表示法："

#: src/ch02-02-starkli-scarb-katana.md:261
msgid ""
"```bash\n"
"starkli parse-cairo-string 0x737461726b6e6574626f6f6b\n"
"```"
msgstr ""
"```bash\n"
"starkli parse-cairo-string 0x737461726b6e6574626f6f6b\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:265
msgid "The result:"
msgstr "结果是："

#: src/ch02-02-starkli-scarb-katana.md:267
msgid ""
"```bash\n"
"starknetbook\n"
"```"
msgstr ""
"```bash\n"
"starknetbook\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:271
msgid "## Modifying Contract State with `invoke`"
msgstr "## 使用`invoke`修改合约状态"

#: src/ch02-02-starkli-scarb-katana.md:273
msgid "To alter the contract's state, use the `invoke` command. For instance, if you want to update the name field in the storage, utilize the `set_name` function:"
msgstr "要改变合约的状态，请使用 `invoke` 命令。例如，如果要更新存储中的名称字段，请使用 `set_name` 函数："

#: src/ch02-02-starkli-scarb-katana.md:275
msgid ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        set_name \\\n"
"        <felt252>\n"
"```"
msgstr ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        set_name \\\n"
"        <felt252>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:282
msgid "Where:"
msgstr "在这里："

#: src/ch02-02-starkli-scarb-katana.md:284
msgid ""
"- **`<CONTRACT_ADDRESS>`** is the address of your contract.\n"
"- **`<felt252>`** is the new value for the **`name`** field, in felt252 format."
msgstr ""
"- **`<CONTRACT_ADDRESS>`** 是你的合约地址。\n"
"- **`<felt252>`** 是 **`name`** 字段的新值，格式为 felt252。"

#: src/ch02-02-starkli-scarb-katana.md:287
msgid "For example, to update the name to \"Omar\", first convert the string \"Omar\" to its felt252 representation:"
msgstr "例如，要将名称更新为 \"Omar\"，首先要将字符串 \"Omar \"转换为其 felt252 表示形式："

#: src/ch02-02-starkli-scarb-katana.md:289
msgid ""
"```bash\n"
"    starkli to-cairo-string Omar\n"
"```"
msgstr ""
"```bash\n"
"    starkli to-cairo-string Omar\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:293
msgid "This will return:"
msgstr "将返回："

#: src/ch02-02-starkli-scarb-katana.md:295
msgid ""
"```bash\n"
"    0x4f6d6172\n"
"```"
msgstr ""
"```bash\n"
"    0x4f6d6172\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:299
msgid "Now, proceed with the `invoke` command:"
msgstr "现在，执行 `invoke` 命令："

#: src/ch02-02-starkli-scarb-katana.md:301
msgid ""
"```bash\n"
"    starkli invoke 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44 set_name 0x4f6d6172\n"
"```"
msgstr ""
"```bash\n"
"    starkli invoke 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44 set_name 0x4f6d6172\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:305
msgid "Bravo! You've adeptly modified and interfaced with your Starknet contract."
msgstr "干得好！通过接口的交互，你对你的Starknet合约进行了巧妙的修改。"

#: src/ch02-03-scarb.md:1
msgid "# Scarb: The Package Manager"
msgstr "# Scarb：软件包管理器"

#: src/ch02-03-scarb.md:12
msgid ""
"Scarb is Cairo’s package manager designed for both Cairo and Starknet\n"
"projects. It handles dependencies, compiles projects, and integrates\n"
"with tools like Foundry. It is built by the same team that created\n"
"Foundry for Starknet."
msgstr "Scarb 是 Cairo 的软件包管理器，专为 Cairo 和 Starknet 项目设计。它处理依赖关系、编译项目，并与 Foundry 等工具集成。它由为 Starknet 创建 Foundry 的同一团队打造。"

#: src/ch02-03-scarb.md:17
msgid "# Scarb Workflow"
msgstr "# Scarb 工作流程"

#: src/ch02-03-scarb.md:19
msgid "Follow these steps to develop a Starknet contract using Scarb:"
msgstr "请按照以下步骤使用 Scarb 来开发Starknet合约："

#: src/ch02-03-scarb.md:21
msgid ""
"1.  **Initialize:** Use `scarb new` to set up a new project, generating\n"
"    a `Scarb.toml` file and initial `src/lib.cairo`.\n"
"\n"
"2.  **Code:** Add your Cairo code in the `src` directory.\n"
"\n"
"3.  **Dependencies:** Add external libraries using `scarb add`.\n"
"\n"
"4.  **Compile:** Execute `scarb build` to convert your contract into\n"
"    Sierra code."
msgstr ""
"1.  **初始化：** 使用 `scarb new` 建立一个新项目，生成 `Scarb.toml` 文件和初始的 `src/lib.cairo` 文件。\n"
"\n"
"2.  **代码：** 在`src`目录下添加你的Cairo代码。\n"
"\n"
"3.  **依赖：** 使用 `scarb add` 添加外部库。\n"
"\n"
"4.  **编译：** 执行 `scarb build` 将合约转换为Sierra 代码。"

#: src/ch02-03-scarb.md:31
msgid ""
"Scarb simplifies your development workflow, making it efficient and\n"
"streamlined."
msgstr "Scarb 简化了您的开发工作流程，使其高效、精简。"

#: src/ch02-03-scarb.md:36
msgid ""
"Scarb is cross-platform, supporting macOS, Linux, and Windows. For\n"
"installation, refer to the [Chapter 1 setup\n"
"guide](https://book.starknet.io/chapter_1/environment_setup.html#the_scarb_package_manager_installation)."
msgstr "Scarb 可跨平台运行，支持 macOS、Linux 和 Windows。有关安装，请参阅 [第1章的安装指南](https://book.starknet.io/chapter_1/environment_setup.html#the_scarb_package_manager_installation)。"

#: src/ch02-03-scarb.md:40
msgid "# Cairo Project Structure"
msgstr "# Cairo项目结构"

#: src/ch02-03-scarb.md:42
msgid "Next, we’ll dive into the key components that make up a Cairo project."
msgstr "接下来，我们将深入探讨Cairo项目的关键组成部分。"

#: src/ch02-03-scarb.md:44
msgid "## Cairo Packages"
msgstr "## Cairo 包"

#: src/ch02-03-scarb.md:46
msgid ""
"Cairo packages, also referred to as \"crates\" in some contexts, are the\n"
"building blocks of a Cairo project. Each package must follow several\n"
"rules:"
msgstr "Cairo 包在某些情况下也被称为 \"crate\"，是 Cairo 项目的组成部分。每个包都必须遵循几条规则："

#: src/ch02-03-scarb.md:50
msgid ""
"- A package must include a `Scarb.toml` file, which is Scarb’s\n"
"  manifest file. It contains the dependencies for your package.\n"
"\n"
"- A package must include a `src/lib.cairo` file, which is the root of\n"
"  the package tree. It allows you to define functions and declare used\n"
"  modules."
msgstr ""
"- 包必须包含一个 `Scarb.toml` 文件，它是 Scarb 的\n"
"  清单文件。它包含软件包的依赖项。\n"
"\n"
"- 包必须包含一个 `src/lib.cairo` 文件，它是包的树形结构的根文件。\n"
"  它允许你定义函数和声明使用过的模块。"

#: src/ch02-03-scarb.md:57
msgid ""
"Package structures might look like the following case where we have a\n"
"package named `my_package`, which includes a `src` directory with the\n"
"`lib.cairo` file inside, a `snips` directory which in itself a package\n"
"we can use, and a `Scarb.toml` file in the top-level directory."
msgstr "软件包结构可能如下所示：我们有一个名为 `my_package`的包，其中包括一个包含`lib.cairo` 文件的 `src` 目录、一个本身就是我们可以使用的软件包的 `snips`目录和一个位于顶层目录的`Scarb.toml`文件。"

#: src/ch02-03-scarb.md:62
msgid ""
"my_package/\n"
"    ├── src/\n"
"    │   ├── module1.cairo\n"
"    │   ├── module2.cairo\n"
"    │   └── lib.cairo\n"
"    ├── snips/\n"
"    │   ├── src/\n"
"    │   │   ├── lib.cairo\n"
"    │   ├── Scarb.toml\n"
"    └── Scarb.toml"
msgstr ""
"my_package/\n"
"    ├── src/\n"
"    │   ├── module1.cairo\n"
"    │   ├── module2.cairo\n"
"    │   └── lib.cairo\n"
"    ├── snips/\n"
"    │   ├── src/\n"
"    │   │   ├── lib.cairo\n"
"    │   ├── Scarb.toml\n"
"    └── Scarb.toml"

#: src/ch02-03-scarb.md:73
msgid "Within the `Scarb.toml` file, you might have:"
msgstr "在 `Scarb.toml` 文件中，可能有："

#: src/ch02-03-scarb.md:75
msgid ""
"[package]\n"
"    name = \"my_package\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    [dependencies]\n"
"    starknet = \">=2.0.1\"\n"
"    snips = { path = \"snips\" }"
msgstr ""
"[package]\n"
"    name = \"my_package\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    [dependencies]\n"
"    starknet = \">=2.0.1\"\n"
"    snips = { path = \"snips\" }"

#: src/ch02-03-scarb.md:83
msgid ""
"Here starknet and snips are the dependencies of the package. The\n"
"`starknet` dependency is hosted on the Scarb registry (we do not need to\n"
"download it), while the `snips` dependency is located in the `snips`\n"
"directory."
msgstr "这里的 `starknet`  和 `snips` 是软件包的依赖项。`starknet` 依赖项位于 Scarb 注册表中（我们无需下载），而 `snips`依赖项位于 `snips`目录中。"

#: src/ch02-03-scarb.md:88
msgid "# Setting Up a Project with Scarb"
msgstr "# 使用 Scarb 设置项目"

#: src/ch02-03-scarb.md:90
msgid ""
"To create a new project using Scarb, navigate to your desired project\n"
"directory and execute the following command:"
msgstr "要使用 Scarb 创建新项目，请导航到所需的项目目录并执行以下命令："

#: src/ch02-03-scarb.md:93
msgid "$ scarb new hello_scarb"
msgstr "$ scarb new hello_scarb"

#: src/ch02-03-scarb.md:95
msgid ""
"This command will create a new project directory named `hello_scarb`,\n"
"including a `Scarb.toml` file, a `src` directory with a `lib.cairo` file\n"
"inside, and initialize a new Git repository with a `.gitignore` file."
msgstr "该命令将创建一个名为 `hello_scarb` 的新项目目录，包括一个 `Scarb.toml` 文件、一个包含 `lib.cairo` 文件的 `src` 目录，并使用 `.gitignore` 文件初始化一个新的 Git 仓库。"

#: src/ch02-03-scarb.md:99
msgid ""
"hello_scarb/\n"
"    ├── src/\n"
"    │   └── lib.cairo\n"
"    └── Scarb.toml"
msgstr ""
"hello_scarb/\n"
"    ├── src/\n"
"    │   └── lib.cairo\n"
"    └── Scarb.toml"

#: src/ch02-03-scarb.md:104
msgid ""
"Upon opening `Scarb.toml` in a text editor, you should see something\n"
"similar to the code snippet below:"
msgstr "在文本编辑器中打开`Scarb.toml`后，您应该会看到与下面代码片段类似的内容："

#: src/ch02-03-scarb.md:107
msgid ""
"[package]\n"
"    name = \"hello_scarb\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"    [dependencies]\n"
"    # foo = { path = \"vendor/foo\" }"
msgstr ""
"[package]\n"
"    name = \"hello_scarb\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"    [dependencies]\n"
"    # foo = { path = \"vendor/foo\" }"

#: src/ch02-03-scarb.md:115
msgid "# Building a Scarb Project"
msgstr "# 编译Scarb项目"

#: src/ch02-03-scarb.md:117
msgid "Clear all content in `src/lib.cairo` and replace with the following:"
msgstr "删除 `src/lib.cairo` 中的所有内容，并替换为以下内容："

#: src/ch02-03-scarb.md:119
msgid ""
"// src/lib.cairo\n"
"    mod hello_scarb;"
msgstr ""
"// src/lib.cairo\n"
"    mod hello_scarb;"

#: src/ch02-03-scarb.md:122
msgid ""
"Next, create a new file titled `src/hello_scarb.cairo` and add the\n"
"following:"
msgstr "接下来，创建一个名为 `src/hello_scarb.cairo` 的新文件，并添加以下内容："

#: src/ch02-03-scarb.md:125
msgid ""
"// src/hello_scarb.cairo\n"
"    use debug::PrintTrait;\n"
"    fn main() {\n"
"        'Hello, Scarb!'.print();\n"
"    }"
msgstr ""
"// src/hello_scarb.cairo\n"
"    use debug::PrintTrait;\n"
"    fn main() {\n"
"        'Hello, Scarb!'.print();\n"
"    }"

#: src/ch02-03-scarb.md:131
msgid ""
"In this instance, the `lib.cairo` file contains a module declaration\n"
"referencing _hello_scarb_, which includes the _hello_scarb.cairo_\n"
"file’s implementation. For more on modules, imports, and the `lib.cairo`\n"
"file, please refer to the subchapter on [imports in Chapter\n"
"2](https://book.starknet.io/chapter_2/imports.html)."
msgstr ""
"在这个例子中，`lib.cairo`文件包含了引用 _hello_scarb_ 的模块声明，其中包含了 _hello_scarb.cairo_ 文件的实现。有关模块、导入和`lib.cairo`文件的更多信息，请参阅[第2章里的 导入 ](https://book.starknet."
"io/chapter_2/imports.html)。"

#: src/ch02-03-scarb.md:137
msgid ""
"Scarb mandates that your source files be located within the `src`\n"
"directory."
msgstr "Scarb 要求代码源文件应位于 `src` 目录中。"

#: src/ch02-03-scarb.md:140
msgid ""
"To build (compile) your project from your `hello_scarb` directory, use\n"
"the following command:"
msgstr "要在 `hello_scarb` 目录中构建（编译）项目，请使用以下命令："

#: src/ch02-03-scarb.md:143
msgid "scarb build"
msgstr "scarb build"

#: src/ch02-03-scarb.md:145
msgid ""
"This command compiles your project and produces the Sierra code in the\n"
"`target/dev/hello_scarb.sierra` file. Sierra serves as an intermediate\n"
"layer between high-level Cairo and compilation targets such as Cairo\n"
"Assembly (CASM). To understand more about Sierra, check out this\n"
"[article](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)."
msgstr ""
"该命令可编译项目并在 `target/dev/hello_scarb.sierra` 文件中生成 Sierra 代码。Sierra 是高级 Cairo 和编译目标（如 Cairo Assembly (CASM)）之间的中间层。要了解有关 Sierra 的更多信息，请参阅此 [文章]"
"(https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)。"

#: src/ch02-03-scarb.md:151
msgid ""
"To remove the build artifacts and delete the target directory, use the\n"
"`scarb clean` command."
msgstr "要移除编译成果并删除目标目录，请使用 `scarb clean` 命令。"

#: src/ch02-03-scarb.md:154
msgid "## Adding Dependencies"
msgstr "## 添加依赖项"

#: src/ch02-03-scarb.md:156
msgid ""
"Scarb facilitates the seamless management of dependencies for your Cairo\n"
"packages. Here are two methods to add dependencies to your project:"
msgstr "Scarb 可以帮助你无缝管理 Cairo 软件包的依赖关系。以下是为项目添加依赖包的两种方法："

#: src/ch02-03-scarb.md:159
msgid "- Edit Scarb.toml File"
msgstr "编辑 Scarb.toml 文件"

#: src/ch02-03-scarb.md:161
msgid ""
"Open the Scarb.toml file in your project directory and locate the\n"
"`[dependencies]` section. If it doesn’t exist, add it. To include a\n"
"dependency hosted on a Git repository, use the following format:"
msgstr "打开项目目录中的 Scarb.toml 文件，找到`[dependencies]`部分。如果不存在，请添加。要包含托管在 Git 仓库中的依赖项，请使用以下格式："

#: src/ch02-03-scarb.md:165
msgid ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }"
msgstr ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }"

#: src/ch02-03-scarb.md:168
msgid ""
"For consistency, it’s recommended to pin Git dependencies to specific\n"
"commits. This can be done by adding the `rev` field with the commit\n"
"hash:"
msgstr "为保持一致性，建议将 Git 依赖项固定在某个特定提交上。这可以通过添加带有提交哈希值的 `rev` 字段来实现："

#: src/ch02-03-scarb.md:172
msgid ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", rev = \"81bb93c\" }"
msgstr ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", rev = \"81bb93c\" }"

#: src/ch02-03-scarb.md:175
msgid "After adding the dependency, remember to save the file."
msgstr "添加依赖项后，记得保存文件。"

#: src/ch02-03-scarb.md:177
msgid "- Use the scarb add Command"
msgstr "- 使用 scarb add 命令"

#: src/ch02-03-scarb.md:179
msgid ""
"Alternatively, you can use the `scarb add` command to add dependencies\n"
"to your project. Open your terminal and execute the following command:"
msgstr "您也可以使用 `scarb add` 命令为项目添加依赖项。打开终端并执行以下命令："

#: src/ch02-03-scarb.md:182
msgid "$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git"
msgstr "$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git"

#: src/ch02-03-scarb.md:184
msgid ""
"This command will add the alexandria_math dependency from the specified\n"
"Git repository to your project."
msgstr "这条命令会将指定 Git 仓库中的 alexandria_math 外部依赖项添加到项目中。"

#: src/ch02-03-scarb.md:187
msgid "To remove a dependency, you can use the `scarb rm` command."
msgstr "要删除依赖项，可以使用 `scarb rm` 命令。"

#: src/ch02-03-scarb.md:189
msgid ""
"Once a dependency is added, the Scarb.toml file will be automatically\n"
"updated with the new dependency information."
msgstr "一旦添加了依赖项，Scarb.toml 文件就会自动更新，加入新的依赖项信息。"

#: src/ch02-03-scarb.md:192
msgid "## Using Dependencies in Your Code"
msgstr "## 在代码中使用依赖项"

#: src/ch02-03-scarb.md:194
msgid ""
"After dependencies are added to your project, you can start utilizing\n"
"them in your Cairo code."
msgstr "将依赖项添加到项目中后，就可以开始在 Cairo 代码中使用它们了。"

#: src/ch02-03-scarb.md:197
msgid ""
"For example, let’s assume you have added the alexandria_math\n"
"dependency. Now, you can import and utilize functions from the\n"
"alexandria_math library in your `src/hello_scarb.cairo` file:"
msgstr "例如，假设你已经添加了 alexandria_math 依赖项。现在，你可以在你的 `src/hello_scarb.cairo` 文件中导入并使用 alexandria_math 库中的函数："

#: src/ch02-03-scarb.md:201
msgid ""
"// src/hello_scarb.cairo\n"
"    use alexandria_math::fibonacci;\n"
"\n"
"    fn main() -> felt252 {\n"
"        fibonacci::fib(0, 1, 10)\n"
"    }"
msgstr ""
"// src/hello_scarb.cairo\n"
"    use alexandria_math::fibonacci;\n"
"\n"
"    fn main() -> felt252 {\n"
"        fibonacci::fib(0, 1, 10)\n"
"    }"

#: src/ch02-03-scarb.md:208
msgid ""
"In the above example, we import the fibonacci function from the\n"
"alexandria_math library and utilize it in the main function."
msgstr "在上面的示例中，我们从 alexandria_math 库中导入了 fibonacci 函数，并在主函数中使用了它。"

#: src/ch02-03-scarb.md:211
msgid "# Scarb Cheat Sheet"
msgstr "# Scarb Cheat Sheet"

#: src/ch02-03-scarb.md:213
msgid ""
"Here’s a quick cheat sheet of some of the most commonly used Scarb\n"
"commands:"
msgstr "下面是一些最常用的 Scarb 命令的cheat sheet："

#: src/ch02-03-scarb.md:216
msgid ""
"- `scarb new <project_name>`: Initialize a new project with the given\n"
"  project name.\n"
"\n"
"- `scarb build`: Compile your Cairo code into Sierra code.\n"
"\n"
"- `scarb add <dependency> --git <repository>`: Add a dependency to\n"
"  your project from a specified Git repository.\n"
"\n"
"- `scarb rm <dependency>`: Remove a dependency from your project.\n"
"\n"
"- `scarb run <script>`: Run a custom script defined in your\n"
"  `Scarb.toml` file."
msgstr ""
"- `scarb new<project_name>`：用给定的项目名称初始化一个新项目。\n"
"\n"
"- `scarb build`：将 Cairo 代码编译成 Sierra 代码。\n"
"\n"
"- `scarb add<dependency> --git<repository>`：从指定的 Git仓库添加一个依赖项。\n"
"\n"
"- `scarb rm<dependency>`：从项目中移除依赖项。\n"
"\n"
"- `scarb run<script>`：运行您在文件中定义的自定义脚本。"

#: src/ch02-03-scarb.md:229
msgid ""
"Scarb is a versatile tool, and this is just the beginning of what you\n"
"can achieve with it. As you gain more experience in the Cairo language\n"
"and the Starknet platform, you’ll discover how much more you can do with\n"
"Scarb."
msgstr "Scarb 是一个多功能工具，上面的教程只是一个开始，这这些仅仅只是它所能实现功能的一小部分。随着您在Cairo语言和Starknet平台上获得更多的经验，您会发现 Scarb 能为您做更多的事情。"

#: src/ch02-03-scarb.md:234
msgid ""
"To stay updated on Scarb and its features, be sure to check the\n"
"[official Scarb\n"
"documentation](https://docs.swmansion.com/scarb/docs.html) regularly.\n"
"Happy coding!"
msgstr "要了解 Scarb 及其功能的最新情况，请务必定期查看 [Scarb 官方文档](https://docs.swmansion.com/scarb/docs.html)。祝您代码写的愉快！"

#: src/ch02-03-scarb.md:239 src/ch02-08-starknet-react.md:395 src/ch03-00-architecture.md:264 src/ch03-02-sequencers.md:254 src/ch03-03-provers.md:233 src/ch03-04-nodes.md:439
#: src/ch04-00-account-abstraction.md:400 src/ch04-04-standard-account.md:370 src/ch04-05-01-multicaller.md:91 src/ch04-05-02-multisig.md:412
msgid "The Book is a community-driven effort created for the community."
msgstr "这本书由社区推动，为社区而生。"

#: src/ch02-03-scarb.md:241 src/ch02-08-starknet-react.md:397 src/ch03-00-architecture.md:266 src/ch03-02-sequencers.md:256 src/ch03-03-provers.md:235 src/ch03-04-nodes.md:441
#: src/ch04-00-account-abstraction.md:402 src/ch04-04-standard-account.md:372 src/ch04-05-01-multicaller.md:93 src/ch04-05-02-multisig.md:414
msgid ""
"- If you’ve learned something, or not, please take a moment to provide\n"
"  feedback through [this 3-question\n"
"  survey](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=).\n"
"\n"
"- If you discover any errors or have additional suggestions, don’t\n"
"  hesitate to open an [issue on our GitHub\n"
"  repository](https://github.com/starknet-edu/starknetbook/issues)."
msgstr ""
"- 如果您学到了什么，或者没有学到什么，请花点时间通过这个[3 个问题的调查表](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=)提供反馈意见。\n"
"\n"
"- 如果您发现任何错误或有其他建议，请在Github仓库上打开一个[issue](https://github.com/starknet-edu/starknetbook/issues)。"

#: src/ch02-04-katana.md:1
msgid "# Katana: A Local Node"
msgstr "# Katana: 本地节点"

#: src/ch02-04-katana.md:3
msgid ""
"`Katana` is designed to aid in local development.\n"
"This creation by the [Dojo\n"
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)\n"
"enables you to perform all Starknet-related activities in a local\n"
"environment, thus serving as an efficient platform for development and\n"
"testing."
msgstr ""
"`Katana` is designed to aid in local development.\n"
"This creation by the [Dojo\n"
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)\n"
"enables you to perform all Starknet-related activities in a local\n"
"environment, thus serving as an efficient platform for development and\n"
"testing."

#: src/ch02-04-katana.md:10
msgid ""
"We suggest employing either `katana` or `starknet-devnet` for testing\n"
"your contracts, with the latter discussed in another\n"
"subchapter. The `starknet-devnet` is a public testnet, maintained by the\n"
"[Shard Labs team](https://github.com/0xSpaceShard/starknet-devnet-rs). Both\n"
"these tools offer an effective environment for development and testing."
msgstr ""
"我们建议使用 `katana` 或 `starknet-devnet` \"来测试你的合约，后者将在下一章中详细讨论。`starknet-devnet`是一个公共测试网络，由[Shard Labs team](https://github.com/Shard-Labs/starknet-devnet)维护。这"
"两种工具都为开发和测试提供了有效的环境。"

#: src/ch02-04-katana.md:16
msgid ""
"For an example of how to use `katana` to deploy and interact with a\n"
"contract, see the introduction subchapter of this Chapter or a voting contract example in [The Cairo Book](https://book.cairo-lang.org/ch99-01-04-01-voting-contract.html)."
msgstr "有关如何使用 `katana` 来部署合约并与之交互的示例，请参阅本章的介绍分章或 [Cairo之书](https://book.cairo-lang.org/zh-cn/ch99-01-04-01-voting-contract.html) 中的投票合同示例。"

#: src/ch02-04-katana.md:19
msgid "## Understanding RPC in Starknet"
msgstr "## 了解Starknet中的 RPC"

#: src/ch02-04-katana.md:21
msgid ""
"Remote Procedure Call (RPC) establishes the communication between nodes\n"
"in the Starknet network. Essentially, it allows us to interact with a\n"
"node in the Starknet network. The RPC server is responsible for\n"
"receiving these calls."
msgstr "远程过程调用（RPC）建立了Starknet节点之间的通信。从本质上讲，它允许我们与 Starknet 网络中的节点进行交互。RPC 服务器负责接收这些调用。"

#: src/ch02-04-katana.md:26
msgid ""
"RPC can be obtained from various sources: . To support the\n"
"decentralization of the Network, you can use your own local Starknet\n"
"node. For ease of access, consider using a provider such as\n"
"[Infura](https://docs.infura.io/networks/starknet/how-to) or\n"
"[Alchemy](https://www.alchemy.com/starknet) to get an RPC client. . For\n"
"development and testing, a temporary local node such as `katana` can be\n"
"used."
msgstr ""
"RPC 可从各种来源获取：为了支持网络的分散化，您可以使用自己的本地Starknet节点。为了便于访问，您可考虑使用 [Infura](https://docs.infura.io/networks/starknet/how-to) 或 [Alchemy](https://www.alchemy."
"com/starknet) 等提供商来获取 RPC 客户端。为便于开发和测试，可使用临时本地节点（如 `katana`）。"

#: src/ch02-04-katana.md:34
msgid "## Getting Started with Katana"
msgstr "## 开始使用Katana"

#: src/ch02-04-katana.md:51
msgid "To initialize a local Starknet node, execute the following command:"
msgstr "要初始化本地 Starknet 节点，请执行以下命令："

#: src/ch02-04-katana.md:53
msgid ""
"```bash\n"
"katana --accounts 3 --seed 0 --gas-price 250\n"
"```"
msgstr ""
"```bash\n"
"katana --accounts 3 --seed 0 --gas-price 250\n"
"```"

#: src/ch02-04-katana.md:57
msgid ""
"The `--accounts` flag determines the number of accounts to be created,\n"
"while the `--seed` flag sets the seed for the private keys of these\n"
"accounts. This ensures that initializing the node with the same seed\n"
"will always yield the same accounts. Lastly, the `--gas-price` flag\n"
"specifies the transaction gas price."
msgstr "`--accounts` 标志决定要创建的账户数量，而 `--seed` 标志则为这些账户的私钥设置种子。这样可以确保用相同的种子初始化节点时，总是会产生相同的账户。最后，\"--gas-price \"标志指定了交易gas的价格。"

#: src/ch02-04-katana.md:63
msgid "Running the command produces output similar to this:"
msgstr "运行该命令会产生类似下面的输出结果："

#: src/ch02-04-katana.md:65
msgid ""
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"    ██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"    █████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"    ██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"    ██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"    ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"    PREFUNDED ACCOUNTS\n"
"    ==================\n"
"\n"
"    | Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"    | Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"    | Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"    | Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"    | Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"    | Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"    | Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"    | Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"    | Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"    ACCOUNTS SEED\n"
"    =============\n"
"    0\n"
"\n"
"\n"
"    🚀 JSON-RPC server started: http://0.0.0.0:5050"
msgstr ""
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"    ██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"    █████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"    ██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"    ██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"    ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"    PREFUNDED ACCOUNTS\n"
"    ==================\n"
"\n"
"    | Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"    | Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"    | Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"    | Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"    | Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"    | Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"    | Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"    | Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"    | Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"    ACCOUNTS SEED\n"
"    =============\n"
"    0\n"
"\n"
"\n"
"    🚀 JSON-RPC server started: http://0.0.0.0:5050"

#: src/ch02-04-katana.md:96
msgid ""
"The output includes the addresses, private keys, and public keys of the\n"
"created accounts. It also contains the seed used to generate the\n"
"accounts. This seed can be reused to create identical accounts in future\n"
"runs. Additionally, the output provides the URL of the JSON-RPC server.\n"
"This URL can be used to establish a connection to the local Starknet\n"
"node."
msgstr ""
"输出结果包括已创建账户的地址、私钥和公钥。它还包含用于生成账户的种子。该种子可重复使用，以便在以后的运行中创建相同的账户。此外，输出还提供了 JSON-RPC 服务器的 URL。该 URL 可用于建立与本地 Starknet "
"节点的连接。"

#: src/ch02-04-katana.md:103
msgid "To stop the local Starknet node, simply press `Ctrl+C`."
msgstr "要停止本地 Starknet 节点，只需按`Ctrl+C`键。"

#: src/ch02-04-katana.md:105
msgid ""
"The local Starknet node does not persist data. Hence, once it’s stopped,\n"
"all data will be erased."
msgstr "本地 Starknet 节点不会永久保存数据。因此，一旦停止运行，所有数据都将被清除。"

#: src/ch02-04-katana.md:108
msgid ""
"For a practical demonstration of `katana` to deploy and interact with a\n"
"contract, see [Chapter 2’s Voting contract\n"
"example](https://book.starknet.io/chapter_2/deploy_call_invoke.html)."
msgstr "有关 `katana` 部署合约并与之交互的实际演示，请参阅 [第 2 章 投票合约示例](https://book.starknet.io/chapter_2/deploy_call_invoke.html)。"

#: src/ch02-05-testnet-deployment.md:1
msgid "# Testnet Deployment"
msgstr "# 测试网部署"

#: src/ch02-05-testnet-deployment.md:3
msgid ""
"This chapter guides developers through the process of compiling, deploying, and interacting with a Starknet smart contract written in Cairo on the testnet. Earlier, the focus was on deploying "
"contracts using a local node, Katana. This time, the deployment and interaction target the Starknet testnet."
msgstr "本章将指导开发者在 testnet 上编译、部署用Cairo编写的Starknet智能合约，并与之交互。前面的重点是使用本地节点 Katana 部署合约。这一次，部署和交互的目标是 Starknet 测试网。"

#: src/ch02-05-testnet-deployment.md:5
msgid "Ensure the following commands run successfully on your system. If not, see the 'Basic Installation' section:"
msgstr "确保以下命令在系统上成功运行。如果没有，请参阅 '基本安装' 部分："

#: src/ch02-05-testnet-deployment.md:7
msgid ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"```"
msgstr ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"```"

#: src/ch02-05-testnet-deployment.md:12
msgid "## Smart Wallet Setup"
msgstr "## 智能钱包设置"

#: src/ch02-05-testnet-deployment.md:14
msgid ""
"A smart wallet comprises a Signer and an Account Descriptor. The Signer\n"
"is a smart contract with a private key for signing transactions, while\n"
"the Account Descriptor is a JSON file detailing the wallet’s address and\n"
"public key."
msgstr "智能钱包由签名者和账户描述符组成。签名者是一个智能合约，带有用于签署交易的私钥，而账户描述符是一个 JSON 文件，详细说明了钱包的地址和公钥。"

#: src/ch02-05-testnet-deployment.md:19
msgid ""
"In order for an account to be used as a signer it must be deployed to the appropriate network,\n"
"Starknet Goerli or mainnet, and funded. For this example we are going to use Goerli Testnet. To deploy your wallet, visit [Getting Started](ch01-00-getting-started.md) and find the `Smart Wallet "
"Setup` section."
msgstr ""
"要将一个账户用作签名者，该账户必须部署到相应的网络、\n"
"星网 Goerli 或主网，并为其提供资金。在本例中，我们将使用 Goerli Testnet。要部署你的钱包，请访问[入门](ch01-00-getting-started.md)并找到 \"智能钱包设置 \"部分。"

#: src/ch02-05-testnet-deployment.md:22
msgid "Now you’re ready to interact with Starknet smart contracts."
msgstr "现在，您已经准备好与Starknet智能合约交互了。"

#: src/ch02-05-testnet-deployment.md:24
msgid "### Creating a Signer"
msgstr "### 创建签名者"

#: src/ch02-05-testnet-deployment.md:26
msgid ""
"The Signer is an essential smart contract capable of signing\n"
"transactions in Starknet. You’ll need the private key from your smart\n"
"wallet to create one, from which the public key can be derived."
msgstr "签名者是一种重要的智能合约，能够在Starknet中签署交易。你需要从你的智能钱包中获取私钥来创建签名者，并从中获取公钥。"

#: src/ch02-05-testnet-deployment.md:30
msgid ""
"Starkli enables secure storage of your private key through a keystore\n"
"file. This encrypted file can be accessed using a password and is\n"
"generally stored in the default Starkli directory."
msgstr "Starkli 可以通过密钥存储文件安全存储你的私人密钥。该加密文件可以通过密码访问，通常存储在默认的 Starkli 目录中。"

#: src/ch02-05-testnet-deployment.md:34
msgid "First, create the default directory:"
msgstr "首先，创建默认目录："

#: src/ch02-05-testnet-deployment.md:36
msgid ""
"```bash\n"
"    mkdir -p ~/.starkli-wallets/deployer\n"
"```"
msgstr ""
"```bash\n"
"    mkdir -p ~/.starkli-wallets/deployer\n"
"```"

#: src/ch02-05-testnet-deployment.md:40
msgid ""
"Then generate the keystore file. The signer command contains subcommands\n"
"for creating a keystore file from a private key or completely create a\n"
"new one. In this tutorial, we’ll use the private key option which is the\n"
"most common use case. You need to provide the path to the keystore file\n"
"you want to create. You can give any name to the keystore file, you will\n"
"likely have several wallets. In this tutorial, we will use the name\n"
"`my_keystore_ 1.json`."
msgstr ""
"然后生成密钥存储文件。签名者命令包含从私钥创建密钥存储文件或完全创建一个新文件的子命令。在本教程中，我们将使用最常用的私钥选项。你需要提供要创建的密钥存储文件的路径。你可以给密钥存储文件起任何名字，"
"因为你可能会有多个钱包。在本教程中，我们将使用 `my_keystore_ 1.json`。"

#: src/ch02-05-testnet-deployment.md:48
msgid ""
"```bash\n"
"    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"    Enter private key:\n"
"    Enter password:\n"
"```"
msgstr ""
"```bash\n"
"    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"    Enter private key:\n"
"    Enter password:\n"
"```"

#: src/ch02-05-testnet-deployment.md:54
msgid ""
"In the private key prompt, paste the private key of your smart wallet.\n"
"In the password prompt, enter a password of your choice. You will need\n"
"this password to sign transactions using Starkli."
msgstr "在私钥提示符下，粘贴智能钱包的私钥。在密码提示中，输入你选择的密码。使用 Starkli 签署交易时需要这个密码。"

#: src/ch02-05-testnet-deployment.md:58
msgid ""
"Export the private key from your Braavos or Argent wallet. For Argent X,\n"
"you can find it in the \"Settings\" section → Select your Account →\n"
"\"Export Private Key\". For Braavos, you can find it in the \"Settings\"\n"
"section → \"Privacy and Security\" → \"Export Private Key\"."
msgstr "从您的Braavos或 Argent 钱包中导出私钥。对于 Argent X，可以在 \"设置\"→\"选择账户\"→\"导出私钥 \"中找到。对于Braavos，您可以在 \"设置\"→\"隐私和安全\"→\"导出私人密钥 \"中找到它。"

#: src/ch02-05-testnet-deployment.md:63
msgid ""
"While knowing the private key of a smart wallet is necessary to sign\n"
"transactions, it’s not sufficient. We also need to inform Starkli about\n"
"the signing mechanism employed by our smart wallet created by Braavos or\n"
"Argent X. Does it use an elliptic curve? If yes, which one? This is the\n"
"reason why we need an account descriptor file."
msgstr "虽然签署交易的必要条件是需要知晓智能钱包的私钥，但这还不够。我们还需要告知Starkli，由 Braavos 或 Argent X 创建的智能钱包所采用的签名机制。如果是，是哪一种？这就是我们需要账户描述文件的原因。"

#: src/ch02-05-testnet-deployment.md:69
msgid "#### [OPTIONAL] The Architecture of the Starknet Signer"
msgstr "#### [OPTIONAL] Starknet签名者的架构"

#: src/ch02-05-testnet-deployment.md:71
msgid "This section is optional and is intended for those who want to learn more about the Starknet Signer. If you are not interested in the details, you can skip it."
msgstr "本节为可选内容，供希望进一步了解Starknet签名者的用户使用。如果对细节不感兴趣，可以跳过。"

#: src/ch02-05-testnet-deployment.md:73
msgid ""
"The Starknet Signer plays an instrumental role in securing your\n"
"transactions. Let’s demystify what goes on under the hood."
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch02-05-testnet-deployment.md:76
msgid "Key Components:"
msgstr "主要组成部分："

#: src/ch02-05-testnet-deployment.md:78
msgid ""
"1.  **Private Key**: A 256-bit/32-byte/64-character (ignoring the _0x_\n"
"    prefix) hexadecimal key that is the cornerstone of your wallet’s\n"
"    security.\n"
"\n"
"2.  **Public Key**: Derived from the private key, it’s also a\n"
"    256-bit/32-byte/64-character hexadecimal key.\n"
"\n"
"3.  **Smart Wallet Address**: Unlike Ethereum, the address here is\n"
"    influenced by the public key, class hash, and a salt. **[Learn more\n"
"    in Starknet\n"
"    Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/)**."
msgstr ""
"1.  **私钥**：256 位/32 字节/64 个字符（忽略 _0x_\n"
"    前缀）的十六进制密钥，它是钱包安全的基石。\n"
"\n"
"2.  **公钥**：源自私钥，也是一个\n"
"    256 位/32 字节/64 个字符的十六进制密钥。\n"
"\n"
"3.  **智能钱包地址**：与以太坊不同，这里的地址\n"
"    受公钥、class hash和salt的影响。\n"
"    ** 在[Starknet 文档](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/) 了解更多**。"

#: src/ch02-05-testnet-deployment.md:90
msgid "To view the details of the previously created keystore file:"
msgstr "查看先前创建的密钥存储文件的详细信息："

#: src/ch02-05-testnet-deployment.md:92
msgid ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:96
msgid "Anatomy of the `keystore.json` File:"
msgstr "`keystore.json` 文件的剖析："

#: src/ch02-05-testnet-deployment.md:98
msgid ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": \"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": \"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": \"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": \"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": \"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": \"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"

#: src/ch02-05-testnet-deployment.md:121
msgid ""
"- **`version`**: The version of the smart wallet implementation.\n"
"\n"
"- **`id`**: A randomly generated identification string.\n"
"\n"
"- **`crypto`**: Houses all encryption details."
msgstr ""
"- **`version`**: 智能钱包的实现版本。\n"
"\n"
"- **`id`**：随机生成的标识字符串。\n"
"\n"
"- **`crypto`**：包含所有加密细节。"

#: src/ch02-05-testnet-deployment.md:127
msgid "Inside **`crypto`**:"
msgstr "在 **`crypto`** 内部:"

#: src/ch02-05-testnet-deployment.md:129
msgid ""
"- **`cipher`**: Specifies the encryption algorithm used, which in this\n"
"  case is AES-128-CTR.\n"
"\n"
"  - **AES (Advanced Encryption Standard)**: A globally accepted\n"
"    encryption standard.\n"
"\n"
"  - **128**: Refers to the key size in bits, making it a 128-bit\n"
"    key.\n"
"\n"
"  - **CTR (Counter Mode)**: A specific mode of operation for the AES\n"
"    cipher.\n"
"\n"
"- **`cipherparams`**: Contains an Initialization Vector (IV), which\n"
"  ensures that encrypting the same plaintext with the same key will\n"
"  produce different ciphertexts.\n"
"\n"
"  - **`iv` (Initialization Vector)**: A 16-byte hex string that\n"
"    serves as a random and unique starting point for each encryption\n"
"    operation.\n"
"\n"
"- **`ciphertext`**: This is the private key after encryption, securely\n"
"  stored so that only the correct password can reveal it.\n"
"\n"
"- **`kdf` and `kdfparams`**: KDF stands for Key Derivation Function.\n"
"  This adds a layer of security by requiring computational work,\n"
"  making brute-force attacks harder.\n"
"\n"
"  - **`dklen`**: The length (in bytes) of the derived key. Typically\n"
"    32 bytes.\n"
"\n"
"  - **`n`**: A cost factor representing CPU/memory usage. A higher\n"
"    value means more computational work is needed, thus increasing\n"
"    security.\n"
"\n"
"  - **`p`**: Parallelization factor, affecting the computational\n"
"    complexity.\n"
"\n"
"  - **`r`**: Block size for the hash function, again affecting\n"
"    computational requirements.\n"
"\n"
"  - **`salt`**: A random value that is combined with the password to\n"
"    deter dictionary attacks.\n"
"\n"
"- **`mac` (Message Authentication Code)**: This is a cryptographic\n"
"  code that ensures the integrity of the message (the encrypted\n"
"  private key in this case). It is generated using a hash of both the\n"
"  ciphertext and a portion of the derived key."
msgstr ""
"- **`cipher`**：指定所使用的加密算法，本例中为 AES-128-CTR。\n"
"\n"
"  - **AES（高级加密标准）**：全球公认的加密标准。\n"
"\n"
"  - **128**：指密钥大小（比特），即 128 位密钥。\n"
"\n"
"  - **CTR（计数器模式）**：AES密码的一种特定操作模式。\n"
"\n"
"- **`cipherparams`**：包含初始化向量（IV），它可确保用相同的密钥加密相同的明文会产生不同的密文。\n"
"\n"
"  - **`iv`（初始化向量）**：一个 16 字节十六进制字符串，\n"
"    作为每个加密操作的随机和唯一起点。\n"
"\n"
"- **`ciphertext`**：这是加密后的私人密钥，被安全地\n"
"  存储，因此只有正确的密码才能显示它。\n"
"\n"
"- **`kdf` 和`kdfparams`**：KDF 代表密钥衍生函数。\n"
"  解开它需要大量的计算工作，从而增加了一层安全性、\n"
"  使暴力破解更加困难。\n"
"\n"
"  - **dklen`**：派生密钥的长度（以字节为单位）。通常为32 字节。\n"
"\n"
"  - **`n`**:代表 CPU/内存使用量的成本系数。值越高\n"
"    意味着需要更多的计算工作，从而增加了安全性。\n"
"\n"
"  - **`p`**:并行化系数，影响计算复杂度。\n"
"\n"
"  - **`r`**:散列函数的块大小，同样影响计算要求。\n"
"\n"
"  - **`salt`**：随机值：与密码相结合的随机值，用于防护字典攻击。\n"
"\n"
"- **`mac`（信息验证码）**：这是一个加密\n"
"代码，可确保信息（本例中为加密私钥）的完整性。\n"
"  它是使用密文和部分衍生密钥的哈希值生成的。"

#: src/ch02-05-testnet-deployment.md:177
msgid "### Creating an Account Descriptor"
msgstr "### 创建账户描述符"

#: src/ch02-05-testnet-deployment.md:179
msgid ""
"An Account Descriptor informs Starkli about your smart wallet’s unique\n"
"features, such as its signing mechanism. You can generate this\n"
"descriptor using Starkli’s `fetch` subcommand under the `account`\n"
"command. The `fetch` subcommand takes your on-chain wallet address as\n"
"input and generates the account descriptor file. The account descriptor\n"
"file is a JSON file that contains the details of your smart wallet."
msgstr ""
"账户描述符（Account Descriptor）会告知 Starkli 你的智能钱包的独特功能，比如它的签名机制。你可以使用 Starkli `account` 命令下的 `fetch` 子命令来生成这个描述符。`fetch`子命令将你的链上钱包地址作为输"
"入，并生成账户描述文件。账户描述文件是一个 JSON 文件，包含了你的智能钱包的详细信息。"

#: src/ch02-05-testnet-deployment.md:186
msgid ""
"```bash\n"
"    starkli account fetch <SMART_WALLET_ADDRESS> --output ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"
msgstr ""
"```bash\n"
"    starkli account fetch <SMART_WALLET_ADDRESS> --output ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:190
msgid ""
"After running the command, you’ll see a message like the one below.\n"
"We’re using a Braavos wallet as an example, but the steps are the same\n"
"for an Argent wallet."
msgstr "运行该命令后，你会看到如下信息。我们这里以Braavos钱包为例，但Argent钱包上步骤是一样的。"

#: src/ch02-05-testnet-deployment.md:194
msgid ""
"```bash\n"
"    Account contract type identified as: Braavos\n"
"    Description: Braavos official proxy account\n"
"    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"
msgstr ""
"```bash\n"
"    Account contract type identified as: Braavos\n"
"    Description: Braavos official proxy account\n"
"    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:200
msgid "In case you face an error like this:"
msgstr "如果您遇到这样的错误："

#: src/ch02-05-testnet-deployment.md:202
msgid ""
"```bash\n"
"    Error: code=ContractNotFound, message=\"Contract with address {SMART_WALLET_ADDRESS} is not deployed.\"\n"
"```"
msgstr ""
"```bash\n"
"    Error: code=ContractNotFound, message=\"Contract with address {SMART_WALLET_ADDRESS} is not deployed.\"\n"
"```"

#: src/ch02-05-testnet-deployment.md:206
msgid ""
"It means you probably just created a new wallet and it has not been deployed yet. To accomplish this you have to fund your wallet with tokens and transfer tokens to a different wallet address. "
"After this process, search your wallet address on the Starknet explorer. To see the details, go back to [Getting Started](ch01-00-getting-started.md) and find the `Smart Wallet Setup` section."
msgstr ""
"这意味着您可能刚刚创建了一个新钱包，但尚未部署。为此，您必须为钱包注入代币资金，并将代币转移到不同的钱包地址。完成此过程后，在星网浏览器中搜索你的钱包地址。要查看详情，请返回[入门](ch01-00-getting-"
"started.md)并找到 \"智能钱包设置 \"部分。"

#: src/ch02-05-testnet-deployment.md:208
msgid "After the acount descriptor file is generated, you can see the its detalis, run:"
msgstr "账户描述符文件生成后，您可以查看其详细信息，然后运行："

#: src/ch02-05-testnet-deployment.md:210
msgid ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:214
msgid "Here’s what a typical descriptor might look like:"
msgstr "下面是一个典型的描述符："

#: src/ch02-05-testnet-deployment.md:216
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": \"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": \"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": \"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": \"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"

#: src/ch02-05-testnet-deployment.md:241
msgid "Note: The structure will differ if you use an Argent wallet."
msgstr "注意：如果使用 Argent 钱包，结构会有所不同。"

#: src/ch02-05-testnet-deployment.md:243
msgid "## Setting up Environment Variables"
msgstr "## 设置环境变量"

#: src/ch02-05-testnet-deployment.md:245
msgid ""
"To simplify Starkli commands, you can set environment variables. Two key\n"
"variables are crucial: one for the Signer’s keystore file location and\n"
"another for the Account Descriptor file."
msgstr "为了简化 Starkli 命令，可以设置环境变量。有两个关键变量至关重要：一个是签名者的密钥存储文件位置，另一个是账户描述符文件。"

#: src/ch02-05-testnet-deployment.md:249
msgid ""
"```bash\n"
"    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"
msgstr ""
"```bash\n"
"    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:254
msgid ""
"Setting these variables makes running Starkli commands easier and more\n"
"efficient."
msgstr "设置这些变量可以让运行 Starkli 命令变得更简单、更高效。"

#: src/ch02-05-testnet-deployment.md:259
msgid "Deploying a smart contract on Starknet involves two steps:"
msgstr "在 Starknet 上部署智能合约包括两个步骤："

#: src/ch02-05-testnet-deployment.md:261
msgid ""
"- Declare your contract’s code.\n"
"\n"
"- Deploy an instance of the declared code."
msgstr ""
"- 声明您的合约代码。\n"
"\n"
"- 部署已声明代码的实例。"

#: src/ch02-05-testnet-deployment.md:265
msgid ""
"To get started, navigate to the `contracts/` directory in the [first\n"
"chapter](https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/contracts)\n"
"of the Starknet Book repo. The `src/lib.cairo` file contains a basic\n"
"contract to practice with."
msgstr ""
"要开始学习，请导航到Starknet之书 github仓库的 [第一章](https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/contracts) 中的 `contracts/` 目录。`src/lib."
"cairo` 文件包含一个基本合约，可供练习。"

#: src/ch02-05-testnet-deployment.md:270
msgid ""
"First, compile the contract using the Scarb compiler. If you haven’t\n"
"installed Scarb, follow the installation guide in the [Setting up your\n"
"Environment](https://book.starknet.io/chapter_1/environment_setup.html)\n"
"section."
msgstr "首先，使用 Scarb 编译器编译合约。如果尚未安装 Scarb，请按照 [设置环境](https://book.starknet.io/chapter_1/environment_setup.html) 部分的安装指南进行安装。"

#: src/ch02-05-testnet-deployment.md:275
msgid ""
"```bash\n"
"    scarb build\n"
"```"
msgstr ""
"```bash\n"
"    scarb build\n"
"```"

#: src/ch02-05-testnet-deployment.md:279
msgid ""
"This creates a compiled contract in `target/dev/` as\n"
"\"contracts_Ownable.sierra.json\" (in Chapter 2 of the book we will learn\n"
"more details about Scarb)."
msgstr "这将在 `target/dev/` 中创建一个编译好的合约，名为 \"contracts_Ownable.sierra.json\"（在本书第 2 章中，我们将了解有关 Scarb 的更多细节）。"

#: src/ch02-05-testnet-deployment.md:283
msgid ""
"With the smart contract compiled, we’re ready to declare it using\n"
"Starkli. Before declaring your contract, decide on an RPC provider."
msgstr "编译好智能合约后，我们就可以使用 Starkli 声明它了。在声明合约之前，我们需要决定使用哪个 RPC 提供商。"

#: src/ch02-05-testnet-deployment.md:286
msgid "### Choosing an RPC Provider"
msgstr "### 选择 RPC 提供商"

#: src/ch02-05-testnet-deployment.md:288
msgid "There are three main options for RPC providers, sorted by ease of use:"
msgstr "你主要有三种RPC 提供商可供选择，按易用性排序："

#: src/ch02-05-testnet-deployment.md:290
msgid ""
"1.  **Starknet Sequencer’s Gateway**: The quickest option and it’s the\n"
"    default for Starkli for now. The sequencer gateway is deprecated and\n"
"    will be disabled by StarkWare soon. You’re strongly recommended to\n"
"    use a third-party JSON-RPC API provider like Infura, Alchemy, or\n"
"    Chainstack.\n"
"\n"
"2.  **Infura or Alchemy**: A step up in complexity. You’ll need to set\n"
"    up an API key and choose an endpoint. For Infura, it would look like\n"
"    `https://starknet-goerli.infura.io/v3/<API_KEY>`. Learn more in the\n"
"    [Infura\n"
"    documentation](https://docs.infura.io/networks/starknet/how-to/choose-a-network).\n"
"\n"
"3.  **Your Own Node**: For those who want full control. It’s the most\n"
"    complex but offers the most freedom. Check out [Chapter 4 of the\n"
"    Starknet Book](https://book.starknet.io/chapter_4/node.html) or\n"
"    [Kasar](https://www.kasar.io/) for setup guides."
msgstr ""
"1.  **Starknet排序器网关**：最快捷的选择，Starkli 目前的默认设置。但排序器网关已被弃用，很快 StarkWare 将关闭它。\n"
"    强烈建议使用第三方 JSON-RPC API 提供商，如 Infura、Alchemy 或Chainstack 等。\n"
"\n"
"2.  **Infura或Alchemy**：复杂度更高。您需要设置API 密钥并选择一个端点。对于 Infura，它看起来应该是\n"
"    `https://starknet-goerli.infura.io/v3/<API_KEY>`。请参阅[Infura 文档](https://docs.infura.io/networks/starknet/how-to/choose-a-network)中了解更多信息。\n"
"\n"
"3.  **您自己的节点**：适合想要完全控制的用户。这是最复杂，但自由度最高的选项。\n"
"     查看[Starknet之书第 4 章](https://book.starknet.io/chapter_4/node.html) 或[Kasar](https://www.kasar.io/) 获取设置指南。"

#: src/ch02-05-testnet-deployment.md:307
msgid ""
"In this tutorial, we will use Alchemy. We can set the STARKNET_RPC\n"
"environment variable to make command invocations easier:"
msgstr "在本教程中，我们将使用 Alchemy。我们可以设置 `STARKNET_RPC` 环境变量，使命令调用更容易："

#: src/ch02-05-testnet-deployment.md:310
msgid ""
"```bash\n"
"    export STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/<API_KEY>\"\n"
"```"
msgstr ""
"```bash\n"
"    export STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/<API_KEY>\"\n"
"```"

#: src/ch02-05-testnet-deployment.md:314
msgid "### Declaring Your Contract"
msgstr "### 声明您的合约"

#: src/ch02-05-testnet-deployment.md:316
msgid ""
"Run this command to declare your contract using the default Starknet\n"
"Sequencer’s Gateway:"
msgstr "运行此命令可使用默认的 Starknet 排序器网关声明您的合约："

#: src/ch02-05-testnet-deployment.md:319
msgid ""
"```bash\n"
"    starkli declare target/dev/contracts_Ownable.sierra.json\n"
"```"
msgstr ""
"```bash\n"
"    starkli declare target/dev/contracts_Ownable.sierra.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:323
msgid ""
"According to the `STARKNET_RPC` url, starkli can recognize the target\n"
"blockchain network, in this case \"goerli\", so it is not necessary\n"
"explicitly specify it."
msgstr "根据 `STARKNET_RPC` url，starkli 可以识别目标区块链网络，本例中为 \"goerli\"，因此无需显式指定。"

#: src/ch02-05-testnet-deployment.md:327
msgid ""
"Unless you’re working with custom networks where it’s infeasible for\n"
"Starkli to detect the right compiler version, you shouldn’t need to\n"
"manually choose a version with `--network` and `--compiler-version`."
msgstr "除非你使用的是自定义网络，Starkli 无法检测到正确的编译器版本，否则你应该不需要使用 `--network` 和 `--compiler-version` 来手动选择版本。"

#: src/ch02-05-testnet-deployment.md:331
msgid ""
"If you encounter an \"Error: Invalid contract class,\" it likely means\n"
"your Scarb’s compiler version is incompatible with Starkli. Follow the\n"
"steps above to align the versions. Starkli usually supports compiler\n"
"versions accepted by mainnet, even if Scarb’s latest version is not yet\n"
"compatible."
msgstr ""
"如果遇到 `\"Error: Invalid contract class,\"`，这很可能意味着你的 Scarb 编译器版本与 Starkli 不兼容。请按照上面的步骤调整版本。Starkli 通常支持主网接受的编译器版本，即使 Scarb 的最新版本还不兼容。"

#: src/ch02-05-testnet-deployment.md:337
msgid ""
"After running the command, you’ll receive a contract class hash. This\n"
"unique hash serves as the identifier for your contract class within\n"
"Starknet. For example:"
msgstr "运行该命令后，您将收到一个合约的class hash（类哈希）。这个唯一的哈希值是您的合约类在Starknet中的标识符。例如:"

#: src/ch02-05-testnet-deployment.md:341
msgid ""
"```bash\n"
"    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"
msgstr ""
"```bash\n"
"    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"

#: src/ch02-05-testnet-deployment.md:345
msgid ""
"You can think of this hash as the contract class’s _address._ Use a\n"
"block explorer like\n"
"[StarkScan](https://testnet.starkscan.co/class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8)\n"
"to verify this hash on the blockchain."
msgstr ""
"您可以将此散列值视为合约类的 _address_  使用如 [StarkScan](https://testnet.starkscan.co/class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) 之类的区块浏览器在区块链上验证此"
"hash。"

#: src/ch02-05-testnet-deployment.md:350
msgid ""
"If the contract class you’re attempting to declare already exists, it is\n"
"ok we can continue. You’ll receive a message like:"
msgstr "如果您试图声明的合约类已经存在，我们可以继续。您将收到如下信息："

#: src/ch02-05-testnet-deployment.md:353
msgid ""
"```bash\n"
"    Not declaring class as its already declared. Class hash:\n"
"    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"
msgstr ""
"```bash\n"
"    Not declaring class as its already declared. Class hash:\n"
"    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"

#: src/ch02-05-testnet-deployment.md:358
msgid "## Deploying Smart Contracts on Starknet"
msgstr "## 在Starknet部署智能合约"

#: src/ch02-05-testnet-deployment.md:360
msgid ""
"To deploy a smart contract, you’ll need to instantiate it on Starknet’s\n"
"testnet. This process involves executing a command that requires two\n"
"main components:"
msgstr "要部署智能合约，您需要在 Starknet 的测试网上将其实例化。这个过程需要执行一个命令，该命令需要两个主要组件："

#: src/ch02-05-testnet-deployment.md:364
msgid ""
"1.  The class hash of your smart contract.\n"
"\n"
"2.  Any constructor arguments that the contract expects."
msgstr ""
"1.  智能合约的Class Hash(类哈希值)。\n"
"\n"
"2.  合约所需的所有构造函数参数。"

#: src/ch02-05-testnet-deployment.md:368
msgid ""
"In our example, the constructor expects an _owner_ address. You can\n"
"learn more about constructors in \\[Chapter 12 of The Cairo\n"
"Book\\](<https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-constructors>)."
msgstr ""
"在我们的例子中，构造函数期望得到一个 _owner_ 地址。关于构造函数的更多信息，请参阅 [Cairo之书 第12章](<https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-"
"constructors>)。"

#: src/ch02-05-testnet-deployment.md:372
msgid "The command would look like this:"
msgstr "命令如下："

#: src/ch02-05-testnet-deployment.md:380
msgid ""
"Here’s a specific example with an actual class hash and constructor\n"
"inputs (as the owner address use the address of your smart wallet so you\n"
"can invoke the transfer_ownership function later):"
msgstr "下面是一个具体示例，其中包含一个实际类的哈希值和构造函数输入（作为所有者地址，请使用智能钱包的地址，以便稍后调用 `transfer_ownership` 函数）："

#: src/ch02-05-testnet-deployment.md:384
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \\\n"
"        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \\\n"
"        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510\n"
"```"

#: src/ch02-05-testnet-deployment.md:390
msgid ""
"After executing the command and entering your password, you should see\n"
"output like the following:"
msgstr "执行命令并输入密码后，您应该会看到如下输出："

#: src/ch02-05-testnet-deployment.md:393
msgid ""
"```bash\n"
"    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...\n"
"    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14\n"
"    Contract deployed:\n"
"    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"```"
msgstr ""
"```bash\n"
"    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...\n"
"    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14\n"
"    Contract deployed:\n"
"    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"```"

#: src/ch02-05-testnet-deployment.md:401
msgid ""
"The contract is now live on the Starknet testnet. You can verify its\n"
"status using a block explorer like\n"
"[StarkScan](https://testnet.starkscan.co/contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012).\n"
"On the \"Read/Write Contract\" tab, you’ll see the contract’s external\n"
"functions."
msgstr ""
"合约现已存在于Starknet测试网上。你可以使用像 [StarkScan](https://testnet.starkscan.co/contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012) 这样的区块浏览器来验证它的状态。在 "
"\"Read/Write Contract\" 选项卡上，你可以看到合约的外部功能。"

#: src/ch02-05-testnet-deployment.md:407
msgid "## Interacting with the Starknet Contract"
msgstr "## 与Starknet合约交互"

#: src/ch02-05-testnet-deployment.md:409
msgid ""
"Starkli enables interaction with smart contracts via two primary\n"
"methods: `call` for read-only functions and `invoke` for write functions\n"
"that modify the state."
msgstr "Starkli 通过两种主要方法实现与智能合约的交互：`call`用于只读函数，`invoke`用于修改状态的写入函数。"

#: src/ch02-05-testnet-deployment.md:413
msgid "### Calling a Read Function"
msgstr "### 调用只读函数"

#: src/ch02-05-testnet-deployment.md:415
msgid ""
"The `call` command enables you to query a smart contract function\n"
"without sending a transaction. For instance, to find out who the current\n"
"owner of the contract is, you can use the `get_owner` function, which\n"
"requires no arguments."
msgstr "`call`命令使你可以在不发送交易的情况下查询智能合约函数。例如，要想知道谁是合约的当前所有者，可以使用`get_owner`函数，该函数不需要参数。"

#: src/ch02-05-testnet-deployment.md:420 src/ch02-05-testnet-deployment.md:477
msgid ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        get_owner\n"
"```"
msgstr ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        get_owner\n"
"```"

#: src/ch02-05-testnet-deployment.md:430
msgid ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"
msgstr ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"

#: src/ch02-05-testnet-deployment.md:436
msgid "## Invoking a Write Function"
msgstr "## 调用写入函数"

#: src/ch02-05-testnet-deployment.md:438
msgid ""
"You can modify the contract’s state using the `invoke` command. For\n"
"example, let’s transfer the contract’s ownership with the\n"
"`transfer_ownership` function."
msgstr "您可以使用 `invoke` 命令修改合约的状态。例如，让我们使用 `transfer_ownership` 函数转移合约的所有权。"

#: src/ch02-05-testnet-deployment.md:442
msgid ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        transfer_ownership \\\n"
"        <NEW_OWNER_ADDRESS>\n"
"```"
msgstr ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        transfer_ownership \\\n"
"        <NEW_OWNER_ADDRESS>\n"
"```"

#: src/ch02-05-testnet-deployment.md:449
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of the contract and\n"
"`<NEW_OWNER_ADDRESS>` with the address you want to transfer ownership\n"
"to. If the smart wallet you’re using isn’t the contract’s owner, an\n"
"error will appear. Note that the initial owner was set when deploying\n"
"the contract:"
msgstr "将 `<CONTRACT_ADDRESS>` 替换为合约地址，将 `<NEW_OWNER_ADDRESS>`替换为你想转移所有权的地址。如果您使用的智能钱包不是合约的所有者，则会出现错误。请注意，初始所有者是在部署合约时设置的："

#: src/ch02-05-testnet-deployment.md:455
msgid ""
"```bash\n"
"    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].\n"
"```"
msgstr ""
"```bash\n"
"    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].\n"
"```"

#: src/ch02-05-testnet-deployment.md:459
msgid ""
"The failure reason is encoded as a felt. o decode it, use the starkli’s\n"
"`parse-cairo-string` command."
msgstr "失败的原因被编码成了`felt`类型。要解码失败原因，请使用 starkli 的 `parse-cairo-string` 命令。"

#: src/ch02-05-testnet-deployment.md:462
msgid ""
"```bash\n"
"    starkli parse-cairo-string <ENCODED_ERROR>\n"
"```"
msgstr ""
"```bash\n"
"    starkli parse-cairo-string <ENCODED_ERROR>\n"
"```"

#: src/ch02-05-testnet-deployment.md:466
msgid ""
"For example, if you see\n"
"`0x43616c6c6572206973206e6f7420746865206f776e6572`, decoding it will\n"
"yield \"Caller is not the owner.\""
msgstr "例如，如果您看到 \"0x43616c6c6572206973206e6f7420746865206f776e6572\"，它解码结果将是 \"Caller is not the owner.\"。"

#: src/ch02-05-testnet-deployment.md:470
msgid ""
"After a successful transaction on L2, use a block explorer like\n"
"StarkScan or Voyager to confirm the transaction status using the hash\n"
"provided by the `invoke` command."
msgstr "在 L2 上成功进行交易后，使用 StarkScan 或 Voyager 等区块资源管理器，使用 `invoke`命令提供的哈希值确认交易状态。"

#: src/ch02-05-testnet-deployment.md:474
msgid ""
"To verify that the ownership has successfully transferred, you can call\n"
"the `get_owner` function again:"
msgstr "要验证所有权是否已成功转移，可以再次调用 `get_owner` 函数："

#: src/ch02-05-testnet-deployment.md:483
msgid ""
"If the function returns the new owner’s address, the transfer was\n"
"successful."
msgstr "如果函数返回新所有者的地址，则说明转账成功。"

#: src/ch02-05-testnet-deployment.md:486
msgid ""
"Congratulations! You’ve successfully deployed and interacted with a\n"
"Starknet contract."
msgstr "恭喜您！您已成功部署Starknet合约并与之交互。"

#: src/ch02-05-foundry-cast.md:1
msgid "# Foundry Cast: Starknet CLI Interaction"
msgstr "# Foundry Cast：Starknet CLI 交互"

#: src/ch02-05-foundry-cast.md:3
msgid ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) is a tool designed for testing and developing Starknet contracts. It is an adaptation of the Ethereum Foundry for Starknet, aiming "
"to expedite the development process."
msgstr "[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) 是一个用于测试和开发Starknet合约的工具。它是根据以太坊上的 Foundry 工具进行了一些针对 Starknet 的改造，旨在加快开发过程。"

#: src/ch02-05-foundry-cast.md:5
msgid "The project consists of two primary components:"
msgstr "该项目由两个主要部分组成："

#: src/ch02-05-foundry-cast.md:7
msgid ""
"- **Forge**: A testing tool specifically for Cairo contracts. This tool acts as a test runner and boasts features designed to enhance your testing process. Tests are written directly in Cairo, "
"eliminating the need for other programming languages. Additionally, the Forge implementation uses Rust, mirroring Ethereum Foundry's choice of language.\n"
"- **Cast**: This serves as a DevOps tool for Starknet, initially supporting a series of commands to interface with Starknet. In the future, Cast aims to offer deployment scripts for contracts and "
"other DevOps functions."
msgstr ""
"- **Forge**：专门用于Cairo合约的测试工具。该工具可用作测试运行器，并具有旨在增强测试流程的功能。测试直接用Cairo语言编写，无需使用其他编程语言。此外，Forge 的实现使用 Rust，与以太坊 Foundry 的语言选"
"择如出一辙。\n"
"- **Cast**：这是 Starknet 的 DevOps 工具，最初支持一系列与 Starknet 接口的命令。未来，Cast 的目标是为合约和其他 DevOps 功能提供部署脚本。"

#: src/ch02-05-foundry-cast.md:10
msgid "## Cast"
msgstr "## Cast"

#: src/ch02-05-foundry-cast.md:12
msgid ""
"Cast provides the Command Line Interface (CLI) for starknet, while Forge addresses testing. Written in Rust, Cast utilizes starknet Rust and integrates with Scarb. This integration allows for "
"argument specification in `Scarb.toml`, streamlining the process."
msgstr "Cast 为 starknet 提供命令行界面（CLI），而 Forge 则负责测试。Cast 采用 Rust 编写，利用 starknet Rust 并与 Scarb 集成。这种集成允许在 `Scarb.toml`中指定参数，从而简化了流程。"

#: src/ch02-05-foundry-cast.md:14
msgid "`sncast` simplifies interaction with smart contracts, reducing the number of necessary commands compared to using `starkli` alone."
msgstr "与单独使用 `starkli` 相比，`sncast` 简化了与智能合约的交互，减少了必要命令的数量。"

#: src/ch02-05-foundry-cast.md:16
msgid "In this section, we'll delve into `sncast`."
msgstr "在本节中，我们将深入研究 `sncast`。"

#: src/ch02-05-foundry-cast.md:18
msgid "## Step 1: Sample Smart Contract"
msgstr "## 步骤 1：示例智能合约"

#: src/ch02-05-foundry-cast.md:20
msgid "The following code sample is sourced from `starknet foundry`. You can find the original [here](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html)."
msgstr "以下代码示例来自 `starknet foundry`。您可以在 [此处](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html) 找到原文。"

#: src/ch02-05-foundry-cast.md:22
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            assert(amount != 0, 'amount cannot be 0');\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            assert(amount != 0, 'amount cannot be 0');\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-foundry-cast.md:49
msgid "Before interacting with this sample smart contract, it's crucial to test its functionality using **`snforge`** to ensure its integrity."
msgstr "在与此示例智能合约交互之前，使用 **`snforge`** 测试其功能以确保其完整性至关重要。"

#: src/ch02-05-foundry-cast.md:51
msgid "Here are the associated tests:"
msgstr "以下是相关测试："

#: src/ch02-05-foundry-cast.md:53
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use learnsncast::IHelloStarknetDispatcherTrait;\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"    use super::{IHelloStarknetDispatcher};\n"
"\n"
"    #[test]\n"
"    fn call_and_invoke() {\n"
"        // Declare and deploy a contract\n"
"        let contract = declare('HelloStarknet');\n"
"        let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"        // Create a Dispatcher object for interaction with the deployed contract\n"
"        let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"        // Query a contract view function\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 0, 'balance == 0');\n"
"\n"
"        // Invoke a contract function to mutate state\n"
"        dispatcher.increase_balance(100);\n"
"\n"
"        // Verify the transaction's effect\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 100, 'balance == 100');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use learnsncast::IHelloStarknetDispatcherTrait;\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"    use super::{IHelloStarknetDispatcher};\n"
"\n"
"    #[test]\n"
"    fn call_and_invoke() {\n"
"        // Declare and deploy a contract\n"
"        let contract = declare('HelloStarknet');\n"
"        let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"        // Create a Dispatcher object for interaction with the deployed contract\n"
"        let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"        // Query a contract view function\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 0, 'balance == 0');\n"
"\n"
"        // Invoke a contract function to mutate state\n"
"        dispatcher.increase_balance(100);\n"
"\n"
"        // Verify the transaction's effect\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 100, 'balance == 100');\n"
"    }\n"
"}\n"
"```"

#: src/ch02-05-foundry-cast.md:83
msgid "If needed, copy the provided code snippets into the `lib.cairo` file of your new scarb project."
msgstr "如有需要，将提供的代码片段复制到新 scarb 项目的 `lib.cairo`文件中。"

#: src/ch02-05-foundry-cast.md:85
msgid "To execute tests, follow the steps below:"
msgstr "执行测试的步骤如下："

#: src/ch02-05-foundry-cast.md:87
msgid ""
"1. Ensure `snforge` is listed as a dependency in your `Scarb.toml` file, positioned beneath the `starknet` dependency. Your dependencies section should appear as (make sure to use the latest "
"version of `snforge` and `starknet`):"
msgstr "1.确保将 `snforge` 列为`Scarb.toml`文件中的依赖项，位于`starknet`依赖项的下方。您的依赖关系部分应显示为（确保使用最新版本的 `snforge` 和 `starknet`）："

#: src/ch02-05-foundry-cast.md:89
msgid ""
"```txt\n"
"starknet = \"2.1.0-rc2\"\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.7.1\" }\n"
"```"
msgstr ""
"```txt\n"
"starknet = \"2.1.0-rc2\"\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.7.1\" }\n"
"```"

#: src/ch02-05-foundry-cast.md:94
msgid "2. Run the command:"
msgstr "2.运行命令："

#: src/ch02-05-foundry-cast.md:96
msgid ""
"```sh\n"
"snforge\n"
"```"
msgstr ""
"```sh\n"
"snforge\n"
"```"

#: src/ch02-05-foundry-cast.md:100
msgid "Note: Use `snforge` for testing instead of the `scarb test` command. The tests are set up to utilize functions from `snforge_std`. Running `scarb test` would cause errors."
msgstr "注意: 测试时使用 `snforge` 而不是 `scarb test` 命令。测试将使用 `snforge_std` 中的函数。运行 `scarb test` 会导致错误。"

#: src/ch02-05-foundry-cast.md:102
msgid "## Step 2: Setting Up Starknet Devnet"
msgstr "## 第 2 步：设置Starknet Devnet"

#: src/ch02-05-foundry-cast.md:104
msgid ""
"For this guide, the focus is on using `starknet-devnet`. If you've been using `katana`, please be cautious as there might be inconsistencies. If you haven't configured `devnet`, consider following "
"this [guide](https://livesoftwaredeveloper.com/articles/9/how-to-set-up-starknet-devnet-and-frontend-for-smart-contract-development) for a quick setup."
msgstr ""
"本指南的重点是使用 `starknet-devnet`。如果您一直在使用 `katana`，请务必谨慎，因为可能会有不一致的地方。如果您还没有配置过 `devnet`，请考虑按照本 [指南](https://livesoftwaredeveloper.com/articles/9/"
"how-to-set-up-starknet-devnet-and-frontend-for-smart-contract-development)进行快速设置。"

#: src/ch02-05-foundry-cast.md:106
msgid "To launch `starknet devnet`, use the command:"
msgstr "要启动 `starknet devnet`，请使用以下命令："

#: src/ch02-05-foundry-cast.md:108
msgid ""
"```sh\n"
"starknet-devnet\n"
"```"
msgstr ""
"```sh\n"
"starknet-devnet\n"
"```"

#: src/ch02-05-foundry-cast.md:112
msgid "Upon successful startup, you should receive a response similar to:"
msgstr "启动成功后，您应该会收到类似的回复："

#: src/ch02-05-foundry-cast.md:114
msgid ""
"```sh\n"
"Predeployed FeeToken\n"
"Address: 0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\n"
"Class Hash: 0x6a22bf63c7bc07effa39a25dfbd21523d211db0100a0afd054d172b81840eaf\n"
"Symbol: ETH\n"
"\n"
"Account #0:\n"
"Address: 0x5fd5ef7f4b0e23a44a3670bd84f802f6cc37983c7766d562a8d4d72bb8360ba\n"
"Public key: 0x6bd5d1d46a7f603f1106824a3b276fdb52168f55b595ba7ff6b2ded390161cd\n"
"Private key: 0xc12927df61303656b3c066e65eda0acc\n"
"...\n"
"...\n"
"...\n"
" * Listening on http://127.0.0.1:5050/ (Press CTRL+C to quit)\n"
"```"
msgstr ""
"```sh\n"
"Predeployed FeeToken\n"
"Address: 0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\n"
"Class Hash: 0x6a22bf63c7bc07effa39a25dfbd21523d211db0100a0afd054d172b81840eaf\n"
"Symbol: ETH\n"
"\n"
"Account #0:\n"
"Address: 0x5fd5ef7f4b0e23a44a3670bd84f802f6cc37983c7766d562a8d4d72bb8360ba\n"
"Public key: 0x6bd5d1d46a7f603f1106824a3b276fdb52168f55b595ba7ff6b2ded390161cd\n"
"Private key: 0xc12927df61303656b3c066e65eda0acc\n"
"...\n"
"...\n"
"...\n"
" * Listening on http://127.0.0.1:5050/ (Press CTRL+C to quit)\n"
"```"

#: src/ch02-05-foundry-cast.md:130
msgid "(Note: The abbreviated ... is just a placeholder for the detailed response. In your actual output, you'll see the full details.)"
msgstr "(注意：缩写的...只是详细回复的占位符。在实际输出中，您将看到完整的详细信息。）"

#: src/ch02-05-foundry-cast.md:132
msgid "Now, you have written a smart contract, tested it, and successfully initiated starknet devnet."
msgstr "现在，您已经编写了一份智能合约，对其进行了测试，并成功启动了Starknet Devnet。"

#: src/ch02-05-foundry-cast.md:134
msgid "## Dive into `sncast`"
msgstr "## 深入 `sncast`"

#: src/ch02-05-foundry-cast.md:136
msgid "Let's unpack **`sncast`**."
msgstr "让我们来解读**`sncast`**。"

#: src/ch02-05-foundry-cast.md:138
msgid "As a multifunctional tool, the quickest way to discover its capabilities is via the command:"
msgstr "作为一款多功能工具，了解其功能的最快方法就是通过命令："

#: src/ch02-05-foundry-cast.md:140
msgid ""
"```sh\n"
"sncast --help\n"
"```"
msgstr ""
"```sh\n"
"sncast --help\n"
"```"

#: src/ch02-05-foundry-cast.md:144
msgid "In the output, you'll notice distinct categories: `commands` and `options`. Each option offers both a concise (`short`) and a descriptive (`long`) variant."
msgstr "在输出中，你会注意到不同的类别：`commands` 和 `options`。每个选项都有简短(`short`) 和描述性(`long`)两种版本。"

#: src/ch02-05-foundry-cast.md:146
msgid "> Tip: While both option variants are useful, we'll prioritize the long form in this guide. This choice aids clarity, especially when constructing intricate commands."
msgstr "> 提示：虽然两种选项变体都很有用，但在本指南中我们将优先使用长格式。这种选择有助于提高清晰度，尤其是在编写复杂的命令时。"

#: src/ch02-05-foundry-cast.md:148
msgid "Delving deeper, to understand specific commands such as **`account`**, you can run:"
msgstr "要深入了解**`account`**等特定命令，可以运行："

#: src/ch02-05-foundry-cast.md:150
msgid ""
"```sh\n"
"sncast account help\n"
"```"
msgstr ""
"```sh\n"
"sncast account help\n"
"```"

#: src/ch02-05-foundry-cast.md:154
msgid "Each account subcommand like `add`, `create`, and `deploy` can be further explored. For instance:"
msgstr "每个账户子命令，如 `add`, `create`, 和 `deploy` ，都可以进一步探索。例如："

#: src/ch02-05-foundry-cast.md:156
msgid ""
"```sh\n"
"sncast account add --help\n"
"```"
msgstr ""
"```sh\n"
"sncast account add --help\n"
"```"

#: src/ch02-05-foundry-cast.md:160
msgid ""
"The layered structure of `sncast` provides a wealth of information right at your fingertips. It's like having dynamic documentation. Make it a habit to explore, and you'll always stay informed."
msgstr "`sncast` 的分层结构为您提供了丰富的信息。这就像拥有动态文档一样。养成探索的习惯，您就能始终掌握最新信息。"

#: src/ch02-05-foundry-cast.md:162
msgid "## Step 3: Using `sncast` for Account Management"
msgstr "## 第 3 步：使用 `sncast` 进行账户管理"

#: src/ch02-05-foundry-cast.md:164
msgid "Let's delve into how to use `sncast` for interacting with the contract."
msgstr "让我们深入了解如何使用 `sncast` 与合约交互。"

#: src/ch02-05-foundry-cast.md:166
msgid ""
"By default, `starknet devnet` offers several `predeployed accounts`. These are accounts already registered with the node, loaded with test tokens (for gas fees and various transactions). Developers "
"can use them directly with any `contract` on the `local node` (i.e., starknet devnet)."
msgstr "默认情况下，`starknet devnet`提供多个 `predeployed accounts`（预部署账户）。这些账户已经在节点上注册，并装载了测试代币（用于gas和各种交易）。开发者可以直接在本地节点上使用它们。"

#: src/ch02-05-foundry-cast.md:168
msgid "### How to Utilize Predeployed Accounts"
msgstr "### 如何利用预先部署的账户"

#: src/ch02-05-foundry-cast.md:170
msgid "To employ a predeployed account with the smart contract, execute the `account add` command as shown below:"
msgstr "要在智能合约中使用预先部署的账户，请执行`account add`命令，如下所示："

#: src/ch02-05-foundry-cast.md:172
msgid ""
"```sh\n"
"sncast [SNCAST_MAIN_OPTIONS] account add [SUBCOMMAND_OPTIONS] --name <NAME> --address <ADDRESS> --private-key <PRIVATE_KEY>\n"
"```"
msgstr ""
"```sh\n"
"sncast [SNCAST_MAIN_OPTIONS] account add [SUBCOMMAND_OPTIONS] --name <NAME> --address <ADDRESS> --private-key <PRIVATE_KEY>\n"
"```"

#: src/ch02-05-foundry-cast.md:176
msgid ""
"Although several options can accompany the `add` command (e.g., `--name, --address, --class-hash, --deployed, --private-key, --public-key, --salt, --add-profile`), we'll focus on a select few for "
"this illustration."
msgstr "虽然 `add` 命令可以包含多个选项（例如，`--name, --address, --class-hash, --deployed, --private-key, --public-key, -salt, --add-profile` ），但我们在本例中将重点介绍其中的几个选项。"

#: src/ch02-05-foundry-cast.md:178
msgid "Choose an account from the **`starknet-devnet`**, for demonstration, we'll select account **`#0`**, and execute:"
msgstr "从**`starknet-devnet`**中选择一个账户，作为演示，我们将选择账户**`#0`**，然后执行："

#: src/ch02-05-foundry-cast.md:180
msgid ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account add  --name account1 --address 0x5f...60ba --private-key 0xc...0acc --add-profile\n"
"```"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account add  --name account1 --address 0x5f...60ba --private-key 0xc...0acc --add-profile\n"
"```"

#: src/ch02-05-foundry-cast.md:184
msgid "Points to remember:"
msgstr "需要记住的要点："

#: src/ch02-05-foundry-cast.md:186
msgid ""
"1. **`-name`** - Mandatory field.\n"
"2. **`-address`** - Necessary account address.\n"
"3. **`-private-key`** - Private key of the account.\n"
"4. **`-add-profile`** - Though optional, it's pivotal. By enabling **`sncast`** to include the account in your **`Scarb.toml`** file, you can manage multiple accounts, facilitating transactions "
"among them when working with your smart contract using sncast."
msgstr ""
"1. **`-name`** - 必填字段。\n"
"2. **`-address`** - 必要的账户地址。\n"
"3. **`-private-key`** - 账户的私人密钥。\n"
"4. **`-add-profile`** - 虽然是可选项，但非常重要。通过启用**`sncast`**，将账户包含在**`Scarb.toml`**文件中，您可以管理多个账户，在使用sncast处理智能合约时，方便它们之间的交易。"

#: src/ch02-05-foundry-cast.md:191
msgid "Now that we have familiarized ourselves with using a predeployed account, let's proceed to adding a new account."
msgstr "现在，我们已经熟悉了如何使用预先部署的账户，让我们继续添加一个新账户。"

#: src/ch02-05-foundry-cast.md:193
msgid "### Creating and Deploying a New Account to Starknet Devnet"
msgstr "### 在Starknet Devnet 创建和部署新账户"

#: src/ch02-05-foundry-cast.md:195
msgid "Creating a new account involves a few more steps than using an existing one, but it's straightforward when broken down. Here are the steps:"
msgstr "创建新账户要比使用现有账户多几个步骤，但细分起来也很简单。具体步骤如下："

#: src/ch02-05-foundry-cast.md:197
msgid "1. Account Creation"
msgstr "1.创建账户"

#: src/ch02-05-foundry-cast.md:199
msgid "To create a new account, use (you can use `sncast account create --help` to see the available options):"
msgstr "要创建新账户，请使用（可以使用 `sncast account create --help` 查看可用选项）："

#: src/ch02-05-foundry-cast.md:201
msgid ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account create --name new_account --class-hash  0x19...8dd6 --add-profile\n"
"```"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account create --name new_account --class-hash  0x19...8dd6 --add-profile\n"
"```"

#: src/ch02-05-foundry-cast.md:205
msgid "Wondering where the `--class-hash` comes from? It's visible in the output from the `starknet-devnet` command under the Predeclared Starknet CLI account section. For example:"
msgstr "想知道 `--class-hash` 从何而来？在预设 Starknet CLI 账户部分的 `starknet-devnet` 命令输出中可以看到它。例如："

#: src/ch02-05-foundry-cast.md:207
msgid ""
"```sh\n"
"Predeclared Starknet CLI account:\n"
"Class hash: 0x195c984a44ae2b8ad5d49f48c0aaa0132c42521dcfc66513530203feca48dd6\n"
"```"
msgstr ""
"```sh\n"
"Predeclared Starknet CLI account:\n"
"Class hash: 0x195c984a44ae2b8ad5d49f48c0aaa0132c42521dcfc66513530203feca48dd6\n"
"```"

#: src/ch02-05-foundry-cast.md:212
msgid "2. Funding the Account"
msgstr "2.为账户提供资金"

#: src/ch02-05-foundry-cast.md:214
msgid "To fund the new account, replace the address in the following command with your new one:"
msgstr "要为新账户注资，请将以下命令中的地址替换为新地址："

#: src/ch02-05-foundry-cast.md:216
msgid ""
"```sh\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5050/mint\n"
"```"
msgstr ""
"```sh\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5050/mint\n"
"```"

#: src/ch02-05-foundry-cast.md:220
msgid "Note: The **amount** is specified in the previous command's output."
msgstr "注意：**amount**已在上一条命令的输出中指定。"

#: src/ch02-05-foundry-cast.md:222
msgid "A successful fund addition will return:"
msgstr "成功增资后将返回："

#: src/ch02-05-foundry-cast.md:224
msgid ""
"```sh\n"
"{\"new_balance\":8646000000000,\"tx_hash\":\"0x48...1919\",\"unit\":\"wei\"}\n"
"```"
msgstr ""
"```sh\n"
"{\"new_balance\":8646000000000,\"tx_hash\":\"0x48...1919\",\"unit\":\"wei\"}\n"
"```"

#: src/ch02-05-foundry-cast.md:228
msgid "3. Account Deployment"
msgstr "3.账户部署"

#: src/ch02-05-foundry-cast.md:230
msgid "Deploy the account to the **`starknet devnet`** local node to register it with the chain:"
msgstr "将账户部署到 **`starknet devnet`** 本地节点，以便在链上注册："

#: src/ch02-05-foundry-cast.md:232
msgid ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account deploy --name new_account --max-fee 0x64a7168300\n"
"```"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account deploy --name new_account --max-fee 0x64a7168300\n"
"```"

#: src/ch02-05-foundry-cast.md:236
msgid "A successful deployment provides a transaction hash. If it doesn't work, revisit your previous steps."
msgstr "成功部署会提供一个事务哈希值。如果不成功，请重新检查之前的步骤。"

#: src/ch02-05-foundry-cast.md:238
msgid "4. Setting a Default Profile"
msgstr "4.设置默认配置文件"

#: src/ch02-05-foundry-cast.md:240
msgid ""
"You can define a default profile for your **`sncast`** actions. To set one, edit the **`Scarb.toml`** file. To make the **`new_account`** the default profile, find the section **`[tool.sncast."
"new_account]`** and change it to **`[tool.sncast]`**. This means **`sncast`** will default to using this profile unless instructed otherwise."
msgstr ""
"您可以为**`sncast`**操作定义默认配置文件。要设置默认配置文件，请编辑**`Scarb.toml`**文件。要将**`new_account`**设为默认配置文件，请找到**`[tool.sncast.new_account]`**部分并将其更改为**`[tool."
"sncast]`**。这意味着除非另有指示，**`sncast`** 将默认使用此配置文件。"

#: src/ch02-05-foundry-cast.md:242
msgid "## Step 4: Declaring and Deploying our Contract"
msgstr "## 第 4 步：声明和部署我们的合约"

#: src/ch02-05-foundry-cast.md:244
msgid "By now, we've arrived at the crucial step of using `sncast` to declare and deploy our smart contracts."
msgstr "现在，我们已经到了使用 `sncast` 来声明和部署智能合约的关键步骤。"

#: src/ch02-05-foundry-cast.md:246
msgid "### Declaring the Contract"
msgstr "### 声明合约"

#: src/ch02-05-foundry-cast.md:248
msgid "Recall that we drafted and tested the contract in **Step 1**. Here, we'll focus on two actions: building and declaring."
msgstr "回顾一下，我们在**步骤 1** 中起草并测试了合约。在这里，我们将重点关注两个操作：编译和声明。"

#: src/ch02-05-foundry-cast.md:250
msgid "1. **Building the Contract**"
msgstr "1. **编译合约**"

#: src/ch02-05-foundry-cast.md:252
msgid "Execute the following to build the contract:"
msgstr "执行以下操作以编译合约："

#: src/ch02-05-foundry-cast.md:254
msgid ""
"```sh\n"
"scarb build\n"
"```"
msgstr ""
"```sh\n"
"scarb build\n"
"```"

#: src/ch02-05-foundry-cast.md:258
msgid ""
"If you've successfully run tests using **`snforge`**, the **`scarb build`** should operate without issues. After the build completes, a new **`target`** folder will appear at the root of your "
"project."
msgstr "如果您已成功使用**`snforge`**进行了测试，那么**`scarb build`**应该可以顺利运行。构建完成后，项目根目录下会出现一个新的 **`target`** 文件夹。"

#: src/ch02-05-foundry-cast.md:260
msgid "Within the **`target`** folder, you'll find a **`dev`** sub-folder containing three files: **`*.casm.json`**, **`*.sierra.json`**, and **`*.starknet_artifacts.json`**."
msgstr "在**`target`**文件夹中，你会发现一个**`dev`**子文件夹，其中包含三个文件： ***`*.casm.json`**、**`*.sierra.json`**和**`*.starknet_artifacts.json`**。"

#: src/ch02-05-foundry-cast.md:262
msgid "If these files aren't present, it's likely due to missing configurations in your **`Scarb.toml`** file. To address this, append the following lines after **`dependencies`**:"
msgstr "如果没有这些文件，很可能是由于**`Scarb.toml`**文件中缺少配置。要解决这个问题，请在 **`dependencies`** 后添加以下几行："

#: src/ch02-05-foundry-cast.md:264
msgid ""
"```toml\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"
msgstr ""
"```toml\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"

#: src/ch02-05-foundry-cast.md:270
msgid "These lines instruct the compiler to produce both `sierra` and `casm` outputs."
msgstr "这些行指示编译器同时生成 `sierra` 和 `casm` 输出。"

#: src/ch02-05-foundry-cast.md:272
msgid "2. Declaring the Contract"
msgstr "2.声明合约"

#: src/ch02-05-foundry-cast.md:274
msgid "We will use the `sncast declare` command to declare the contract. Here's the format:"
msgstr "我们将使用 `sncast declare` 命令来声明合约。格式如下："

#: src/ch02-05-foundry-cast.md:276
msgid ""
"```shell\n"
"sncast declare [OPTIONS] --contract-name <CONTRACT>\n"
"```"
msgstr ""
"```shell\n"
"sncast declare [OPTIONS] --contract-name <CONTRACT>\n"
"```"

#: src/ch02-05-foundry-cast.md:280
msgid "Given this, the correct command would be:"
msgstr "因此，正确的指令应该是："

#: src/ch02-05-foundry-cast.md:282
msgid ""
"```\n"
"sncast --profile account1 declare --contract-name HelloStarknet\n"
"```"
msgstr ""
"```\n"
"sncast --profile account1 declare --contract-name HelloStarknet\n"
"```"

#: src/ch02-05-foundry-cast.md:286
msgid ""
"Note that we've omitted the **`--url`** option. Why? When using **`--profile`**, as seen here with **`account1`**, it's not necessary. Remember, earlier in this guide, we discussed adding and "
"creating new accounts. You can use either **`account1`** or **`new_account`** and achieve the desired result."
msgstr ""
"请注意，我们省略了 **`--url`** 选项。为什么呢？在使用 **`--profile`**（如这里的 **`account1`**）时，它不是必需的。请记住，在本指南的前面部分，我们讨论了添加和创建新账户。你可以使用**`account1`**或"
"**`new_account`**来达到预期效果。"

#: src/ch02-05-foundry-cast.md:288
msgid ""
"> Hint: You can define a default profile for sncast actions. Modify the `Scarb.toml` file to set a default. For example, to make `new_account` the default, find `[tool.sncast.new_account]` and "
"change it to `[tool.sncast]`. Then, there's no need to specify the profile for each call, simplifying your command to:"
msgstr ""
"> 提示：您可以为 sncast 操作定义默认配置文件。修改 `Scarb.toml` 文件以设置默认值。例如，要将 `new_account` 设置为默认值，请找到 `[tool.sncast.new_account]`，并将其更改为 `[tool.sncast]`。这样，就无"
"需为每次调用指定配置文件，从而简化了命令："

#: src/ch02-05-foundry-cast.md:290
msgid ""
"```sh\n"
"sncast declare --contract-name HelloStarknet\n"
"```"
msgstr ""
"```sh\n"
"sncast declare --contract-name HelloStarknet\n"
"```"

#: src/ch02-05-foundry-cast.md:294
msgid "The output will resemble:"
msgstr "输出结果类似于："

#: src/ch02-05-foundry-cast.md:296
msgid ""
"```sh\n"
"command: declare\n"
"class_hash: 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"transaction_hash: 0x7fbdcca80e7c666f1b5c4522fdad986ad3b731107001f7d8df5f3cb1ce8fd11\n"
"```"
msgstr ""
"```sh\n"
"command: declare\n"
"class_hash: 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"transaction_hash: 0x7fbdcca80e7c666f1b5c4522fdad986ad3b731107001f7d8df5f3cb1ce8fd11\n"
"```"

#: src/ch02-05-foundry-cast.md:302
msgid "Make sure to note the \\*\\*`class hash` as it will be essential in the subsequent step."
msgstr "请务必记下 \\*\\*`class hash`，因为它在后续步骤中至关重要。"

#: src/ch02-05-foundry-cast.md:304
msgid ""
"> Note: If you encounter an error stating Class hash already declared, simply move to the next step. Redeclaring an already-declared contract isn't permissible. Use the mentioned class hash for "
"deployment."
msgstr "> 注意：如果遇到 \"Class hash already declared \"的错误提示，请直接进入下一步。不允许重新声明已声明的合约。请使用上述类散列进行部署。"

#: src/ch02-05-foundry-cast.md:306
msgid "### Deploying the Contract"
msgstr "### 部署合约"

#: src/ch02-05-foundry-cast.md:308
msgid ""
"With the contract successfully declared and a `class hash` obtained, we're ready to proceed to contract deployment. This step is straightforward. Replace `<class-hash>` in the command below with "
"your obtained class hash:"
msgstr "成功声明了合约并获得了 `class hash`后，我们就可以开始部署合约了。这一步很简单。将下面命令中的 `<class-hash>` 替换为获得的类散列："

#: src/ch02-05-foundry-cast.md:310
msgid ""
"```sh\n"
"sncast deploy --class-hash 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"```"
msgstr ""
"```sh\n"
"sncast deploy --class-hash 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"```"

#: src/ch02-05-foundry-cast.md:314
msgid "Executing this will likely yield:"
msgstr "这样做的结果可能是："

#: src/ch02-05-foundry-cast.md:316
msgid ""
"```sh\n"
"command: deploy\n"
"contract_address: 0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\n"
"transaction_hash: 0x6bdf6cfc8080336d9315f9b4df7bca5fb90135817aba4412ade6f942e9dbe60\n"
"```"
msgstr ""
"```sh\n"
"command: deploy\n"
"contract_address: 0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\n"
"transaction_hash: 0x6bdf6cfc8080336d9315f9b4df7bca5fb90135817aba4412ade6f942e9dbe60\n"
"```"

#: src/ch02-05-foundry-cast.md:322
msgid "However, you may encounter some issues, such as:"
msgstr "不过，您可能会遇到一些问题，例如："

#: src/ch02-05-foundry-cast.md:324
msgid "**Error: RPC url not passed nor found in Scarb.toml**. This indicates the absence of a default profile in the **`Scarb.toml`** file. To remedy this:"
msgstr "**Error: RPC url not passed nor found in Scarb.toml**。这表明 **`Scarb.toml`** 文件中没有默认配置文件。要解决这个问题："

#: src/ch02-05-foundry-cast.md:326
msgid ""
"- Add the **`-profile`** option, followed by the desired profile name, as per the ones you've established.\n"
"- Alternatively, set a default profile as previously discussed in the \"Declaring the Contract\" section under \"Hint\" or as detailed in the \"Adding, Creating, and Deploying Account\" subsection."
msgstr ""
"- 添加**`-profile`***选项，之后是所需的配置文件名称，与已建立的配置文件名称一致。\n"
"- 或者，按照之前在 \"Hint \"下的 \"声明合约 \"一节中讨论的方法或 \"添加、创建和部署账户 \"小节中的详细说明，设置默认配置文件。"

#: src/ch02-05-foundry-cast.md:329
msgid "You've successfully deployed your contract with `sncast`! Now, let's explore how to interact with it."
msgstr "您已经成功地用 `sncast` 部署了您的合约！现在，让我们来探讨一下如何与之交互。"

#: src/ch02-05-foundry-cast.md:331
msgid "## Interacting with the Contract"
msgstr "## 与合约交互"

#: src/ch02-05-foundry-cast.md:333
msgid "This section explains how to read and write information to the contract."
msgstr "本节介绍如何读取和写入合约信息。"

#: src/ch02-05-foundry-cast.md:335
msgid "### Invoking Contract Functions"
msgstr "### 调用合约函数"

#: src/ch02-05-foundry-cast.md:337
msgid "To write to the contract, invoke its functions. Here's a basic overview of the command:"
msgstr "要写入合约，请调用其函数。下面是该命令的基本概述："

#: src/ch02-05-foundry-cast.md:339
msgid ""
"```sh\n"
"Usage: sncast invoke [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Options:\n"
"  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract\n"
"  -f, --function <FUNCTION>                  Name of the function\n"
"  -c, --calldata <CALLDATA>                  Data for the function\n"
"  -m, --max-fee <MAX_FEE>                    Maximum transaction fee (auto-estimated if absent)\n"
"  -h, --help                                 Show help\n"
"```"
msgstr ""
"```sh\n"
"Usage: sncast invoke [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Options:\n"
"  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract\n"
"  -f, --function <FUNCTION>                  Name of the function\n"
"  -c, --calldata <CALLDATA>                  Data for the function\n"
"  -m, --max-fee <MAX_FEE>                    Maximum transaction fee (auto-estimated if absent)\n"
"  -h, --help                                 Show help\n"
"```"

#: src/ch02-05-foundry-cast.md:350
msgid ""
"To demonstrate, let's invoke the `increase_balance` method of our smart contract with a preset default profile. Not every option is always necessary; for instance, sometimes, including the `--max-"
"fee` might be essential."
msgstr "为了演示，让我们调用智能合约的 `increase_balance`方法，并预设一个默认配置文件。并非每个选项都是必要的；例如，有时可能必须包含\"-max-fee\"。"

#: src/ch02-05-foundry-cast.md:352
msgid ""
"```sh\n"
"sncast invoke --contract-address 0x7e...b3f9 --function increase_balance --calldata 4\n"
"```"
msgstr ""
"```sh\n"
"sncast invoke --contract-address 0x7e...b3f9 --function increase_balance --calldata 4\n"
"```"

#: src/ch02-05-foundry-cast.md:356
msgid "If successful, you'll receive a transaction hash like this:"
msgstr "如果成功，您将收到这样的交易哈希值："

#: src/ch02-05-foundry-cast.md:358
msgid ""
"```sh\n"
"command: invoke\n"
"transaction_hash: 0x33248e393d985a28826e9fbb143d2cf0bb3342f1da85483cf253b450973b638\n"
"```"
msgstr ""
"```sh\n"
"command: invoke\n"
"transaction_hash: 0x33248e393d985a28826e9fbb143d2cf0bb3342f1da85483cf253b450973b638\n"
"```"

#: src/ch02-05-foundry-cast.md:363
msgid "### Reading from the Contract"
msgstr "### 从合约读取数据"

#: src/ch02-05-foundry-cast.md:365
msgid "To retrieve data from the contract, use the `sncast call` command. Here's how it works:"
msgstr "要从合约中获取数据，请使用 `sncast call` 命令。具体操作如下："

#: src/ch02-05-foundry-cast.md:367
msgid ""
"```sh\n"
"sncast call --help\n"
"```"
msgstr ""
"```sh\n"
"sncast call --help\n"
"```"

#: src/ch02-05-foundry-cast.md:371
msgid "Executing the command displays:"
msgstr "执行命令后会显示："

#: src/ch02-05-foundry-cast.md:373
msgid ""
"```sh\n"
"Usage: sncast call [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Options:\n"
"  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract (hex format)\n"
"  -f, --function <FUNCTION>                  Name of the function to call\n"
"  -c, --calldata <CALLDATA>                  Function arguments (list of hex values)\n"
"  -b, --block-id <BLOCK_ID>                  Block identifier for the call. Accepts: pending, latest, block hash (with a 0x prefix), or block number (u64). Default is 'pending'.\n"
"  -h, --help                                 Show help\n"
"```"
msgstr ""
"```sh\n"
"Usage: sncast call [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Options:\n"
"  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract (hex format)\n"
"  -f, --function <FUNCTION>                  Name of the function to call\n"
"  -c, --calldata <CALLDATA>                  Function arguments (list of hex values)\n"
"  -b, --block-id <BLOCK_ID>                  Block identifier for the call. Accepts: pending, latest, block hash (with a 0x prefix), or block number (u64). Default is 'pending'.\n"
"  -h, --help                                 Show help\n"
"```"

#: src/ch02-05-foundry-cast.md:384 src/ch03-01-02-fee-mechanism.md:58
msgid "For instance:"
msgstr "例如："

#: src/ch02-05-foundry-cast.md:386 src/ch02-05-foundry-cast.md:498
msgid ""
"```sh\n"
"sncast call --contract-address 0x7e...b3f9 --function get_balance\n"
"```"
msgstr ""
"```sh\n"
"sncast call --contract-address 0x7e...b3f9 --function get_balance\n"
"```"

#: src/ch02-05-foundry-cast.md:390
msgid "While not all options are used in the example, you might need to include options like `--calldata`, specifying it as a list or array."
msgstr "虽然示例中并未使用所有选项，但您可能需要包含类似 `--calldata` 这样的选项，并将其指定为列表或数组。"

#: src/ch02-05-foundry-cast.md:392
msgid "A successful call returns:"
msgstr "调用成功返回："

#: src/ch02-05-foundry-cast.md:394
msgid ""
"```sh\n"
"command: call\n"
"response: [0x4]\n"
"```"
msgstr ""
"```sh\n"
"command: call\n"
"response: [0x4]\n"
"```"

#: src/ch02-05-foundry-cast.md:399
msgid "This indicates successful read and write operations on the contract."
msgstr "这表示对合约的读写操作成功。"

#: src/ch02-05-foundry-cast.md:401
msgid "### sncast Multicall Guide"
msgstr "### sncast 多重调用指南"

#: src/ch02-05-foundry-cast.md:403
msgid "Use `sncast multicall` to simultaneously read and write to the contract. Let's explore how to effectively use this feature."
msgstr "使用 `sncast multicall`可同时读写合约。让我们来探讨如何有效使用这一功能。"

#: src/ch02-05-foundry-cast.md:405
msgid "First, understand its basic usage:"
msgstr "首先，了解其基本用法："

#: src/ch02-05-foundry-cast.md:407
msgid ""
"```sh\n"
"sncast multicall --help\n"
"```"
msgstr ""
"```sh\n"
"sncast multicall --help\n"
"```"

#: src/ch02-05-foundry-cast.md:411
msgid "This command displays:"
msgstr "该命令将显示："

#: src/ch02-05-foundry-cast.md:413
msgid ""
"```sh\n"
"Execute multiple calls\n"
"\n"
"Usage: sncast multicall <COMMAND>\n"
"\n"
"Commands:\n"
"  run   Execute multicall using a .toml file\n"
"  new   Create a template for the multicall .toml file\n"
"  help  Display help for subcommand(s)\n"
"\n"
"Options:\n"
"  -h, --help  Show help\n"
"```"
msgstr ""
"```sh\n"
"Execute multiple calls\n"
"\n"
"Usage: sncast multicall <COMMAND>\n"
"\n"
"Commands:\n"
"  run   Execute multicall using a .toml file\n"
"  new   Create a template for the multicall .toml file\n"
"  help  Display help for subcommand(s)\n"
"\n"
"Options:\n"
"  -h, --help  Show help\n"
"```"

#: src/ch02-05-foundry-cast.md:427
msgid "To delve deeper, initiate the `new` subcommand:"
msgstr "要深入研究，请执行 `new` 子命令："

#: src/ch02-05-foundry-cast.md:429
msgid ""
"```sh\n"
"Generate a template for the multicall .toml file\n"
"\n"
"Usage: sncast multicall new [OPTIONS]\n"
"\n"
"Options:\n"
"  -p, --output-path <OUTPUT_PATH>  File path for saving the template\n"
"  -o, --overwrite                  Overwrite file if it already exists at specified path\n"
"  -h, --help                       Display help\n"
"```"
msgstr ""
"```sh\n"
"Generate a template for the multicall .toml file\n"
"\n"
"Usage: sncast multicall new [OPTIONS]\n"
"\n"
"Options:\n"
"  -p, --output-path <OUTPUT_PATH>  File path for saving the template\n"
"  -o, --overwrite                  Overwrite file if it already exists at specified path\n"
"  -h, --help                       Display help\n"
"```"

#: src/ch02-05-foundry-cast.md:440
msgid "Generate a template called `call1.toml`:"
msgstr "生成名为 `call1.toml` 的模板："

#: src/ch02-05-foundry-cast.md:442
msgid ""
"```sh\n"
"sncast multicall new --output-path ./call1.toml --overwrite\n"
"```"
msgstr ""
"```sh\n"
"sncast multicall new --output-path ./call1.toml --overwrite\n"
"```"

#: src/ch02-05-foundry-cast.md:446
msgid "This provides a basic template:"
msgstr "这提供了一个基本模板："

#: src/ch02-05-foundry-cast.md:448
msgid ""
"```toml\n"
"[[call]]\n"
"call_type = \"deploy\"\n"
"class_hash = \"\"\n"
"inputs = []\n"
"id = \"\"\n"
"unique = false\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"\"\n"
"function = \"\"\n"
"inputs = []\n"
"```"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"deploy\"\n"
"class_hash = \"\"\n"
"inputs = []\n"
"id = \"\"\n"
"unique = false\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"\"\n"
"function = \"\"\n"
"inputs = []\n"
"```"

#: src/ch02-05-foundry-cast.md:463
msgid "Modify `call1.toml` to:"
msgstr "修改 `call1.toml` 为："

#: src/ch02-05-foundry-cast.md:465
msgid ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"

#: src/ch02-05-foundry-cast.md:479
msgid "In multicalls, only `deploy` and `invoke` actions are allowed. For a detailed guide on these, refer to the earlier section."
msgstr "在多重调用中，只允许执行`deploy` 和 `invoke`操作。有关这些操作的详细指南，请参阅前面的章节。"

#: src/ch02-05-foundry-cast.md:481
msgid "> Note: Ensure inputs are in hexadecimal format. Strings work normally, but numbers require this format for accurate results."
msgstr "> 注意：确保输入为十六进制格式。字符串可以正常工作，但数字需要这种格式才能获得准确结果。"

#: src/ch02-05-foundry-cast.md:483
msgid "To execute the multicall, use:"
msgstr "要执行多重调用，请使用："

#: src/ch02-05-foundry-cast.md:485
msgid ""
"```sh\n"
"sncast multicall run --path call1.toml\n"
"```"
msgstr ""
"```sh\n"
"sncast multicall run --path call1.toml\n"
"```"

#: src/ch02-05-foundry-cast.md:489
msgid "Upon success:"
msgstr "成功后："

#: src/ch02-05-foundry-cast.md:491
msgid ""
"```sh\n"
"command: multicall run\n"
"transaction_hash: 0x1ae4122266f99a5ede495ff50fdbd927c31db27ec601eb9f3eaa938273d4d61\n"
"```"
msgstr ""
"```sh\n"
"command: multicall run\n"
"transaction_hash: 0x1ae4122266f99a5ede495ff50fdbd927c31db27ec601eb9f3eaa938273d4d61\n"
"```"

#: src/ch02-05-foundry-cast.md:496
msgid "Check the balance:"
msgstr "检查余额："

#: src/ch02-05-foundry-cast.md:502
msgid "The response:"
msgstr "返回是："

#: src/ch02-05-foundry-cast.md:504
msgid ""
"```shell\n"
"command: call\n"
"response: [0x9]\n"
"```"
msgstr ""
"```shell\n"
"command: call\n"
"response: [0x9]\n"
"```"

#: src/ch02-05-foundry-cast.md:509
msgid "The expected balance, `0x9`, is confirmed."
msgstr "我们确认了余额 `0x9`是我们所预期的 。"

#: src/ch02-05-foundry-cast.md:513
msgid ""
"This guide detailed the use of `sncast`, a robust command-line tool tailored for starknet smart contracts. Its purpose is to make interactions with starknet's smart contracts effortless. Key "
"functionalities include contract deployment, function invocation, and function calling."
msgstr "本指南详细介绍了 `sncast`的使用，这是一个专为Starknet智能合约定制的强大的命令行工具。其目的是让与 starknet 智能合约的交互变得非常轻松。主要功能包括合约部署、写函数调用和读函数调用。"

#: src/ch02-05-01-deployment-script.md:1
msgid "# Deployment Script Example"
msgstr "# 部署脚本示例"

#: src/ch02-05-01-deployment-script.md:3
msgid "This tutorial explains how to set up a test and deployment environment for smart contracts. The given script initializes accounts, runs tests, and carries out multicalls."
msgstr "本教程介绍如何为智能合约建立测试和部署环境。给出的脚本会初始化账户、运行测试并执行多重调用。"

#: src/ch02-05-01-deployment-script.md:5
msgid "Disclaimer: This is an example. Use it as a foundation for your own work, adjusting as needed."
msgstr "免责声明：这只是一个示例。请以此为基础，根据需要进行调整。"

#: src/ch02-05-01-deployment-script.md:7 src/ch03-04-nodes.md:68
msgid "## Setup"
msgstr "## 设置"

#: src/ch02-05-01-deployment-script.md:9
msgid "### 1. Prepare the Script File"
msgstr "### 1.准备脚本文件"

#: src/ch02-05-01-deployment-script.md:11
msgid ""
"- In your project's root folder, create a file named **`script.sh`**. This will house the script.\n"
"- Adjust permissions to make the file executable:"
msgstr ""
"- 在项目根文件夹中创建一个名为 **`script.sh`** 的文件。该文件将存放脚本。\n"
"- 调整权限，使文件可执行："

#: src/ch02-05-01-deployment-script.md:14
msgid ""
"```sh\n"
"chmod +x script.sh\n"
"```"
msgstr ""
"```sh\n"
"chmod +x script.sh\n"
"```"

#: src/ch02-05-01-deployment-script.md:18
msgid "### 2. Insert the Script"
msgstr "### 2.插入脚本"

#: src/ch02-05-01-deployment-script.md:20
msgid "Below is the content for `script.sh`. It adheres to best practices for clarity, error management, and long-term support."
msgstr "以下是 `script.sh` 的内容。它遵循代码清晰度、错误管理和长期支持方面的最佳实践。"

#: src/ch02-05-01-deployment-script.md:22
msgid ""
"**Security Note**: Using environment variables is safer than hardcoding private keys in your scripts, but they're still accessible to any process on your machine and could potentially be leaked in "
"logs or error messages."
msgstr "**安全提示**：虽然使用环境变量比在脚本中硬编码私钥更安全，但你的电脑上的任何进程仍可访问它们，并有可能在日志或错误信息中泄露出来。"

#: src/ch02-05-01-deployment-script.md:24
msgid ""
"```sh\n"
"#!/usr/bin/env bash\n"
"\n"
"# Ensure the script stops on first error\n"
"set -e\n"
"\n"
"# Global variables\n"
"file_path=\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\"\n"
"CONTRACT_NAME=\"HelloStarknet\"\n"
"PROFILE_NAME=\"account1\"\n"
"MULTICALL_FILE=\"multicall.toml\"\n"
"FAILED_TESTS=false\n"
"\n"
"# Addresses and Private keys as environment variables\n"
"ACCOUNT1_ADDRESS=${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}\n"
"ACCOUNT2_ADDRESS=${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}\n"
"ACCOUNT1_PRIVATE_KEY=${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"ACCOUNT2_PRIVATE_KEY=${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"\n"
"# Utility function to log messages\n"
"function log_message() {\n"
"    echo -e \"\\n$1\"\n"
"}\n"
"\n"
"# Step 1: Clean previous environment\n"
"if [ -e \"$file_path\" ]; then\n"
"    log_message \"Removing existing accounts file...\"\n"
"    rm -rf \"$file_path\"\n"
"fi\n"
"\n"
"# Step 2: Define accounts for the smart contract\n"
"accounts_json=$(cat <<EOF\n"
"[\n"
"    {\n"
"        \"name\": \"account1\",\n"
"        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
"    },\n"
"    {\n"
"        \"name\": \"account2\",\n"
"        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
"    }\n"
"]\n"
"EOF\n"
")\n"
"\n"
"# Step 3: Run contract tests\n"
"echo -e \"\\nTesting the contract...\"\n"
"testing_result=$(snforge 2>&1)\n"
"if echo \"$testing_result\" | grep -q \"Failure\"; then\n"
"    echo -e \"Tests failed!\\n\"\n"
"    snforge\n"
"    echo -e \"\\nEnsure that your tests are passing before proceeding.\\n\"\n"
"    FAILED_TESTS=true\n"
"fi\n"
"\n"
"if [ \"$FAILED_TESTS\" != \"true\" ]; then\n"
"    echo \"Tests passed successfully.\"\n"
"\n"
"    # Step 4: Create new account(s)\n"
"    echo -e \"\\nCreating account(s)...\"\n"
"    for row in $(echo \"${accounts_json}\" | jq -c '.[]'); do\n"
"        name=$(echo \"${row}\" | jq -r '.name')\n"
"        address=$(echo \"${row}\" | jq -r '.address')\n"
"        private_key=$(echo \"${row}\" | jq -r '.private_key')\n"
"\n"
"        account_creation_result=$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)\n"
"        if echo \"$account_creation_result\" | grep -q \"error:\"; then\n"
"            echo \"Account $name already exists.\"\n"
"        else\n"
"            echo \"Account $name created successfully.\"\n"
"        fi\n"
"    done\n"
"\n"
"    # Step 5: Build, declare, and deploy the contract\n"
"    echo -e \"\\nBuilding the contract...\"\n"
"    scarb build\n"
"\n"
"    echo -e \"\\nDeclaring the contract...\"\n"
"    declaration_output=$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)\n"
"\n"
"    if echo \"$declaration_output\" | grep -q \"error: Class with hash\"; then\n"
"        echo \"Class hash already declared.\"\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p')\n"
"    else\n"
"        echo \"New class hash declaration.\"\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')\n"
"    fi\n"
"\n"
"    echo \"Class Hash: $CLASS_HASH\"\n"
"\n"
"    echo -e \"\\nDeploying the contract...\"\n"
"    deployment_result=$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")\n"
"    CONTRACT_ADDRESS=$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')\n"
"    echo \"Contract address: $CONTRACT_ADDRESS\"\n"
"\n"
"    # Step 6: Create and execute multicalls\n"
"    echo -e \"\\nSetting up multicall...\"\n"
"    cat >\"$MULTICALL_FILE\" <<-EOM\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x1']\n"
"\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x2']\n"
"EOM\n"
"\n"
"    echo \"Executing multicall...\"\n"
"    sncast --profile \"$PROFILE_NAME\" multicall run --path \"$MULTICALL_FILE\"\n"
"\n"
"    # Step 7: Query the contract state\n"
"    echo -e \"\\nChecking balance...\"\n"
"    sncast --profile \"$PROFILE_NAME\" call --contract-address \"$CONTRACT_ADDRESS\" --function get_balance\n"
"\n"
"    # Step 8: Clean up temporary files\n"
"    echo -e \"\\nCleaning up...\"\n"
"    [ -e \"$MULTICALL_FILE\" ] && rm \"$MULTICALL_FILE\"\n"
"\n"
"    echo -e \"\\nScript completed successfully.\\n\"\n"
"fi\n"
"```"
msgstr ""
"```sh\n"
"#!/usr/bin/env bash\n"
"\n"
"# Ensure the script stops on first error\n"
"set -e\n"
"\n"
"# Global variables\n"
"file_path=\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\"\n"
"CONTRACT_NAME=\"HelloStarknet\"\n"
"PROFILE_NAME=\"account1\"\n"
"MULTICALL_FILE=\"multicall.toml\"\n"
"FAILED_TESTS=false\n"
"\n"
"# Addresses and Private keys as environment variables\n"
"ACCOUNT1_ADDRESS=${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}\n"
"ACCOUNT2_ADDRESS=${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}\n"
"ACCOUNT1_PRIVATE_KEY=${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"ACCOUNT2_PRIVATE_KEY=${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"\n"
"# Utility function to log messages\n"
"function log_message() {\n"
"    echo -e \"\\n$1\"\n"
"}\n"
"\n"
"# Step 1: Clean previous environment\n"
"if [ -e \"$file_path\" ]; then\n"
"    log_message \"Removing existing accounts file...\"\n"
"    rm -rf \"$file_path\"\n"
"fi\n"
"\n"
"# Step 2: Define accounts for the smart contract\n"
"accounts_json=$(cat <<EOF\n"
"[\n"
"    {\n"
"        \"name\": \"account1\",\n"
"        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
"    },\n"
"    {\n"
"        \"name\": \"account2\",\n"
"        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
"    }\n"
"]\n"
"EOF\n"
")\n"
"\n"
"# Step 3: Run contract tests\n"
"echo -e \"\\nTesting the contract...\"\n"
"testing_result=$(snforge 2>&1)\n"
"if echo \"$testing_result\" | grep -q \"Failure\"; then\n"
"    echo -e \"Tests failed!\\n\"\n"
"    snforge\n"
"    echo -e \"\\nEnsure that your tests are passing before proceeding.\\n\"\n"
"    FAILED_TESTS=true\n"
"fi\n"
"\n"
"if [ \"$FAILED_TESTS\" != \"true\" ]; then\n"
"    echo \"Tests passed successfully.\"\n"
"\n"
"    # Step 4: Create new account(s)\n"
"    echo -e \"\\nCreating account(s)...\"\n"
"    for row in $(echo \"${accounts_json}\" | jq -c '.[]'); do\n"
"        name=$(echo \"${row}\" | jq -r '.name')\n"
"        address=$(echo \"${row}\" | jq -r '.address')\n"
"        private_key=$(echo \"${row}\" | jq -r '.private_key')\n"
"\n"
"        account_creation_result=$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)\n"
"        if echo \"$account_creation_result\" | grep -q \"error:\"; then\n"
"            echo \"Account $name already exists.\"\n"
"        else\n"
"            echo \"Account $name created successfully.\"\n"
"        fi\n"
"    done\n"
"\n"
"    # Step 5: Build, declare, and deploy the contract\n"
"    echo -e \"\\nBuilding the contract...\"\n"
"    scarb build\n"
"\n"
"    echo -e \"\\nDeclaring the contract...\"\n"
"    declaration_output=$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)\n"
"\n"
"    if echo \"$declaration_output\" | grep -q \"error: Class with hash\"; then\n"
"        echo \"Class hash already declared.\"\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p')\n"
"    else\n"
"        echo \"New class hash declaration.\"\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')\n"
"    fi\n"
"\n"
"    echo \"Class Hash: $CLASS_HASH\"\n"
"\n"
"    echo -e \"\\nDeploying the contract...\"\n"
"    deployment_result=$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")\n"
"    CONTRACT_ADDRESS=$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')\n"
"    echo \"Contract address: $CONTRACT_ADDRESS\"\n"
"\n"
"    # Step 6: Create and execute multicalls\n"
"    echo -e \"\\nSetting up multicall...\"\n"
"    cat >\"$MULTICALL_FILE\" <<-EOM\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x1']\n"
"\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x2']\n"
"EOM\n"
"\n"
"    echo \"Executing multicall...\"\n"
"    sncast --profile \"$PROFILE_NAME\" multicall run --path \"$MULTICALL_FILE\"\n"
"\n"
"    # Step 7: Query the contract state\n"
"    echo -e \"\\nChecking balance...\"\n"
"    sncast --profile \"$PROFILE_NAME\" call --contract-address \"$CONTRACT_ADDRESS\" --function get_balance\n"
"\n"
"    # Step 8: Clean up temporary files\n"
"    echo -e \"\\nCleaning up...\"\n"
"    [ -e \"$MULTICALL_FILE\" ] && rm \"$MULTICALL_FILE\"\n"
"\n"
"    echo -e \"\\nScript completed successfully.\\n\"\n"
"fi\n"
"```"

#: src/ch02-05-01-deployment-script.md:152
msgid "### 3. Adjust the Bash Path"
msgstr "### 3.调整 Bash 路径"

#: src/ch02-05-01-deployment-script.md:154
msgid "The line `#!/usr/bin/env bash` indicates the path to the bash interpreter. If you require a different version or location of bash, determine its path using:"
msgstr "行 `#!/usr/bin/env bash` 表示 bash 解释器的路径。如果需要不同版本或不同位置的 bash，请使用："

#: src/ch02-05-01-deployment-script.md:156
msgid ""
"```sh\n"
"which bash\n"
"```"
msgstr ""
"```sh\n"
"which bash\n"
"```"

#: src/ch02-05-01-deployment-script.md:160
msgid "Then replace `#!/usr/bin/env` bash in the script with the resulting path, such as `#!/path/to/your/bash`."
msgstr "然后将脚本中的 `#!/usr/bin/env` bash 替换为生成的路径，如 `#!/path/to/your/bash`。"

#: src/ch02-05-01-deployment-script.md:162
msgid "## Execution"
msgstr "## 执行"

#: src/ch02-05-01-deployment-script.md:164
msgid "When running the script, you'll need to provide the environment variables `ACCOUNT1_PRIVATE_KEY` and `ACCOUNT2_PRIVATE_KEY`."
msgstr "运行脚本时，需要提供环境变量 `ACCOUNT1_PRIVATE_KEY` 和 `ACCOUNT2_PRIVATE_KEY`。"

#: src/ch02-05-01-deployment-script.md:166 src/ch03-05-layer-3.md:9
msgid "Example:"
msgstr "例子:"

#: src/ch02-05-01-deployment-script.md:168
msgid ""
"```sh\n"
"ACCOUNT1_PRIVATE_KEY=\"0x259f4329e6f4590b\" ACCOUNT2_PRIVATE_KEY=\"0xb4862b21fb97d\" ./script.sh\n"
"```"
msgstr ""
"```sh\n"
"ACCOUNT1_PRIVATE_KEY=\"0x259f4329e6f4590b\" ACCOUNT2_PRIVATE_KEY=\"0xb4862b21fb97d\" ./script.sh\n"
"```"

#: src/ch02-05-01-deployment-script.md:172 src/ch04-05-01-multicaller.md:83
msgid "## Considerations"
msgstr "## 考量"

#: src/ch02-05-01-deployment-script.md:174
msgid ""
"- The **`set -e`** directive in the script ensures it exits if any command fails, enhancing the reliability of the deployment and testing process.\n"
"- Always secure private keys and sensitive information. Keep them away from logs and visible outputs.\n"
"- For greater flexibility, consider moving hardcoded values like accounts or contract names to a configuration file. This approach simplifies updates and overall management."
msgstr ""
"- 脚本中的 **`set -e`** 指令可确保在任何命令失败时退出脚本，从而提高部署和测试过程的可靠性。\n"
"- 始终确保私钥和敏感信息的安全。让它们远离日志和可见输出。\n"
"- 为提高灵活性，可考虑将账户或合约名称等硬编码值转移到配置文件中。这种方法可简化更新和整体管理。"

#: src/ch02-06-starknet-devnet.md:1
msgid "# Starknet Devnet 🚧"
msgstr "# Starknet Devnet 🚧"

#: src/ch02-07-starknet-js.md:1
msgid "# Starknet-js: Javascript SDK"
msgstr "# Starknet-js：Javascript SDK"

#: src/ch02-07-starknet-js.md:3
msgid ""
"Starknet.js is a JavaScript/TypeScript library designed to connect your\n"
"website or decentralized application (D-App) to Starknet. It aims to\n"
"mimic the architecture of [ethers.js](https://docs.ethers.org/v5/), so\n"
"if you are familiar with ethers, you should find Starknet.js easy to\n"
"work with."
msgstr ""
"Starknet.js 是一个 JavaScript/TypeScript 库，用于将您的网站或去中心化应用程序（D-App）连接到Starknet。它旨在模仿 [ethers.js](https://docs.ethers.org/v5/) 的架构，所以如果你熟悉 ethers，你会发现 "
"Starknet.js 很容易使用。"

#: src/ch02-07-starknet-js.md:9
msgid "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch02-07-starknet-js.md:11
msgid "<span class=\"caption\">Starknet-js in your dapp</span>"
msgstr "<span class=\"caption\">Starknet-js in your dapp</span>"

#: src/ch02-07-starknet-js.md:15
msgid "To install Starknet.js, follow these steps:"
msgstr "按照以下步骤安装 Starknet.js："

#: src/ch02-07-starknet-js.md:17
msgid "- For the latest official release (main branch):"
msgstr "最新正式版本（主分支）："

#: src/ch02-07-starknet-js.md:19 src/ch02-07-starknet-js.md:25 src/ch04-04-standard-account.md:305 src/ch04-04-standard-account.md:314
msgid "<!-- -->"
msgstr "<!-- -->"

#: src/ch02-07-starknet-js.md:21
msgid "npm install starknet"
msgstr "npm install starknet"

#: src/ch02-07-starknet-js.md:23
msgid "- To use the latest features (merges in develop branch):"
msgstr "使用最新功能（开发分支已合并的功能）："

#: src/ch02-07-starknet-js.md:27
msgid "npm install starknet@next"
msgstr "npm install starknet@next"

#: src/ch02-07-starknet-js.md:29
msgid "## Getting Started"
msgstr "## 入门"

#: src/ch02-07-starknet-js.md:31
msgid ""
"To build an app that users are able to connect to and interact with\n"
"Starknet, we recommend adding the\n"
"[get-starknet](https://github.com/starknet-io/get-starknet) library,\n"
"which allows you to manage wallet connections."
msgstr "要构建一个用户能够连接到Starknet并与之交互的应用程序，我们建议添加[get-starknet](https://github.com/starknet-io/get-starknet)库，该库允许您管理钱包连接。"

#: src/ch02-07-starknet-js.md:36
msgid ""
"With these tools ready, there are basically 3 main concepts to know on\n"
"the frontend: Account, Provider, and Contracts."
msgstr "准备好这些工具后，在前端基本上需要了解 3 个主要概念：账户、提供商和合约。"

#: src/ch02-07-starknet-js.md:39
msgid "### Account"
msgstr "### 账户"

#: src/ch02-07-starknet-js.md:41
msgid ""
"We can generally think of the account as the \"end user\" of a\n"
"dapp, and some user interaction will be involved to gain access to it."
msgstr "一般来说，我们可以把账户看作是 dapp 的 \"最终用户\"，要访问该账户，需要与用户进行一些交互。"

#: src/ch02-07-starknet-js.md:44
msgid ""
"Think of a dapp where the user connects their browser extension wallet\n"
"(such as ArgentX or Braavos) - if the user accepts the connection, that\n"
"gives us access to the account and signer, which can sign transactions\n"
"and messages."
msgstr "想象一下用户连接浏览器扩展钱包（如 ArgentX 或 Braavos）的 dapp，如果用户接受连接，我们就可以访问账户和签名者，从而签署交易和信息。"

#: src/ch02-07-starknet-js.md:49
msgid ""
"Unlike Ethereum, where user accounts are Externally Owned Accounts,\n"
"Starknet **accounts are contracts**. This might not necessarily impact\n"
"your dapp’s frontend, but you should definitely be aware of this\n"
"difference."
msgstr "以太坊的用户账户是EOA（外部拥有账户），而Starknet的**账户是合约**。这可能不一定会影响你的 dapp 前端，但你一定要意识到这种差异。"

#: src/ch02-07-starknet-js.md:54
msgid ""
"```ts\n"
"async function connectWallet() {\n"
"    const starknet = await connect();\n"
"    console.log(starknet.account);\n"
"\n"
"    const nonce = await starknet.account.getNonce();\n"
"    const message = await starknet.account.signMessage(...)\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"async function connectWallet() {\n"
"    const starknet = await connect();\n"
"    console.log(starknet.account);\n"
"\n"
"    const nonce = await starknet.account.getNonce();\n"
"    const message = await starknet.account.signMessage(...)\n"
"}\n"
"```"

#: src/ch02-07-starknet-js.md:64
msgid ""
"The snippet above uses the `connect` function provided by `get-starknet` to establish a connection to the user wallet. Once connected, we are able to access account methods, such as `signMessage` "
"or `execute`."
msgstr "上面的代码段使用`get-starknet`提供的`connect`函数与用户钱包建立连接。连接后，我们就可以访问账户方法，如 `signMessage` 或 `execute`。"

#: src/ch02-07-starknet-js.md:66 src/ch02-07-01-00-counter-ui.md:145
msgid "### Provider"
msgstr "### 提供商"

#: src/ch02-07-starknet-js.md:68
msgid ""
"The provider allows you to interact with the Starknet\n"
"network. You can think of it as a \"read\" connection to the blockchain,\n"
"as it doesn’t allow signing transactions or messages. Just like in\n"
"Ethereum, you can use a default provider, or use services such as Infura\n"
"or Alchemy, both of which support Starknet, to create an RPC provider."
msgstr ""
"提供商允许您与Starknet网络进行交互。你可以把它看作是与区块链的 \"只读 \"连接，因为它不允许签署交易或消息。就像在以太坊中一样，你可以使用默认的提供者，也可以使用 Infura 或 Alchemy（两者都支持 "
"Starknet）等服务来创建 RPC 提供者。"

#: src/ch02-07-starknet-js.md:74
msgid "By default, the Provider is a sequencer provider."
msgstr "默认情况下，提供商指的是排序器提供商。"

#: src/ch02-07-starknet-js.md:76
msgid ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"
msgstr ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"

#: src/ch02-07-starknet-js.md:90
msgid "## Contracts"
msgstr "## 合约"

#: src/ch02-07-starknet-js.md:92
msgid ""
"Your frontend will likely be interacting with deployed\n"
"contracts. For each contract, there should be a counterpart on the\n"
"frontend. To create these instances, you will need the contract’s\n"
"address and ABI, and either a provider or signer."
msgstr "您的前端可能需要与已部署的合约进行交互。对于每个合约，前端都应该有一个对应的实例。要创建这些实例，你需要合约的地址和 ABI，以及提供者或签署者。"

#: src/ch02-07-starknet-js.md:97
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"
msgstr ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"

#: src/ch02-07-starknet-js.md:107
msgid ""
"If you create a contract instance with a provider, you’ll be limited to\n"
"calling read functions on the contract - only with a signer can you\n"
"change the state of the blockchain. However, you are able to connect a\n"
"previously created `Contract` instance with a new account:"
msgstr "如果使用提供者创建合约实例，则只能调用合约上的只读函数，只有使用签名者才能改变区块链的状态。不过，您可以将以前创建的 \"合约 \"实例与新账户连接起来："

#: src/ch02-07-starknet-js.md:112
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, provider);\n"
"\n"
"contract.connect(starknet.account);\n"
"```"
msgstr ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, provider);\n"
"\n"
"contract.connect(starknet.account);\n"
"```"

#: src/ch02-07-starknet-js.md:118
msgid ""
"In the snippet above, after\n"
"calling the `connect` method, it would be possible to call read\n"
"functions on the contract, but not before."
msgstr "在上面的代码段中，在调用 `connect` 方法后，可以调用合约上的只读函数，但在此之前则不行。"

#: src/ch02-07-starknet-js.md:122
msgid "### Units"
msgstr "### 单位"

#: src/ch02-07-starknet-js.md:124
msgid ""
"If you have previous experience with web3, you know dealing\n"
"with units requires care, and Starknet is no exception. Once again, the\n"
"docs are very useful here, in particular [this section on data\n"
"transformation](https://www.starknetjs.com/docs/guides/define_call_message/)."
msgstr ""
"如果你以前有过 web3开发经验，就会知道处理单位需要小心谨慎，Starknet 也不例外。遇上这种情况时，文档总是非常有用的，尤其是[关于数据转换的这一部分](https://www.starknetjs.com/docs/guides/"
"define_call_message/)。"

#: src/ch02-07-starknet-js.md:129
msgid ""
"Very often you will need to convert Cairo structs (such as Uint256) that\n"
"are returned from contracts into numbers:"
msgstr "您经常需要将从合约返回的 Cairo 结构体（如 Uint256）转换为数字："

#: src/ch02-07-starknet-js.md:132
msgid ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"
msgstr ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"

#: src/ch02-07-starknet-js.md:145
msgid "And vice versa:"
msgstr "反之亦然："

#: src/ch02-07-starknet-js.md:147
msgid ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"
msgstr ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"

#: src/ch02-07-starknet-js.md:156
msgid ""
"There are other helpful utils, besides `bnToUint256` and `uint256ToBN`,\n"
"provided by Starknet.js."
msgstr "除了 `bnToUint256` 和 `uint256ToBN` 之外，Starknet.js 还提供了其他有用的工具。"

#: src/ch02-07-starknet-js.md:159
msgid ""
"We now have a solid foundation to build a Starknet dapp. However, there\n"
"are framework specific tools that help us build Starknet dapps, which\n"
"are covered in chaper 5."
msgstr "我们现在有了构建Starknet应用程序的坚实基础。不过，还有一些特定的框架工具可以帮助我们构建Starknet应用程序，这将在第 5 章中介绍。"

#: src/ch02-07-01-examples.md:1 src/ch02-08-01-examples.md:1 src/ch04-05-examples.md:1
msgid "# Examples"
msgstr "# 示例"

#: src/ch02-07-01-examples.md:3
msgid ""
"In this subchapter, readers will find practical examples demonstrating the usage of `starknet-js`. It provides insight into real-world applications and serves as a guide for developers to "
"understand and implement these tools effectively."
msgstr "在本分章中，读者将看到演示使用 `starknet-js` 的实际示例。它提供了对真实世界应用的洞察，可作为开发人员理解和有效实施这些工具的指南。"

#: src/ch02-07-01-examples.md:5 src/ch02-08-01-examples.md:5
msgid "We value the contribution of our developer community:"
msgstr "我们重视开发人员社区的贡献："

#: src/ch02-07-01-examples.md:7 src/ch02-08-01-examples.md:7
msgid ""
"- We encourage developers to contribute additional examples.\n"
"- Please inform us if you identify any mistakes or inaccuracies."
msgstr ""
"- 我们鼓励开发人员提供更多示例。\n"
"- 如果您发现任何错误或不准确之处，请通知我们。"

#: src/ch02-07-01-examples.md:10 src/ch02-08-01-examples.md:10
msgid "Your insights and feedback are instrumental in making this resource more comprehensive and accurate."
msgstr "您的见解和反馈有助于使本资料更加全面和准确。"

#: src/ch02-07-01-00-counter-ui.md:1
msgid "# Counter Smart Contract UI Integration"
msgstr "# 计数器智能合约用户界面集成"

#: src/ch02-07-01-00-counter-ui.md:3
msgid "This guide walks readers through integrating a simple counter smart contract with a frontend. By the end of this guide, readers will understand how to:"
msgstr "本指南指导读者如何将简单的计数器智能合约与前端集成。在本指南结束时，读者将了解如何："

#: src/ch02-07-01-00-counter-ui.md:5
msgid ""
"- Connect the frontend to a smart contract.\n"
"- Initiate transactions, such as incrementing or decrementing the counter.\n"
"- Read and display data, such as showing the counter value on the frontend."
msgstr ""
"- 将前端连接到智能合约。\n"
"- 启动交易，如递增或递减计数器。\n"
"- 读取和显示数据，如在前端显示计数器值。"

#: src/ch02-07-01-00-counter-ui.md:9 src/ch02-07-01-00-counter-ui.md:237
msgid ""
"For a visual walkthrough, do check out the [Basecamp frontend session](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view). This comprehensive session delves deeper into the "
"nuances of the concepts we've touched upon, presenting a mix of theoretical explanations and hands-on demonstrations."
msgstr ""
"要获得直观的演示，请查看 [Basecamp 前端课程](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view)。这节综合课程深入探讨了我们所涉及概念的细微差别，既有理论解释，也有实践演示。"

#: src/ch02-07-01-00-counter-ui.md:11
msgid "## Tools Used"
msgstr "## 使用的工具"

#: src/ch02-07-01-00-counter-ui.md:13
msgid ""
"- [Reactjs](https://react.dev/learn/start-a-new-react-project): A frontend building framework.\n"
"- [@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet): A wrapper for **[starknet.js](https://github.com/0xs34n/starknet.js)**, aiding interaction with wallet extensions.\n"
"- [starknet](https://www.npmjs.com/package/starknet): A JavaScript library for Starknet."
msgstr ""
"- [Reactjs](https://react.dev/learn/start-a-new-react-project)：前端构建框架。\n"
"- [@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet)：是**[starknet.js](https://github.com/0xs34n/starknet.js)**的一个封装，可帮助与钱包扩展进行交互。\n"
"- [starknet](https://www.npmjs.com/package/starknet)：Starknet的 JavaScript 库。"

#: src/ch02-07-01-00-counter-ui.md:17
msgid "## Setting Up the Environment"
msgstr "## 配置环境"

#: src/ch02-07-01-00-counter-ui.md:19
msgid "To begin, clone the project repository:"
msgstr "首先，克隆项目仓库："

#: src/ch02-07-01-00-counter-ui.md:21
msgid ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"
msgstr ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:25
msgid "Then, navigate to the project directory and install necessary packages:"
msgstr "然后，导航至项目目录并安装必要的软件包："

#: src/ch02-07-01-00-counter-ui.md:27
msgid ""
"```bash\n"
"cd basecamp-frontend-boilerplate\n"
"npm install\n"
"```"
msgstr ""
"```bash\n"
"cd basecamp-frontend-boilerplate\n"
"npm install\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:32
msgid "To launch the project, run:"
msgstr "要启动该项目，请运行："

#: src/ch02-07-01-00-counter-ui.md:34
msgid ""
"```bash\n"
"yarn start\n"
"```"
msgstr ""
"```bash\n"
"yarn start\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:38
msgid "In `index.js`, several key functions are provided:"
msgstr "在 `index.js` 中，提供了几个关键函数："

#: src/ch02-07-01-00-counter-ui.md:40
msgid ""
"```javascript\n"
"// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
"const connectWallet = async () => {};\n"
"\n"
"// Terminate the connection\n"
"const disconnectWallet = async () => {};\n"
"\n"
"// Trigger increment\n"
"const increaseCounter = async () => {};\n"
"\n"
"// Trigger decrement\n"
"const decreaseCounter = async () => {};\n"
"\n"
"// Retrieve current count\n"
"const getCounter = async () => {};\n"
"```"
msgstr ""
"```javascript\n"
"// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
"const connectWallet = async () => {};\n"
"\n"
"// Terminate the connection\n"
"const disconnectWallet = async () => {};\n"
"\n"
"// Trigger increment\n"
"const increaseCounter = async () => {};\n"
"\n"
"// Trigger decrement\n"
"const decreaseCounter = async () => {};\n"
"\n"
"// Retrieve current count\n"
"const getCounter = async () => {};\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:57
msgid "## Managing Connection"
msgstr "## 管理连接"

#: src/ch02-07-01-00-counter-ui.md:59
msgid "### `connectWallet`"
msgstr "### `connectWallet` （连接钱包）"

#: src/ch02-07-01-00-counter-ui.md:61
msgid ""
"The `connectWallet` function serves as the mechanism to establish a connection to the blockchain through specific wallet providers such as ArgentX or Braavos. It is asynchronous, allowing the use "
"of `await` for handling asynchronous tasks."
msgstr "`connectWallet` 函数是通过 ArgentX 或 Braavos 等特定钱包提供商与区块链建立连接的机制。它是异步的，允许使用 `await` 来处理异步任务。"

#: src/ch02-07-01-00-counter-ui.md:63
msgid ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:74
msgid ""
"- Initiates the connection using the **`connect`** method from the **`@argent/get-starknet`** library, targeting Starknet.\n"
"- Upon a successful connection, updates the React component's state with details of the **`connection`**, **`account`**, and **`selectedAddress`**."
msgstr ""
"- 使用**`@argent/get-starknet`**库中的**`connect`**方法启动连接，目标为Starknet。\n"
"- 连接成功后，用**`connection`**、**`account`**和**`selectedAddress`**的详细信息更新 React 组件的状态。"

#: src/ch02-07-01-00-counter-ui.md:77
msgid "### `disconnectWallet`"
msgstr "###`disconnectWallet` （断开钱包连接）"

#: src/ch02-07-01-00-counter-ui.md:79
msgid "The `disconnectWallet` function is designed to sever the connection with the web wallet asynchronously. After disconnection, it updates the component's state, resetting connection details."
msgstr "`disconnectWallet`函数旨在异步断开与网络钱包的连接。断开连接后，它会更新组件的状态，重置连接详情。"

#: src/ch02-07-01-00-counter-ui.md:81
msgid ""
"```bash\n"
"const disconnectWallet = async() => {\n"
"    await disconnect();\n"
"    setConnection(undefined);\n"
"    setAccount(undefined);\n"
"    setAddress('');\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"const disconnectWallet = async() => {\n"
"    await disconnect();\n"
"    setConnection(undefined);\n"
"    setAccount(undefined);\n"
"    setAddress('');\n"
"}\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:90
msgid ""
"- It utilizes the **`disconnect`** function, possibly from an external library, and handles the operation asynchronously with **`await`**.\n"
"- Post-disconnection, the state of the React component is updated:\n"
"  - **`setConnection`** is set to **`undefined`**.\n"
"  - **`setAccount`** is set to **`undefined`**.\n"
"  - **`setAddress`** is cleared with an empty string."
msgstr ""
"- 它利用**`disconnect`**函数（可能来自外部库），并通过**`await`**异步处理操作。\n"
"- 断开连接后，React 组件的状态会被更新：\n"
"  - **`setConnection`**被设置为**`undefined`**。\n"
"  - 将**`setAccount`**设置为**`undefined`**。\n"
"  - **`setAddress`**被清除为空字符串。"

#: src/ch02-07-01-00-counter-ui.md:96
msgid "### `EagerlyConnect`"
msgstr "### `EagerlyConnect`"

#: src/ch02-07-01-00-counter-ui.md:98
msgid "The `EagerlyConnect` mechanism leverages React's `useEffect` hook to initiate a connection to Starknet upon the component's mounting or initial rendering."
msgstr "`EagerlyConnect`机制利用 React 的 `useEffect` 钩子，在组件挂载或初始渲染时启动与Starknet的连接。"

#: src/ch02-07-01-00-counter-ui.md:100
msgid ""
"```javascript\n"
"useEffect(() => {\n"
"  const connectToStarknet = async () => {\n"
"    const connection = await connect({\n"
"      modalMode: \"neverAsk\",\n"
"      webWalletUrl: \"https://web.argent.xyz\",\n"
"    });\n"
"\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"  };\n"
"  connectToStarknet();\n"
"}, []);\n"
"```"
msgstr ""
"```javascript\n"
"useEffect(() => {\n"
"  const connectToStarknet = async () => {\n"
"    const connection = await connect({\n"
"      modalMode: \"neverAsk\",\n"
"      webWalletUrl: \"https://web.argent.xyz\",\n"
"    });\n"
"\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"  };\n"
"  connectToStarknet();\n"
"}, []);\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:118
msgid ""
"- Inside the **`useEffect`**, the **`connectToStarknet`** function is defined, aiming to establish an asynchronous connection using the **`connect`** function. Parameters like **`modalMode`** and "
"**`webWalletUrl`** are passed to guide the connection process.\n"
"- If successful in connecting (**`connection && connection.isConnected`**), the state updates with details of the connection, the account, and the selected address using **`setConnection`**, "
"**`setAccount`**, and **`setAddress`**.\n"
"- The **`connectToStarknet`** function is executed immediately after its definition."
msgstr ""
"- 在**`useEffect`**内部，定义了**`connectToStarknet`**函数，旨在使用**`connect`**函数建立异步连接。传递**`modalMode`**和**`webWalletUrl`**等参数是为了指导连接过程。\n"
"- 如果连接成功（**`connection && connection.isConnected`**），则使用**`setConnection`**、**`setAccount`**和**`setAddress`**更新状态，包括连接、账户和所选地址的详细信息。\n"
"- **`connectToStarknet`**函数在定义后立即执行。"

#: src/ch02-07-01-00-counter-ui.md:122
msgid "## Important Refresher on Smart Contract Interactions"
msgstr "## 智能合约交互的要点回顾"

#: src/ch02-07-01-00-counter-ui.md:124
msgid ""
"For effective interaction with a smart contract on the network, it's crucial to understand key components after establishing a connection. Among these are the `contract address`, `ABI`, `Signer`, "
"and `Provider`."
msgstr "要与网络上的智能合约进行有效交互，关键是要了解建立连接后的关键组件。其中包括 `contract address`, `ABI`, `Signer`, 和 `Provider`.。"

#: src/ch02-07-01-00-counter-ui.md:126
msgid "### ABI (Application Binary Interface)"
msgstr "### ABI - 应用二进制接口"

#: src/ch02-07-01-00-counter-ui.md:128
msgid "ABI is a standardized bridge between two binary program modules. It is essential for:"
msgstr "ABI 是两个二进制程序模块之间的标准化桥梁。它对以下方面至关重要："

#: src/ch02-07-01-00-counter-ui.md:130
msgid ""
"- Interacting with smart contracts on the blockchain.\n"
"- Specifying the structure of functions, events, and variables for software applications.\n"
"- Enabling smooth communication with the smart contract, detailing function signatures, input/output types, event formats, and variable types.\n"
"- Facilitating invocation of functions and data retrieval from the contract."
msgstr ""
"- 与区块链上的智能合约交互。\n"
"- 为软件应用程序指定函数、事件和变量的结构。\n"
"- 实现与智能合约的顺畅通信，详细说明函数签名、输入/输出类型、事件格式和变量类型。\n"
"- 方便调用函数和从合约中检索数据。"

#: src/ch02-07-01-00-counter-ui.md:135
msgid "### Signer"
msgstr "### 签名者"

#: src/ch02-07-01-00-counter-ui.md:137
msgid "The Signer plays a pivotal role in:"
msgstr "签名者在以下方面发挥着关键作用："

#: src/ch02-07-01-00-counter-ui.md:139
msgid ""
"- Signing transactions.\n"
"- Authorizing actions on the blockchain.\n"
"- Bearing the fees associated with blockchain operations."
msgstr ""
"- 签署交易。\n"
"- 授权区块链上的操作。\n"
"- 承担与区块链操作相关的费用。"

#: src/ch02-07-01-00-counter-ui.md:143
msgid "Signers are especially linked to write operations that change the state of the blockchain. These operations need cryptographic signing for security and validity."
msgstr "签名者与改变区块链状态的写入操作尤其相关。这些操作需要加密签名来保证安全性和有效性。"

#: src/ch02-07-01-00-counter-ui.md:147
msgid "The Provider acts as the medium for:"
msgstr "提供者充当以下活动的媒介："

#: src/ch02-07-01-00-counter-ui.md:149
msgid ""
"- Communication with the blockchain.\n"
"- Creating transactions.\n"
"- Fetching data from the blockchain."
msgstr ""
"- 与区块链通信。\n"
"- 创建交易。\n"
"- 从区块链获取数据。"

#: src/ch02-07-01-00-counter-ui.md:153
msgid "To initiate a write transaction, the connected account (signer) must be provided. This signer then signs the transaction, bearing the necessary fee for execution."
msgstr "要启动写入交易，必须提供连接账户（签名者）。签名者随后签署交易，并承担执行所需的费用。"

#: src/ch02-07-01-00-counter-ui.md:155
msgid "## Invoking the `increment` Function"
msgstr "## 调用 `increment` 函数"

#: src/ch02-07-01-00-counter-ui.md:157
msgid ""
"```javascript\n"
"const increaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.increment();\n"
"    alert(\"You successfully incremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```javascript\n"
"const increaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.increment();\n"
"    alert(\"You successfully incremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:169
msgid "The **`increaseCounter`** function is crafted to interact with a smart contract and increment a specific counter. Here's a step-by-step breakdown:"
msgstr "**`increaseCounter`**函数用于与智能合约交互并递增特定计数器。下面是按照步骤的分解讲解："

#: src/ch02-07-01-00-counter-ui.md:171
msgid ""
"1. Establishes a new contract instance using the provided contract's ABI, its address, and the connected account. The account is essential since this write transaction alters the contract's state.\n"
"2. Executes the contract's **`increment`** method. The **`await`** keyword ensures the program pauses until this action completes.\n"
"3. On successful execution, the user receives a confirmation alert indicating the counter's increment.\n"
"4. In case of any errors during the process, an alert displays the corresponding error message to the user."
msgstr ""
"1.使用提供的合约 ABI、合约地址和连接的账户建立一个新合约实例。账户是必不可少的，因为这个写入事务会改变合约的状态。\n"
"2.执行合约的 **`increment`** 方法。**`await`**关键字确保程序暂停，直到该操作完成。\n"
"3.执行成功后，用户会收到计数器递增的确认提示。\n"
"4.如果在执行过程中出现任何错误，警报会向用户显示相应的错误信息。"

#: src/ch02-07-01-00-counter-ui.md:176
msgid "## Invoking the `decrement` Function"
msgstr "## 调用 `decrement` 函数"

#: src/ch02-07-01-00-counter-ui.md:178
msgid ""
"```javascript\n"
"const decreaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.decrement();\n"
"    alert(\"You successfully decremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```javascript\n"
"const decreaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.decrement();\n"
"    alert(\"You successfully decremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:190
msgid "The **`decreaseCounter`** function is designed to interact with a smart contract and decrement a specific counter. Here's a succinct breakdown of its operation:"
msgstr "递减计数器（**`decreaseCounter`** ）函数旨在与智能合约交互，让一个特定的计数器递减。下面是其操作的简要说明："

#: src/ch02-07-01-00-counter-ui.md:192
msgid ""
"1. Creates a new contract instance by utilizing the provided contract's ABI, its address, and the connected account. The account is vital as this write transaction modifies the contract's state.\n"
"2. Initiates the contract's **`decrement`** method. With the use of the **`await`** keyword, the program ensures it waits for the decrement action to finalize.\n"
"3. Upon successful execution, the user is notified with an alert indicating the counter's decrement.\n"
"4. Should any errors arise during the interaction, the user is promptly alerted with the pertinent error message."
msgstr ""
"1.利用提供的合约 ABI、地址和连接的账户创建新合约实例。账户至关重要，因为该写入事务会修改合约的状态。\n"
"2.启动合约的 **`decrement`** 方法。使用**`await`**关键字，程序可确保等待递减操作最终完成。\n"
"3.执行成功后，用户会收到计数器递减的警报。\n"
"4.如果在交互过程中出现任何错误，用户会立即收到相关错误信息的提示。"

#: src/ch02-07-01-00-counter-ui.md:197
msgid "## Fetching the Current Count with `get_current_count` Function"
msgstr "## 使用`get_current_count`函数获取当前计数"

#: src/ch02-07-01-00-counter-ui.md:199
msgid ""
"```javascript\n"
"const getCounter = async () => {\n"
"  const provider = new Provider({\n"
"    sequencer: { network: constants.NetworkName.SN_MAIN },\n"
"  });\n"
"  try {\n"
"    const mycontract = new Contract(contractAbi, contractAddress, provider);\n"
"    const num = await mycontract.get_current_count();\n"
"    setRetrievedValue(num.toString());\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```javascript\n"
"const getCounter = async () => {\n"
"  const provider = new Provider({\n"
"    sequencer: { network: constants.NetworkName.SN_MAIN },\n"
"  });\n"
"  try {\n"
"    const mycontract = new Contract(contractAbi, contractAddress, provider);\n"
"    const num = await mycontract.get_current_count();\n"
"    setRetrievedValue(num.toString());\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:214
msgid "The **`getCounter`** function is designed to retrieve the current count from a smart contract. Here's a breakdown of its operation:"
msgstr "**`getCounter`**函数旨在从智能合约中获取当前计数。下面是该函数的具体操作："

#: src/ch02-07-01-00-counter-ui.md:216
msgid ""
"1. Establishes a provider instance, specifying the sequencer network – in this instance, it's set to the **`mainnet`** through **`constants.NetworkName.SN_MAIN`**.\n"
"2. With this provider, it then initiates a contract instance using the provided contract's ABI, its address, and the aforementioned provider.\n"
"3. The function then invokes the **`get_current_count`** method of the contract to fetch the current count. This is an asynchronous action, and the program waits for its completion with the "
"**`await`** keyword.\n"
"4. Once successfully retrieved, the count, which is presumably a number, is converted to a string and stored using the **`setRetrievedValue`** function.\n"
"5. In the event of any errors during the process, an alert provides the user with the relevant error message."
msgstr ""
"1.建立提供商实例，指定排序器网络--在本例中，通过**`constants.NetworkName.SN_MAIN`** 将其设置为**`mainnet`**。\n"
"2.有了这个提供商，它就会使用所提供的合约 ABI、合约地址和上述提供商启动合约实例。\n"
"3.然后，函数会调用合约的 **`get_current_count`** 方法来获取当前计数。这是一个异步操作，程序会使用**`await`**关键字等待其完成。\n"
"4.一旦成功获取，计数（可能是一个数字）将被转换为字符串，并使用 **`setRetrievedValue`** 函数进行存储。\n"
"5.如果过程中出现任何错误，系统会发出警报，向用户提供相关的错误信息。"

#: src/ch02-07-01-00-counter-ui.md:222
msgid ""
"It's essential to emphasize that while performing read operations, like fetching data from a blockchain network, the function uses the provider. Unlike write operations, which typically require a "
"signer (or an account) for transaction signing, read operations don't mandate such authentication. Thus, in this function, only the provider is specified, and not the signer."
msgstr ""
"必须强调的是，在执行读取操作（如从区块链网络中获取数据）时，该功能使用的是提供商。与通常需要签名者（或账户）进行交易签名的写入操作不同，读取操作并不强制要求进行此类身份验证。因此，在该函数中，只指定"
"了提供商，而没有指定签名者。"

#: src/ch02-07-01-00-counter-ui.md:224
msgid "## Wrapping It Up: Integrating a Frontend with a Counter Smart Contract"
msgstr "## 合而为一：将前端与计数器智能合约整合在一起"

#: src/ch02-07-01-00-counter-ui.md:226
msgid "In this tutorial, we review the process of integrating a basic counter smart contract with a frontend application."
msgstr "在本教程中，我们将回顾将基本计数器智能合约与前端应用程序集成的过程。"

#: src/ch02-07-01-00-counter-ui.md:228
msgid "Here's a quick recap:"
msgstr "下面是简要回顾："

#: src/ch02-07-01-00-counter-ui.md:230
msgid ""
"1. **Establishing Connection**: With the **`connectWallet`** function, we made seamless connections to the blockchain, paving the way for interactions with our smart contract.\n"
"2. **Terminating Connection**: The **`disconnectWallet`** function ensures that users can safely terminate their active connections to the blockchain, maintaining security and control.\n"
"3. **Interacting with the Smart Contract**: Using the **`increaseCounter`**, **`decreaseCounter`**, and **`getCounter`** functions, we explored how to:\n"
"   - Initiate transactions\n"
"   - Adjust the counter value (increment or decrement)\n"
"   - Fetch data from the blockchain"
msgstr ""
"1. **建立连接**：通过**`connectWallet`**函数，我们与区块链建立了无缝连接，为与我们的智能合约进行交互铺平了道路。\n"
"2. **终止连接**：通过**`disconnectWallet`**函数，用户可以安全地终止与区块链的活动连接，从而维护安全和控制。\n"
"3. **与智能合约交互**：使用**`increaseCounter`**、**`decreaseCounter`**和**`getCounter`**函数，我们探索了如何：\n"
"   - 启动交易\n"
"   - 调整计数器值（递增或递减）\n"
"   - 从区块链中获取数据"

#: src/ch02-07-01-01-erc20-ui.md:1 src/ch02-08-01-01-erc20-ui.md:1
msgid "# ERC-20 UI"
msgstr "# ERC-20 UI"

#: src/ch02-07-01-01-erc20-ui.md:3
msgid "This guide offers steps to build an ERC20 smart contract using Cairo and to incorporate it within a React web application with StarknetJS. Readers will:"
msgstr "本指南提供了使用 Cairo 构建 ERC20 智能合约的步骤，并将其纳入使用 StarknetJS 的 React Web 应用程序中。读者将："

#: src/ch02-07-01-01-erc20-ui.md:5 src/ch02-08-01-01-erc20-ui.md:5
msgid ""
"- Understand how to implement the ERC20 interface\n"
"- Learn how to deploy contracts on the Starknet network\n"
"- Discover ways to engage with contracts within a React application\n"
"- Design their own ERC20 token and initiate it on Starknet"
msgstr ""
"- 了解如何实现 ERC20 接口\n"
"- 了解如何在 Starknet 网络上部署合约\n"
"- 探索在 React 应用程序中使用合约的方法\n"
"- 设计自己的 ERC20 Token并在 Starknet 上启动它"

#: src/ch02-07-01-01-erc20-ui.md:10
msgid "A prerequisite for this guide is a foundational understanding of both the Cairo programming language and StarknetJS. Additionally, ensure Node.js and NPM are installed on the system."
msgstr "本指南的前提条件是对 Cairo 编程语言和 StarknetJS 有基本的了解。此外，确保系统上已安装 Node.js 和 NPM。"

#: src/ch02-07-01-01-erc20-ui.md:12 src/ch02-08-01-01-erc20-ui.md:12
msgid "The example will walk through creating an ERC20 token named MKT and crafting a web3 interface for functionalities such as balance verification and token transfer."
msgstr "该示例将介绍如何创建一个名为 MKT 的 ERC20 代币，并为余额验证和代币转移等功能创建一个 web3 界面。"

#: src/ch02-07-01-01-erc20-ui.md:14
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:16 src/ch02-08-01-01-erc20-ui.md:16
msgid "Throughout this guide, the following tools and libraries will be utilized:"
msgstr "本指南将使用以下工具和库："

#: src/ch02-07-01-01-erc20-ui.md:18
msgid ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- StarknetJS v5.19.5\n"
"- get-starknet v3.0.1\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.5.5\n"
"- Visual Studio Code\n"
"- Vercel"
msgstr ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- StarknetJS v5.19.5\n"
"- get-starknet v3.0.1\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.5.5\n"
"- Visual Studio Code\n"
"- Vercel"

#: src/ch02-07-01-01-erc20-ui.md:28 src/ch02-08-01-01-erc20-ui.md:27
msgid "## Initiating a New Starknet Project"
msgstr "## 启动新的Starknet项目"

#: src/ch02-07-01-01-erc20-ui.md:30 src/ch02-08-01-01-erc20-ui.md:29
msgid "Begin by establishing a new Starknet project named \"erc20\" using Scarb:"
msgstr "首先使用 Scarb 建立一个名为 \"erc20 \"的新Starknet项目："

#: src/ch02-07-01-01-erc20-ui.md:32 src/ch02-08-01-01-erc20-ui.md:31
msgid ""
"```bash\n"
"mkdir erc20\n"
"cd erc20\n"
"scarb init --name erc20\n"
"```"
msgstr ""
"```bash\n"
"mkdir erc20\n"
"cd erc20\n"
"scarb init --name erc20\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:38 src/ch02-08-01-01-erc20-ui.md:37
msgid "Subsequently, update the Scarb.toml to include the essential OpenZeppelin libraries. Post edits, the Scarb.toml should appear as:"
msgstr "随后，更新 Scarb.toml，使其包含 OpenZeppelin 的基本库。编辑完成后，Scarb.toml 应显示为："

#: src/ch02-07-01-01-erc20-ui.md:40
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:54 src/ch02-08-01-01-erc20-ui.md:53
msgid "## Implementing the ERC20 Token"
msgstr "## 实现 ERC20 token"

#: src/ch02-07-01-01-erc20-ui.md:56 src/ch02-08-01-01-erc20-ui.md:55
msgid "Begin by creating a new file named `src/erc20.cairo`. In this file, the ERC20 token named MKT, along with its associated functions, will be defined:"
msgstr "首先创建一个名为`src/erc20.cairo`的新文件。在该文件中，将定义名为 MKT 的 ERC20 代币及其相关函数："

#: src/ch02-07-01-01-erc20-ui.md:58 src/ch02-08-01-01-erc20-ui.md:57
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    #[generate_trait]\n"
"    impl Ierc20Impl of Ierc20 {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    #[generate_trait]\n"
"    impl Ierc20Impl of Ierc20 {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:97
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:99 src/ch02-08-01-01-erc20-ui.md:98
msgid "Now edit `src/lib.cairo` and replace the content with:"
msgstr "现在编辑 `src/lib.cairo`，将内容替换为"

#: src/ch02-07-01-01-erc20-ui.md:101 src/ch02-08-01-01-erc20-ui.md:100
msgid ""
"```rust\n"
"mod erc20;\n"
"```"
msgstr ""
"```rust\n"
"mod erc20;\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:105 src/ch02-08-01-01-erc20-ui.md:104
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_lib_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_lib_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:107 src/ch02-08-01-01-erc20-ui.md:106
msgid "Upon completing your contract, proceed to compile it using Scarb:"
msgstr "完成合约后，使用 Scarb 进行编译："

#: src/ch02-07-01-01-erc20-ui.md:113
msgid "Subsequent to the compilation, declare the smart contract on the Starknet testnet (using your own account and keystore):"
msgstr "编译完成后，在Starknet测试网上声明智能合约（使用你自己的账户和keystore）："

#: src/ch02-07-01-01-erc20-ui.md:115 src/ch02-08-01-01-erc20-ui.md:114
msgid ""
"```bash\n"
"starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 --watch\n"
"```"
msgstr ""
"```bash\n"
"starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 --watch\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:119 src/ch02-07-01-01-erc20-ui.md:146 src/ch02-08-01-01-erc20-ui.md:118 src/ch02-08-01-01-erc20-ui.md:145
msgid "The output should appear similar to:"
msgstr "输出结果应类似于："

#: src/ch02-07-01-01-erc20-ui.md:121 src/ch02-08-01-01-erc20-ui.md:120
msgid ""
"```bash\n"
"Enter keystore password:\n"
"Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"... [shortened for brevity]\n"
"Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"... [shortened for brevity]\n"
"Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:128 src/ch02-08-01-01-erc20-ui.md:127
msgid "In cases where no modifications have been made to the provided contract, a notification will indicate that the contract has previously been declared on Starknet:"
msgstr "如果你没有对所提供的合约进行修改，则会有一个显示该合约之前已在Starknet声明的通知出现："

#: src/ch02-07-01-01-erc20-ui.md:130 src/ch02-08-01-01-erc20-ui.md:129
msgid ""
"```bash\n"
"Enter keystore password:\n"
"Not declaring class as it's already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"Not declaring class as it's already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:135 src/ch02-08-01-01-erc20-ui.md:134
msgid "## Deploying the ERC20 Contract"
msgstr "## 部署 ERC20 合约"

#: src/ch02-07-01-01-erc20-ui.md:137 src/ch02-08-01-01-erc20-ui.md:136
msgid "Proceed to deploy the MKT Token using Starkli. Provide these arguments for successful deployment:"
msgstr "继续使用 Starkli 部署 MKT 代币。想要成功部署需提供这些参数："

#: src/ch02-07-01-01-erc20-ui.md:139
msgid ""
"- `Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 \\* 10^18 or 0xd3c21bcecceda1000000. Due to the "
"contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively.\n"
"- `Receiver address`: Use a preferred address who wiil be the initial recipient of 1,000,000 MKT. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""
"- `Initial mint`：铸造 1,000,000 个代币。鉴于 MKT 代币包含 18 位小数（OpenZeppelin 的标准），所需的输入为 1,000,000 \\* 10^18 或 0xd3c21bcecceda1000000。由于合约期望的是 u256 类型的铸币值，因此需要"
"同时提供低值和高值：分别为 0xd3c21bcecceda1000000 和 0。\n"
"- `Receiver address`：接收者地址可以使用任何你掌控的地址。例如：0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#: src/ch02-07-01-01-erc20-ui.md:142 src/ch02-08-01-01-erc20-ui.md:141
msgid ""
"```bash\n"
"starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 "
"0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc\n"
"```"
msgstr ""
"```bash\n"
"starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 "
"0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:148 src/ch02-08-01-01-erc20-ui.md:147
msgid ""
"```bash\n"
"Enter keystore password:\n"
"... [shortened for brevity]\n"
"Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\n"
"```"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"... [shortened for brevity]\n"
"Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:154 src/ch02-08-01-01-erc20-ui.md:153
msgid "NOTE: The deployed address received will differ for every user. Retain this address, as it will replace instances in subsequent TypeScript files to match the specific contract address."
msgstr "注意：每个用户收到的部署地址都不同。请保留此地址，因为它将替换后续 TypeScript 文件中的实例，以匹配特定的合约地址。"

#: src/ch02-07-01-01-erc20-ui.md:156 src/ch02-08-01-01-erc20-ui.md:155
msgid "Well done! The Cairo ERC20 smart contract has been deployed successfully on Starknet."
msgstr "干得漂亮！Cairo ERC20 智能合约已在Starknet成功部署。"

#: src/ch02-07-01-01-erc20-ui.md:158 src/ch02-08-01-01-erc20-ui.md:173
msgid "## Setting Up a New React Project"
msgstr "## 设置新的 React 项目"

#: src/ch02-07-01-01-erc20-ui.md:160
msgid ""
"With the contract in place, initiate the development of the web application. Begin by\n"
"setting up our react project. To do this, Nextjs framework provides the `create-next-app` script that streamlines the setup of a Nextjs application:"
msgstr "合约部署完成后后，我们可以开始开发网络应用程序。首先设置我们的 react 项目。为此，Nextjs 框架提供了 \"create-next-app \"脚本，可简化 Nextjs 应用程序的设置："

#: src/ch02-07-01-01-erc20-ui.md:163
msgid ""
"```bash\n"
"npx create-next-app@latest erc20_web --use-npm\n"
"✔ Would you like to use TypeScript? … Yes\n"
"✔ Would you like to use ESLint? … Yes\n"
"✔ Would you like to use Tailwind CSS? … Yes\n"
"✔ Would you like to use `src/` directory? … Yes\n"
"✔ Would you like to use App Router? (recommended) … Yes\n"
"✔ Would you like to customize the default import alias (@/*)? … No\n"
"```"
msgstr ""
"```bash\n"
"npx create-next-app@latest erc20_web --use-npm\n"
"✔ Would you like to use TypeScript? … Yes\n"
"✔ Would you like to use ESLint? … Yes\n"
"✔ Would you like to use Tailwind CSS? … Yes\n"
"✔ Would you like to use `src/` directory? … Yes\n"
"✔ Would you like to use App Router? (recommended) … Yes\n"
"✔ Would you like to customize the default import alias (@/*)? … No\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:173
msgid "Then, you should see something like this:"
msgstr "然后，你应该会看到类似这样的内容："

#: src/ch02-07-01-01-erc20-ui.md:175
msgid ""
"```bash\n"
"Creating a new Next.js app in /home/kali/cairo/erc20_web.\n"
"Using npm.\n"
"Initializing project with template: app-tw\n"
"Installing dependencies:\n"
"- react\n"
"- react-dom\n"
"- next\n"
"\n"
"... [shortened for brevity]\n"
"\n"
"Initialized a git repository.\n"
"Success! Created erc20_web at /home/kali/cairo/erc20_web\n"
"```"
msgstr ""
"```bash\n"
"Creating a new Next.js app in /home/kali/cairo/erc20_web.\n"
"Using npm.\n"
"Initializing project with template: app-tw\n"
"Installing dependencies:\n"
"- react\n"
"- react-dom\n"
"- next\n"
"\n"
"... [shortened for brevity]\n"
"\n"
"Initialized a git repository.\n"
"Success! Created erc20_web at /home/kali/cairo/erc20_web\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:190
msgid "## Installing the Starknet.js Library"
msgstr "## 安装 Starknet.js 库"

#: src/ch02-07-01-01-erc20-ui.md:192
msgid "Now, let's install the starknet.js and recommended get-starknet (manage wallet connections) libraries:"
msgstr "现在，让我们安装 starknet.js 和推荐的 get-starknet（管理钱包连接）库："

#: src/ch02-07-01-01-erc20-ui.md:194
msgid ""
"```bash\n"
"cd erc20_web\n"
"npm install get-starknet\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web\n"
"npm install get-starknet\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:199 src/ch02-07-01-01-erc20-ui.md:213
msgid "You should see something like this:"
msgstr "你应该看到这样的内容："

#: src/ch02-07-01-01-erc20-ui.md:201
msgid ""
"```bash\n"
"added 3 packages, changed 1 package, and audited 1549 packages in 7s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"
msgstr ""
"```bash\n"
"added 3 packages, changed 1 package, and audited 1549 packages in 7s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:207
msgid "Install starknetJS:"
msgstr "安装 starknetJS："

#: src/ch02-07-01-01-erc20-ui.md:209
msgid ""
"```bash\n"
"npm install starknet\n"
"```"
msgstr ""
"```bash\n"
"npm install starknet\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:215
msgid ""
"```bash\n"
"added 18 packages, and audited 1546 packages in 6s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"
msgstr ""
"```bash\n"
"added 18 packages, and audited 1546 packages in 6s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:221
msgid "Post-installation, confirm the version of the Starknet.js library:"
msgstr "安装后，确认 Starknet.js 库的版本："

#: src/ch02-07-01-01-erc20-ui.md:223
msgid ""
"```bash\n"
"npm list starknet\n"
"\n"
"npm list get-starknet\n"
"```"
msgstr ""
"```bash\n"
"npm list starknet\n"
"\n"
"npm list get-starknet\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:229
msgid "The output should display the installed version, such as `starknet@5.19.5` and `get-starknet@3.0.1`."
msgstr "输出结果应显示已安装的版本，如 `starknet@5.19.5` 和 `get-starknet@3.0.1`。"

#: src/ch02-07-01-01-erc20-ui.md:231
msgid "## Building our Project"
msgstr "## 编译我们的项目"

#: src/ch02-07-01-01-erc20-ui.md:233
msgid "Once set up, make modifications to `erc20_web/src/app/layout.tsx` by replacing its content with the following code:"
msgstr "设置完成后，用以下代码替换 `erc20_web/src/app/layout.tsx` 中的内容，对其进行修改："

#: src/ch02-07-01-01-erc20-ui.md:235
msgid ""
"```typescript\n"
"import type { Metadata } from 'next'\n"
"\n"
"export const metadata: Metadata = {\n"
"  title: 'Create Next App',\n"
"  description: 'Generated by create next app',\n"
"}\n"
"\n"
"export default function RootLayout({\n"
"  children,\n"
"}: {\n"
"  children: React.ReactNode\n"
"}) {\n"
"  return (\n"
"    <html lang=\"en\">\n"
"      <body>{children}</body>\n"
"    </html>\n"
"  )\n"
"}\n"
"\n"
"```"
msgstr ""
"```typescript\n"
"import type { Metadata } from 'next'\n"
"\n"
"export const metadata: Metadata = {\n"
"  title: 'Create Next App',\n"
"  description: 'Generated by create next app',\n"
"}\n"
"\n"
"export default function RootLayout({\n"
"  children,\n"
"}: {\n"
"  children: React.ReactNode\n"
"}) {\n"
"  return (\n"
"    <html lang=\"en\">\n"
"      <body>{children}</body>\n"
"    </html>\n"
"  )\n"
"}\n"
"\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:257
msgid "Now, edit `erc20_web/src/app/page.tsx` and replace its content with the following code:"
msgstr "现在，编辑 `erc20_web/src/app/page.tsx` 并用以下代码替换其内容："

#: src/ch02-07-01-01-erc20-ui.md:259
msgid ""
"```typescript\n"
"import Head from \"next/head\";\n"
"import App from \"../components/App\";\n"
"\n"
"export default function Home() {\n"
"\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Homepage</title>\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"      <p>A basic web3 example with StarknetJS</p>\n"
"          <App />\n"
"      </main>\n"
"    </>\n"
"  );\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import Head from \"next/head\";\n"
"import App from \"../components/App\";\n"
"\n"
"export default function Home() {\n"
"\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Homepage</title>\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"      <p>A basic web3 example with StarknetJS</p>\n"
"          <App />\n"
"      </main>\n"
"    </>\n"
"  );\n"
"}\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:280 src/ch02-08-01-01-erc20-ui.md:229
msgid "## Enhancing Your React Application with Additional Features"
msgstr "## 利用附加功能改进你的 React 应用程序"

#: src/ch02-07-01-01-erc20-ui.md:282
msgid "To enhance the app's functionality, create one component (`erc20_web/src/components/App.tsx`) for balance and transfer with the following code."
msgstr "为增强应用程序的功能，请使用以下代码为余额和转账创建一个组件（`erc20_web/src/components/App.tsx`）。"

#: src/ch02-07-01-01-erc20-ui.md:284
msgid ""
"```typescript\n"
"'use client';\n"
"import { useState, useMemo } from \"react\"\n"
"import { connect, disconnect } from \"get-starknet\"\n"
"import { Contract, Provider, SequencerProvider, constants } from \"starknet\"\n"
"\n"
"const contractAddress = \"0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\"\n"
"\n"
"function App() {\n"
"  const [provider, setProvider] = useState({} as Provider)\n"
"  const [address, setAddress] = useState('')\n"
"  const [currentBlockHash, setCurrentBlockHash] = useState('')\n"
"  const [balance, setBalance] = useState('')\n"
"  const [isConnected, setIsConnected] = useState(false)\n"
"  const [recipient, setRecipient] = useState('0x');\n"
"  const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"  const disconnectWallet = async () => {\n"
"    try {\n"
"      await disconnect({ clearLastWallet: true })\n"
"      setProvider({} as Provider)\n"
"      setAddress('')\n"
"      setIsConnected(false)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const connectWallet = async () => {\n"
"    try {\n"
"      const starknet = await connect()\n"
"      if (!starknet) throw new Error(\"Failed to connect to wallet.\")\n"
"      await starknet.enable({ starknetVersion: \"v5\" })\n"
"      setProvider(starknet.account)\n"
"      setAddress(starknet.selectedAddress || '')\n"
"      setIsConnected(true)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const checkBalance = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      const data = await contract.balance_of(address)\n"
"      setBalance(data.toString())\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const transfer = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      await contract.transfer(recipient, amount)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const current_block_hash = async () => {\n"
"    try {\n"
"      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });\n"
"\n"
"      const block = await provider1.getBlock(\"latest\"); // <- Get latest block\n"
"      setCurrentBlockHash(block.block_hash);\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  current_block_hash()\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!isConnected) return ''\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`\n"
"  }, [isConnected, address])\n"
"\n"
"  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"    setRecipient(event.target.value);\n"
"  };\n"
"\n"
"  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"      setAmount(event.target.value);\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Latest block hash: {currentBlockHash}</p>\n"
"      {isConnected ?\n"
"        <div>\n"
"          <span>Connected: {shortenedAddress}</span>\n"
"          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>\n"
"          <hr />\n"
"          <p>Balance.</p>\n"
"          <p>{balance}</p>\n"
"          <p><button onClick={() => checkBalance()}>Check Balance</button></p>\n"
"          <hr />\n"
"          <p>Transfer.</p>\n"
"          <p>Recipient:\n"
"              <input\n"
"              type=\"text\"\n"
"              value={recipient}\n"
"              onChange={handleRecipientChange}\n"
"              />\n"
"          </p>\n"
"          <p>Amount (default 1 MKT with 18 decimals):\n"
"            <input\n"
"            type=\"number\"\n"
"            value={amount}\n"
"            onChange={handleAmountChange}\n"
"            />\n"
"          </p>\n"
"          <p>\n"
"            <button onClick={() => transfer()}>Transfer</button>\n"
"          </p>\n"
"          <hr/>\n"
"        </div> :\n"
"        <div>\n"
"          <span>Choose a wallet:</span>\n"
"          <p>\n"
"            <button onClick={() => connectWallet()}>Connect a Wallet</button>\n"
"          </p>\n"
"        </div>\n"
"      }\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default App;\n"
"```"
msgstr ""
"```typescript\n"
"'use client';\n"
"import { useState, useMemo } from \"react\"\n"
"import { connect, disconnect } from \"get-starknet\"\n"
"import { Contract, Provider, SequencerProvider, constants } from \"starknet\"\n"
"\n"
"const contractAddress = \"0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\"\n"
"\n"
"function App() {\n"
"  const [provider, setProvider] = useState({} as Provider)\n"
"  const [address, setAddress] = useState('')\n"
"  const [currentBlockHash, setCurrentBlockHash] = useState('')\n"
"  const [balance, setBalance] = useState('')\n"
"  const [isConnected, setIsConnected] = useState(false)\n"
"  const [recipient, setRecipient] = useState('0x');\n"
"  const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"  const disconnectWallet = async () => {\n"
"    try {\n"
"      await disconnect({ clearLastWallet: true })\n"
"      setProvider({} as Provider)\n"
"      setAddress('')\n"
"      setIsConnected(false)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const connectWallet = async () => {\n"
"    try {\n"
"      const starknet = await connect()\n"
"      if (!starknet) throw new Error(\"Failed to connect to wallet.\")\n"
"      await starknet.enable({ starknetVersion: \"v5\" })\n"
"      setProvider(starknet.account)\n"
"      setAddress(starknet.selectedAddress || '')\n"
"      setIsConnected(true)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const checkBalance = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      const data = await contract.balance_of(address)\n"
"      setBalance(data.toString())\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const transfer = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      await contract.transfer(recipient, amount)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const current_block_hash = async () => {\n"
"    try {\n"
"      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });\n"
"\n"
"      const block = await provider1.getBlock(\"latest\"); // <- Get latest block\n"
"      setCurrentBlockHash(block.block_hash);\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  current_block_hash()\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!isConnected) return ''\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`\n"
"  }, [isConnected, address])\n"
"\n"
"  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"    setRecipient(event.target.value);\n"
"  };\n"
"\n"
"  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"      setAmount(event.target.value);\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Latest block hash: {currentBlockHash}</p>\n"
"      {isConnected ?\n"
"        <div>\n"
"          <span>Connected: {shortenedAddress}</span>\n"
"          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>\n"
"          <hr />\n"
"          <p>Balance.</p>\n"
"          <p>{balance}</p>\n"
"          <p><button onClick={() => checkBalance()}>Check Balance</button></p>\n"
"          <hr />\n"
"          <p>Transfer.</p>\n"
"          <p>Recipient:\n"
"              <input\n"
"              type=\"text\"\n"
"              value={recipient}\n"
"              onChange={handleRecipientChange}\n"
"              />\n"
"          </p>\n"
"          <p>Amount (default 1 MKT with 18 decimals):\n"
"            <input\n"
"            type=\"number\"\n"
"            value={amount}\n"
"            onChange={handleAmountChange}\n"
"            />\n"
"          </p>\n"
"          <p>\n"
"            <button onClick={() => transfer()}>Transfer</button>\n"
"          </p>\n"
"          <hr/>\n"
"        </div> :\n"
"        <div>\n"
"          <span>Choose a wallet:</span>\n"
"          <p>\n"
"            <button onClick={() => connectWallet()}>Connect a Wallet</button>\n"
"          </p>\n"
"        </div>\n"
"      }\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default App;\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:429
msgid "Finally, launch the web3 application:"
msgstr "最后，启动 web3 应用程序："

#: src/ch02-07-01-01-erc20-ui.md:431 src/ch02-08-01-01-erc20-ui.md:222
msgid ""
"```bash\n"
"cd erc20_web/\n"
"npm run dev\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web/\n"
"npm run dev\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:436
msgid "Congratulations, you have your starknetjs web3 application. Now connect your wallet in goerli testnet, check your balance and transfer MKT tokens to your friends:"
msgstr "恭喜您，您已经拥有了自己的 starknetjs web3 应用程序。现在在 goerli testnet 中连接您的钱包，查看余额并将 MKT 代币转给您的朋友："

#: src/ch02-07-01-01-erc20-ui.md:438
msgid "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:440 src/ch02-08-01-01-erc20-ui.md:392
msgid "## Deploying Your Project Online"
msgstr "## 在线部署项目"

#: src/ch02-07-01-01-erc20-ui.md:442 src/ch02-08-01-01-erc20-ui.md:394
msgid "To share your application with friends and allow them to check their balances and transfer tokens, publish your app online. Vercel offers a straightforward way to do this:"
msgstr "要与朋友分享您的应用程序，并允许他们查看余额和转移代币，请在线发布您的应用程序。Vercel 提供了一种简单易行的方法："

#: src/ch02-07-01-01-erc20-ui.md:444 src/ch02-08-01-01-erc20-ui.md:396
msgid "### Set Up Vercel"
msgstr "### 设置 Vercel"

#: src/ch02-07-01-01-erc20-ui.md:446 src/ch02-08-01-01-erc20-ui.md:398
msgid ""
"1. Register for an account at [Vercel Signup](https://vercel.com/signup).\n"
"2. Install Vercel in your web application folder (`erc20_web`):"
msgstr ""
"1.在 [Vercel Signup](https://vercel.com/signup) 上注册账户。\n"
"2.在网络应用程序文件夹 (`erc20_web`) 中安装 Vercel："

#: src/ch02-07-01-01-erc20-ui.md:449
msgid ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:454 src/ch02-08-01-01-erc20-ui.md:407
msgid "3. Authenticate your Vercel account:"
msgstr "3.验证您的 Vercel 账户："

#: src/ch02-07-01-01-erc20-ui.md:456
msgid ""
"```bash\n"
"vercel login\n"
"Continue with Email (or select your preferent login method)\n"
"```"
msgstr ""
"```bash\n"
"vercel login\n"
"Continue with Email (or select your preferent login method)\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:461 src/ch02-08-01-01-erc20-ui.md:413
msgid "After entering your email, check your inbox and click on the \"Verify\" button."
msgstr "输入电子邮件后，检查收件箱并点击 \"Verify\"按钮。"

#: src/ch02-07-01-01-erc20-ui.md:463
msgid ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login_js.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login_js.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:467 src/ch02-08-01-01-erc20-ui.md:419
msgid "On successful verification, you'll receive a confirmation in the console."
msgstr "验证成功后，您将在控制台中收到确认信息。"

#: src/ch02-07-01-01-erc20-ui.md:469 src/ch02-08-01-01-erc20-ui.md:421
msgid "4. Link your project to Vercel:"
msgstr "4.将您的项目链接到 Vercel："

#: src/ch02-07-01-01-erc20-ui.md:471
msgid ""
"```bash\n"
"vercel link\n"
"? Set up “~/cairo/erc20_web”? [Y/n] y\n"
"? Which scope should contain your project? (just press enter)\n"
"? Link to existing project? [y/N] n\n"
"? What’s your project’s name? erc20-web\n"
"? In which directory is your code located? ./\n"
"? Want to modify these settings? [y/N] n\n"
"✅  Linked erc20-web (created .vercel)\n"
"```"
msgstr ""
"```bash\n"
"vercel link\n"
"? Set up “~/cairo/erc20_web”? [Y/n] y\n"
"? Which scope should contain your project? (just press enter)\n"
"? Link to existing project? [y/N] n\n"
"? What’s your project’s name? erc20-web\n"
"? In which directory is your code located? ./\n"
"? Want to modify these settings? [y/N] n\n"
"✅  Linked erc20-web (created .vercel)\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:482 src/ch02-08-01-01-erc20-ui.md:427
msgid "5. Upload it:"
msgstr "5.上传："

#: src/ch02-07-01-01-erc20-ui.md:484 src/ch02-08-01-01-erc20-ui.md:429
msgid ""
"```bash\n"
"vercel\n"
"```"
msgstr ""
"```bash\n"
"vercel\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:488 src/ch02-08-01-01-erc20-ui.md:433
msgid "6. Publish your project:"
msgstr "6.发布您的项目："

#: src/ch02-07-01-01-erc20-ui.md:490
msgid ""
"```bash\n"
"vercel --prod\n"
"✅  Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]\n"
"```"
msgstr ""
"```bash\n"
"vercel --prod\n"
"✅  Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:495
msgid "Check your production URL and congratulations! Your MKT token web3 application is now accessible to everyone."
msgstr "检查您的生产 URL，然后恭喜您！现在所有人都可以访问您的 MKT 代币的 web3 应用程序了。"

#: src/ch02-07-01-01-erc20-ui.md:497
msgid "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:499 src/ch02-08-01-01-erc20-ui.md:443
msgid "Engage with your app by:"
msgstr "通过以下方式与您的应用程序交互："

#: src/ch02-07-01-01-erc20-ui.md:501 src/ch02-08-01-01-erc20-ui.md:445
msgid "- Connecting your wallet:"
msgstr "- 连接您的钱包："

#: src/ch02-07-01-01-erc20-ui.md:503
msgid "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:505 src/ch02-08-01-01-erc20-ui.md:449
msgid "- Checking your balance:"
msgstr "- 查看余额："

#: src/ch02-07-01-01-erc20-ui.md:507
msgid "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:509 src/ch02-08-01-01-erc20-ui.md:453
msgid "- Transferring tokens:"
msgstr "- 转让代币："

#: src/ch02-07-01-01-erc20-ui.md:511
msgid "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-07-01-01-erc20-ui.md:513 src/ch02-08-01-01-erc20-ui.md:457
msgid "## Wrapping Up"
msgstr "## 总结"

#: src/ch02-07-01-01-erc20-ui.md:515
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 application using React, StarknetJS and Cairo. This application, complete with an ERC20 smart contract, offers a modern web "
"interface for user interaction. Here's a snapshot of your achievements:"
msgstr "在本教程中，您将学习使用 React、StarknetJS 和 Cairo 制作 Web3 应用程序的步骤。这个应用程序包含一个 ERC20 智能合约，为用户交互提供了一个现代化的 Web 界面。下面是您的成果快照："

#: src/ch02-07-01-01-erc20-ui.md:517
msgid ""
"- **Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries.\n"
"\n"
"- **Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
"network.\n"
"\n"
"- **React Application**: Built a React application powered by StarknetJS, featuring components dedicated to balance inquiries and token transactions.\n"
"\n"
"- **Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token "
"transactions."
msgstr ""
"- **项目初始化**：使用 Scarb 和 OpenZeppelin 库建立Starknet项目。\n"
"\n"
"- **创建 ERC20 合约**：使用Cairo开发了一个 ERC20 代币，并丰富了余额检查和代币转账等功能。然后将其编译并在Starknet上发布。\n"
"\n"
"- **React 应用程序**：构建了一个由 Starknet React 支持的 React 应用程序，其中包含专门用于余额查询和代币交易的组件。\n"
"\n"
"- **在线部署**：通过在 Vercel 上部署，将您的应用程序带给更多用户。这使得用户能够连接他们的钱包，查看他们的余额，并执行代币交易。"

#: src/ch02-07-01-01-erc20-ui.md:525 src/ch02-08-01-01-erc20-ui.md:470
msgid ""
"The insights you've gathered from this tutorial lay a solid groundwork for creating intricate web3 applications. You're now equipped with the prowess to craft more intricate decentralized "
"applications and smart contracts. The vast expanse of decentralized finance and blockchain is ripe for your innovative inputs. Dive in and happy coding!"
msgstr ""
"通过本教程的学习，您将为创建复杂的 Web3 应用程序打下坚实的基础。现在，您已经具备了制作更复杂的去中心化应用程序和智能合约的能力。去中心化金融和区块链的广阔天地正等着你的创新投入。投入其中，快乐编码！"

#: src/ch02-08-starknet-react.md:1
msgid "# Starknet-React: React Integration"
msgstr "# Starknet-React: React 集成"

#: src/ch02-08-starknet-react.md:3
msgid ""
"Several tools exist in the starknet ecosystem to build the front-end for\n"
"your application. The most popular ones are:"
msgstr ""
"Starknet生态系统中有几种工具可以为您的应用程序构建前端。\n"
"最受欢迎的工具有:"

#: src/ch02-08-starknet-react.md:6
msgid ""
"- [starknet-react](https://github.com/apibara/starknet-react)\n"
"  ([documentation](https://apibara.github.io/starknet-react)):\n"
"  Collection of React hooks for Starknet. It is inspired by\n"
"  [wagmi](https://github.com/tmm/wagmi), powered by\n"
"  [starknet.js](https://github.com/0xs34n/starknet.js).\n"
"\n"
"- [starknet.js](https://github.com/0xs34n/starknet.js): A JavaScript\n"
"  library for interacting with Starknet contracts. It would be the\n"
"  equivalent of [web3.js](https://web3js.org/) for Ethereum."
msgstr ""
"- [starknet-react](https://github.com/apibara/starknet-react)\n"
"  ([文档](https://apibara.github.io/starknet-react))：\n"
"  用于 Starknet 的 React 钩子集。其灵感来源于\n"
"  [wagmi](https://github.com/tmm/wagmi)，由\n"
"  [starknet.js](https://github.com/0xs34n/starknet.js) 开发.\n"
"\n"
"- [starknet.js](https://github.com/0xs34n/starknet.js)：一个 JavaScript库。\n"
"  它相当于以太坊的 [web3.js](https://web3js.org/)。"

#: src/ch02-08-starknet-react.md:16
msgid ""
"For Vue developers, vue-stark-boil, created by the team at [Don’t Panic\n"
"DAO](https://github.com/dontpanicdao), is a great option. For a deeper\n"
"understanding of Vue, visit their [website](https://vuejs.org/). The\n"
"vue-stark-boil boilerplate enables various functionalities, such as\n"
"connecting to a wallet, listening for account changes, and calling a\n"
"contract."
msgstr ""
"对于 Vue 开发人员来说，由 [Don't Panic DAO](https://github.com/dontpanicdao)团队创建的 vue-stark-boil 是一个不错的选择。要深入\n"
"了解 Vue，请访问他们的 [网站](https://vuejs.org/)。\n"
"vue-stark-boil 模板可实现各种功能，例如\n"
"连接到钱包、监听账户变更以及调用合约。"

#: src/ch02-08-starknet-react.md:23
msgid ""
"Authored by the [Apibara](https://github.com/apibara/) team, [Starknet\n"
"React](https://github.com/apibara/starknet-react/) is an open-source\n"
"collection of React providers and hooks meticulously designed for\n"
"Starknet."
msgstr ""
"由[Apibara](https://github.com/apibara/)团队编写的[Starknet React](https://github.com/apibara/starknet-react/)是一个开源的\n"
"，为Starknet设计的的React provider和钩子的集合。"

#: src/ch02-08-starknet-react.md:28
msgid ""
"To immerse in the real-world application of Starknet React, we recommend\n"
"exploring the comprehensive example dApp project at\n"
"[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)."
msgstr ""
"要深入了解 Starknet React 的实际应用，我们建议您\n"
"探索位于[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)上的dApp项目范例。"

#: src/ch02-08-starknet-react.md:32
msgid "## Integrating Starknet React"
msgstr "## 与Starknet React 集成"

#: src/ch02-08-starknet-react.md:34
msgid ""
"Embarking on your Starknet React journey necessitates the incorporation\n"
"of vital dependencies. Let’s start by adding them to your project."
msgstr "要开始 Starknet React 之旅，我们必须添加一些重要的依赖关系。让我们先将它们添加到您的项目中。"

#: src/ch02-08-starknet-react.md:37
msgid "yarn add @starknet-react/core starknet get-starknet"
msgstr "yarn add @starknet-react/core starknet get-starknet"

#: src/ch02-08-starknet-react.md:39
msgid ""
"[Starknet.js](https://www.starknetjs.com/) is an essential SDK\n"
"facilitating interactions with Starknet. In contrast,\n"
"[get-starknet](https://github.com/starknet-io/get-starknet/) is a\n"
"package adept at managing wallet connections."
msgstr ""
"[Starknet.js](https://www.starknetjs.com/)是一个\n"
"用于与 Starknet 交互的重要 SDK。相比之下，[get-starknet]()\n"
"[get-starknet](https://github.com/starknet-io/get-starknet/)是一个\n"
"是一个擅长管理钱包连接的软件包。"

#: src/ch02-08-starknet-react.md:44
msgid ""
"Proceed by swaddling your app within the `StarknetConfig` component.\n"
"This enveloping action offers a degree of configuration, while\n"
"simultaneously providing a React Context for the application beneath to\n"
"utilize shared data and hooks. The `StarknetConfig` component accepts a\n"
"connectors prop, allowing the definition of wallet connection options\n"
"available to the user."
msgstr ""
"将应用程序裹在 `StarknetConfig`组件中。\n"
"这种封装方式提供了一定程度的配置，\n"
"同时为下面的应用程序提供 React 上下文，以便利用共享数据和钩子。\n"
"`StarknetConfig`组件接受一个\n"
"连接器prop，允许定义用户可用的钱包连接选项。"

#: src/ch02-08-starknet-react.md:51
msgid ""
"const connectors = [\n"
"      new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"      new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"    ];\n"
"\n"
"    return (\n"
"        <StarknetConfig\n"
"          connectors={connectors}\n"
"          autoConnect\n"
"        >\n"
"          <App />\n"
"        </StarknetConfig>\n"
"    )"
msgstr ""
"const connectors = [\n"
"      new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"      new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"    ];\n"
"\n"
"    return (\n"
"        <StarknetConfig\n"
"          connectors={connectors}\n"
"          autoConnect\n"
"        >\n"
"          <App />\n"
"        </StarknetConfig>\n"
"    )"

#: src/ch02-08-starknet-react.md:65
msgid "## Establishing Connection and Managing Account"
msgstr "## 建立连接和管理账户"

#: src/ch02-08-starknet-react.md:67
msgid ""
"Once the connectors are defined in the config, the stage is set to use a\n"
"hook to access these connectors, enabling users to connect their\n"
"wallets:"
msgstr ""
"一旦在配置中定义了连接器，应用就会被设置为使用\n"
"钩子来访问这些连接器，使用户能够连接他们的\n"
"钱包："

#: src/ch02-08-starknet-react.md:71
msgid ""
"export default function Connect() {\n"
"      const { connect, connectors, disconnect } = useConnectors();\n"
"\n"
"      return (\n"
"        <div>\n"
"          {connectors.map((connector) => (\n"
"            <button\n"
"              key={connector.id}\n"
"              onClick={() => connect(connector)}\n"
"              disabled={!connector.available()}\n"
"            >\n"
"              Connect with {connector.id}\n"
"            </button>\n"
"          ))}\n"
"        </div>\n"
"      );\n"
"    }"
msgstr ""
"export default function Connect() {\n"
"      const { connect, connectors, disconnect } = useConnectors();\n"
"\n"
"      return (\n"
"        <div>\n"
"          {connectors.map((connector) => (\n"
"            <button\n"
"              key={connector.id}\n"
"              onClick={() => connect(connector)}\n"
"              disabled={!connector.available()}\n"
"            >\n"
"              Connect with {connector.id}\n"
"            </button>\n"
"          ))}\n"
"        </div>\n"
"      );\n"
"    }"

#: src/ch02-08-starknet-react.md:89
msgid ""
"Observe the `disconnect` function that terminates the connection when\n"
"invoked. Post connection, access to the connected account is provided\n"
"through the `useAccount` hook, offering insight into the current state\n"
"of connection:"
msgstr ""
"观察`disconnect`函数，该函数会在调用时终止连接。\n"
"连接后，可通过 `useAccount` 钩子访问已连接的账户，以了解当前的连接状态："

#: src/ch02-08-starknet-react.md:94
msgid ""
"const { address, isConnected, isReconnecting, account } = useAccount();\n"
"\n"
"    return (\n"
"        <div>\n"
"          {isConnected ? (\n"
"              <p>Hello, {address}</p>\n"
"          ) : (\n"
"            <Connect />\n"
"          )}\n"
"        </div>\n"
"    );"
msgstr ""
"const { address, isConnected, isReconnecting, account } = useAccount();\n"
"\n"
"    return (\n"
"        <div>\n"
"          {isConnected ? (\n"
"              <p>Hello, {address}</p>\n"
"          ) : (\n"
"            <Connect />\n"
"          )}\n"
"        </div>\n"
"    );"

#: src/ch02-08-starknet-react.md:106
msgid ""
"The state values, such as `isConnected` and `isReconnecting`, receive\n"
"automatic updates, simplifying UI conditional updates. This convenient\n"
"pattern shines when dealing with asynchronous processes, as it\n"
"eliminates the need to manually manage the state within your components."
msgstr ""
"`isConnected`和 `isReconnecting`等状态值会自动更新，\n"
"从而简化了用户界面的条件更新。这种方便的\n"
"模式在处理异步进程时大显身手，因为它\n"
"无需在组件中手动管理状态。"

#: src/ch02-08-starknet-react.md:111
msgid ""
"Having established a connection, signing messages becomes a breeze using\n"
"the account value returned from the `useAccount` hook. For a more\n"
"streamlined experience, the `useSignTypedData` hook is at your disposal."
msgstr ""
"建立连接后，使用`useAccount`钩子返回的账户值签署信息就变得轻而易举了。\n"
"要获得更顺滑的体验，请使用`useSignTypedData` 钩子。"

#: src/ch02-08-starknet-react.md:115
msgid ""
"const { data, signTypedData } = useSignTypedData(typedMessage)\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>\n"
"          <button onClick={signTypedData}>Sign</button>\n"
"        </p>\n"
"        {data && <p>Signed: {JSON.stringify(data)}</p>}\n"
"      </>\n"
"    )"
msgstr ""
"const { data, signTypedData } = useSignTypedData(typedMessage)\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>\n"
"          <button onClick={signTypedData}>Sign</button>\n"
"        </p>\n"
"        {data && <p>Signed: {JSON.stringify(data)}</p>}\n"
"      </>\n"
"    )"

#: src/ch02-08-starknet-react.md:126
msgid ""
"Starknet React supports signing an array of `BigNumberish` values or an\n"
"object. While signing an object, it is crucial to ensure that the data\n"
"conforms to the EIP712 type. For a more comprehensive guide on signing,\n"
"refer to the Starknet.js documentation:\n"
"[here](https://www.starknetjs.com/docs/guides/signature/)."
msgstr ""
"Starknet React 支持签署一个`BigNumberish`值数组或一个对象。\n"
"签署对象时，必须确保数据符合 EIP712 类型。\n"
"有关签名的更全面指南，请参阅 Starknet.js 文档：\n"
"[此处](https://www.starknetjs.com/docs/guides/signature/)."

#: src/ch02-08-starknet-react.md:132
msgid "## Displaying StarkName"
msgstr "## 显示StarkName"

#: src/ch02-08-starknet-react.md:134
msgid ""
"After an account has been connected, the `useStarkName` hook can be used\n"
"to retrieve the StarkName of this connected account. Related to\n"
"[Starknet.id](https://www.starknet.id/) it permits to display the user\n"
"address in a more user friendly way."
msgstr ""
"连接账户后，可使用 `useStarkName` 钩子来获取已连接账户的 StarkName。\n"
"StarkName与[Starknet.id](https://www.starknet.id/)有关，它允许以更方便用户的方式显示用户地址。"

#: src/ch02-08-starknet-react.md:139
msgid ""
"const { data, isError, isLoading, status } = useStarkName({ address });\n"
"    // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')\n"
"\n"
"    if (isLoading) return <p>Loading...</p>\n"
"    return <p>Account: {isError ? address : data}</p>"
msgstr ""
"const { data, isError, isLoading, status } = useStarkName({ address });\n"
"    // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')\n"
"\n"
"    if (isLoading) return <p>Loading...</p>\n"
"    return <p>Account: {isError ? address : data}</p>"

#: src/ch02-08-starknet-react.md:145
msgid ""
"You also have additional information you can get from this hook →\n"
"**error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**,\n"
"**isFetchedAfterMount**, **isRefetching**, **refetch** which can give\n"
"you more precise information on what is happening."
msgstr ""
"您还可以从该钩子获取其他信息 → \n"
"**error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**,\n"
"**isFetchedAfterMount**, **isRefetching**, **refetch**，这可以为您提供更精确的信息。"

#: src/ch02-08-starknet-react.md:150
msgid "## Fetching address from StarkName"
msgstr "## 从 StarkName 获取地址"

#: src/ch02-08-starknet-react.md:152
msgid ""
"You could also want to retrieve an address corresponding to a StarkName.\n"
"For this purpose, you can use the `useAddressFromStarkName` hook."
msgstr ""
"您可能还想获取与 StarkName 相对应的地址。\n"
"为此，您可以使用 `useAddressFromStarkName` 钩子。"

#: src/ch02-08-starknet-react.md:155
msgid ""
"const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n"
"\n"
"    if (isLoading) return <p>Loading...</p>\n"
"    if (isError) return <p>Something went wrong</p>\n"
"    return <p>Address: {data}</p>"
msgstr ""
"const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n"
"\n"
"    if (isLoading) return <p>Loading...</p>\n"
"    if (isError) return <p>Something went wrong</p>\n"
"    return <p>Address: {data}</p>"

#: src/ch02-08-starknet-react.md:161
msgid ""
"If the provided name does not have an associated address, it will return\n"
"**\"0x0\"**"
msgstr "如果所提供的名称没有相关地址，它将返回**\"0x0\"**"

#: src/ch02-08-starknet-react.md:164
msgid "## Navigating the Network"
msgstr "## 网络导航"

#: src/ch02-08-starknet-react.md:166
msgid ""
"In addition to wallet and account management, Starknet React equips\n"
"developers with hooks for network interactions. For instance, useBlock\n"
"enables the retrieval of the latest block:"
msgstr ""
"除了钱包和账户管理，Starknet React 还为开发人员提供了网络交互钩子。\n"
"例如，`useBlock` 可以检索最新的区块："

#: src/ch02-08-starknet-react.md:170
msgid ""
"const { data, isError, isFetching } = useBlock({\n"
"        refetchInterval: 10_000,\n"
"        blockIdentifier: \"latest\",\n"
"    });\n"
"\n"
"    if (isError) {\n"
"      return (\n"
"        <p>Something went wrong</p>\n"
"      )\n"
"    }\n"
"\n"
"    return (\n"
"        <p>Current block: {isFetching ? \"Loading...\" : data?.block_number}<p>\n"
"    )"
msgstr ""
"const { data, isError, isFetching } = useBlock({\n"
"        refetchInterval: 10_000,\n"
"        blockIdentifier: \"latest\",\n"
"    });\n"
"\n"
"    if (isError) {\n"
"      return (\n"
"        <p>Something went wrong</p>\n"
"      )\n"
"    }\n"
"\n"
"    return (\n"
"        <p>Current block: {isFetching ? \"Loading...\" : data?.block_number}<p>\n"
"    )"

#: src/ch02-08-starknet-react.md:185
msgid ""
"In the aforementioned code, refetchInterval controls the frequency of\n"
"data refetching. Behind the scenes, Starknet React harnesses\n"
"[react-query](https://github.com/TanStack/query/) for managing state and\n"
"queries. In addition to useBlock, Starknet React offers other hooks like\n"
"useContractRead and useWaitForTransaction, which can be configured to\n"
"update at regular intervals."
msgstr ""
"在上述代码中，refetchInterval 控制数据重取的频率。\n"
"在幕后，Starknet React 利用[react-query](https://github.com/TanStack/query/)来管理状态和查询。\n"
"除了 `useBlock`，Starknet React 还提供了其他钩子，如\n"
"`useContractRead` 和 `useWaitForTransaction` 等钩子，这些钩子可配置为定期更新。"

#: src/ch02-08-starknet-react.md:192
msgid "The useStarknet hook provides direct access to the ProviderInterface:"
msgstr "`useStarknet` 钩子可直接访问 `ProviderInterface`："

#: src/ch02-08-starknet-react.md:194
msgid ""
"const { library } = useStarknet();\n"
"\n"
"    // library.getClassByHash(...)\n"
"    // library.getTransaction(...)"
msgstr ""
"const { library } = useStarknet();\n"
"\n"
"    // library.getClassByHash(...)\n"
"    // library.getTransaction(...)"

#: src/ch02-08-starknet-react.md:199
msgid "## Tracking Wallet changes"
msgstr "## 跟踪钱包变化"

#: src/ch02-08-starknet-react.md:201
msgid ""
"To improve your dApp User Experience, you can track the user wallet\n"
"changes, especially when the user changes the wallet account (or\n"
"connects/disconnects). But also when the user changes the network. You\n"
"could want to reload correct balances when the user changes the account,\n"
"or to reset the state of your dApp when the user changes the network. To\n"
"do so, you can use a previous hook we already looked at: `useAccount`\n"
"and a new one `useNetwork`."
msgstr ""
"为改善您的 dApp 用户体验，您可以跟踪用户钱包\\的变化，尤其是当用户更换钱包账户（或 连接/断开连接时）。\n"
"用户更换网络时也是如此。当用户更换账户时，您可能希望重新加载正确的余额、\n"
"或在用户更换网络时重置 dApp 的状态。\n"
"为此您可以使用我们之前介绍过的钩子：`useAccount`和一个新钩子 `useNetwork`。"

#: src/ch02-08-starknet-react.md:209
msgid ""
"The `useNetwork` hook can provide you with the network chain currently\n"
"in use."
msgstr "`useNetwork` 钩子可提供当前使用的链的信息。"

#: src/ch02-08-starknet-react.md:212
msgid ""
"const { chain: {id, name} } = useNetwork();\n"
"\n"
"    return (\n"
"        <>\n"
"            <p>Connected chain: {name}</p>\n"
"            <p>Connected chain id: {id}</p>\n"
"        </>\n"
"    )"
msgstr ""
"const { chain: {id, name} } = useNetwork();\n"
"\n"
"    return (\n"
"        <>\n"
"            <p>Connected chain: {name}</p>\n"
"            <p>Connected chain id: {id}</p>\n"
"        </>\n"
"    )"

#: src/ch02-08-starknet-react.md:221
msgid ""
"You also have additional information you can get from this hook →\n"
"**blockExplorer**, **testnet** which can give you more precise\n"
"information about the current network being used."
msgstr ""
"您还可以从该钩子获取更多信息 → \n"
"**blockExplorer**、**testnet**，它们可以为您提供更精确的当前使用的网络的信息。"

#: src/ch02-08-starknet-react.md:225
msgid ""
"After knowing this you have all you need to track user interaction on\n"
"the using account and network. You can use the `useEffect` hook to do\n"
"some work on changes."
msgstr ""
"了解这些信息后，你就可以跟踪用户在使用账户和网络上的交互情况了。\n"
"当网络发生变更时，您可以使用 `useEffect` 钩子。"

#: src/ch02-08-starknet-react.md:229
msgid ""
"const { chain } = useNetwork();\n"
"    const { address } = useAccount();\n"
"\n"
"    useEffect(() => {\n"
"        if(address) {\n"
"            // Do some work when the user changes the account on the wallet\n"
"            // Like reloading the balances\n"
"        }else{\n"
"            // Do some work when the user disconnects the wallet\n"
"            // Like reseting the state of your dApp\n"
"        }\n"
"    }, [address]);\n"
"\n"
"    useEffect(() => {\n"
"        // Do some work when the user changes the network on the wallet\n"
"        // Like reseting the state of your dApp\n"
"    }, [chain]);"
msgstr ""
"const { chain } = useNetwork();\n"
"    const { address } = useAccount();\n"
"\n"
"    useEffect(() => {\n"
"        if(address) {\n"
"            // Do some work when the user changes the account on the wallet\n"
"            // Like reloading the balances\n"
"        }else{\n"
"            // Do some work when the user disconnects the wallet\n"
"            // Like reseting the state of your dApp\n"
"        }\n"
"    }, [address]);\n"
"\n"
"    useEffect(() => {\n"
"        // Do some work when the user changes the network on the wallet\n"
"        // Like reseting the state of your dApp\n"
"    }, [chain]);"

#: src/ch02-08-starknet-react.md:247
msgid "## Contract Interactions"
msgstr "## 合约交互"

#: src/ch02-08-starknet-react.md:249
msgid "### Read Functions"
msgstr "### 读取函数"

#: src/ch02-08-starknet-react.md:251
msgid ""
"Starknet React presents useContractRead, a specialized hook for invoking\n"
"read functions on contracts, akin to wagmi. This hook functions\n"
"independently of the user’s connection status, as read operations do not\n"
"necessitate a signer."
msgstr ""
"Starknet React 提供了 useContractRead，这是一个专门的钩子，用于调用\n"
"读取合约函数的专门钩子，类似于 wagmi。\n"
"该钩子的功能与用户的连接状态无关，因为读取操作并不需要签名者。"

#: src/ch02-08-starknet-react.md:256
msgid ""
"const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
"        abi: abi_erc20,\n"
"        address: CONTRACT_ADDRESS,\n"
"        functionName: \"allowance\",\n"
"        args: [owner, spender],\n"
"        // watch: true <- refresh at every block\n"
"    });"
msgstr ""
"const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
"        abi: abi_erc20,\n"
"        address: CONTRACT_ADDRESS,\n"
"        functionName: \"allowance\",\n"
"        args: [owner, spender],\n"
"        // watch: true <- refresh at every block\n"
"    });"

#: src/ch02-08-starknet-react.md:264
msgid ""
"For ERC20 operations, Starknet React offers a convenient useBalance\n"
"hook. This hook exempts you from passing an ABI and returns a suitably\n"
"formatted balance value."
msgstr ""
"对于 ERC20 操作，Starknet React 提供了方便的 `useBalance`钩子。\n"
"该钩子无需传递 ABI，并返回一个被格式化的余额值。"

#: src/ch02-08-starknet-react.md:268
msgid ""
"  const { data, isLoading } = useBalance({\n"
"        address,\n"
"        token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
"        // watch: true <- refresh at every block\n"
"      });\n"
"\n"
"      return (\n"
"        <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
"      )"
msgstr ""
"  const { data, isLoading } = useBalance({\n"
"        address,\n"
"        token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
"        // watch: true <- refresh at every block\n"
"      });\n"
"\n"
"      return (\n"
"        <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
"      )"

#: src/ch02-08-starknet-react.md:278
msgid "### Write Functions"
msgstr "### 写入函数"

#: src/ch02-08-starknet-react.md:280
msgid ""
"The useContractWrite hook, designed for write operations, deviates\n"
"slightly from wagmi. The unique architecture of Starknet facilitates\n"
"multicall transactions natively at the account level. This feature\n"
"enhances the user experience when executing multiple transactions,\n"
"eliminating the need to approve each transaction individually. Starknet\n"
"React capitalizes on this functionality through the useContractWrite\n"
"hook. Below is a demonstration of its usage:"
msgstr ""
"用于写操作的 `useContractWrite` 钩子与 wagmi 稍有不同。\n"
"Starknet的独特架构有利于多重调用交易。\n"
"该功能在执行多笔交易时增强用户体验、无需逐笔审批。\n"
"Starknet React 通过 `useContractWrite`\n"
"钩子利用了这一功能。下面是其用法演示："

#: src/ch02-08-starknet-react.md:288
msgid ""
"const calls = useMemo(() => {\n"
"        // compile the calldata to send\n"
"        const calldata = stark.compileCalldata({\n"
"          argName: argValue,\n"
"        });\n"
"\n"
"        // return a single object for single transaction,\n"
"        // or an array of objects for multicall**\n"
"        return {\n"
"          contractAddress: CONTRACT_ADDRESS,\n"
"          entrypoint: functionName,\n"
"          calldata,\n"
"        };\n"
"    }, [argValue]);\n"
"\n"
"\n"
"    // Returns a function to trigger the transaction\n"
"    // and state of tx after being sent\n"
"    const { write, isLoading, data } = useContractWrite({\n"
"        calls,\n"
"    });\n"
"\n"
"    function execute() {\n"
"      // trigger the transaction\n"
"      write();\n"
"    }\n"
"\n"
"    return (\n"
"      <button type=\"button\" onClick={execute}>\n"
"        Make a transaction\n"
"      </button>\n"
"    )"
msgstr ""
"const calls = useMemo(() => {\n"
"        // compile the calldata to send\n"
"        const calldata = stark.compileCalldata({\n"
"          argName: argValue,\n"
"        });\n"
"\n"
"        // return a single object for single transaction,\n"
"        // or an array of objects for multicall**\n"
"        return {\n"
"          contractAddress: CONTRACT_ADDRESS,\n"
"          entrypoint: functionName,\n"
"          calldata,\n"
"        };\n"
"    }, [argValue]);\n"
"\n"
"\n"
"    // Returns a function to trigger the transaction\n"
"    // and state of tx after being sent\n"
"    const { write, isLoading, data } = useContractWrite({\n"
"        calls,\n"
"    });\n"
"\n"
"    function execute() {\n"
"      // trigger the transaction\n"
"      write();\n"
"    }\n"
"\n"
"    return (\n"
"      <button type=\"button\" onClick={execute}>\n"
"        Make a transaction\n"
"      </button>\n"
"    )"

#: src/ch02-08-starknet-react.md:321
msgid ""
"The code snippet begins by compiling the calldata using the\n"
"compileCalldata utility provided by Starknet.js. This calldata, along\n"
"with the contract address and entry point, are passed to the\n"
"useContractWrite hook. The hook returns a write function that is\n"
"subsequently used to execute the transaction. The hook also provides the\n"
"transaction’s hash and state."
msgstr ""
"代码片段首先使用 Starknet.js 提供的`compileCalldata`。\n"
"这些 calldata以及合约地址和入口点一起传递给`useContractWrite` 钩子。\n"
"该钩子会返回一个写入函数,随后用于执行事务。\n"
"该钩子还提供了事务的哈希值和状态。"

#: src/ch02-08-starknet-react.md:328
msgid "### A Single Contract Instance"
msgstr "### 单合约实例"

#: src/ch02-08-starknet-react.md:330
msgid ""
"In certain use cases, working with a single contract instance may be\n"
"preferable to specifying the contract address and ABI in each hook.\n"
"Starknet React accommodates this requirement with the useContract hook:"
msgstr ""
"在某些用例中，使用单个合约实例可能比在每个钩子中指定合约地址和 ABI更可取。\n"
"Starknet React 使用 `useContract` 钩子满足了这一要求："

#: src/ch02-08-starknet-react.md:334
msgid ""
"const { contract } = useContract({\n"
"        address: CONTRACT_ADDRESS,\n"
"        abi: abi_erc20,\n"
"    });\n"
"\n"
"    // Call functions directly on contract\n"
"    // contract.transfer(...);\n"
"    // contract.balanceOf(...);"
msgstr ""
"const { contract } = useContract({\n"
"        address: CONTRACT_ADDRESS,\n"
"        abi: abi_erc20,\n"
"    });\n"
"\n"
"    // Call functions directly on contract\n"
"    // contract.transfer(...);\n"
"    // contract.balanceOf(...);"

#: src/ch02-08-starknet-react.md:343
msgid "## Tracking Transactions"
msgstr "## 跟踪交易"

#: src/ch02-08-starknet-react.md:345
msgid ""
"The useTransaction hook allows for the tracking of transaction states\n"
"given a transaction hash. This hook maintains a cache of all\n"
"transactions, thereby minimizing redundant network requests."
msgstr ""
"使用`useTransaction`钩子可以跟踪给定哈希值交易的状态。\n"
"该钩子会缓存所有交易，从而最大限度地减少冗余网络请求。"

#: src/ch02-08-starknet-react.md:349
msgid ""
"const { data, isLoading, error } = useTransaction({ hash: txHash });\n"
"\n"
"    return (\n"
"      <pre>\n"
"        {JSON.stringify(data?.calldata)}\n"
"      </pre>\n"
"    )"
msgstr ""
"const { data, isLoading, error } = useTransaction({ hash: txHash });\n"
"\n"
"    return (\n"
"      <pre>\n"
"        {JSON.stringify(data?.calldata)}\n"
"      </pre>\n"
"    )"

#: src/ch02-08-starknet-react.md:357
msgid ""
"The full array of available hooks can be discovered in the Starknet\n"
"React documentation, accessible here:\n"
"<https://apibara.github.io/starknet-react/>."
msgstr ""
"所有可用钩子的列表，可在 Starknet React 文档里查阅：\n"
"<https://apibara.github.io/starknet-react/>。"

#: src/ch02-08-starknet-react.md:363
msgid ""
"The Starknet React library offers a comprehensive suite of React hooks\n"
"and providers, purpose-built for Starknet and the Starknet.js SDK. By\n"
"taking advantage of these well-crafted tools, developers can build\n"
"robust decentralized applications that harness the power of the Starknet\n"
"network."
msgstr ""
"Starknet React 库提供了一整套 React 钩子和provider，专为 Starknet 和 Starknet.js SDK 而设计。\n"
"通过这些精心设计的工具，开发人员可以构建去中心化应用程序来驾驭Starknet网络的强大功能。"

#: src/ch02-08-starknet-react.md:369
msgid ""
"Through the diligent work of dedicated developers and contributors,\n"
"Starknet React continues to evolve. New features and optimizations are\n"
"regularly added, fostering a dynamic and growing ecosystem of\n"
"decentralized applications."
msgstr ""
"通过敬业的开发人员和贡献者的辛勤工作、Starknet React 不断发展。\n"
"新功能和优化会被定期添加，促进了一个充满活力、不断发展的去中心化应用生态系统。"

#: src/ch02-08-starknet-react.md:374
msgid ""
"It’s a fascinating journey, filled with innovative technology, endless\n"
"opportunities, and a growing community of passionate individuals. As a\n"
"developer, you’re not only building applications, but contributing to\n"
"the advancement of a global, decentralized network."
msgstr ""
"这是一段令人神往的旅程，充满了创新的技术、无尽的机遇，以及由充满激情的个人组成的不断壮大的社区。\n"
"作为一名开发人员，你不仅要开发应用程序，还要为推动全球去中心化网络的发展做出贡献。"

#: src/ch02-08-starknet-react.md:379
msgid ""
"Have questions or need help? The Starknet community is always ready to\n"
"assist. Join the [Starknet Discord](https://discord.gg/starknet) or\n"
"explore the [StarknetBook’s GitHub\n"
"repository](https://github.com/starknet-edu/starknetbook) for resources\n"
"and support."
msgstr ""
"有问题或需要帮助？Starknet社区随时准备帮助。\n"
"加入 [Starknet Discord](https://discord.gg/starknet) 或\n"
"探索[StarknetBook 的 GitHub 资源库](https://github.com/starknet-edu/starknetbook) 获取资源和支持。"

#: src/ch02-08-starknet-react.md:385
msgid "## Further Reading"
msgstr "## 进一步阅读"

#: src/ch02-08-starknet-react.md:387
msgid ""
"- [Starknet.js](https://starknet.js.org)\n"
"\n"
"- [Starknet React Docs](https://www.apibara.com/starknet-react-docs)\n"
"\n"
"- [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)\n"
"\n"
"- [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"
msgstr ""
"- [Starknet.js](https://starknet.js.org)\n"
"\n"
"- [Starknet React Docs](https://www.apibara.com/starknet-react-docs)\n"
"\n"
"- [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)\n"
"\n"
"- [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"

#: src/ch02-08-01-examples.md:3
msgid ""
"In this subchapter, readers will find practical examples demonstrating the usage of `starknet-react`. It provides insight into real-world applications and serves as a guide for developers to "
"understand and implement these tools effectively."
msgstr "在本分章中，读者将看到演示如何使用 `starknet-react` 的实际示例。它提供了对真实世界应用的洞察，可作为开发人员理解和有效实施这些工具的指南。"

#: src/ch02-08-01-01-erc20-ui.md:3
msgid "This guide offers steps to build an ERC20 smart contract using Cairo and to incorporate it within a React web application with Starknet React. Readers will:"
msgstr "本指南提供了使用 Cairo 构建 ERC20 智能合约的步骤，并将其纳入使用 Starknet React 的 React Web 应用程序中。读者将："

#: src/ch02-08-01-01-erc20-ui.md:10
msgid "A prerequisite for this guide is a foundational understanding of both the Cairo programming language and ReactJS. Additionally, ensure Node.js and NPM are installed on the system."
msgstr "本指南的前提条件是对 Cairo 编程语言和 ReactJS 有基本的了解。此外，确保系统上已安装 Node.js 和 NPM。"

#: src/ch02-08-01-01-erc20-ui.md:14
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:18
msgid ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- Starknet React v1.0.4\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.1.6\n"
"- Visual Studio Code\n"
"- Vercel"
msgstr ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- Starknet React v1.0.4\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.1.6\n"
"- Visual Studio Code\n"
"- Vercel"

#: src/ch02-08-01-01-erc20-ui.md:39
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.0-beta.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.0-beta.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:96
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:112
msgid "Subsequent to the compilation, declare the smart contract on the Starknet testnet:"
msgstr "编译完成后，在Starknet测试网上声明智能合约："

#: src/ch02-08-01-01-erc20-ui.md:138
msgid ""
"- `Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 \\* 10^18 or 0xd3c21bcecceda1000000. Due to the "
"contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively.\n"
"- `Receiver address`: Use a preferred address. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""
"- `Initial mint`：铸造 1,000,000 个代币。鉴于 MKT 代币包含 18 位小数（OpenZeppelin 的标准），所需的输入为 1,000,000 \\* 10^18 或 0xd3c21bcecceda1000000。由于合约期望的是 u256 铸币值，因此需要同时提"
"供低值和高值：分别为 0xd3c21bcecceda1000000 和 0。\n"
"- `Receiver address`：接收者地址可以使用任何你掌控的地址。例如：0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#: src/ch02-08-01-01-erc20-ui.md:157
msgid "## Installing the Starknet React Library"
msgstr "## 安装 Starknet React 库"

#: src/ch02-08-01-01-erc20-ui.md:159
msgid "With the contract in place, initiate the development of the web application. Begin by incorporating the Starknet React library:"
msgstr "合约部署完成后，我们可以开始开发网络应用程序了。首先导入 Starknet React 库："

#: src/ch02-08-01-01-erc20-ui.md:161
msgid ""
"```bash\n"
"npm add @starknet-react/core\n"
"```"
msgstr ""
"```bash\n"
"npm add @starknet-react/core\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:165
msgid "Post-installation, confirm the version of the Starknet React library:"
msgstr "安装后，确认 Starknet React 库的版本："

#: src/ch02-08-01-01-erc20-ui.md:167
msgid ""
"```bash\n"
"npm list @starknet-react/core\n"
"```"
msgstr ""
"```bash\n"
"npm list @starknet-react/core\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:171
msgid "The output should display the installed version, such as `@starknet-react/core@1.0.4`."
msgstr "输出结果应显示已安装的版本，如 `@starknet-react/core@1.0.4`。"

#: src/ch02-08-01-01-erc20-ui.md:175
msgid "Starknet React library provides the `create-starknet` script that streamlines the setup of a Starknet application using TypeScript:"
msgstr "Starknet React 库提供了`create-starknet` 脚本，可使用 TypeScript 简化 Starknet 应用程序的设置："

#: src/ch02-08-01-01-erc20-ui.md:177
msgid ""
"```bash\n"
"npx create-starknet erc20_web --use-npm\n"
"```"
msgstr ""
"```bash\n"
"npx create-starknet erc20_web --use-npm\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:181
msgid "Once set up, make modifications to `erc20_web/index.tsx` by replacing its content with the following code:"
msgstr "设置完成后，用以下代码替换 `erc20_web/index.tsx` 中的内容，对其进行修改："

#: src/ch02-08-01-01-erc20-ui.md:183
msgid ""
"```typescript\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from '../components/WalletBar'\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" />\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from '../components/WalletBar'\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" />\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:220
msgid "To launch the web3 application:"
msgstr "启动 web3 应用程序："

#: src/ch02-08-01-01-erc20-ui.md:227
msgid "NOTE: Observe the server port that appears during launch. This will be useful for subsequent testing."
msgstr "注意：观察启动过程中出现的服务器端口。这将有助于后续测试。"

#: src/ch02-08-01-01-erc20-ui.md:231
msgid "To enhance the app's functionality, create two components for balance and transfer. Subsequently, update the `Wallet.tsx` file to incorporate the new features:"
msgstr "为增强应用程序的功能，创建余额和转账两个组件。随后，更新 `Wallet.tsx` 文件以纳入新功能："

#: src/ch02-08-01-01-erc20-ui.md:233
msgid "<img alt=\"Basic Dapp ERC20 React Files\" src=\"img/ch02-basic-dapp-react-files.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20 React Files\" src=\"img/ch02-basic-dapp-react-files.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:235
msgid "### Balance Component"
msgstr "### 余额组件"

#: src/ch02-08-01-01-erc20-ui.md:237
msgid "Design a balance component inside `components/Balance.tsx` and integrate the following code:"
msgstr "在 `components/Balance.tsx` 中设计一个余额组件，并整合以下代码："

#: src/ch02-08-01-01-erc20-ui.md:239
msgid ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../assets/erc20.json';\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address],\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={refetch}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default Balance;\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../assets/erc20.json';\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address],\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={refetch}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default Balance;\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:269
msgid "NOTE: Replace the address with the address of your deployed contract."
msgstr "注意：请将地址替换为已部署合约的地址。"

#: src/ch02-08-01-01-erc20-ui.md:271
msgid "### Transfer Component"
msgstr "### 转账组件"

#: src/ch02-08-01-01-erc20-ui.md:273
msgid "Craft a transfer component in `components/Transfer.tsx` and embed the subsequent code:"
msgstr "在 `components/Transfer.tsx` 中制作一个转账组件，并嵌入后续代码："

#: src/ch02-08-01-01-erc20-ui.md:275
msgid ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:316
msgid "NOTE: Replace contractAddress with the address of your deployed contract."
msgstr "注意：将 contractAddress 替换为已部署合约的地址。"

#: src/ch02-08-01-01-erc20-ui.md:318
msgid "### Updating the Wallet Component"
msgstr "### 更新钱包组件"

#: src/ch02-08-01-01-erc20-ui.md:320
msgid "Proceed to modify the `components/Wallet.tsx` file. Replace any existing content with the following enhanced code:"
msgstr "继续修改 `components/Wallet.tsx` 文件。用以下新代码替换任何现有内容："

#: src/ch02-08-01-01-erc20-ui.md:322
msgid ""
"```typescript\n"
"import { useAccount, useConnectors } from '@starknet-react/core'\n"
"import { useMemo } from 'react'\n"
"import Balance from '../components/Balance'\n"
"import Transfer from '../components/Transfer'\n"
"\n"
"function WalletConnected() {\n"
"  const { address } = useAccount();\n"
"  const { disconnect } = useConnectors();\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return '';\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Connected: {shortenedAddress}</span>\n"
"      <p><button onClick={disconnect}>Disconnect</button></p>\n"
"      <hr/>\n"
"      <Balance />\n"
"      <Transfer />\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Select a wallet:</span>\n"
"      <p>\n"
"      {connectors.map((connector) => (\n"
"        <button key={connector.id} onClick={() => connect(connector)}>\n"
"          {connector.id}\n"
"        </button>\n"
"      ))}\n"
"      </p>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar() {\n"
"  const { address } = useAccount();\n"
"\n"
"  return address ? <WalletConnected /> : <ConnectWallet />;\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useConnectors } from '@starknet-react/core'\n"
"import { useMemo } from 'react'\n"
"import Balance from '../components/Balance'\n"
"import Transfer from '../components/Transfer'\n"
"\n"
"function WalletConnected() {\n"
"  const { address } = useAccount();\n"
"  const { disconnect } = useConnectors();\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return '';\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Connected: {shortenedAddress}</span>\n"
"      <p><button onClick={disconnect}>Disconnect</button></p>\n"
"      <hr/>\n"
"      <Balance />\n"
"      <Transfer />\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Select a wallet:</span>\n"
"      <p>\n"
"      {connectors.map((connector) => (\n"
"        <button key={connector.id} onClick={() => connect(connector)}>\n"
"          {connector.id}\n"
"        </button>\n"
"      ))}\n"
"      </p>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar() {\n"
"  const { address } = useAccount();\n"
"\n"
"  return address ? <WalletConnected /> : <ConnectWallet />;\n"
"}\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:372
msgid "This updated code refines the Wallet component to offer a more interactive experience for users intending to connect or manage their wallets."
msgstr "更新后的代码完善了钱包组件，为打算连接或管理钱包的用户提供了交互性更强的体验。"

#: src/ch02-08-01-01-erc20-ui.md:374
msgid "## Finalizing the MKT Token Application"
msgstr "## 完成 MKT 代币应用"

#: src/ch02-08-01-01-erc20-ui.md:376
msgid "To finalize the application setup, we need the ABI file for the MKT token. Follow the steps below to generate and integrate it:"
msgstr "要完成应用程序设置，我们需要 MKT 代币的 ABI 文件。请按照以下步骤生成并集成该文件："

#: src/ch02-08-01-01-erc20-ui.md:378
msgid ""
"1. At the root of your project, create a new directory named `assets/`.\n"
"2. Inside the `assets/` directory, create an empty JSON file named `erc20.json`.\n"
"3. Go back to your ERC20 Cairo project folder and locate the `erc20/target/erc20_erc20_sierra.json` file."
msgstr ""
"1.在项目根目录下新建一个名为 `assets/` 的目录。\n"
"2.在 `assets/` 目录中，创建一个名为 `erc20.json` 的空 JSON 文件。\n"
"3.返回 ERC20 Cairo 项目文件夹，找到 `erc20/target/erc20_erc20_sierra.json` 文件。"

#: src/ch02-08-01-01-erc20-ui.md:382
msgid "<img alt=\"ABI Original\" src=\"img/ch02-basic-dapp-abi.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"ABI Original\" src=\"img/ch02-basic-dapp-abi.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:384
msgid "4. Extract the ABI definition (ensuring you include the square brackets) and integrate it into the previously created `assets/erc20.json` file."
msgstr "4.提取 ABI 定义（确保包含方括号）并将其整合到之前创建的 `assets/erc20.json` 文件中。"

#: src/ch02-08-01-01-erc20-ui.md:386
msgid "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:388
msgid ""
"Well done! The basic MKT token application is now operational locally. Access it via `http://localhost:3000` or the port noted from earlier server setup. The app allows users to connect their "
"wallets, review their balances, and perform token transfers."
msgstr "做得好！基本的 MKT 代币应用程序现已在本地运行。请通过 `http://localhost:3000`或先前服务器设置中指出的端口访问该应用程序。该应用程序允许用户连接自己的钱包、查看余额和执行代币转账。"

#: src/ch02-08-01-01-erc20-ui.md:390
msgid "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:401
msgid ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"vercel init\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"vercel init\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:409
msgid ""
"```bash\n"
"vercel login\n"
"```"
msgstr ""
"```bash\n"
"vercel login\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:415
msgid ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:423
msgid ""
"```bash\n"
"vercel link\n"
"```"
msgstr ""
"```bash\n"
"vercel link\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:435
msgid ""
"```bash\n"
"vercel --prod\n"
"```"
msgstr ""
"```bash\n"
"vercel --prod\n"
"```"

#: src/ch02-08-01-01-erc20-ui.md:439
msgid "Congratulations! Your MKT token web3 application is now accessible to everyone."
msgstr "恭喜您！现在所有人都可以访问您的 MKT 代币 web3 应用了。"

#: src/ch02-08-01-01-erc20-ui.md:441
msgid "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:447
msgid "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:451
msgid "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:455
msgid "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-01-erc20-ui.md:459
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 application using React and Starknet Cairo. This application, complete with an ERC20 smart contract, offers a modern web "
"interface for user interaction. Here's a snapshot of your achievements:"
msgstr "在本教程中，您一步步的学习了如何使用 React 和 Starknet Cairo 制作 Web3 应用。这个应用程序包含一个 ERC20 智能合约，为用户交互提供了一个现代化的 Web 界面。下面是您的成果快照："

#: src/ch02-08-01-01-erc20-ui.md:461
msgid ""
"- **Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries.\n"
"- **Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
"network.\n"
"\n"
"- **React Application**: Built a React application powered by Starknet React, featuring components dedicated to balance inquiries and token transactions.\n"
"\n"
"- **ABI Creation**: Produced the ABI for the MKT token, a critical component to liaise with the contract.\n"
"\n"
"- **Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token "
"transactions."
msgstr ""
"- **项目初始化**：使用 Scarb 和 OpenZeppelin 库建立Starknet项目。\n"
"- **创建 ERC20 合约**：使用Cairo开发了一个 ERC20 代币，并丰富了余额检查和代币转账等功能。然后将其编译并在Starknet上发布。\n"
"\n"
"- **React 应用程序**：构建了一个由 Starknet React 支持的 React 应用程序，其中包含专门用于余额查询和代币交易的组件。\n"
"\n"
"- **创建ABI**：制作 MKT 代币的 ABI，这是链接合约的关键组件。\n"
"\n"
"- **在线部署**：通过在 Vercel 上部署，将您的应用程序带给更多用户。这使得用户能够连接他们的钱包，查看他们的余额，并执行代币交易。"

#: src/ch02-08-01-02-million-dollar-homepage.md:1
msgid "# Million Dollar Homepage"
msgstr "# 百万美元级别的主页"

#: src/ch02-08-01-02-million-dollar-homepage.md:3
msgid ""
"[Starknet Homepage](https://github.com/dbejarano820/starknet_homepage) is a decentralized application on the Starknet blockchain. It provides a virtual space where users can claim and personalize "
"sections of a 100x100 grid, known as \"Starknet Homepage\". Each section is a 10x10 pixel area. Users can acquire these sections by minting non-fungible tokens (NFTs) and then personalizing them "
"with images and other content."
msgstr ""
"[Starknet主页](https://github.com/dbejarano820/starknet_homepage) 是Starknet区块链上的一个去中心化应用程序。它为用户提供了一个虚拟空间，用户可以在这个 100x100 网格（即 \"Starknet主页\"）上申请并个性"
"化自己的部分。每个区域为 10x10 像素。用户可以通过铸造不可兑换代币（NFT）获得这些区域，然后用图片和其他内容对其进行个性化设置。"

#: src/ch02-08-01-02-million-dollar-homepage.md:5
msgid "View the live app on testnet [here](https://starknet-homepage-kappa.vercel.app/)."
msgstr "在[此处](https://starknet-homepage-kappa.vercel.app/) 可以从testnet上查看实时应用程序。"

#: src/ch02-08-01-02-million-dollar-homepage.md:7
msgid "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-02-million-dollar-homepage.md:9
msgid ""
"This initiative is an adaptation of the renowned Million Dollar Homepage and was conceived at the Starknet Summit 2023 Hacker House in Palo Alto, California. The following is a guide to "
"understanding how this project was developed using the available tools in the ecosystem."
msgstr ""
"该项目是对著名的 \"百万美元主页\"（Million Dollar Homepage）的改编，是在加利福尼亚州帕洛阿尔托的 \"Starknet峰会 2023 创客之家\"（Starknet Summit 2023 Hacker House）上构思的。下面的内容将帮助你了解这"
"个项目是如何利用生态系统中的可用工具开发出来的。"

#: src/ch02-08-01-02-million-dollar-homepage.md:11
msgid "### Tools Utilized:"
msgstr "### 使用的工具："

#: src/ch02-08-01-02-million-dollar-homepage.md:13
msgid ""
"- [Starknet-react](https://github.com/apibara/starknet-react)\n"
"- [Starknet.js](https://github.com/0xs34n/starknet.js)\n"
"- [OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)\n"
"- [MaterialUI](https://mui.com/material-ui/)"
msgstr ""
"- [Starknet-react](https://github.com/apibara/starknet-react)\n"
"- [Starknet.js](https://github.com/0xs34n/starknet.js)\n"
"- [OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)\n"
"- [MaterialUI](https://mui.com/material-ui/)"

#: src/ch02-08-01-02-million-dollar-homepage.md:18
msgid "## Initial Setup"
msgstr "## 初始设置"

#: src/ch02-08-01-02-million-dollar-homepage.md:20
msgid "The `Starknet-react` app offers a command to initialize a Starknet app. This command sets up the foundational structure needed for a NextJS application."
msgstr "`Starknet-react` 应用程序提供了一个用于初始化 Starknet 应用程序的命令。该命令设置了 NextJS 应用程序所需的基础结构。"

#: src/ch02-08-01-02-million-dollar-homepage.md:22
msgid ""
"```shell\n"
"npx create-starknet\n"
"```"
msgstr ""
"```shell\n"
"npx create-starknet\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:26
msgid ""
"The `StarknetConfig` component accepts a `connectors` prop, which defines wallet connection options for the user. Additionally, it can take a `defaultProvider` to set the network the application "
"should connect to by default."
msgstr "`StarknetConfig` 组件接受一个名为 `connectors`的prop，为用户定义钱包连接选项。此外，它还可以接受一个 `defaultProvider` 来设置应用程序默认应连接的网络。"

#: src/ch02-08-01-02-million-dollar-homepage.md:28
msgid ""
"```javascript\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
"});\n"
"return (\n"
"  <StarknetConfig\n"
"    autoConnect\n"
"    defaultProvider={provider}\n"
"    connectors={connectors}\n"
"  >\n"
"    <CacheProvider value={emotionCache}>\n"
"      <ThemeProvider theme={theme}>\n"
"        <Component {...pageProps} />\n"
"      </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"
msgstr ""
"```javascript\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
"});\n"
"return (\n"
"  <StarknetConfig\n"
"    autoConnect\n"
"    defaultProvider={provider}\n"
"    connectors={connectors}\n"
"  >\n"
"    <CacheProvider value={emotionCache}>\n"
"      <ThemeProvider theme={theme}>\n"
"        <Component {...pageProps} />\n"
"      </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:51
msgid ""
"Both `CacheProvider` and `ThemeProvider` are components that facilitate the seamless integration of MaterialUI with NextJS. For a comprehensive setup guide on these components, please refer to "
"[this link](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)."
msgstr ""
"`CacheProvider` 和 `ThemeProvider` 都是帮助 MaterialUI 与 NextJS 无缝集成的组件。有关这些组件的全面设置指南，请参阅 [此链接](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)。"

#: src/ch02-08-01-02-million-dollar-homepage.md:53
msgid "## Main Functionality"
msgstr "## 主要功能"

#: src/ch02-08-01-02-million-dollar-homepage.md:55
msgid ""
"The core functionality of the Starknet Homepage centers around selecting a 4-sided region on a matrix, representing the desired 10x10 cells, and minting a token based on those cells. The "
"responsibility of the smart contract is to validate whether the selected cells are available for minting. If a user owns Starknet Homepage tokens, they can access a dropdown to modify the token's "
"content, including the associated image and link on the grid."
msgstr ""
"Starknet Homepage 的核心功能是在矩阵上选择一个四边形区域（代表所需的 10x10 单元），并根据这些单元铸造代币。智能合约的职责是验证所选单元格是否可用于铸币。如果用户拥有Starknet主页代币，就可以访问下拉"
"菜单来修改代币的内容，包括网格上的相关图片和链接。"

#: src/ch02-08-01-02-million-dollar-homepage.md:57
msgid "The app's primary requirements are:"
msgstr "该应用程序的主要要求是："

#: src/ch02-08-01-02-million-dollar-homepage.md:59
msgid ""
"- Wallet connectivity\n"
"- Grid for displaying existing tokens\n"
"- Cell selection capability\n"
"- Multicall function for token approval and minting\n"
"- Dropdown to view owned tokens\n"
"- On-chain representation of the entire 1 million pixel grid"
msgstr ""
"- 钱包连接\n"
"- 用于显示现有代币的网格\n"
"- 单元选择功能\n"
"- 用于代币使用许可和铸币的多重调用功能\n"
"- 下拉菜单可查看拥有的代币\n"
"- 在链上显示整个 100 万像素网格"

#: src/ch02-08-01-02-million-dollar-homepage.md:66
msgid ""
"A significant aspect to consider is the string limitation in Cairo contracts. To store links of varying sizes, they are stored as arrays of `felt252`s. The contract uses the following logic for "
"this purpose:"
msgstr "需要考虑的一个重要方面是 Cairo 合约中的字符串限制。为了存储不同大小的链接，它们被存储为 `felt252`数组。为此，合约使用了以下逻辑："

#: src/ch02-08-01-02-million-dollar-homepage.md:68
msgid ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"        // Read the stored array's length. If the length is superior to 255, the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)\n"
"            .expect('Storage Span too large');\n"
"\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot. 255 of elements is max\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None => {\n"
"                    break Result::Ok(());\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -> u8 {\n"
"        255 / Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"        // Read the stored array's length. If the length is superior to 255, the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)\n"
"            .expect('Storage Span too large');\n"
"\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot. 255 of elements is max\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None => {\n"
"                    break Result::Ok(());\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -> u8 {\n"
"        255 / Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:126
msgid "The storage method for links in the contract state is structured as:"
msgstr "合约状态下链接的存储方法结构如下："

#: src/ch02-08-01-02-million-dollar-homepage.md:128
msgid ""
"```rust\n"
"struct Cell {\n"
"    token_id: u256,\n"
"    xpos: u8,\n"
"    ypos: u8,\n"
"    width: u8,\n"
"    height: u8,\n"
"    img: Array<felt252>,\n"
"    link: Array<felt252>,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Cell {\n"
"    token_id: u256,\n"
"    xpos: u8,\n"
"    ypos: u8,\n"
"    width: u8,\n"
"    height: u8,\n"
"    img: Array<felt252>,\n"
"    link: Array<felt252>,\n"
"}\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:140
msgid ""
"The OpenZeppelin Cairo Contracts library played a crucial role in speeding up the development of the ERC721 contract for Starknet Homepage. You can find the contract for review [here](https://"
"github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo). Once you have installed the library, you can refer to the following example for typical usage:"
msgstr ""
"OpenZeppelin Cairo Contracts 库在加速开发Starknet首页的 ERC721 合约方面发挥了至关重要的作用。您可以在 [此处](https://github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721."
"cairo) 找到该合约以供查阅。安装该库后，您可以参考以下示例了解其典型用法："

#: src/ch02-08-01-02-million-dollar-homepage.md:142
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod MyToken {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"    #[storage]\n"
"    struct Storage {}\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"    #[external(v0)]\n"
"    fn name(self: @ContractState) -> felt252 {\n"
"        let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::ERC20Impl::name(@unsafe_state)\n"
"    }\n"
"    ...\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod MyToken {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"    #[storage]\n"
"    struct Storage {}\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"    #[external(v0)]\n"
"    fn name(self: @ContractState) -> felt252 {\n"
"        let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::ERC20Impl::name(@unsafe_state)\n"
"    }\n"
"    ...\n"
"}\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:170
msgid "### Component Logic"
msgstr "### 组件逻辑"

#: src/ch02-08-01-02-million-dollar-homepage.md:172
msgid "#### Grid"
msgstr "#### 网格"

#: src/ch02-08-01-02-million-dollar-homepage.md:174
msgid ""
"The Grid component represents a 100x100 matrix, with each cell being 100 pixels. This layout corresponds to the data structure found in the smart contract. To showcase the tokens already minted on "
"the Homepage, the app employs a React Hook from `starknet-react` to invoke the `getAllTokens` function from the contract."
msgstr ""
"网格组件表示一个 100x100 的矩阵，每个单元格为 100 个像素。这种布局与智能合约中的数据结构相对应。为了展示主页上已经铸造的代币，该应用程序使用了来自 `starknet-react` 的 React Hook 来调用合约中的 "
"`getAllTokens` 函数。"

#: src/ch02-08-01-02-million-dollar-homepage.md:176
msgid ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"
msgstr ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:194
msgid "Deserialization ensures the data from the Starknet contract is aptly transformed for frontend use. This process involves decoding the array of `felt252`s into extensive strings."
msgstr "反序列化可确保Starknet合约中的数据经过适当转换后供前端使用。这一过程包括将 `felt252` 数组解码为字符串。"

#: src/ch02-08-01-02-million-dollar-homepage.md:196
msgid ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"
msgstr ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:211
msgid ""
"Furthermore, the Grid component manages the cell selection process, leading to the minting of a corresponding token. Once an area is chosen, a modal appears displaying the mint details and other "
"necessary inputs for the call data. The intricacies of the multicall will be addressed subsequently."
msgstr "此外，网格组件还负责管理单元格的选择过程，从而铸造相应的代币。一旦选择了一个区域，就会出现一个模态，显示铸币细节和其他必要的呼叫数据输入。多重呼叫的复杂性将在随后讨论。"

#: src/ch02-08-01-02-million-dollar-homepage.md:213
msgid "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-02-million-dollar-homepage.md:215
msgid "#### Modals"
msgstr "#### 模态窗"

#: src/ch02-08-01-02-million-dollar-homepage.md:217
msgid "Modals offer a convenient means to present varied functionalities within the app, such as wallet connection, token minting, and token editing."
msgstr "模态窗提供了一种便捷的方式，可在应用程序中展示各种功能，如钱包连接、代币铸造和代币编辑。"

#: src/ch02-08-01-02-million-dollar-homepage.md:219
msgid "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-wallets.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-wallets.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-02-million-dollar-homepage.md:221
msgid "A recognized best practice is to invoke the React hook for shared information at a top-level, ensuring components like the `WalletBar` remain streamlined and focused."
msgstr "公认的最佳做法是在顶层调用 React 钩子来共享信息，从而确保 `WalletBar` 等组件保持精简和集中。"

#: src/ch02-08-01-02-million-dollar-homepage.md:223
msgid ""
"```typescript\n"
"const { address } = useAccount();\n"
"\n"
"return (\n"
"    ...\n"
"    <WalletBar account={address} />\n"
"    ...\n"
")\n"
"```"
msgstr ""
"```typescript\n"
"const { address } = useAccount();\n"
"\n"
"return (\n"
"    ...\n"
"    <WalletBar account={address} />\n"
"    ...\n"
")\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:233
msgid ""
"Below, the `WalletConnected` function displays the connected wallet's address, while the `ConnectWallet` function allows users to select and connect their wallet. The `WalletBar` function renders "
"the appropriate modal based on the connection status."
msgstr "下面，`WalletConnected` 函数显示连接的钱包地址，而 `ConnectWallet`函数允许用户选择并连接他们的钱包。钱包栏 \"函数会根据连接状态渲染相应的模态。"

#: src/ch02-08-01-02-million-dollar-homepage.md:235
msgid ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet />;\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet />;\n"
"}\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:317
msgid "#### Token Dropdown"
msgstr "#### 代币下拉菜单"

#: src/ch02-08-01-02-million-dollar-homepage.md:319
msgid ""
"The dropdown component is dedicated to showcasing the tokens associated with the currently connected wallet. To retrieve these tokens, a transaction like the one shown below can be executed. The "
"sole argument for this function is the contract address of the intended owner."
msgstr "下拉组件用于显示与当前连接的钱包相关的代币。要检索这些代币，可以执行下图所示的交易。该功能的唯一参数是目标所有者的合约地址。"

#: src/ch02-08-01-02-million-dollar-homepage.md:321
msgid ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"
msgstr ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:335
msgid "### Multicall Contract Interaction"
msgstr "### 多重调用合约交互"

#: src/ch02-08-01-02-million-dollar-homepage.md:337
msgid ""
"The provided code offers an illustration of a multicall, specifically to approve a transaction for the mint price transfer followed by the actual minting action. Notably, the `shortString` module "
"from `starknet.js` plays a pivotal role; it encodes and segments a lengthy string into an array of `felt252`s, the expected argument type for the contract on Starknet."
msgstr ""
"所提供的代码提供了多重调用的示例，特别是批准以铸币价格进行转让交易，然后进行实际的铸币操作。值得注意的是，`starknet.js`中的 `shortString`模块发挥了关键作用；它将冗长的字符串编码并分割成 \"felt252 "
"\"数组，这是Starknet合约的预期参数类型。"

#: src/ch02-08-01-02-million-dollar-homepage.md:339
msgid "The `useContractWrite` is a Hook dedicated to executing a Starknet multicall, which can be employed for a singular transaction or multiple ones."
msgstr "`useContractWrite` 是一个专门用于执行Starknet多重调用的钩子，可用于单个或多个事务。"

#: src/ch02-08-01-02-million-dollar-homepage.md:341
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"
msgstr ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:372
msgid ""
"Another crucial aspect to point out is the `calldata` of the approve function for the ether transfer: calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`. The amount argument is "
"split into two parts because it's a `u256`, which is composed of two separate `felt252` values."
msgstr ""
"需要指出的另一个重要方面是以太网传输批准函数的 `calldata`： calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`。金额参数被分成两部分，因为它是一个 `u256`，由两个独立的 `felt252` 值组"
"成。"

#: src/ch02-08-01-02-million-dollar-homepage.md:374
msgid "Once the multicall is prepared, the next step is to initiate the function and sign the transaction using the connected wallet."
msgstr "准备好多重调用后，下一步就是使用连接的钱包启动功能并签署交易。"

#: src/ch02-08-01-02-million-dollar-homepage.md:376
msgid ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:394
msgid "### Conditional Multicall for Token Editing"
msgstr "### 用于代币编辑的条件多重调用"

#: src/ch02-08-01-02-million-dollar-homepage.md:396
msgid "Another instructive illustration of a conditional multicall setup is the modal used to modify the data associated with a token."
msgstr "设置条件多重调用的另一个有启发性的例子是用于修改标记相关数据的模态窗。"

#: src/ch02-08-01-02-million-dollar-homepage.md:398
msgid "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage-edit.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage-edit.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-08-01-02-million-dollar-homepage.md:400
msgid ""
"There are scenarios where the user may wish to alter just one attribute of the token, rather than both. Consequently, a conditional multicall configuration becomes necessary. It's essential to "
"recall that the token id in the Cairo contract is defined as a `u256`, implying it comprises two `felt252` values."
msgstr "在某些情况下，用户可能只想更改代币的一个属性，而不是两个都改。因此，有条件的多重调用配置就变得很有必要。必须记住，Cairo合约中的代币 id 被定义为 `u256`，这意味着它由两个`felt252`值组成。"

#: src/ch02-08-01-02-million-dollar-homepage.md:402
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"
msgstr ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"

#: src/ch02-08-01-02-million-dollar-homepage.md:430
msgid "## Starknet Homepage Overview"
msgstr "## Starknet主页概览"

#: src/ch02-08-01-02-million-dollar-homepage.md:432
msgid ""
"- **Grid Component**: Represents a 100x100 matrix, allowing users to select cells and mint corresponding tokens. It fetches existing tokens using the `getAllTokens` function from the contract and "
"displays them.\n"
"- **Modals**: Serve as the user interface for actions like wallet connection, token minting, and token editing.\n"
"- **Token Dropdown**: Displays tokens associated with a connected wallet. It retrieves these tokens using the `getTokensByOwner` function.\n"
"- **Multicall Contract Interaction**: Enables token minting and editing. This process utilizes conditional multicalls based on user preferences, especially for editing token attributes."
msgstr ""
"- **网格组件**：代表一个 100x100 的矩阵，允许用户选择单元格和相应的代币。它使用 `getAllTokens`函数从合约中获取现有代币并显示出来。\n"
"- **模版**：作为钱包连接、代币铸造和代币编辑等操作的用户界面。\n"
"- **代币下拉菜单**：显示与已连接钱包相关的代币。它使用 `getTokensByOwner`函数检索这些代币。\n"
"- **多调用合约交互**：启用代币铸造和编辑。此过程根据用户偏好使用有条件多钱包，尤其是在编辑代币属性时。"

#: src/ch02-08-01-02-million-dollar-homepage.md:437
msgid ""
"Throughout the platform, string limitations in Cairo contracts require encoding lengthy strings into arrays of `felt252`s. The OpenZeppelin Cairo Contracts library significantly expedites the "
"development of the ERC721 contract for the Starknet Homepage."
msgstr "在整个平台中，Cairo合约中的字符串限制要求将冗长的字符串编码为 `felt252`数组。OpenZeppelin Cairo合约库大大加快了Starknet主页 ERC721 合约的开发。"

#: src/ch02-09-starknet-py.md:1
msgid "# Starknet-py: Python SDK 🚧"
msgstr "# Starknet-py: Python SDK 🚧"

#: src/ch02-10-starknet-rs.md:1
msgid "# Starknet-rs: Rust SDK 🚧"
msgstr "# Starknet-rs: Rust SDK 🚧"

#: src/ch02-11-starkli.md:1
msgid "# Starkli: A CLI interface 🚧"
msgstr "# Starkli：CLI 界面 🚧"

#: src/ch02-12-foundry-forge.md:1
msgid "# Foundry Forge: Testing"
msgstr "# Foundry Forge: 测试工具"

#: src/ch02-12-foundry-forge.md:3
msgid ""
"Merely deploying contracts is not the end game. Many tools have offered this capability in the past. Forge sets itself apart by hosting a Cairo VM instance, enabling the sequential execution of "
"tests. It employs Scarb for contract compilation."
msgstr "仅仅部署合约并不是最终目的。过去，许多工具都提供了这种功能。Forge 通过托管 Cairo 虚拟机实例，实现了测试的顺序执行，从而与众不同。它采用 Scarb 进行合约编译。"

#: src/ch02-12-foundry-forge.md:5
msgid ""
"To utilize Forge, define test functions and label them with test attributes. Users can either test standalone Cairo functions or integrate contracts, dispatchers, and test contract interactions on-"
"chain."
msgstr "要使用 Forge，只需定义测试功能并标注测试属性即可。用户既可以测试独立的 Cairo 函数，也可以集成合约、调度程序，并测试链上的合约交互。"

#: src/ch02-12-foundry-forge.md:7
msgid "## `snForge` Command-Line Usage"
msgstr "## 使用 `snForge` 命令行"

#: src/ch02-12-foundry-forge.md:9
msgid "This section guides you through the Starknet Foundry `snforge` command-line tool. Learn how to set up a new project, compile the code, and execute tests."
msgstr "本节将指导您使用 Starknet Foundry `snforge` 命令行工具。了解如何建立新项目、编译代码和执行测试。"

#: src/ch02-12-foundry-forge.md:11
msgid "To start a new project with Starknet Foundry, use the `--init` command and replace `project_name` with your project's name."
msgstr "要使用 Starknet Foundry 启动一个新项目，可以使用 `--init` 命令。将 `project_name` 替换为你的项目名称。"

#: src/ch02-12-foundry-forge.md:13
msgid ""
"```shell\n"
"snforge --init project_name\n"
"```"
msgstr ""
"```shell\n"
"snforge --init project_name\n"
"```"

#: src/ch02-12-foundry-forge.md:17
msgid "Once you've set up the project, inspect its layout:"
msgstr "设置好项目后，检查其结构："

#: src/ch02-12-foundry-forge.md:19
msgid ""
"```shell\n"
"cd project_name\n"
"tree . -L 1\n"
"```"
msgstr ""
"```shell\n"
"cd project_name\n"
"tree . -L 1\n"
"```"

#: src/ch02-12-foundry-forge.md:24
msgid "The project structure is as follows:"
msgstr "创建项目后，您可以发现其结构如下："

#: src/ch02-12-foundry-forge.md:26
msgid ""
"```shell\n"
".\n"
"├── README.md\n"
"├── Scarb.toml\n"
"├── src\n"
"└── tests\n"
"```"
msgstr ""
"```shell\n"
".\n"
"├── README.md\n"
"├── Scarb.toml\n"
"├── src\n"
"└── tests\n"
"```"

#: src/ch02-12-foundry-forge.md:34
msgid ""
"- `src/` holds your contract source code.\n"
"- `tests/` is the location of your test files.\n"
"- `Scarb.toml` is for project and **`snforge`** configurations."
msgstr ""
"- `src/` holds your contract source code.\n"
"- `tests/` is the location of your test files.\n"
"- `Scarb.toml` is for project and **`snforge`** configurations."

#: src/ch02-12-foundry-forge.md:38
msgid "Ensure the CASM code generation is active in the `Scarb.toml` file:"
msgstr "确保在 `Scarb.toml` 文件中激活 CASM 代码生成："

#: src/ch02-12-foundry-forge.md:40
msgid ""
"```shell\n"
"# ...\n"
"[[target.starknet-contract]]\n"
"casm = true\n"
"# ...\n"
"```"
msgstr ""
"```shell\n"
"# ...\n"
"[[target.starknet-contract]]\n"
"casm = true\n"
"# ...\n"
"```"

#: src/ch02-12-foundry-forge.md:47
msgid "To run tests using `snforge`:"
msgstr "您可以使用 `snforge` 运行测试："

#: src/ch02-12-foundry-forge.md:49
msgid ""
"```shell\n"
"snforge\n"
"\n"
"Collected 2 test(s) from the `test_name` package\n"
"Running 0 test(s) from `src/`\n"
"Running 2 test(s) from `tests/`\n"
"[PASS] tests::test_contract::test_increase_balance\n"
"[PASS] tests::test_contract::test_cannot_increase_balance_with_zero_value\n"
"Tests: 2 passed, 0 failed, 0 skipped\n"
"```"
msgstr ""
"```shell\n"
"snforge\n"
"\n"
"Collected 2 test(s) from the `test_name` package\n"
"Running 0 test(s) from `src/`\n"
"Running 2 test(s) from `tests/`\n"
"[PASS] tests::test_contract::test_increase_balance\n"
"[PASS] tests::test_contract::test_cannot_increase_balance_with_zero_value\n"
"Tests: 2 passed, 0 failed, 0 skipped\n"
"```"

#: src/ch02-12-foundry-forge.md:60
msgid "## Integrating `snforge` with Existing Scarb Projects"
msgstr "## 在现有 Scarb 项目中使用 `snforge`"

#: src/ch02-12-foundry-forge.md:62
msgid ""
"For those with an established Scarb project who wish to incorporate `snforge`, ensure the `snforge_std package` is declared as a dependency. Insert the line below in the [dependencies] section of "
"your `Scarb.toml`:"
msgstr "对于那些已建立 Scarb 项目并希望将 `snforge` 纳入其中的用户，请确保已将 `snforge_std package` 声明为依赖项。在您的 `Scarb.toml` 的 [dependencies] 部分插入下面一行："

#: src/ch02-12-foundry-forge.md:64
msgid ""
"```shell\n"
"# ...\n"
"[dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"[VERSION]\" }\n"
"```"
msgstr ""
"```shell\n"
"# ...\n"
"[dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"[VERSION]\" }\n"
"```"

#: src/ch02-12-foundry-forge.md:70
msgid "Ensure the tag version corresponds with your `snforge` version. To verify your `snforge` version:"
msgstr "确保标签版本与您的 `snforge` 版本一致。验证您的 `snforge` 版本："

#: src/ch02-12-foundry-forge.md:72
msgid ""
"```sh\n"
"snforge --version\n"
"```"
msgstr ""
"```sh\n"
"snforge --version\n"
"```"

#: src/ch02-12-foundry-forge.md:76
msgid "Or, add this dependency using the `scarb` command:"
msgstr "您也可以使用 `scarb` 命令添加该依赖关系："

#: src/ch02-12-foundry-forge.md:78
msgid ""
"```shell\n"
"scarb add snforge_std --git https://github.com/foundry-rs/starknet-foundry.git --tag VERSION\n"
"```"
msgstr ""
"```shell\n"
"scarb add snforge_std --git https://github.com/foundry-rs/starknet-foundry.git --tag VERSION\n"
"```"

#: src/ch02-12-foundry-forge.md:82
msgid "With these steps, your existing Scarb project is now **`snforge`**-ready."
msgstr "完成这些步骤后，您现有的 Scarb 项目就可以**`snforge`**了。"

#: src/ch02-12-foundry-forge.md:84
msgid "## Testing with `snforge`"
msgstr "## 使用 snforge 运行测试"

#: src/ch02-12-foundry-forge.md:86
msgid "Utilize Starknet Foundry's `snforge` command to efficiently run tests."
msgstr "利用 Starknet Foundry 的 `snforge` 命令可高效的运行测试。"

#: src/ch02-12-foundry-forge.md:88
msgid "### Executing Tests"
msgstr "### 运行测试"

#: src/ch02-12-foundry-forge.md:90
msgid "Navigate to the package directory and issue this command to run tests:"
msgstr "导航至软件包目录，然后使用此命令运行测试："

#: src/ch02-12-foundry-forge.md:92
msgid ""
"```shell\n"
"snforge\n"
"```"
msgstr ""
"```shell\n"
"snforge\n"
"```"

#: src/ch02-12-foundry-forge.md:96
msgid "Sample output might resemble:"
msgstr "输出示例可能类似于"

#: src/ch02-12-foundry-forge.md:98
msgid ""
"```shell\n"
"Collected 3 test(s) from `package_name` package\n"
"Running 3 test(s) from `src/`\n"
"[PASS] package_name::executing\n"
"[PASS] package_name::calling\n"
"[PASS] package_name::calling_another\n"
"Tests: 3 passed, 0 failed, 0 skipped\n"
"```"
msgstr ""
"```shell\n"
"Collected 3 test(s) from `package_name` package\n"
"Running 3 test(s) from `src/`\n"
"[PASS] package_name::executing\n"
"[PASS] package_name::calling\n"
"[PASS] package_name::calling_another\n"
"Tests: 3 passed, 0 failed, 0 skipped\n"
"```"

#: src/ch02-12-foundry-forge.md:107
msgid "## Example: Testing a Simple Contract"
msgstr "## 示例：测试简单合约"

#: src/ch02-12-foundry-forge.md:109
msgid "The example provided below demonstrates how to test a Starknet contract using `snforge`."
msgstr "下面的示例演示了如何使用 `snforge` 测试星网合同。"

#: src/ch02-12-foundry-forge.md:111
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        // Increases the balance by the specified amount.\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"\n"
"        // Returns the balance.\n"
"\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        // Increases the balance by the specified amount.\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"\n"
"        // Returns the balance.\n"
"\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-12-foundry-forge.md:141
msgid "Remember, the identifier following `mod` signifies the contract name. Here, the contract name is `HelloStarknet`."
msgstr "请记住，`mod`后面的标识符表示合约名称。这里，合约名称是 `HelloStarknet`。"

#: src/ch02-12-foundry-forge.md:143
msgid "### Craft the Test"
msgstr "### 设计测试"

#: src/ch02-12-foundry-forge.md:145
msgid "Below is a test for the **`HelloStarknet`** contract. This test deploys **`HelloStarknet`** and interacts with its functions:"
msgstr "下面是 **`HelloStarknet`** 合约的测试。该测试部署 **`HelloStarknet`**，并与其功能交互："

#: src/ch02-12-foundry-forge.md:147
msgid ""
"```rust\n"
"use snforge_std::{ declare, ContractClassTrait };\n"
"\n"
"#[test]\n"
"fn call_and_invoke() {\n"
"    // Declare and deploy the contract\n"
"    let contract = declare('HelloStarknet');\n"
"    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"    // Instantiate a Dispatcher object for contract interactions\n"
"    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"    // Invoke a contract's view function\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 0, 'balance == 0');\n"
"\n"
"    // Invoke another function to modify the storage state\n"
"    dispatcher.increase_balance(100);\n"
"\n"
"    // Validate the transaction's effect\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 100, 'balance == 100');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use snforge_std::{ declare, ContractClassTrait };\n"
"\n"
"#[test]\n"
"fn call_and_invoke() {\n"
"    // Declare and deploy the contract\n"
"    let contract = declare('HelloStarknet');\n"
"    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"    // Instantiate a Dispatcher object for contract interactions\n"
"    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"    // Invoke a contract's view function\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 0, 'balance == 0');\n"
"\n"
"    // Invoke another function to modify the storage state\n"
"    dispatcher.increase_balance(100);\n"
"\n"
"    // Validate the transaction's effect\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 100, 'balance == 100');\n"
"}\n"
"```"

#: src/ch02-12-foundry-forge.md:172
msgid "To run the test, execute the `snforge` command. The expected output is:"
msgstr "要运行测试，请执行 `snforge` 命令。预期输出为"

#: src/ch02-12-foundry-forge.md:174
msgid ""
"```shell\n"
"Collected 1 test(s) from using_dispatchers package\n"
"Running 1 test(s) from src/\n"
"[PASS] using_dispatchers::call_and_invoke\n"
"Tests: 1 passed, 0 failed, 0 skipped\n"
"```"
msgstr ""
"```shell\n"
"Collected 1 test(s) from using_dispatchers package\n"
"Running 1 test(s) from src/\n"
"[PASS] using_dispatchers::call_and_invoke\n"
"Tests: 1 passed, 0 failed, 0 skipped\n"
"```"

#: src/ch02-12-foundry-forge.md:181
msgid "## Example: Testing ERC20 Contract"
msgstr "## 示例：测试 ERC20 合约"

#: src/ch02-12-foundry-forge.md:183
msgid ""
"There are several methods to test smart contracts, such as unit tests, integration tests, fuzz tests, fork tests, E2E tests, and using foundry cheatcodes. This section discusses testing an ERC20 "
"example contract from the `starknet-js` subchapter examples using unit and integration tests, filtering, foundry cheatcodes, and fuzz tests through the `snforge` CLI."
msgstr ""
"测试智能合约有多种方法，如单元测试、集成测试、模糊测试、分叉测试、E2E 测试和使用foundry作弊码。本节将讨论通过 `snforge` CLI 使用单元测试和集成测试、过滤、foundry作弊码和模糊测试来测试 `starknet-js` "
"子章节示例中的 ERC20 示例合约。"

#: src/ch02-12-foundry-forge.md:185
msgid "## ERC20 Contract Example"
msgstr "## ERC20 合约示例"

#: src/ch02-12-foundry-forge.md:187
msgid ""
"After setting up your foundry project, add the following dependency to your `Scarb.toml` (in this case we are using version 0.7.0 of the OpenZeppelin Cairo contracts, but you can use any version "
"you want):"
msgstr "设置好您的 foundry 项目后，将以下依赖项添加到您的 `Scarb.toml`（在本例中，我们使用的是 0.7.0 版 OpenZeppelin Cairo 合约，但您也可以使用任意版本）："

#: src/ch02-12-foundry-forge.md:189
msgid ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"```"
msgstr ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"```"

#: src/ch02-12-foundry-forge.md:193
msgid "Here's a basic ERC20 contract:"
msgstr "这是一份基本的 ERC20 合约："

#: src/ch02-12-foundry-forge.md:195
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait Ierc20<TContractState> {\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: felt252,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply.into());\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl Ierc20Impl of super::Ierc20<ContractState> {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait Ierc20<TContractState> {\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: felt252,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply.into());\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl Ierc20Impl of super::Ierc20<ContractState> {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-12-foundry-forge.md:241
msgid "This contract allows minting tokens to a recipient during deployment, checking balances, and transferring tokens, relying on the openzeppelin ERC20 library."
msgstr "该合约允许在部署过程中向接收者铸造代币、检查余额和转移代币，并依赖于 openzeppelin ERC20 库。"

#: src/ch02-12-foundry-forge.md:243
msgid "### Test Preparation"
msgstr "### 测试准备"

#: src/ch02-12-foundry-forge.md:245
msgid "Organize your test file and include the required imports:"
msgstr "整理测试文件并包含所需的导入："

#: src/ch02-12-foundry-forge.md:247
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use array::ArrayTrait;\n"
"    use result::ResultTrait;\n"
"    use option::OptionTrait;\n"
"    use traits::TryInto;\n"
"    use starknet::ContractAddress;\n"
"    use starknet::Felt252TryIntoContractAddress;\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"    // Additional code here.\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use array::ArrayTrait;\n"
"    use result::ResultTrait;\n"
"    use option::OptionTrait;\n"
"    use traits::TryInto;\n"
"    use starknet::ContractAddress;\n"
"    use starknet::Felt252TryIntoContractAddress;\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"    // Additional code here.\n"
"}\n"
"```"

#: src/ch02-12-foundry-forge.md:261
msgid "For testing, you'll need a helper function to deploy the contract instance. This function requires a `supply` amount and `recipient` address:"
msgstr "测试时，您需要一个辅助函数来部署合同实例。该函数需要一个 `supply` 金额和 `recipient` 地址："

#: src/ch02-12-foundry-forge.md:263
msgid ""
"```rust\n"
"use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"fn deploy_contract(name: felt252) -> ContractAddress {\n"
"    let recipient = starknet::contract_address_const::<0x01>();\n"
"    let supply: felt252 = 20000000;\n"
"    let contract = declare(name);\n"
"    let mut calldata = array![supply, recipient.into()];\n"
"    contract.deploy(@calldata).unwrap()\n"
"}\n"
"// Additional code here.\n"
"```"
msgstr ""
"```rust\n"
"use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"fn deploy_contract(name: felt252) -> ContractAddress {\n"
"    let recipient = starknet::contract_address_const::<0x01>();\n"
"    let supply: felt252 = 20000000;\n"
"    let contract = declare(name);\n"
"    let mut calldata = array![supply, recipient.into()];\n"
"    contract.deploy(@calldata).unwrap()\n"
"}\n"
"// Additional code here.\n"
"```"

#: src/ch02-12-foundry-forge.md:276
msgid "Use `declare` and `ContractClassTrait` from `snforge_std`. Then, initialize the `supply` and `recipient`, declare the contract, compute the calldata, and deploy."
msgstr "使用 `snforge_std` 中的 `declare` 和 `ContractClassTrait`。然后，初始化 `supply` 和 `recipient`，声明合约，计算 calldata 并部署。"

#: src/ch02-12-foundry-forge.md:278
msgid "### Writing the Test Cases"
msgstr "### 编写测试用例"

#: src/ch02-12-foundry-forge.md:280
msgid "#### Verifying the Balance After Deployment"
msgstr "#### 部署后核查余额"

#: src/ch02-12-foundry-forge.md:282
msgid "To begin, test the deployment helper function to confirm the recipient's balance:"
msgstr "首先，测试部署助手功能，确认收件人的余额："

#: src/ch02-12-foundry-forge.md:284
msgid ""
"```rust\n"
"    // ...\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_balance_of() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"        let recipient = starknet::contract_address_const::<0x01>();\n"
"        let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"        assert(balance == 20000000, 'Invalid Balance');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    // ...\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_balance_of() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"        let recipient = starknet::contract_address_const::<0x01>();\n"
"        let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"        assert(balance == 20000000, 'Invalid Balance');\n"
"    }\n"
"```"

#: src/ch02-12-foundry-forge.md:300
msgid "Execute `snforge` to verify:"
msgstr "执行 `snforge` 进行验证："

#: src/ch02-12-foundry-forge.md:302
msgid ""
"```shell\n"
"Collected 1 test from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"```"
msgstr ""
"```shell\n"
"Collected 1 test from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"```"

#: src/ch02-12-foundry-forge.md:307
msgid "#### Utilizing Foundry Cheat Codes"
msgstr "#### 使用Foundry作弊码"

#: src/ch02-12-foundry-forge.md:309
msgid ""
"When testing smart contracts, simulating different conditions is essential. `Foundry Cheat Codes` from the `snforge_std` library offer these simulation capabilities for Starknet smart contracts."
msgstr "在测试智能合约时，模拟不同的条件是必不可少的。`snforge_std`库中的 `Foundry Cheat Codes`为Starknet智能合约提供了这些模拟功能。"

#: src/ch02-12-foundry-forge.md:311
msgid ""
"These cheat codes consist of helper functions that adjust the smart contract's environment. They allow developers to modify parameters or conditions to examine contract behavior in specific "
"scenarios."
msgstr "这些作弊码由调整智能合约环境的辅助函数组成。它们允许开发人员修改参数或条件，以检查特定场景下的合约行为。"

#: src/ch02-12-foundry-forge.md:313
msgid ""
"Using `snforge_std`'s cheat codes, you can change elements like block numbers, timestamps, or even the caller of a function. This guide focuses on `start_prank` and `stop_prank`. You can find a "
"reference to available cheat codes [here](https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html)"
msgstr ""
"使用 `snforge_std` 的作弊代码，您可以更改块编号、时间戳甚至函数的调用者等元素。本指南的重点是 `start_prank` 和 `stop_prank`。您可以在 [此处](https://foundry-rs.github.io/starknet-foundry/appendix/"
"cheatcodes.html) 找到可用的作弊代码参考。"

#: src/ch02-12-foundry-forge.md:315
msgid "Below is a transfer test example:"
msgstr "下面是一个转移测试示例："

#: src/ch02-12-foundry-forge.md:317
msgid ""
"```rust\n"
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_transfer() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"        let sender = starknet::contract_address_const::<0x01>();\n"
"        let receiver = starknet::contract_address_const::<0x02>();\n"
"        let amount : felt252 = 10000000;\n"
"\n"
"        // Set the function's caller\n"
"        start_prank(contract_address, sender);\n"
"        safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"\n"
"        let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"        assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"\n"
"        // End the prank\n"
"        stop_prank(contract_address);\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_transfer() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"        let sender = starknet::contract_address_const::<0x01>();\n"
"        let receiver = starknet::contract_address_const::<0x02>();\n"
"        let amount : felt252 = 10000000;\n"
"\n"
"        // Set the function's caller\n"
"        start_prank(contract_address, sender);\n"
"        safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"\n"
"        let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"        assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"\n"
"        // End the prank\n"
"        stop_prank(contract_address);\n"
"    }\n"
"```"

#: src/ch02-12-foundry-forge.md:342
msgid "Executing `snforge` for the tests displays:"
msgstr "为测试执行 `snforge` 后会显示："

#: src/ch02-12-foundry-forge.md:344
msgid ""
"```shell\n"
"Collected 2 tests from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"[PASS] tests::test_erc20::test_transfer\n"
"```"
msgstr ""
"```shell\n"
"Collected 2 tests from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"[PASS] tests::test_erc20::test_transfer\n"
"```"

#: src/ch02-12-foundry-forge.md:350
msgid "In this example, `start_prank` determines the transfer function's caller, while `stop_prank` concludes the prank."
msgstr "在这个例子中，`start_prank`决定了转移函数的调用者，而 `stop_prank` 则结束了prank。"

#: src/ch02-12-foundry-forge.md:352
msgid ""
"<details>\n"
"<summary>Full `ERC20 test example` file</summary>\n"
"        #[cfg(test)]\n"
"        mod tests {\n"
"        use array::ArrayTrait;\n"
"        use result::ResultTrait;\n"
"        use option::OptionTrait;\n"
"        use traits::TryInto;\n"
"        use starknet::ContractAddress;\n"
"        use starknet::Felt252TryIntoContractAddress;"
msgstr ""
"<details>\n"
"<summary>Full `ERC20 test example` file</summary>\n"
"        #[cfg(test)]\n"
"        mod tests {\n"
"        use array::ArrayTrait;\n"
"        use result::ResultTrait;\n"
"        use option::OptionTrait;\n"
"        use traits::TryInto;\n"
"        use starknet::ContractAddress;\n"
"        use starknet::Felt252TryIntoContractAddress;"

#: src/ch02-12-foundry-forge.md:363
msgid ""
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"        fn deploy_contract(name: felt252) -> ContractAddress {\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let supply : felt252 = 20000000;\n"
"            let contract = declare(name);\n"
"            let mut calldata = array![supply, recipient.into()];\n"
"            contract.deploy(@calldata).unwrap()\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_balance_of() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"            assert(balance == 20000000, 'Invalid Balance');\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_transfer() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"            let sender = starknet::contract_address_const::<0x01>();\n"
"            let receiver = starknet::contract_address_const::<0x02>();\n"
"            let amount : felt252 = 10000000;\n"
"\n"
"            start_prank(contract_address, sender);\n"
"            safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"            let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"            assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"            stop_prank(contract_address);\n"
"        }\n"
"        }"
msgstr ""
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"        fn deploy_contract(name: felt252) -> ContractAddress {\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let supply : felt252 = 20000000;\n"
"            let contract = declare(name);\n"
"            let mut calldata = array![supply, recipient.into()];\n"
"            contract.deploy(@calldata).unwrap()\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_balance_of() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"            assert(balance == 20000000, 'Invalid Balance');\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_transfer() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"            let sender = starknet::contract_address_const::<0x01>();\n"
"            let receiver = starknet::contract_address_const::<0x02>();\n"
"            let amount : felt252 = 10000000;\n"
"\n"
"            start_prank(contract_address, sender);\n"
"            safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"            let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"            assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"            stop_prank(contract_address);\n"
"        }\n"
"        }"

#: src/ch02-12-foundry-forge.md:403
msgid "</details>"
msgstr "</details>"

#: src/ch02-12-foundry-forge.md:405
msgid "## Fuzz Testing"
msgstr "## 模糊测试"

#: src/ch02-12-foundry-forge.md:407
msgid ""
"Fuzz testing introduces random inputs to the code to identify vulnerabilities, security issues, and unforeseen behaviors. While you can manually provide these inputs, automation is preferable when "
"testing a broad set of values. See the example below in `test_fuzz.cairo`:"
msgstr "模糊测试将随机输入引入代码，以识别漏洞、安全问题和不可预见的行为。虽然您可以手动提供这些输入，但在测试一组广泛的值时，最好使用自动化。请参阅下面 `test_fuzz.cairo` 中的示例："

#: src/ch02-12-foundry-forge.md:409
msgid ""
"```rust\n"
"    fn mul(a: felt252, b: felt252) -> felt252 {\n"
"        return a * b;\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn mul(a: felt252, b: felt252) -> felt252 {\n"
"        return a * b;\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"

#: src/ch02-12-foundry-forge.md:420
msgid "Running `snforge` produces:"
msgstr "运行 `snforge` 会产生："

#: src/ch02-12-foundry-forge.md:422
msgid ""
"```shell\n"
"    Collected 1 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 1 test(s) from tests/\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 1 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 6375310854403272271\n"
"```"
msgstr ""
"```shell\n"
"    Collected 1 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 1 test(s) from tests/\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 1 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 6375310854403272271\n"
"```"

#: src/ch02-12-foundry-forge.md:431
msgid "The fuzzer supports these types by November 2023:"
msgstr "直到 2023 年 11 月，模糊器支持这些类型："

#: src/ch02-12-foundry-forge.md:433
msgid ""
"- u8\n"
"- u16\n"
"- u32\n"
"- u64\n"
"- u128\n"
"- u256\n"
"- felt252"
msgstr ""
"- u8\n"
"- u16\n"
"- u32\n"
"- u64\n"
"- u128\n"
"- u256\n"
"- felt252"

#: src/ch02-12-foundry-forge.md:441
msgid "`Fuzzer Configuration`"
msgstr "`Fuzzer Configuration`"

#: src/ch02-12-foundry-forge.md:443
msgid "You can set the number of runs and the seed for a test:"
msgstr "您可以设置测试的运行次数和种子数："

#: src/ch02-12-foundry-forge.md:445
msgid ""
"```rust\n"
"    #[test]\n"
"    #[fuzzer(runs: 100, seed: 38)]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[test]\n"
"    #[fuzzer(runs: 100, seed: 38)]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"

#: src/ch02-12-foundry-forge.md:453
msgid "Or, use the command line:"
msgstr "或者使用命令行："

#: src/ch02-12-foundry-forge.md:455
msgid ""
"```shell\n"
"    $ snforge --fuzzer-runs 500 --fuzzer-seed 4656\n"
"```"
msgstr ""
"```shell\n"
"    $ snforge --fuzzer-runs 500 --fuzzer-seed 4656\n"
"```"

#: src/ch02-12-foundry-forge.md:459
msgid "Or in `scarb.toml`:"
msgstr "或在 `scarb.toml`中："

#: src/ch02-12-foundry-forge.md:461
msgid ""
"```shell\n"
"    # ...\n"
"    [tool.snforge]\n"
"    fuzzer_runs = 500\n"
"    fuzzer_seed = 4656\n"
"    # ...\n"
"```"
msgstr ""
"```shell\n"
"    # ...\n"
"    [tool.snforge]\n"
"    fuzzer_runs = 500\n"
"    fuzzer_seed = 4656\n"
"    # ...\n"
"```"

#: src/ch02-12-foundry-forge.md:469
msgid "For more insight on fuzz tests, you can view it [here](https://foundry-rs.github.io/starknet-foundry/testing/fuzz-testing.html#fuzz-testing)"
msgstr "有关模糊测试的更多信息，请参阅 [此处](https://foundry-rs.github.io/starknet-foundry/testing/fuzz-testing.html#fuzz-testing)"

#: src/ch02-12-foundry-forge.md:471
msgid "## Filter Tests"
msgstr "## 过滤测试"

#: src/ch02-12-foundry-forge.md:473
msgid "To execute specific tests, use a filter string with the `snforge` command. Tests matching the filter based on their absolute module tree path will be executed."
msgstr "要执行特定测试，可在 `snforge` 命令中使用过滤器字符串。根据模块树的绝对路径与过滤器匹配的测试将被执行。"

#: src/ch02-12-foundry-forge.md:475
msgid "For instance, to run all tests with the string 'test\\_' in their name:"
msgstr "例如，运行名称中包含 'test\\_'字符串的所有测试："

#: src/ch02-12-foundry-forge.md:477
msgid ""
"```shell\n"
"snforge test_\n"
"```"
msgstr ""
"```shell\n"
"snforge test_\n"
"```"

#: src/ch02-12-foundry-forge.md:481
msgid "Expected output:"
msgstr "预期输出："

#: src/ch02-12-foundry-forge.md:483
msgid ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [PASS] tests::test_erc20::tests::test_balance_of\n"
"    [PASS] tests::test_erc20::tests::test_transfer\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 3 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 10426315620495146768\n"
"```"
msgstr ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [PASS] tests::test_erc20::tests::test_balance_of\n"
"    [PASS] tests::test_erc20::tests::test_transfer\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 3 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 10426315620495146768\n"
"```"

#: src/ch02-12-foundry-forge.md:494
msgid "All the tests with the string 'test\\_' in their test name went through."
msgstr "所有测试名称中包含 'test\\_'字符串的测试都通过了。"

#: src/ch02-12-foundry-forge.md:496
msgid "Another example: To filter and run `test_fuzz_sum` we can partially match the test name with the string 'fuzz_sum' like this:"
msgstr "再举一个例子：要过滤并运行 `test_fuzz_sum` 时，我们可以将测试名称与字符串 \"fuzz_sum \"部分匹配，如下所示："

#: src/ch02-12-foundry-forge.md:498
msgid ""
"```shell\n"
"snforge test_fuzz_sum\n"
"```"
msgstr ""
"```shell\n"
"snforge test_fuzz_sum\n"
"```"

#: src/ch02-12-foundry-forge.md:502
msgid "To execute an exact test, combine the `--exact` flag with a fully qualified test name:"
msgstr "要执行精确测试，请将 `--exact` 标志与完整的测试名称相结合："

#: src/ch02-12-foundry-forge.md:504
msgid ""
"```shell\n"
"snforge package_name::test_name --exact\n"
"```"
msgstr ""
"```shell\n"
"snforge package_name::test_name --exact\n"
"```"

#: src/ch02-12-foundry-forge.md:508
msgid "To halt the test suite upon the first test failure, use the `--exit-first` flag:"
msgstr "要在第一次测试失败后停止执行测试，请在 `snforge` 命令中加入 `--exit-first` 标志："

#: src/ch02-12-foundry-forge.md:510
msgid ""
"```shell\n"
"snforge --exit-first\n"
"```"
msgstr ""
"```shell\n"
"snforge --exit-first\n"
"```"

#: src/ch02-12-foundry-forge.md:514
msgid "If a test fails, the output will resemble:"
msgstr "如果测试失败，输出将类似于："

#: src/ch02-12-foundry-forge.md:516
msgid ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [FAIL] tests::test_erc20::tests::test_balance_of\n"
"\n"
"    Failure data:\n"
"    original value: [381278114803728420489684244530881381], converted to a string: [Invalid Balance]\n"
"\n"
"    [SKIP] tests::test_erc20::tests::test_transfer\n"
"    [SKIP] tests::test_fuzz::test_fuzz_sum\n"
"    Tests: 0 passed, 1 failed, 2 skipped\n"
"\n"
"    Failures:\n"
"        tests::test_erc20::tests::test_balance_of\n"
"```"
msgstr ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [FAIL] tests::test_erc20::tests::test_balance_of\n"
"\n"
"    Failure data:\n"
"    original value: [381278114803728420489684244530881381], converted to a string: [Invalid Balance]\n"
"\n"
"    [SKIP] tests::test_erc20::tests::test_transfer\n"
"    [SKIP] tests::test_fuzz::test_fuzz_sum\n"
"    Tests: 0 passed, 1 failed, 2 skipped\n"
"\n"
"    Failures:\n"
"        tests::test_erc20::tests::test_balance_of\n"
"```"

#: src/ch02-12-foundry-forge.md:533
msgid "### Conclusion"
msgstr "### 总结"

#: src/ch02-12-foundry-forge.md:535
msgid ""
"Starknet Foundry offers a notable step forward in Starknet contract development and testing. This toolset sharpens the process of creating, deploying, and testing Cairo contracts. Its main "
"components, Forge and Cast, provide developers with robust tools for Cairo contract work."
msgstr "Starknet Foundry在Starknet合约开发和测试方面迈出了显著的一步。该工具集强化了Cairo合约的创建、部署和测试过程。其主要组件 Forge 和 Cast 为开发人员提供了强大的Cairo合约工作工具。"

#: src/ch02-12-foundry-forge.md:537
msgid ""
"Forge shines with its dual functionality: deploying and thoroughly testing Cairo contracts. It directly supports test writing in Cairo, removing the need for other languages and simplifying the "
"task. Moreover, Forge seamlessly integrates with Scarb, emphasizing its adaptability, especially with existing Scarb projects."
msgstr ""
"Forge 具有双重功能：部署和全面测试 Cairo 合约。它直接支持 Cairo 测试编写，无需使用其他语言，简化了任务。此外，Forge 还可以与 Scarb 无缝集成，这强调了其适应性，尤其是与现有 Scarb 项目的适应性。"

#: src/ch02-12-foundry-forge.md:539
msgid "The `snforge` command-line tool makes initializing, setting up, and testing Starknet contracts straightforward."
msgstr "`snforge` 命令行工具可直接初始化、设置和测试Starknet合约。"

#: src/ch03-00-architecture.md:1
msgid "# Architecture"
msgstr "# 架构"

#: src/ch03-00-architecture.md:3
#, fuzzy
msgid ""
"This is an introduction to Starknet’s Layer 2 architecture, designed for\n"
"both beginners and experienced users. It focuses on the key components:\n"
"Sequencers, Provers, and nodes."
msgstr ""
"本文介绍了Starknet的第 2 层架构，专为初学者和有经验的用户设计。\n"
"初学者和有经验的用户。它侧重于关键组件：\n"
"序列器、证明器和节点。"

#: src/ch03-00-architecture.md:7
#, fuzzy
msgid ""
"Starknet is a coordinated system, with each component—Sequencers,\n"
"Provers, and nodes—playing a specific yet interconnected role. Although\n"
"Starknet hasn’t fully decentralized yet, it’s actively moving toward\n"
"that goal. This understanding of the roles and interactions within the\n"
"system will help you better grasp the intricacies of the Starknet\n"
"ecosystem."
msgstr ""
"Starknet是一个协调的系统，每个组成部分--序列器、传播者和节点--都扮演着特定而又相互关联的角色、\n"
"证明者和节点都扮演着特定但又相互关联的角色。虽然\n"
"Starknet 还没有完全去中心化，但它正积极地向这个目标迈进。\n"
"这一目标。通过了解系统内的角色和交互关系\n"
"系统内的角色和交互的了解，将有助于您更好地掌握Starknet错综复杂的\n"
"生态系统的复杂性。"

#: src/ch03-00-architecture.md:14
#, fuzzy
msgid "## High-Level Overview"
msgstr "## 高级概述"

#: src/ch03-00-architecture.md:16
#, fuzzy
msgid ""
"Starknet’s operation begins when a transaction is received by a gateway,\n"
"which serves as the Mempool. This stage could also be managed by the\n"
"Sequencer. The transaction is initially marked as \"RECEIVED.\" The\n"
"Sequencer then incorporates the transaction into the network state and\n"
"tags it as \"ACCEPTED_ON_L2.\" The final step involves the Prover, which\n"
"executes the operating system on the new block, calculates its proof,\n"
"and submits it to the Layer 1 (L1) for verification."
msgstr ""
"当网关接收到一笔交易时，Starknet的运行就开始了、\n"
"网关充当 Mempool。这个阶段也可以由\n"
"序列器管理。事务最初被标记为 \"已接收\"。然后\n"
"然后，定序器将事务纳入网络状态，并标记为 \"ACCEPTED_ON_L2\"。\n"
"标记为 \"ACCEPTED_ON_L2\"。最后一步涉及验证器，它\n"
"在新区块上执行操作系统，计算其证明、\n"
"并提交给第一层 (L1) 进行验证。"

#: src/ch03-00-architecture.md:24
msgid "<img alt=\"Starknet Architecture\" src=\"img/ch03-architecture.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet Architecture\" src=\"img/ch03-architecture.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-00-architecture.md:26
msgid "<span class=\"caption\">Starknet architecture</span>"
msgstr "<span class=\"caption\">Starknet architecture</span>"

#: src/ch03-00-architecture.md:28
#, fuzzy
msgid "In essence, Starknet’s architecture involves multiple components:"
msgstr "从本质上讲，Starknet的架构涉及多个组成部分："

#: src/ch03-00-architecture.md:30
#, fuzzy
msgid ""
"- The Sequencer is responsible for receiving transactions, ordering\n"
"  them, and producing blocks. It operates similarly to validators in\n"
"  Ethereum or Bitcoin.\n"
"\n"
"- The Prover is tasked with generating proofs for the created blocks\n"
"  and transactions. It uses Cairo’s Virtual Machine to run provable\n"
"  programs, thereby creating execution traces necessary for generating\n"
"  STARK proofs.\n"
"\n"
"- Layer 1 (L1), in this case Ethereum, hosts a smart contract capable\n"
"  of verifying these STARK proofs. If the proofs are valid, Starknet’s\n"
"  state root on L1 is updated."
msgstr ""
"- 序列器负责接收事务、排序事务和生成区块。\n"
"  并生成区块。它的操作类似于\n"
"  以太坊或比特币中的验证器类似。\n"
"\n"
"- 证明者的任务是为创建的区块和交易生成证明\n"
"  和交易。它使用Cairo虚拟机运行可证明的\n"
"  程序，从而创建生成\n"
"  STARK 证明。\n"
"\n"
"- 第 1 层（L1），在本例中为以太坊，承载着一个智能合约，该合约能够\n"
"  能够验证这些 STARK 证明。如果证明有效，Starknet在 L1 上的\n"
"  在 L1 上的状态根就会被更新。"

#: src/ch03-00-architecture.md:43
#, fuzzy
msgid ""
"Starknet’s state is a comprehensive snapshot maintained through Merkle\n"
"trees, much like in Ethereum. This establishes the architecture of the\n"
"validity roll-up and the roles of each component."
msgstr ""
"Starknet的状态是通过 Merkle\n"
"树维护的综合快照，这与以太坊非常相似。这就确立了\n"
"的架构以及每个组件的作用。"

#: src/ch03-00-architecture.md:47
#, fuzzy
msgid "For a more in-depth look at each component, read on."
msgstr "如需更深入地了解每个组件，请继续阅读。"

#: src/ch03-00-architecture.md:49
#, fuzzy
msgid ""
"After exploring the introductory overview of the different components,\n"
"delve deeper into their specific roles by referring to their dedicated\n"
"subchapters in this Chapter."
msgstr ""
"在了解了不同组件的介绍性概述之后、\n"
"深入了解它们的具体作用后，请参阅本章中的专\n"
"章，深入了解它们的具体作用。"

#: src/ch03-00-architecture.md:53
#, fuzzy
msgid "## Sequencers"
msgstr "排序器"

#: src/ch03-00-architecture.md:55
#, fuzzy
msgid ""
"Sequencers are the backbone of the Starknet network, akin to Ethereum’s\n"
"validators. They usher transactions into the system."
msgstr ""
"序列器是 Starknet 网络的支柱，类似于以太坊的\n"
"验证器。它们将交易引入系统。"

#: src/ch03-00-architecture.md:58
#, fuzzy
msgid ""
"Validity rollups excel at offloading some network chores, like bundling\n"
"and processing transactions, to specialized players. This setup is\n"
"somewhat like how Ethereum and Bitcoin delegate security to miners.\n"
"Sequencing, like mining, demands hefty resources."
msgstr ""
"有效期滚动功能擅长于卸载一些网络杂务，如捆绑和处理交易。\n"
"和处理交易等工作。这种设置\n"
"有点像以太坊和比特币将安全性委托给矿工的方式。\n"
"排序和挖矿一样，都需要大量资源。"

#: src/ch03-00-architecture.md:63
#, fuzzy
msgid ""
"For networks like Starknet and other platforms utilizing Validity\n"
"rollups, a similar parallel is drawn. These networks outsource\n"
"transaction processing to specialized entities and then verify their\n"
"work. These specialized entities in the context of Validity rollups are\n"
"known as \"Sequencers.\""
msgstr ""
"对于像 Starknet 这样的网络和其他利用 Validity\n"
"rollups的网络也有类似的情况。这些网络将\n"
"这些网络将交易处理外包给专门的实体，然后对其工作进行验证。\n"
"工作。在有效期滚动的背景下，这些专业实体被称为 \"序列器\"。\n"
"称为 \"排序器\"。"

#: src/ch03-00-architecture.md:69
#, fuzzy
msgid ""
"Instead of providing security, as miners do, Sequencers provide\n"
"transaction capacity. They order (sequence) multiple transactions into a\n"
"single batch, executes them, and produce a block that will later be\n"
"proved by the Prover and submmited to the Layer 1 network as a single,\n"
"compact proof, known as a \"rollup.\" In other words, just as validators\n"
"in Ethereum and miners in Bitcoin are specialized actors securing the\n"
"network, Sequencers in Validity rollup-based networks are specialized\n"
"actors that provide transaction capacity."
msgstr ""
"序列器并不像矿工那样提供安全性，而是提供\n"
"交易容量。它们将多个交易排序\n"
"执行，并产生一个区块，该区块随后将被证明者证明，并作为一个单一的、子提交给第一层网络。\n"
"由证明者证明，并作为一个单一的紧凑证明发布到第一层网络、\n"
"紧凑的证明，即 \"卷积\"。换句话说，就像\n"
"和比特币的矿工一样，都是确保网络安全的专业人员。\n"
"网络，基于有效性卷积的网络中的排序器也是提供交易能力的专门角色。\n"
"提供交易能力。"

#: src/ch03-00-architecture.md:78
#, fuzzy
msgid ""
"This mechanism allows Validity (or ZK) rollups to handle a higher volume\n"
"of transactions while maintaining the security of the underlying\n"
"Ethereum network. It enhances scalability without compromising on\n"
"security."
msgstr ""
"这种机制允许有效性（或 ZK）卷积处理更多的交易量，同时保持底层的安全性。\n"
"交易量，同时维护底层\n"
"以太坊网络的安全性。它在不影响\n"
"安全性。"

#: src/ch03-00-architecture.md:83
#, fuzzy
msgid "Sequencers follow a systematic method for transaction processing:"
msgstr "排序器采用系统化方法进行事务处理："

#: src/ch03-00-architecture.md:85
#, fuzzy
msgid ""
"1.  Sequencing: They collect transactions from users and order\n"
"    (sequence) them.\n"
"\n"
"2.  Executing: Sequencers then process these transactions.\n"
"\n"
"3.  Batching: Transactions are grouped together in batches or blocks for\n"
"    efficiency.\n"
"\n"
"4.  Block Production: Sequencers produce blocks that contain batches of\n"
"    processed transactions."
msgstr ""
"1.  排序：它们收集用户的交易并对其进行排序\n"
"    (排序）。\n"
"\n"
"2.  执行：排序器随后处理这些事务。\n"
"\n"
"3.  批处理：将事务分批或分块处理，以提高效率。\n"
"    效率。\n"
"\n"
"4.  区块生产：排序器产生包含成批\n"
"    已处理的交易。"

#: src/ch03-00-architecture.md:96
#, fuzzy
msgid ""
"Sequencers must be reliable and highly available, as their role is\n"
"critical to the network’s smooth functioning. They need powerful and\n"
"well-connected machines to perform their role effectively, as they must\n"
"process transactions rapidly and continuously."
msgstr ""
"编解码器必须可靠且可用性高，因为它们的作用对网络的平稳运行至关重要。\n"
"对网络的平稳运行至关重要。它们需要功能强大、连接良好的\n"
"的机器才能有效发挥作用，因为它们必须\n"
"快速、连续地处理交易。"

#: src/ch03-00-architecture.md:101
#, fuzzy
msgid ""
"The current roadmap for Starknet includes decentralizing the Sequencer\n"
"role. This shift towards decentralization will allow more participants\n"
"to become Sequencers, contributing to the robustness of the network."
msgstr ""
"Starknet 当前的发展蓝图包括下放序列器角色。\n"
"角色。这种去中心化的转变将使更多的参与者\n"
"成为序列员，从而增强网络的稳健性。"

#: src/ch03-00-architecture.md:105
#, fuzzy
msgid ""
"For more details in the Sequencer role, refer to the dedicated\n"
"subchapter in this Chapter."
msgstr ""
"有关序列器角色的更多详情，请参阅本章中专门的\n"
"子章节。"

#: src/ch03-00-architecture.md:108
#, fuzzy
msgid "## Provers"
msgstr "证明器 🚧"

#: src/ch03-00-architecture.md:110
#, fuzzy
msgid ""
"Provers serve as the second line of verification in the Starknet\n"
"network. Their main task is to validate the work of the Sequencers (when\n"
"they receive the block produced by the Sequencer) and to generate proofs\n"
"that these processes were correctly performed."
msgstr ""
"验证器是Starknet的第二道验证关卡。\n"
"网络的第二道验证线。它们的主要任务是验证序列器的工作（当它们收到序列器生成的区块时\n"
"时）验证序列器的工作，并生成证明，证明这些过程是正确执行的。\n"
"证明这些过程的正确性。"

#: src/ch03-00-architecture.md:115
#, fuzzy
msgid "The duties of a Prover include:"
msgstr "Prover 的职责包括"

#: src/ch03-00-architecture.md:117
#, fuzzy
msgid ""
"1.  Receiving Blocks: Provers obtain blocks of processed transactions\n"
"    from Sequencers.\n"
"\n"
"2.  Processing: Provers process these blocks a second time, ensuring\n"
"    that all transactions within the block have been correctly handled.\n"
"\n"
"3.  Proof Generation: After processing, Provers generate a proof of\n"
"    correct transaction processing.\n"
"\n"
"4.  Sending Proof to Ethereum: Finally, the proof is sent to the\n"
"    Ethereum network for validation. If the proof is correct, the\n"
"    Ethereum network accepts the block of transactions."
msgstr ""
"1.  接收区块：证明者从序列器获取已处理的交易块\n"
"    从序列器中获取。\n"
"\n"
"2.  处理：证明者对这些交易块进行第二次处理，确保\n"
"    区块内的所有交易都得到正确处理。\n"
"\n"
"3.  生成证明：处理完成后，证明者会生成证明\n"
"    交易处理正确性的证明。\n"
"\n"
"4.  向以太坊发送证明：最后，证明会被发送到\n"
"    以太坊网络进行验证。如果证明正确\n"
"    以太坊网络接受该交易块。"

#: src/ch03-00-architecture.md:130
#, fuzzy
msgid ""
"Provers need even more computational power than Sequencers because they\n"
"have to calculate and generate proofs, a process that is computationally\n"
"heavy. However, the work of Provers can be split into multiple parts,\n"
"allowing for parallelism and efficient proof generation. The proof\n"
"generation process is asynchronous, meaning it doesn’t have to occur\n"
"immediately or in real-time. This flexibility allows for the workload to\n"
"be distributed among multiple Provers. Each Prover can work on a\n"
"different block, allowing for parallelism and efficient proof\n"
"generation."
msgstr ""
"证明者所需的计算能力甚至比序列发生器还高，因为它们\n"
"因为它们必须计算和生成证明，而这是一个计算量很大的过程。\n"
"繁重。不过，证明者的工作可以分成多个部分、\n"
"这样就可以并行高效地生成证明。证明\n"
"生成过程是异步的，这意味着它不必立即或实时进行。\n"
"立即或实时进行。这种灵活性允许\n"
"分配给多个证明者。每个证明者可以处理\n"
"不同的区块，从而实现并行和高效的证明\n"
"生成。"

#: src/ch03-00-architecture.md:140
#, fuzzy
msgid ""
"The design of Starknet relies on these two types of actors — Sequencers\n"
"and Provers — working in tandem to ensure efficient processing and\n"
"secure verification of transactions."
msgstr ""
"Starknet的设计依赖于这两类行动者--编排器和证明器--的协同工作，以确保高效的处理和验证。\n"
"和证明者协同工作，以确保高效处理和安全验证交易。\n"
"交易的安全验证。"

#: src/ch03-00-architecture.md:144
#, fuzzy
msgid ""
"For more details in the Prover role, refer to the dedicated subchapter\n"
"in this Chapter."
msgstr ""
"有关 Prover 角色的更多详情，请参阅本章的专门子章\n"
"子章节。"

#: src/ch03-00-architecture.md:147
#, fuzzy
msgid "## Optimizing Sequencers and Provers: Debunking Common Misconceptions"
msgstr "## 优化序列器和校验器：揭穿常见误解"

#: src/ch03-00-architecture.md:149
#, fuzzy
msgid ""
"The relationship between Sequencers and Provers in blockchain technology\n"
"often sparks debate. A common misunderstanding suggests that either the\n"
"Prover or the Sequencer is the main bottleneck. To set the record\n"
"straight, let’s discuss the optimization of both components."
msgstr ""
"区块链技术中的序列器和证明器之间的关系\n"
"经常引发争论。一个常见的误解是\n"
"证明者或序列器是主要瓶颈。为了澄清事实\n"
"让我们来讨论一下这两个组件的优化问题。"

#: src/ch03-00-architecture.md:154
#, fuzzy
msgid ""
"Starknet, utilizing the Cairo programming language, currently supports\n"
"only sequential transactions. Plans are in place to introduce parallel\n"
"transactions in the future. However, as of now, the Sequencer operates\n"
"one transaction at a time, making it the bottleneck in the system."
msgstr ""
"Starknet使用Cairo编程语言，目前只支持顺序事务。\n"
"目前只支持顺序事务。计划在未来引入并行\n"
"并行事务。不过，到目前为止，序列发生器每次只运行一个事务，这使它成为系统的瓶颈。\n"
"一次只能处理一个事务，成为系统的瓶颈。"

#: src/ch03-00-architecture.md:159
#, fuzzy
msgid ""
"In contrast, Provers operate asynchronously and can execute multiple\n"
"tasks in parallel. The use of proof recursion allows for task\n"
"distribution across multiple machines, making scalability less of an\n"
"issue for Provers."
msgstr ""
"相比之下，Provers 是异步运行的，可以并行执行多个任务。\n"
"任务并行执行。使用证明递归可以将任务\n"
"任务分配到多台机器上，从而减少了证明者的可扩展性问题。\n"
"扩展性问题。"

#: src/ch03-00-architecture.md:164
#, fuzzy
msgid ""
"Given the asynchronous and scalable nature of Provers, focus in Starknet\n"
"has shifted to enhancing the Sequencer’s efficiency. This explains why\n"
"current development efforts are primarily aimed at the sequencing side\n"
"of the equation."
msgstr ""
"鉴于 Provers 的异步和可扩展特性，Starknet 的重点\n"
"的重点已转向提高序列器的效率。这就解释了为什么\n"
"目前的开发工作主要集中在排序方面。\n"
"的原因。"

#: src/ch03-00-architecture.md:169
#, fuzzy
msgid "## Nodes"
msgstr "节点 🚧"

#: src/ch03-00-architecture.md:171
#, fuzzy
msgid ""
"When it comes to defining what nodes do in Bitcoin or Ethereum, people\n"
"often misinterpret their role as keeping track of every transaction\n"
"within the network. This, however, is not entirely accurate."
msgstr ""
"在定义节点在比特币或以太坊中的作用时，人们\n"
"常常被误解为跟踪网络中的每一笔交易。\n"
"网络中的每一笔交易。然而，这并不完全准确。"

#: src/ch03-00-architecture.md:175
#, fuzzy
msgid ""
"Nodes serve as auditors of the network, maintaining the state of the\n"
"network, such as how much Bitcoin each participant owns or the current\n"
"state of a specific smart contract. They accomplish this by processing\n"
"transactions and preserving a record of all transactions, but that’s a\n"
"means to an end, not the end itself."
msgstr ""
"节点充当网络的审计员，维护网络的状态，例如每个参与者拥有多少比特币或当前的比特币数量。\n"
"网络的状态，如每个参与者拥有多少比特币或特定智能合约的当前\n"
"特定智能合约的当前状态。它们通过处理\n"
"但这只是达到目的的手段，而不是目的。\n"
"但这只是达到目的的手段，而不是目的本身。"

#: src/ch03-00-architecture.md:181
#, fuzzy
msgid ""
"In Validity rollups and specifically within Starknet, this concept is\n"
"somewhat reversed. Nodes don’t necessarily have to process transactions\n"
"to get the state. In contrast to Ethereum or Bitcoin, Starknet nodes\n"
"aren’t required to process all transactions to maintain the state of the\n"
"network."
msgstr ""
"在有效性卷积中，特别是在Starknet中，这一概念有点相反。\n"
"有些相反。节点不一定要处理交易\n"
"来获取状态。与以太坊或比特币相比，Starknet 节点\n"
"并不需要处理所有交易来维持网络状态。\n"
"网络状态。"

#: src/ch03-00-architecture.md:187
#, fuzzy
msgid ""
"There are two main ways to access network state data: via an API gateway\n"
"or using the RPC protocol to communicate with a node. Operating your own\n"
"node is typically faster than using a shared architecture, like the\n"
"gateway. Over time, Starknet plans to deprecate APIs and replace them\n"
"with a JSON RPC standard, making it even more beneficial to operate your\n"
"own node."
msgstr ""
"访问网络状态数据有两种主要方式：通过 API 网关\n"
"或使用 RPC 协议与节点通信。操作自己的\n"
"节点通常比使用共享架构（如\n"
"网关。随着时间的推移，Starknet 计划淘汰 API，代之以\n"
"代之以 JSON RPC 标准，从而使操作自己的节点变得更加有利。\n"
"自己的节点。"

#: src/ch03-00-architecture.md:194
#, fuzzy
msgid ""
"It’s worth noting that encouraging more people to run nodes increases\n"
"the resilience of the network and prevents server flooding, which has\n"
"been an issue in networks in other L2s."
msgstr ""
"值得注意的是，鼓励更多的人运行节点可以增强网络的弹性，防止服务器泛滥。\n"
"值得注意的是，鼓励更多的人运行节点可以提高网络的弹性，防止服务器泛洪，而这在其他 L2 网络中一直是个问题。\n"
"在其他二级网络中，服务器泛洪一直是个问题。"

#: src/ch03-00-architecture.md:198
#, fuzzy
msgid ""
"Currently, there are primarily three methods for a node to keep track of\n"
"the network’s state and we can have nodes implement any of these\n"
"methods:"
msgstr ""
"目前，节点跟踪网络状态的方法主要有三种\n"
"我们可以让节点实现其中任何一种方法\n"
"方法："

#: src/ch03-00-architecture.md:202
#, fuzzy
msgid ""
"1.  **Replaying Old Transactions**: Like Ethereum or Bitcoin, a node can\n"
"    take all the transactions and re-execute them. Although this\n"
"    approach is accurate, it isn’t scalable unless you have a powerful\n"
"    machine that’s capable of handling the load. If you can replay all\n"
"    transactions, you can become a Sequencer.\n"
"\n"
"2.  **Relying on L2 Consensus**: Nodes can trust the Sequencer(s) to\n"
"    execute the network correctly. When the Sequencer updates the state\n"
"    and adds a new block, nodes accept the update as accurate.\n"
"\n"
"3.  **Checking Proof Validation on L1**: Nodes can monitor the state of\n"
"    the network by observing L1 and ensuring that every time a proof is\n"
"    sent, they receive the updated state. This way, they don’t have to\n"
"    trust anyone and only need to keep track of the latest valid\n"
"    transaction for Starknet."
msgstr ""
"1.  **重放旧交易**：与以太坊或比特币一样，节点可以\n"
"    获取所有交易并重新执行。虽然这种\n"
"    方法是准确的，但它不具备可扩展性，除非你有一台强大的\n"
"    的机器。如果可以重放所有\n"
"    事务，就可以成为序列器。\n"
"\n"
"2.  **依靠二级共识**：节点可以信赖序列器来正确执行网络。\n"
"    正确执行网络。当序列器更新状态\n"
"    并添加新区块时，节点会认为更新是准确的。\n"
"\n"
"3.  **在 L1 上检查证明验证**：节点可通过观察 L1\n"
"    节点可以通过观察 L1 来监控网络状态，确保每次发送证明时，节点都能收到更新的状态。\n"
"    节点都能收到更新的状态。这样，节点就不必\n"
"    信任任何人，只需跟踪Starknet的最新有效交易。\n"
"    交易。"

#: src/ch03-00-architecture.md:218
#, fuzzy
msgid ""
"Each type of node setup comes with its own set of hardware requirements\n"
"and trust assumptions."
msgstr ""
"每种节点设置都有自己的硬件要求和信任假设。\n"
"和信任假设。"

#: src/ch03-00-architecture.md:221
#, fuzzy
msgid "### Nodes That Replay Transactions"
msgstr "#### 重播交易的节点"

#: src/ch03-00-architecture.md:223
#, fuzzy
msgid ""
"Nodes that replay transactions require powerful machines to track and\n"
"execute all transactions. These nodes don’t have trust assumptions; they\n"
"rely solely on the transactions they execute, guaranteeing that the\n"
"state at any given point is valid."
msgstr ""
"重放事务的节点需要功能强大的机器来跟踪和执行所有事务。\n"
"执行所有事务。这些节点没有信任假设；它们\n"
"完全依赖于它们执行的事务，以保证任何给定点的状态都是有效的。\n"
"任何给定点的状态都是有效的。"

#: src/ch03-00-architecture.md:228
#, fuzzy
msgid "### Nodes That Rely on L2 Consensus"
msgstr "#### 依靠 L2 共识的节点"

#: src/ch03-00-architecture.md:230
#, fuzzy
msgid ""
"Nodes relying on L2 consensus require less computational power. They\n"
"need sufficient storage to keep the state but don’t need to process a\n"
"lot of transactions. The trade-off here is a trust assumption.\n"
"Currently, Starknet revolves around one Sequencer, so these nodes are\n"
"trusting Starkware not to disrupt the network. However, once a consensus\n"
"mechanism and leader election amongst Sequencers are in place, these\n"
"nodes will only need to trust that a Sequencer who staked their stake to\n"
"produce a block is not willing to lose it."
msgstr ""
"依赖 L2 共识的节点所需的计算能力较低。它们\n"
"需要足够的存储空间来保存状态，但不需要处理大量的事务。\n"
"大量事务。这里的权衡就是信任假设。\n"
"目前，Starknet 围绕着一个序列器，因此这些节点\n"
"因此这些节点相信 Starkware 不会破坏网络。但是，一旦\n"
"机制和序列器之间的领导者选举到位后，这些节点只需相信\n"
"节点将只需要相信押注产生区块的 Sequencer\n"
"不愿意失去它。"

#: src/ch03-00-architecture.md:239
#, fuzzy
msgid "### Nodes That Check Proof Validation on L1"
msgstr "###在 L1 上检查证明验证的节点"

#: src/ch03-00-architecture.md:241
#, fuzzy
msgid ""
"Nodes that only update their state based on proof validation on L1\n"
"require the least hardware. They have the same requirements as an\n"
"Ethereum node, and once Ethereum light nodes become a reality,\n"
"maintaining such a node could be as simple as using a smartphone. The\n"
"only trade-off is latency. Proofs are not sent to Ethereum every block\n"
"but intermittently, resulting in delayed state updates. Plans are in\n"
"place to produce proofs more frequently, even if they are not sent to\n"
"Ethereum immediately, allowing these nodes to reduce their latency.\n"
"However, this development is still a way off in the Starknet roadmap."
msgstr ""
"只根据 L1 上的证明验证更新状态的节点\n"
"的节点所需的硬件最少。它们与\n"
"一旦以太坊轻节点成为现实、\n"
"维护这样的节点就像使用智能手机一样简单。唯一的\n"
"唯一的权衡是延迟。证明不是每个区块都发送到以太坊\n"
"而是断断续续地发送，导致状态更新延迟。计划\n"
"计划更频繁地生成证明，即使它们不是立即发送到\n"
"以太坊，也能让这些节点减少延迟。\n"
"不过，在 Starknet 的路线图中，这一发展还遥遥无期。"

#: src/ch03-00-architecture.md:253
#, fuzzy
msgid ""
"Through this chapter, we delve into Starknet’s structure, uncovering the\n"
"importance of Sequencers, Provers, and nodes. Each plays a unique role,\n"
"but together, they create a highly scalable, efficient, and secure\n"
"network that marks a significant step forward in Layer 2 solutions. As\n"
"Starknet evolves towards decentralization, understanding these roles\n"
"will provide valuable insight into the inner workings of this network."
msgstr ""
"在本章中，我们将深入研究Starknet的结构，揭示序列器、证明器和节点的重要性。\n"
"序列器、证明器和节点的重要性。它们各自发挥着独特的作用、\n"
"但它们共同创建了一个高度可扩展、高效和安全的\n"
"网络，标志着第 2 层解决方案向前迈进了一大步。随着\n"
"随着Starknet向去中心化发展，了解这些角色\n"
"将为了解该网络的内部运作提供宝贵的信息。"

#: src/ch03-00-architecture.md:260
#, fuzzy
msgid ""
"As we venture further into the Starknet universe, our next stop will be\n"
"an exploration of the transaction lifecycle before we dive into the\n"
"heart of coding with Cairo."
msgstr ""
"当我们进一步探索Starknet世界时，我们的下一站将是\n"
"我们的下一站将是探索事务生命周期，然后再进入\n"
"用Cairo编码的核心。"

#: src/ch03-01-transactions.md:1
#, fuzzy
msgid "# Transaction Versions"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-transactions.md:3
msgid ""
"Understanding Starknet's transaction types is essential to master its architecture and capabilities. Each transaction type serves a unique purpose, and getting a grip on their differences is "
"crucial for proficient Starknet usage."
msgstr ""

#: src/ch03-01-transactions.md:5
#, fuzzy
msgid "## Starknet OS: The Backbone"
msgstr "## Starknet堆栈"

#: src/ch03-01-transactions.md:7
msgid "Central to Starknet's functionality is the Starknet Operating System (OS), a Cairo program that fuels the network. This OS orchestrates key activities, including:"
msgstr ""

#: src/ch03-01-transactions.md:9
msgid ""
"- Deploying contracts\n"
"- Executing transactions\n"
"- Facilitating L1<>L2 message exchanges"
msgstr ""

#: src/ch03-01-transactions.md:13
msgid "In Starknet terminology, \"protocol level\" alludes to modifications in the foundational Starknet OS Cairo program, ensuring its steadfastness."
msgstr ""

#: src/ch03-01-transactions.md:15
#, fuzzy
msgid "## Transaction Types"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-transactions.md:17
msgid ""
"- **Declare Transactions**: Unique in their ability to introduce new classes, leading to potential new smart contracts.\n"
"- **Invoke Transactions**: They call upon an action but can't introduce new ones.\n"
"- **Deploy Account Transactions**: Designed for setting up smart wallet contracts."
msgstr ""

#: src/ch03-01-transactions.md:21
#, fuzzy
msgid "## Declare Transactions"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-transactions.md:23
msgid "Declare transactions are the sole mechanism for introducing new smart contracts to Starknet."
msgstr ""

#: src/ch03-01-transactions.md:25
msgid ""
"Recall programming in C++. Before employing a variable or function, it's first 'declared', signaling to the compiler its existence and type. Only then can you 'define' or use it. Declare "
"transactions in Starknet operate on similar principles: they announce a new operation, prepping it for future use."
msgstr ""

#: src/ch03-01-transactions.md:27
msgid "Versions:"
msgstr ""

#: src/ch03-01-transactions.md:29
msgid ""
"- V0 - Suited for Cairo 0 contracts before nonces.\n"
"- V1 - Tailored for Cairo 0 with nonces.\n"
"- V2 (current) - Optimized for the modern Cairo contracts."
msgstr ""

#: src/ch03-01-transactions.md:33
msgid "Here's a key distinction to understand between the different Cairo versions:"
msgstr ""

#: src/ch03-01-transactions.md:35
msgid ""
"With Cairo 0, developers sent Cairo Assembly (CASM) code directly to the sequencer. But with the contemporary Cairo version, they send Sierra code to the Sequencer. Breaking it down, Cairo 0 "
"compiled straight to CASM, while the current Cairo version compiles to Sierra, which subsequently compiles to CASM. A crucial difference is that Sierra executions are infallible and always "
"provable, whereas in Cairo 0, transactions could fail. If they did, they became non-provable. The latest Cairo iteration ensures all code compiles to Sierra, making every transaction reliable."
msgstr ""

#: src/ch03-01-transactions.md:37
msgid "When declaring a contract with the latest version, developers are essentially announcing Sierra code, not just raw CASM."
msgstr ""

#: src/ch03-01-transactions.md:39
msgid ""
"Examining the parameters of a V2 transaction reveals measures that ensure the class hash corresponds to the Sierra code being dispatched. The class hash encompasses the hash of the Cairo assembly "
"code, but since developers send Sierra code, it's imperative to ensure that the dispatched code aligns with the indicated class hash."
msgstr ""

#: src/ch03-01-transactions.md:41
msgid "// TODO -> Provide specifics about the parameters included in the transaction."
msgstr ""

#: src/ch03-01-transactions.md:43
msgid "In essence, using the most recent Cairo version implies the utilization of the latest Declare transaction version."
msgstr ""

#: src/ch03-01-transactions.md:45
#, fuzzy
msgid "## Invoke Transactions"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-transactions.md:47
msgid ""
"Unlike Declare transactions, Invoke transactions don't add new functions. They ask the network to carry out actions, such as executing or deploying contracts. This method contrasts with Ethereum, "
"where a contract can either be deployed by sending a distinct transaction or by having another smart contract factory to deploy it. Starknet uses only the second method."
msgstr ""

#: src/ch03-01-transactions.md:49
msgid "The Universal Deployer Contract (UDC) in Starknet illustrates this idea. UDC, a public utility, helps deploy contracts. This mirrors how in C++, a declared function is called to perform tasks."
msgstr ""

#: src/ch03-01-transactions.md:51
msgid ""
"In computer science terms, think of how functions operate in C++. After declaring a function or object, you invoke it to take action. Starknet's Invoke transaction works similarly, activating pre-"
"declared contracts or functions."
msgstr ""

#: src/ch03-01-transactions.md:53
msgid ""
"Every Invoke transaction in Starknet undergoes `__validate__` and `__execute__` stages. The `__validate__` step checks the transaction's correctness, similar to a syntax or logic check. After "
"validation, the `__execute__` phase processes the transaction."
msgstr ""

#: src/ch03-01-transactions.md:55
msgid "This two-step process, focusing on utilizing existing functionalities, highlights Starknet's distinct transaction strategy."
msgstr ""

#: src/ch03-01-transactions.md:57
#, fuzzy
msgid "## Deploy Account Transactions"
msgstr "## 跟踪交易"

#: src/ch03-01-transactions.md:59
msgid ""
"A challenge arises: How do you set up accounts without having one already? When creating your first smart wallet contract, deployment fees arise. How do you cover these without a smart wallet? The "
"solution is deploy account transactions."
msgstr ""

#: src/ch03-01-transactions.md:61
msgid ""
"Uniquely in Starknet, addresses can accept funds even without an associated smart wallet. This trait is pivotal during deployment. Before an account is formally created, the `__validate__` function "
"checks the proposed deployment address (even if it lacks a smart wallet) for sufficient funds. If present, the constructor proceeds, resulting in account deployment. This method guarantees the new "
"account's legitimacy and financial readiness."
msgstr ""

#: src/ch03-01-transactions.md:65
msgid ""
"It's vital to understand each transaction type. Declare transactions stand out for their role in presenting new functions. By likening the process to C++ declarations, developers can grasp the "
"reasoning behind each transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:1
#, fuzzy
msgid "# Transactions Lifecycle"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-01-transactions-lifecycle.md:3
msgid "This chapter outlines the path of a Starknet transaction from its initiation to its finalization."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:5
msgid "Starknet processes transactions in distinct steps:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:7
msgid ""
"- A transaction starts by being sent to a gateway, a node, which acts as the Mempool.\n"
"- The Sequencer, currently a single service, first validates and the executes the transactions in order.\n"
"  - If validated successfully, the status becomes RECEIVED.\n"
"  - If not, the status is REJECTED.\n"
"  - Successfully executed transactions are applied to the state and marked as ACCEPTED_ON_L2.\n"
"  - Failed transactions during this phase are REVERTED.\n"
"- In the Prover stage, the system operates on the new block, computes its proof, and sends it to L1."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:15
msgid "The following image shows the transaction flow:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:17
msgid "<img alt=\"Transaction Overview\" src=\"img/ch03-transaction-overview.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Transaction Overview\" src=\"img/ch03-transaction-overview.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch03-01-01-transactions-lifecycle.md:19
msgid "Before exploring each step in-depth, let's clarify the different transaction statuses."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:21
msgid "Each transaction has two primary status types:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:23
msgid ""
"- **finality_status**: Reflects the transaction's finality. Possible values are:\n"
"  - RECEIVED: The transaction passed Mempool validation but hasn't been included in a block.\n"
"  - ACCEPTED_ON_L2 and ACCEPTED_ON_L1: The transaction was added to a block on L2 or L1, respectively.\n"
"- **execution_status**: Indicates the transaction's execution outcome. Values include:\n"
"  - REJECTED, REVERTED, or SUCCEEDED."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:29
msgid ""
"To obtain this information, query the transaction receipt returned by the Nodes. Refer to the Tooling chapter in the Starknet Book for methods like the `transaction_receipt` command in starkli or "
"the `fetch_transaction_receipt` method in the starknet-py library. We will use these tools throughout this chapter."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:31
#, fuzzy
msgid "## Nonces in Starknet"
msgstr "## Starknet中的测序仪"

#: src/ch03-01-01-transactions-lifecycle.md:33
msgid ""
"Initially, Starknet did not incorporate nonces. This omission meant that the same transaction could be sent multiple times with an identical nonce, leading to duplicate hashes—a problem. In "
"Ethereum, nonces not only sequence transactions but also ensure each has a unique hash. Similarly, Starknet employs nonces to assign a distinct hash to every transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:35
msgid ""
"Starknet's current stance on nonces mandates that they be sequential. In other words, when you transmit a transaction from your account, its nonce must precisely follow the previous transaction's "
"nonce."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:37
msgid "Although nonce abstraction would allow developers to manage this logic at the smart contract level, Starknet is reviewing this feature. However, its implementation is not deemed a priority."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:39
#, fuzzy
msgid "## Transaction Creation"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-01-transactions-lifecycle.md:41
msgid "A transaction starts with its preparation. The sender:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:43
msgid ""
"1. Queries their account nonce, which acts as a unique identifier for the transaction.\n"
"2. Signs the transaction.\n"
"3. Sends it to their Node."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:47
msgid ""
"The Node, analogous to a post office, receives the transaction and broadcasts it on the Starknet network, primarily to the Sequencer. As the network evolves, the transaction will be broadcasted to "
"multiple Sequencers."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:49
msgid ""
"Before broadcasting the transaction to the Sequencer, the gateways perform a validation step, such as checking that the max fee exceeds a minimum fee and the account's balance is greater than the "
"max fee. The transaction will be saved in the storage if the validation function passes."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:51
#, fuzzy
msgid "## The Sequencer's Role"
msgstr "排序器"

#: src/ch03-01-01-transactions-lifecycle.md:53
msgid "On receiving the transaction, the Sequencer acknowledges its receipt but hasn't processed it yet—similar to Ethereum's mempool state."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:55
#, fuzzy
msgid "Sequencer's Process:"
msgstr "排序器"

#: src/ch03-01-01-transactions-lifecycle.md:57
msgid ""
"1. Receive the transaction.\n"
"2. Validate it.\n"
"3. Execute it.\n"
"4. Update the state."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:62
msgid ""
"Remember, Starknet processes transactions sequentially. The nonce won't change until the Sequencer processes the transaction. This can complicate backend application development, potentially "
"causing errors if sending multiple transactions consecutively."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:64
msgid "## Acceptance on Layer-2 (L2)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:66
msgid ""
"Once the Sequencer validates and executes a transaction, it updates the state without waiting for block creation. The transaction finality status changes from 'RECEIVED' to 'ACCEPTED ON L2' at this "
"stage and the execution status to 'SUCCEEDED'."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:68
msgid ""
"Following the state update, the transaction is included in a block. However, the block isn't emitted immediately. The Sequencer decides the opportune moment to emit the block, either when there are "
"enough transactions to form a block or after a certain time has passed. When the block is emitted, the block becomes available for other Nodes to query."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:70
msgid "The transaction will have the following status:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:72
msgid ""
"- Finality status: ACCEPTED_ON_L2\n"
"- Execution status: SUCCEEDED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:75
msgid "If a transaction fails during execution, it will be included in the block with the status 'REVERTED'. In other words, REVERTED transactions"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:77
msgid ""
"It's essential to remember that at this stage, no proof has been generated, and the transaction relies on L2 consensus for security against censorship. There remains a slim possibility of "
"transaction reversal if all Sequencers collude. Therefore, these stages should be seen as different layers of transaction finality."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:79
msgid "## Acceptance on Layer-1 (L1)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:81
msgid ""
"The final step in the transaction's lifecycle is its acceptance on Layer-1 (L1). A Prover receives the block containing the transaction, re-executes the block, generates a proof, and sends it to "
"Ethereum. Specifically, the proof is sent to a smart contract on Ethereum called the Verifier smart contract, which checks the proof's validity. If valid, the transaction's status changes to "
"'accepted on L1', signifying the transaction's security by Ethereum consensus."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:83
msgid "Transaction Status Transition:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:85
msgid "1. Accepted on L2 -> Accepted on L1"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:87
msgid "## [Optional] Transaction Finality in Starknet"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:89
msgid ""
"Transaction finality refers to the point at which a transaction is considered irreversible and is no longer susceptible to being reversed or undone. It's the assurance that once a transaction is "
"committed, it can't be altered or rolled back, hence securing the integrity of the transaction and the system as a whole."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:91
msgid "Let's dive into the transaction finality in both Starknet and Ethereum, and how they compare."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:93
msgid "### Ethereum Transaction Finality"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:95
msgid ""
"Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A transaction has the finality status when it is part of a block that can't change without a significant amount of ETH getting "
"burned. The number of blocks required to ensure that a transaction won't be rolled back is called 'blocks to finality', and the time to create those blocks is called 'time to finality'."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:97
msgid "It is considered to be an average of 6 blocks to reach the finality status; given that a new block is validated each 12 seconds, the average time to finality for a transaction is 75 seconds."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:99
#, fuzzy
msgid "### Starknet Transaction Finality"
msgstr "## 跟踪交易"

#: src/ch03-01-01-transactions-lifecycle.md:101
msgid ""
"Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction finality process. The first step is when the transaction gets accepted on Layer-2 (Starknet), and the second step is when "
"the transaction gets accepted on Layer-1 (Ethereum)."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:103
msgid ""
"Accepted on L2: When a transaction is processed by the Sequencer and included in a block on Starknet, it reaches L2 finality. However, this finality relies on the L2 consensus and comes with a "
"slight risk of collusion among Sequencers leading to transaction reversal.\n"
"Accepted on L1: The absolute finality comes when the block containing the transaction gets a proof generated, the proof is validated by the Verifier contract on Ethereum, and the state is updated "
"on Ethereum. At this point, the transaction is as secure as the Ethereum's PoW consensus can provide, meaning it becomes computationally infeasible to alter or reverse."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:106
#, fuzzy
msgid "### Comparison"
msgstr "Cairo 是由 Starkware 发明的一种开源编程语言。它是一种图灵完备的语言，用于通用计算。它是一种低级语言，旨在编译到Cairo虚拟机。点击此处了解更多信息：[Cairo](.../theory/cairo.md)。"

#: src/ch03-01-01-transactions-lifecycle.md:108
msgid "The main difference between Ethereum and Starknet's transaction finality lies in the stages of finality and their reliance on consensus mechanisms."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:110
msgid ""
"Ethereum's transaction finality becomes increasingly unlikely to be reversed as more blocks are added.\n"
"Starknet's finality process is two-fold. The initial finality (L2) is quicker but relies on L2 consensus and carries a small risk of collusion. The ultimate finality (L1) is slower, as it involves "
"generation and validation of proofs and updates on Ethereum. However, once reached, it provides the same level of security as an Ethereum transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:113
#, fuzzy
msgid "## REJECTED Transactions"
msgstr "Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch03-01-01-transactions-lifecycle.md:115
msgid ""
"When a transaction passes validation in the Mempool but fails during the sequencer's **validate** phase, it receives the REJECTED status. Such transactions are not included in any block and "
"maintain the `finality_status` as RECEIVED. This rejection can occur for reasons including:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:117
msgid ""
"- Check max_fee is higher than the minimal tx cost\n"
"- Check Account balance is at least max_fee\n"
"- Check nonce. A mismatched nonce, where the transaction's nonce doesn't align with the account's expected next nonce.\n"
"- Execute **validate** (here a repeated contract declaration will fail and the transaction will be rejected)\n"
"- Limit #txs per account in the Gateway"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:123
msgid "Such transaction will have the following status:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:125
msgid ""
"- Finality status: RECEIVED\n"
"- Execution status: REJECTED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:128
msgid "To demonstrate a transaction with an invalid nonce, consider the Python code below (`get_transaction_receipt.py`). Using the `starknet-py` library, it fetches a rejected transaction:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:130
msgid ""
"```python\n"
"import asyncio\n"
"from starknet_py.net.gateway_client import GatewayClient\n"
"\n"
"async def fetch_transaction_receipt(transaction_id: str, network: str = \"testnet\"):\n"
"    client = GatewayClient(network)\n"
"    call_result = await client.get_transaction_receipt(transaction_id)\n"
"    return call_result\n"
"\n"
"receipt = asyncio.run(fetch_transaction_receipt(\"0x6d6e6575b85913ee8dfb170fe0db418f58f9422a0c6115350a79f9b38a1f5b8\"))\n"
"print(receipt)\n"
"```"
msgstr ""
"```python\n"
"import asyncio\n"
"from starknet_py.net.gateway_client import GatewayClient\n"
"\n"
"async def fetch_transaction_receipt(transaction_id: str, network: str = \"testnet\"):\n"
"    client = GatewayClient(network)\n"
"    call_result = await client.get_transaction_receipt(transaction_id)\n"
"    return call_result\n"
"\n"
"receipt = asyncio.run(fetch_transaction_receipt(\"0x6d6e6575b85913ee8dfb170fe0db418f58f9422a0c6115350a79f9b38a1f5b8\"))\n"
"print(receipt)\n"
"```"

#: src/ch03-01-01-transactions-lifecycle.md:143
#, fuzzy
msgid "Execute the code with:"
msgstr "执行命令后会显示："

#: src/ch03-01-01-transactions-lifecycle.md:145
msgid ""
"```bash\n"
"python3 get_transaction_receipt.py\n"
"```"
msgstr ""
"```bash\n"
"python3 get_transaction_receipt.py\n"
"```"

#: src/ch03-01-01-transactions-lifecycle.md:149
msgid "The resulting transaction receipt will include:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:151
msgid ""
"```bash\n"
"execution_status=<TransactionExecutionStatus.REJECTED: 'REJECTED'>, finality_status=<TransactionFinalityStatus.RECEIVED: 'RECEIVED'>,\n"
"block_number=None,\n"
"actual_fee=0\n"
"```"
msgstr ""
"```bash\n"
"execution_status=<TransactionExecutionStatus.REJECTED: 'REJECTED'>, finality_status=<TransactionFinalityStatus.RECEIVED: 'RECEIVED'>,\n"
"block_number=None,\n"
"actual_fee=0\n"
"```"

#: src/ch03-01-01-transactions-lifecycle.md:157
msgid "It's important to note that the user isn't charged a fee because the transaction didn't execute in the Sequencer."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:159
#, fuzzy
msgid "## Handling of Reverted Transactions"
msgstr "## 跟踪交易"

#: src/ch03-01-01-transactions-lifecycle.md:161
msgid "A transaction can be reverted due to failed execution, the transaction will still be included in a block, and the account will be charged for the resources consumed."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:163
msgid ""
"This adds a trust assumption for the Sequencer to be honest and non-censoring. In later versions, there will be an OS change that will enable the Sequencer to prove that a transaction failed and "
"charge the correct amount of gas for it, thus making it censorship-resistant with provably failed transactions."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:165
#, fuzzy
msgid "Transaction Status Transition"
msgstr "## 跟踪交易"

#: src/ch03-01-01-transactions-lifecycle.md:167
msgid "1. Received -> Reverted"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:169
msgid "## Transaction Lifecycle Summary"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:171
msgid "The following outlines the various steps in a transaction's lifecycle:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:173
msgid "<img alt=\"Transaction flow\" src=\"img/ch03-transaction_flow.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Transaction flow\" src=\"img/ch03-transaction_flow.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-01-01-transactions-lifecycle.md:177
msgid ""
"The lifecycle of a Starknet transaction is a carefully curated journey, ensuring efficient, secure, and transparent transaction processing. It incorporates everything from transaction creation, "
"Sequencer processing, Layer-2 and Layer-1 validation, to handling rejected and reverted transactions. By comprehending this lifecycle, developers and users can better navigate the Starknet "
"ecosystem and leverage its capabilities to the fullest."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:1
#, fuzzy
msgid "# Fee Mechanism"
msgstr "费用机制 🚧"

#: src/ch03-01-02-fee-mechanism.md:3
#, fuzzy
msgid "**NOTE: This section is a work in progress. Contributions are welcome.**"
msgstr "**注：本部分正在编写中。欢迎投稿。"

#: src/ch03-01-02-fee-mechanism.md:5
#, fuzzy
msgid "Implementing a fee system enhances Starknet's performance. Without fees, the system risks becoming overwhelmed by numerous transactions, even with optimizations."
msgstr "实施收费系统可以提高Starknet的性能。如果不收费，即使进行了优化，系统也有可能被大量交易淹没。"

#: src/ch03-01-02-fee-mechanism.md:7
#, fuzzy
msgid "## Fee Collection"
msgstr "## 收费"

#: src/ch03-01-02-fee-mechanism.md:9
#, fuzzy
msgid "When a transaction occurs on Layer 2 (L2), Starknet collects the corresponding fee using ERC-20 tokens. The transaction submitter pays the fee, and the sequencer receives it."
msgstr "当第二层（L2）发生交易时，Starknet将使用 ERC-20 代币收取相应的费用。交易提交者支付费用，排序者接收费用。"

#: src/ch03-01-02-fee-mechanism.md:11
#, fuzzy
msgid "## Fee Calculation"
msgstr "## 费用计算"

#: src/ch03-01-02-fee-mechanism.md:13
#, fuzzy
msgid "### Fee Measurement"
msgstr "### 费用测算"

#: src/ch03-01-02-fee-mechanism.md:15
#, fuzzy
msgid "Currently, fees are denominated in ETH. To determine the expected fee, multiply the transaction's gas estimate by the gas price:"
msgstr "目前，费用以 ETH 计价。要确定预期费用，请将交易的天然气估算值乘以天然气价格："

#: src/ch03-01-02-fee-mechanism.md:17
#, fuzzy
msgid ""
"```\n"
"expected_fee = gas_estimate * gas_price;\n"
"```"
msgstr ""
"```\n"
"expected_fee = gas_estimate * gas_price；\n"
"```"

#: src/ch03-01-02-fee-mechanism.md:21
#, fuzzy
msgid "### Fee Computation"
msgstr "### 费用计算"

#: src/ch03-01-02-fee-mechanism.md:23
#, fuzzy
msgid "To grasp fee computation, understand these terms:"
msgstr "要掌握费用计算，请先了解这些术语："

#: src/ch03-01-02-fee-mechanism.md:25
#, fuzzy
msgid ""
"- **Built-In**: These are predefined operations in your code, simplifying common tasks or calculations. The following are built-ins:\n"
"\n"
"  - **Cairo Steps**: These building blocks in Cairo facilitate various program operations. Essential for running smart contracts and apps on blockchain platforms, the steps used influence a "
"program's cost and efficiency.\n"
"  - **Pedersen Hashes**: A method to convert data into a distinct code, similar to a data fingerprint, ensuring data integrity on blockchains.\n"
"  - **Range Checks**: Safety measures in programs, ensuring numbers or values stay within designated limits to avoid errors.\n"
"  - **Signature Verifications**: These confirm that a digital signature matches the anticipated one, verifying the sender's authenticity.\n"
"\n"
"- **Weight**: Indicates the significance or cost of an operation, showing how resource-intensive an action is in the program."
msgstr ""
"- **内置**：这些是代码中的预定义操作，可简化常见任务或计算。以下是内置操作：\n"
"\n"
"  - **Cairo步骤**：Cairo中的这些构件可促进各种程序运行。对于在区块链平台上运行智能合约和应用程序至关重要，所使用的步骤会影响程序的成本和效率。\n"
"  - **Pedersen Hashes**：一种将数据转换为独特代码的方法，类似于数据指纹，可确保区块链上的数据完整性。\n"
"  - **范围检查**：程序中的安全措施，确保数字或数值保持在指定范围内，以避免错误。\n"
"  - **签名验证**：确认数字签名是否与预期相符，验证发送者的真实性。\n"
"\n"
"- **权重**：表示操作的重要性或成本，显示程序中某项操作的资源密集程度。"

#: src/ch03-01-02-fee-mechanism.md:34
#, fuzzy
msgid "### Computation"
msgstr "Cairo 是由 Starkware 发明的一种开源编程语言。它是一种图灵完备的语言，用于通用计算。它是一种低级语言，旨在编译到Cairo虚拟机。点击此处了解更多信息：[Cairo](.../theory/cairo.md)。"

#: src/ch03-01-02-fee-mechanism.md:36
#, fuzzy
msgid "In Cairo, each execution trace is divided into distinct slots dedicated to specific built-in components, influencing fee calculation."
msgstr "在Cairo，每个执行轨迹都被划分为不同的时段，专门用于影响费用计算的特定内置组件。"

#: src/ch03-01-02-fee-mechanism.md:38
#, fuzzy
msgid "Consider a trace containing the following component limits:"
msgstr "考虑包含以下分量限值的轨迹："

#: src/ch03-01-02-fee-mechanism.md:40
#, fuzzy
msgid ""
"| Component               | Limit       |\n"
"| ----------------------- | ----------- |\n"
"| Cairo Steps             | 200,000,000 |\n"
"| Pedersen Hashes         | 5,000,000   |\n"
"| Signature Verifications | 1,000,000   |\n"
"| Range Checks            | 2,500,000   |"
msgstr ""
"| 组件 | 极限\n"
"| ----------------------- | ----------- |\n"
"| Cairo步骤\n"
"| Pedersen 哈希值 | 5,000,000 | 签名验证\n"
"| 签名验证 1,000,000\n"
"| 范围检查 2,500,000"

#: src/ch03-01-02-fee-mechanism.md:47
#, fuzzy
msgid "When a component reaches its maximum, the proof is sent to Layer 1. It's imperative to set these component divisions beforehand as they cannot be adjusted dynamically."
msgstr "当分量达到最大值时，证明将被发送到第 1 层。必须事先设置这些分量，因为它们不能动态调整。"

#: src/ch03-01-02-fee-mechanism.md:49
#, fuzzy
msgid ""
"Assuming a transaction utilizes 10,000 Cairo steps and 500 Pedersen hashes, it could accommodate 40,000 such transactions in this trace (given the calculation 20,000,000/500). The gas price becomes "
"1/40,000 of the proof submission cost. In this instance, the number of Cairo steps isn't the constraining factor, so it isn't factored into our performance estimate."
msgstr ""
"假设一个交易使用 10,000 个Cairo步骤和 500 个佩德森哈希值，那么在这个轨迹中可以容纳 40,000 个这样的交易（按照 20,000,000/500 计算）。气体价格就变成了提交证明成本的 1/40000。在这种情况下，Cairo步数并"
"不是限制因素，因此我们在估算性能时并没有将其考虑在内。"

#: src/ch03-01-02-fee-mechanism.md:51
#, fuzzy
msgid "Typically, the sequencer determines a vector, `CairoResourceUsage`, for every transaction. This vector accounts for:"
msgstr "通常，排序器会为每个事务确定一个向量 \"CairoResourceUsage\"。该向量包括"

#: src/ch03-01-02-fee-mechanism.md:53
#, fuzzy
msgid ""
"1. The count of Cairo steps.\n"
"2. The application count of each Cairo built-in (like range checks and Pedersen hashes)."
msgstr ""
"1.Cairo步数。\n"
"2.每个Cairo内置程序的应用次数（如范围检查和 Pedersen 哈希值）。"

#: src/ch03-01-02-fee-mechanism.md:56
#, fuzzy
msgid "The sequencer then pairs this data with the `CairoResourceFeeWeights` vector, dictating the gas cost of each proof component."
msgstr "然后，排序器将这些数据与 \"Cairo资源费用权重 \"向量配对，决定每个证明组件的气体成本。"

#: src/ch03-01-02-fee-mechanism.md:60
#, fuzzy
msgid ""
"> If a proof with 20,000,000 Pedersen hashes costs 5 million gas, then the Pedersen built-in has a weight of 0.25 gas per use (calculated as 5,000,000/20,000,000). Sequencers set these weight "
"values based on proof parameters."
msgstr "> 如果一个有 20,000,000 个 Pedersen 哈希值的校样需要 500 万个气体，那么内置 Pedersen 每次使用的重量为 0.25 个气体（计算公式为 5,000,000/20,000,000）。序列器根据打样参数设置这些重量值。"

#: src/ch03-01-02-fee-mechanism.md:62
#, fuzzy
msgid "The fee is determined by the most restrictive component and is calculated as:"
msgstr "费用由限制性最强的部分决定，计算公式为"

#: src/ch03-01-02-fee-mechanism.md:64
#, fuzzy
msgid ""
"```\n"
"maxk[CairoResourceUsagek * CairoResourceFeeWeightsk]\n"
"```"
msgstr ""
"```\n"
"maxk[CairoResourceUsagek * CairoResourceFeeWeightsk] 最大值\n"
"```"

#: src/ch03-01-02-fee-mechanism.md:68
#, fuzzy
msgid "Where \"k\" denotes the Cairo resource elements, encompassing step numbers and built-ins. The weightings for these components are:"
msgstr "其中，\"k \"表示Cairo资源要素，包括步骤编号和内置要素。这些要素的权重为"

#: src/ch03-01-02-fee-mechanism.md:70
#, fuzzy
msgid ""
"| Component   | Gas Cost       | Range           |\n"
"| ----------- | -------------- | --------------- |\n"
"| Cairo Step  | 0.01 gwei/gas  | per step        |\n"
"| Pedersen    | 0.32 gwei/gas  | per application |\n"
"| Poseidon    | 0.32 gwei/gas  | per application |\n"
"| Range Check | 0.16 gwei/gas  | per application |\n"
"| ECDSA       | 20.48 gwei/gas | per application |\n"
"| Keccak      | 20.48 gwei/gas | per application |\n"
"| Bitwise     | 0.64 gwei/gas  | per application |\n"
"| EC_OP       | 10.24 gwei/gas | per application |"
msgstr ""
"| 组件 | 燃气成本 | 范围\n"
"| ----------- | -------------- | --------------- |\n"
"| Cairo Step | 0.01 gwei/gas | 每个步骤\n"
"Pedersen | 0.32 gwei/gas | 每个应用 | Poseidon | 0.01 gwei/gas | 每个步骤\n"
"| Poseidon | 0.32 gwei/gas | 每次使用\n"
"| 范围检查 | 0.16 gwei/gas | 每个应用程序\n"
"| ECDSA | 20.48 gwei/gas | 每个应用程序\n"
"| Keccak | 20.48 gwei/gas | 每个应用程序\n"
"| Bitwise | 0.64 gwei/gas | 每个应用程序\n"
"| EC_OP | 10.24 gwei/gas | 每个应用程序"

#: src/ch03-02-sequencers.md:1
#, fuzzy
msgid "# Sequencers"
msgstr "排序器"

#: src/ch03-02-sequencers.md:3
#, fuzzy
msgid ""
"Before diving in, make sure to check out the [\"Understanding Starknet:\n"
"Sequencers, Provers, and\n"
"Nodes\"](https://book.starknet.io/chapter_3/topology.html) chapter for a\n"
"quick rundown of Starknet’s architecture."
msgstr ""
"在深入了解之前，请务必查看[\"了解Starknet：\n"
"序列器、证明器和\n"
"节点\"](https://book.starknet.io/chapter_3/topology.html) 章节，快速了解Starknet的架构。\n"
"Starknet架构的简要介绍。"

#: src/ch03-02-sequencers.md:8
#, fuzzy
msgid ""
"Three main layers exist in blockchain: data availability, ordering, and\n"
"execution. Sequencers have evolved within this evolving modular\n"
"landscape of blockchain technology. Most L1 blockchains, like Ethereum,\n"
"handle all these tasks. Initially, blockchains served as distributed\n"
"virtual machines focused on organizing and executing transactions. Even\n"
"roll-ups running on Ethereum today often centralize sequencing\n"
"(ordering) and execution while relying on Ethereum for data\n"
"availability. This is the current state of Starknet, which uses Ethereum\n"
"for data availability and a centralized Sequencer for ordering and\n"
"execution. However, it is possible to decentralize sequencing and\n"
"execution, as Starknet is doing."
msgstr ""
"区块链有三个主要层次：数据可用性、排序和执行。\n"
"执行。排序器就是在这种不断发展的模块化\n"
"区块链技术的不断发展。大多数 L1 区块链，如以太坊、\n"
"处理所有这些任务。最初，区块链作为分布式\n"
"虚拟机，专注于组织和执行交易。即使是\n"
"如今，即使是在以太坊上运行的卷积链也经常集中排序\n"
"(排序）和执行，同时依赖以太坊提供数据\n"
"可用性。这就是 Starknet 的现状，它使用以太坊\n"
"来提供数据可用性，并使用集中式排序器来进行排序和执行。\n"
"执行。然而，去中心化排序和执行也是可能的。\n"
"执行，就像 Starknet 正在做的那样。"

#: src/ch03-02-sequencers.md:20
#, fuzzy
msgid ""
"Each of these layers plays a crucial role in achieving consensus. First,\n"
"the data must be available. Second, it needs to be put in a specific\n"
"order. That’s the main job of a Sequencer, whether run by a single\n"
"computer or a decentralized protocol. Lastly, you execute transactions\n"
"in the order they’ve been sequenced. This final step, done by the\n"
"Sequencer too, determines the system’s current state and keeps all\n"
"connected clients on the same page."
msgstr ""
"在达成共识的过程中，每一层都发挥着至关重要的作用。首先、\n"
"数据必须可用。其次，数据必须按照特定的\n"
"顺序排列。这就是序列器的主要工作，无论是由单台计算机运行的序列器\n"
"计算机或分散协议运行。最后，执行交易\n"
"按顺序执行。这最后一步也是由\n"
"定系统的当前状态，并让所有连接的客户端保持一致。\n"
"连接的客户端保持一致。"

#: src/ch03-02-sequencers.md:28
#, fuzzy
msgid "## Introduction to Sequencers"
msgstr "## 音序器简介"

#: src/ch03-02-sequencers.md:30
#, fuzzy
msgid ""
"The advent of Layer Two (L2) solutions like Roll-Ups has altered the\n"
"blockchain landscape, improving scalability and efficiency. But what\n"
"about transaction order? Is it still managed by the base layer (L1), or\n"
"is an external system involved? Enter Sequencers. They ensure\n"
"transactions are in the correct order, regardless of whether they’re\n"
"managed by L1 or another system."
msgstr ""
"Roll-Ups 等第二层（L2）解决方案的出现改变了\n"
"区块链的格局，提高了可扩展性和效率。但是\n"
"交易秩序呢？是仍由基础层（L1）管理，还是有外部系统参与？\n"
"涉及外部系统？进入序列器。它们能确保\n"
"事务顺序正确，无论它们是由 L1 还是其他系统管理。\n"
"由 L1 还是其他系统管理。"

#: src/ch03-02-sequencers.md:37
#, fuzzy
msgid ""
"In essence, sequencing has two core tasks: sequencing (ordering) and\n"
"executing (validation). First, it orders transactions, determining the\n"
"canonical sequence of blocks for a given chain fork. It then appends new\n"
"blocks to this sequence. Second, it executes these transactions,\n"
"updating the system’s state based on a given function."
msgstr ""
"从本质上讲，排序有两个核心任务：排序（排序）和执行（验证）。\n"
"执行（验证）。首先，它对交易进行排序，确定\n"
"给定链分叉的典型区块顺序。然后，它将新\n"
"区块到该序列中。其次，它执行这些事务、\n"
"根据给定函数更新系统状态。"

#: src/ch03-02-sequencers.md:43
#, fuzzy
msgid ""
"To clarify, we see sequencing as the act of taking a group of unordered\n"
"transactions and producing an ordered block. Sequencers also confirm the\n"
"resulting state of the machine. However, the approach explained here\n"
"separates these tasks. While some systems handle both ordering and state\n"
"validation simultaneously, we advocate for treating them as distinct\n"
"steps."
msgstr ""
"为了澄清这一点，我们认为排序是将一组无序的交易\n"
"交易并生成一个有序区块的行为。排序器还会确认\n"
"机器的状态。不过，这里解释的方法\n"
"将这些任务分开。虽然有些系统会同时处理排序和状态\n"
"同时进行，但我们主张将它们作为不同的\n"
"步骤。"

#: src/ch03-02-sequencers.md:50
msgid "<img alt=\"Sequencer role in the Starknet network\" src=\"img/ch03-sequencer.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Sequencer role in the Starknet network\" src=\"img/ch03-sequencer.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-02-sequencers.md:52
msgid "<span class=\"caption\">Sequencer role in the Starknet network</span>"
msgstr "<span class=\"caption\">Sequencer role in the Starknet network</span>"

#: src/ch03-02-sequencers.md:54
#, fuzzy
msgid "## Sequencers in Starknet"
msgstr "## Starknet中的测序仪"

#: src/ch03-02-sequencers.md:56
#, fuzzy
msgid ""
"Let’s delve into Sequencers by focusing on\n"
"[Madara](https://github.com/keep-starknet-strange/madara) and\n"
"[Kraken](https://github.com/lambdaclass/starknet_stack/tree/main/sequencer),\n"
"two high-performance Starknet Sequencers. A Sequencer must, at least, do\n"
"two things: order and execute transactions."
msgstr ""
"让我们深入了解序列器，重点关注\n"
"[玛达拉](https://github.com/keep-starknet-strange/madara) 和\n"
"[卡拉基](https://github.com/lambdaclass/starknet_stack/tree/main/sequencer)、\n"
"两个高性能Starknet编曲器。序列器至少必须做两件事：排序和执行事务。\n"
"两件事：排序和执行事务。"

#: src/ch03-02-sequencers.md:62
#, fuzzy
msgid ""
"- **Ordering**: Madara handles the sequencing process, supporting\n"
"  methods from simple FCFS and PGA to complex ones like Narwhall &\n"
"  Bullshark. It also manages the mempool, a critical data structure\n"
"  that holds unconfirmed transactions. Developers can choose the\n"
"  consensus protocol through Madara’s use of Substrate, which offers\n"
"  multiple built-in options.\n"
"\n"
"- **Execution**: Madara lets you choose between two execution crates:\n"
"  [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)\n"
"  and\n"
"  [Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust).\n"
"  Both use the [Cairo VM](https://github.com/lambdaclass/cairo-vm) for\n"
"  their framework."
msgstr ""
"- ** 排序**：Madara 处理排序过程，支持\n"
"  从简单的 FCFS 和 PGA 到复杂的 Narwhall 和\n"
"  Bullshark 等复杂方法。它还管理内存池，这是一个重要的数据结构\n"
"  存储未确认事务的重要数据结构。开发者可以通过\n"
"  共识协议。\n"
"  多种内置选项。\n"
"\n"
"- **执行**：Madara 可让你在两种执行工具箱中进行选择：\n"
"  [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)\n"
"  和\n"
"  [Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust)。\n"
"  两者都使用 [Cairo VM](https://github.com/lambdaclass/cairo-vm)作为框架。\n"
"  框架。"

#: src/ch03-02-sequencers.md:76
#, fuzzy
msgid "We also have the Kraken Sequencer as another option."
msgstr "我们还有 Kraken Sequencer 作为另一种选择。"

#: src/ch03-02-sequencers.md:78
#, fuzzy
msgid ""
"- **Ordering**: It employs Narwhall & Bullshark for mempool\n"
"  management. You can choose from multiple consensus methods, like\n"
"  Bullshark, Tendermint, or Hotstuff.\n"
"\n"
"- **Execution**: Runs on Starknet_in_Rust. Execution can be deferred\n"
"  to either [Cairo\n"
"  Native](https://github.com/lambdaclass/cairo_native) or [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm)."
msgstr ""
"- **订购**：它采用 Narwhall 和 Bullshark 进行内存池\n"
"  管理。您可以选择多种共识方法，如\n"
"  Bullshark、Tendermint 或 Hotstuff。\n"
"\n"
"- **执行**：在 Starknet_in_Rust 上运行。执行可以推迟到\n"
"  Cairo\n"
"  Native](https://github.com/lambdaclass/cairo_native) 或 [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm)。"

#: src/ch03-02-sequencers.md:87
msgid ""
"<table style=\"width:100%;\">\n"
"<colgroup>\n"
"<col style=\"width: 42%\" />\n"
"<col style=\"width: 28%\" />\n"
"<col style=\"width: 28%\" />\n"
"</colgroup>\n"
"<thead>\n"
"<tr class=\"header\">\n"
"<th style=\"text-align: left;\">Feature</th>\n"
"<th style=\"text-align: left;\"><a\n"
"href=\"https://github.com/keep-starknet-strange/madara\">Madara</a></th>\n"
"<th style=\"text-align: left;\"><a\n"
"href=\"https://github.com/lambdaclass/starknet_stack/tree/main/sequencer\">Kraken</a></th>\n"
"</tr>\n"
"</thead>\n"
"<tbody>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Ordering\n"
"Method</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>FCFS, PGA, Narwhall &amp;\n"
"Bullshark</p></td>\n"
"<td style=\"text-align: left;\"><p>Narwhall &amp; Bullshark</p></td>\n"
"</tr>\n"
"<tr class=\"even\">\n"
"<td style=\"text-align: left;\"><p><strong>Mempool\n"
"Management</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>Managed by Madara</p></td>\n"
"<td style=\"text-align: left;\"><p>Managed using Narwhall &amp;\n"
"Bullshark</p></td>\n"
"</tr>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Consensus\n"
"Options</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>Developer’s choice through\n"
"Substrate</p></td>\n"
"<td style=\"text-align: left;\"><p>Bullshark, Tendermint or\n"
"Hotstuff</p></td>\n"
"</tr>\n"
"<tr class=\"even\">\n"
"<td style=\"text-align: left;\"><p><strong>Execution\n"
"Crates</strong></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/starkware-libs/blockifier/tree/main\">Blockifier</a>,\n"
"Starknet_in_rust</p></td>\n"
"<td style=\"text-align: left;\"><p>Starknet_in_rust</p></td>\n"
"</tr>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Execution\n"
"Framework</strong></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/lambdaclass/cairo_native\">Cairo Native</a> or\n"
"<a href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
"</tr>\n"
"</tbody>\n"
"</table>"
msgstr ""
"<table style=\"width:100%;\">\n"
"<colgroup>\n"
"<col style=\"width: 42%\" />\n"
"<col style=\"width: 28%\" />\n"
"<col style=\"width: 28%\" />\n"
"</colgroup>\n"
"<thead>\n"
"<tr class=\"header\">\n"
"<th style=\"text-align: left;\">Feature</th>\n"
"<th style=\"text-align: left;\"><a\n"
"href=\"https://github.com/keep-starknet-strange/madara\">Madara</a></th>\n"
"<th style=\"text-align: left;\"><a\n"
"href=\"https://github.com/lambdaclass/starknet_stack/tree/main/sequencer\">Kraken</a></th>\n"
"</tr>\n"
"</thead>\n"
"<tbody>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Ordering\n"
"Method</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>FCFS, PGA, Narwhall &amp;\n"
"Bullshark</p></td>\n"
"<td style=\"text-align: left;\"><p>Narwhall &amp; Bullshark</p></td>\n"
"</tr>\n"
"<tr class=\"even\">\n"
"<td style=\"text-align: left;\"><p><strong>Mempool\n"
"Management</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>Managed by Madara</p></td>\n"
"<td style=\"text-align: left;\"><p>Managed using Narwhall &amp;\n"
"Bullshark</p></td>\n"
"</tr>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Consensus\n"
"Options</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>Developer’s choice through\n"
"Substrate</p></td>\n"
"<td style=\"text-align: left;\"><p>Bullshark, Tendermint or\n"
"Hotstuff</p></td>\n"
"</tr>\n"
"<tr class=\"even\">\n"
"<td style=\"text-align: left;\"><p><strong>Execution\n"
"Crates</strong></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/starkware-libs/blockifier/tree/main\">Blockifier</a>,\n"
"Starknet_in_rust</p></td>\n"
"<td style=\"text-align: left;\"><p>Starknet_in_rust</p></td>\n"
"</tr>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Execution\n"
"Framework</strong></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/lambdaclass/cairo_native\">Cairo Native</a> or\n"
"<a href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
"</tr>\n"
"</tbody>\n"
"</table>"

#: src/ch03-02-sequencers.md:145
#, fuzzy
msgid "### Understanding the Execution Layer"
msgstr "### 了解执行层"

#: src/ch03-02-sequencers.md:147
#, fuzzy
msgid ""
"- [Blockifier](https://github.com/starkware-libs/blockifier/tree/main),\n"
"  a Rust component in Starknet Sequencers, generates state diffs and\n"
"  blocks. It uses [Cairo VM](https://github.com/lambdaclass/cairo-vm).\n"
"  Its goal is to become a full Starknet Sequencer.\n"
"\n"
"- Starknet_in_Rust is another Rust component for Starknet that also\n"
"  generates state diffs and blocks. It uses [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm).\n"
"\n"
"- [Cairo Native](https://github.com/lambdaclass/cairo_native) stands\n"
"  out by converting Cairo’s Sierra code to MLIR. See an example\n"
"  [here](https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)."
msgstr ""
"- [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)、\n"
"  Starknet时序器中的 Rust 组件，可生成状态差异和块。\n"
"  块。它使用 [Cairo VM](https://github.com/lambdaclass/cairo-vm)。\n"
"  它的目标是成为一个完整的 Starknet 序列器。\n"
"\n"
"- Starknet_in_Rust是Starknet的另一个Rust组件，它也能\n"
"  生成状态差异和块。它使用 [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm)。\n"
"\n"
"- [Cairo本地](https://github.com/lambdaclass/cairo_native)\n"
"  通过将 Cairo 的 Sierra 代码转换为 MLIR 而脱颖而出。请看示例\n"
"  [这里](https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)。"

#: src/ch03-02-sequencers.md:160
#, fuzzy
msgid "## The Need for Decentralized Sequencers"
msgstr "## 对分散式序列器的需求"

#: src/ch03-02-sequencers.md:162
#, fuzzy
msgid ""
"For more details on the Decentralization of Starknet, refer to the\n"
"dedicated subchapter in this Chapter."
msgstr ""
"有关Starknet权力下放的更多详情，请参阅本章的\n"
"本章的专门分章。"

#: src/ch03-02-sequencers.md:165
#, fuzzy
msgid ""
"Proving transactions doesn’t require to be decentralized (although in\n"
"the near future Starknet will operate with decentralized provers). Once\n"
"the order is set, anyone can submit a proof; it’s either correct or not.\n"
"However, the process that determines this order should be decentralized\n"
"to maintain a blockchain’s original qualities."
msgstr ""
"证明交易并不需要去中心化（尽管在\n"
"但在不久的将来，Starknet将使用去中心化的证明器）。一旦\n"
"任何人都可以提交证明；证明要么正确，要么错误。\n"
"但是，决定这个顺序的过程应该是去中心化的\n"
"以保持区块链的原有特性。"

#: src/ch03-02-sequencers.md:171
#, fuzzy
msgid ""
"In the context of Ethereum’s Layer 1 (L1), Sequencers can be likened to\n"
"Ethereum validators. They are responsible for creating and broadcasting\n"
"blocks. This role is divided under the concept of \"Proposer-Builder\n"
"Separation\" (PBS) ([Hasu,\n"
"2023](https://www.youtube.com/watch?v=6xS0xMzh9Tc)). Block builders form\n"
"blocks (order the transactions), while block proposers, unaware of the\n"
"block’s content, choose the most profitable one. This separation\n"
"prevents transaction censorship at the protocol level. Currently, most\n"
"Layer 2 (L2) Sequencers, including Starknet, perform both roles, which\n"
"can create issues."
msgstr ""
"在以太坊第一层（L1）的背景下，序列器可以比作\n"
"以太坊验证器。它们负责创建和广播\n"
"区块。这一角色在 \"提议者--创建者分离\"（Proposer-Builder\n"
"分离\"（PBS）（[Hasu、\n"
"2023](https://www.youtube.com/watch?v=6xS0xMzh9Tc)）。区块构建者形成\n"
"交易），而区块提议者在不知道区块内容的情况下，选择最有利可图的\n"
"选择最有利可图的区块。这种分离\n"
"防止了协议层面的交易审查。目前，大多数\n"
"第 2 层（L2）序列器（包括Starknet）都同时扮演这两种角色，这可能会产生问题。\n"
"会产生问题。"

#: src/ch03-02-sequencers.md:182
#, fuzzy
msgid ""
"The drive toward centralized Sequencers mainly stems from performance\n"
"issues like high costs and poor user experience on Ethereum for both\n"
"data storage and transaction ordering. The challenge is scalability: how\n"
"to expand without sacrificing decentralization. Opting for\n"
"centralization risks turning the blockchain monopolistic, negating its\n"
"unique advantages like network-effect services without monopoly."
msgstr ""
"对集中式序列器的推动主要源于性能问题，如以太坊上的高成本和糟糕的用户体验。\n"
"成本高、用户体验差等问题。\n"
"数据存储和交易排序的成本和用户体验差等性能问题。挑战在于可扩展性：如何\n"
"在不牺牲去中心化的前提下进行扩展。选择\n"
"中心化有可能使区块链变成垄断性的，否定其\n"
"网络效应服务等独特优势。"

#: src/ch03-02-sequencers.md:189
#, fuzzy
msgid ""
"With centralization, blockchain loses its core principles: credible\n"
"neutrality and resistance to monopolization. What’s wrong with a\n"
"centralized system? It raises the risks of censorship (via transaction\n"
"reordering)."
msgstr ""
"随着中心化的发展，区块链失去了其核心原则：可信性、中立性和抵制垄断。\n"
"中立性和抵制垄断。中心化系统有什么不好？\n"
"中心化系统有什么问题？它增加了审查的风险（通过交易\n"
"重新排序）。"

#: src/ch03-02-sequencers.md:194
#, fuzzy
msgid "A centralized validity roll-up looks like this:"
msgstr "集中式有效性卷积看起来像这样："

#: src/ch03-02-sequencers.md:196
#, fuzzy
msgid ""
"- User Interaction & Selection: Users send transactions to a\n"
"  centralized Sequencer, which selects and orders them.\n"
"\n"
"- Block Formation: The Sequencer packages these ordered transactions\n"
"  into a block.\n"
"\n"
"- Proof & Verification: The block is sent to a proving service, which\n"
"  generates a proof and posts it to Layer 1 (L1) for verification.\n"
"\n"
"- Verification: Once verified on L1, the transactions are considered\n"
"  finalized and integrated into the L1 blockchain."
msgstr ""
"- 用户交互与选择：用户将交易发送给\n"
"  中央排序器，由其进行选择和排序。\n"
"\n"
"- 区块形成：排序器将这些已排序的交易\n"
"  打包成一个区块。\n"
"\n"
"- 证明与验证：区块被发送到证明服务，由其生成证明并发布到第一层（L1）进行验证。\n"
"  生成证明并发布到第一层（L1）进行验证。\n"
"\n"
"- 验证：一旦在 L1 层得到验证，交易即被视为\n"
"  最终完成并整合到 L1 区块链中。"

#: src/ch03-02-sequencers.md:208
msgid "<img alt=\"Centralized rollup\" src=\"img/ch03-centralized-rollup.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Centralized rollup\" src=\"img/ch03-centralized-rollup.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-02-sequencers.md:210
msgid "<span class=\"caption\">Centralized rollup</span>"
msgstr "<span class=\"caption\">Centralized rollup</span>"

#: src/ch03-02-sequencers.md:212
#, fuzzy
msgid ""
"While centralized roll-ups can provide L1 security, they come with a\n"
"significant downside: the risk of censorship. Hence, the push for\n"
"decentralization in roll-ups."
msgstr ""
"虽然集中式卷积可以提供 L1 级安全性，但也有一个显著的缺点：审查风险。\n"
"一个显著的缺点：审查风险。因此\n"
"分散式卷积。"

#: src/ch03-02-sequencers.md:218
#, fuzzy
msgid ""
"This chapter has dissected the role of Sequencers in the complex\n"
"ecosystem of blockchain technology, focusing on Starknet’s current state\n"
"and future directions. Sequencers essentially serve two main functions:\n"
"ordering transactions and executing them. While these tasks may seem\n"
"straightforward, they are pivotal in achieving network consensus and\n"
"ensuring security."
msgstr ""
"本章剖析了 Sequencers 在复杂的区块链技术生态系统中的作用。\n"
"生态系统中的作用，重点介绍了 Starknet 的现状和未来发展方向。\n"
"和未来发展方向。序列器主要有两大功能：\n"
"订购交易和执行交易。这些任务看似简单\n"
"简单明了，但它们在达成网络共识和确保安全方面至关重要。\n"
"确保安全的关键。"

#: src/ch03-02-sequencers.md:225
#, fuzzy
msgid ""
"Given the evolving modular architecture of blockchain—with distinct\n"
"layers for data availability, transaction ordering, and\n"
"execution—Sequencers provide a crucial link. Their role gains more\n"
"significance in the context of Layer 2 solutions, where achieving\n"
"scalability without sacrificing decentralization is a pressing concern."
msgstr ""
"鉴于区块链不断发展的模块化架构--数据可用性、交易排序和\n"
"数据可用性、交易排序和\n"
"分割器提供了一个关键环节。在第二层解决方案中，它们的作用变得更加重要。\n"
"在第二层解决方案中，它们的作用变得更加重要。\n"
"在不牺牲去中心化的前提下实现可扩展性是一个迫切需要解决的问题。"

#: src/ch03-02-sequencers.md:231
#, fuzzy
msgid ""
"In Starknet, Sequencers like Madara and Kraken demonstrate the potential\n"
"of high-performance, customizable solutions. These Sequencers allow for\n"
"a range of ordering methods and execution frameworks, proving that\n"
"there’s room for innovation even within seemingly rigid structures."
msgstr ""
"在Starknet中，Madara 和 Kraken 等序列器展示了高性能定制解决方案的潜力。\n"
"高性能、可定制解决方案的潜力。这些序列器允许\n"
"一系列排序方法和执行框架，证明即使在看似僵化的结构中，也有创新的空间。\n"
"即使在看似僵化的结构中也有创新的空间。"

#: src/ch03-02-sequencers.md:236
#, fuzzy
msgid ""
"The discussion on \"Proposer-Builder Separation\" (PBS) highlights the\n"
"need for role specialization to maintain a system’s integrity and thwart\n"
"transaction censorship. This becomes especially crucial when we\n"
"recognize that the current model of many L2 Sequencers, Starknet\n"
"included, performs both proposing and building, potentially exposing the\n"
"network to vulnerabilities."
msgstr ""
"关于 \"建议者--建设者分离\"（PBS）的讨论突出了\n"
"角色专业化的必要性，以保持系统的完整性并防止\n"
"事务审查。当我们\n"
"这一点变得尤为重要。\n"
"等许多 L2 排序器的当前模式都同时进行提议和构建，这可能会使网络面临漏洞。\n"
"网络漏洞。"

#: src/ch03-02-sequencers.md:243
#, fuzzy
msgid ""
"To reiterate, Sequencers aren’t just a mechanism for transaction\n"
"ordering and execution; they are a linchpin in blockchain’s\n"
"decentralized ethos. Whether centralized or decentralized, Sequencers\n"
"must strike a delicate balance between scalability, efficiency, and the\n"
"overarching principle of decentralization."
msgstr ""
"重申一下，序列器不仅仅是交易排序和执行的机制，它还是区块链的关键。\n"
"排序和执行的机制；它们是区块链去中心化精神的关键所在。\n"
"去中心化精神的关键。无论是中心化还是去中心化，序列器\n"
"都必须在可扩展性、效率和\n"
"去中心化的总体原则之间取得微妙的平衡。"

#: src/ch03-02-sequencers.md:249
#, fuzzy
msgid ""
"As blockchain technology continues to mature, it’s worth keeping an eye\n"
"on how the role of Sequencers evolves. They hold the potential to either\n"
"strengthen or weaken the unique advantages that make blockchain\n"
"technology so revolutionary."
msgstr ""
"随着区块链技术的不断成熟，值得关注的是\n"
"序列器的作用如何演变。它们有可能\n"
"加强或削弱使区块链技术具有革命性意义的独特优势。\n"
"技术如此具有革命性的独特优势。"

#: src/ch03-03-provers.md:1
#, fuzzy
msgid "# Provers"
msgstr "证明器 🚧"

#: src/ch03-03-provers.md:3
#, fuzzy
msgid ""
"SHARP is like public transportation for proofs on Starknet, aggregating\n"
"multiple Cairo programs to save costs and boost efficiency. It uses\n"
"recursive proofs, allowing parallelization and optimization, making it\n"
"more affordable for all users. Critical services like the gateway,\n"
"validator, and Prover work together with a stateless design for\n"
"flexibility. SHARP’s adoption by StarkEx, Starknet, and external users\n"
"(through the Cairo Playground) highlights its significance and potential\n"
"for future optimization."
msgstr ""
"SHARP 就像Starknet打样的公共交通，汇集了\n"
"多个Cairo计划，以节约成本，提高效率。它使用\n"
"递归证明，允许并行化和优化，使所有用户都能负担得起。\n"
"让所有用户都能负担得起。关键服务，如网关、\n"
"验证器和证明器等关键服务一起工作，采用无状态设计，具有灵活性。\n"
"灵活性。StarkEx、Starknet 和外部用户（通过 Cairo Playground）都采用了 SHARP。\n"
"(通过Cairo游乐场）的采用凸显了其重要性和未来优化的潜力。\n"
"未来优化的潜力。"

#: src/ch03-03-provers.md:12
#, fuzzy
msgid ""
"This chapter will discuss SHARP, how it has evolved to incorporate\n"
"recursive proofs, and its role in reducing costs and improving\n"
"efficiency within the Starknet network."
msgstr ""
"本章将讨论 SHARP，它是如何发展以纳入递归证明的。\n"
"递归证明，以及它在降低成本和提高Starknet效率方面的作用。\n"
"提高Starknet效率的作用。"

#: src/ch03-03-provers.md:16
#, fuzzy
msgid "## What is SHARP?"
msgstr "##什么是夏普？"

#: src/ch03-03-provers.md:18
#, fuzzy
msgid ""
"SHARP, which stands for \"Shared Prover\", is a mechanism used in Starknet\n"
"that aggregates multiple Cairo programs from different users, each\n"
"containing different logic. These Cairo programs are then executed\n"
"together, generating a single proof common to all the programs. Rather\n"
"than sending the proof directly to the Solidity Verifier in Ethereum, it\n"
"is initially sent to a STARK Verifier program written in Cairo. The\n"
"STARK Verifier generates a new proof to confirm that the initial proofs\n"
"were verified, which can be sent back into SHARP and the STARK Verifier.\n"
"This recursive proof process will be discussed in more detail later in\n"
"this chapter. Ultimately, the last proof in the series is sent to the\n"
"Solidity Verifier on Ethereum. In other words, there are many proofs\n"
"generated until we reach Ethereum and the Solidity Verifier."
msgstr ""
"SHARP 是 \"共享证明器 \"的缩写，是Starknet中使用的一种机制。\n"
"中使用的一种机制，它将来自不同用户的多个Cairo程序聚合在一起，每个程序都\n"
"包含不同的逻辑。然后将这些Cairo程序\n"
"一起执行，生成所有程序共有的一个证明。而不是\n"
"直接发送给以太坊的 Solidity 校验器，而是\n"
"而是先发送给用Cairo编写的 STARK 校验程序。该\n"
"STARK 校验器会生成一个新的证明，以确认初始证明\n"
"得到验证，然后再发送回 SHARP 和 STARK 校验器。\n"
"本章稍后将详细讨论这一递归证明过程。\n"
"本章稍后将详细讨论。最终，这一系列中的最后一个证明会被发送到\n"
"以太坊上的 Solidity 校验器。换句话说，在我们到达以太坊\n"
"直到我们到达以太坊和 Solidity 校验器。"

#: src/ch03-03-provers.md:31
#, fuzzy
msgid ""
"The primary benefit of SHARP system lies in its ability to decrease\n"
"costs and enhance efficiency within the Starknet network. It achieves\n"
"this by aggregating multiple Cairo jobs, which are individual sets of\n"
"computations. This aggregation allows the protocol to leverage the\n"
"exponential amortization offered by STARK proofs."
msgstr ""
"SHARP 系统的主要优势在于它能够降低成本，提高Starknet网络的效率。\n"
"成本和提高Starknet效率的能力。它通过\n"
"它通过聚合多个Cairo作业（即单个计算集）来实现这一目标。\n"
"计算。这种聚合使协议能够利用Starknet提供的\n"
"STARK 证明提供的指数级摊销。"

#: src/ch03-03-provers.md:37
#, fuzzy
msgid ""
"Exponential amortization means that as the computational load of the\n"
"proofs increases, the cost of verifying those proofs rises at a slower\n"
"logarithmic rate than the computation increase. In other words, the\n"
"computation itself grows slower than the verification cost. As a result,\n"
"the cost of each transaction within the aggregated set is significantly\n"
"reduced, making the overall process more cost-effective and accessible\n"
"for users."
msgstr ""
"指数摊销意味着，随着证明的计算负荷增加\n"
"证明的增加，验证这些证明的成本会以比计算量增加更慢的对数速度上升。\n"
"对数速率上升。换句话说\n"
"换句话说，计算本身的增长速度要慢于验证成本的增长速度。因此\n"
"聚合集内每笔交易的成本就会大大降低，使整个流程的成本更低。\n"
"因此，聚合集内每笔交易的成本都会大大降低，从而使整个流程更具成本效益，也更便于用户使用。\n"
"用户。"

#: src/ch03-03-provers.md:45
#, fuzzy
msgid ""
"In SHARP and Cairo context, \"jobs\" refer to the individual Cairo\n"
"programs or tasks submitted by different users. These jobs contain\n"
"specific logic or computations that must be executed on the Starknet\n"
"network."
msgstr ""
"在 SHARP 和Cairo的语境中，\"作业 \"是指不同用户提交的单个Cairo\n"
"程序或任务。这些任务包含\n"
"必须在Starknet执行的特定逻辑或计算。\n"
"网络上执行。"

#: src/ch03-03-provers.md:50
#, fuzzy
msgid ""
"Additionally, SHARP allows smaller users with limited computation to\n"
"benefit from joining other jobs and share the cost of generating the\n"
"proofs. This collaborative approach is similar to using public\n"
"transportation instead of a private car, where the cost is distributed\n"
"among all participants, making it more affordable for everyone."
msgstr ""
"此外，SHARP 还允许计算能力有限的小型用户\n"
"从加入其他工作中获益，并分担生成证明的成本。\n"
"证明。这种合作方式类似于\n"
"这种合作方式类似于使用公共交通而不是私家车。\n"
"费用由所有参与者分担，使每个人都能负担得起。"

#: src/ch03-03-provers.md:56
#, fuzzy
msgid "## Recursive Proofs in SHARP"
msgstr "## SHARP 中的递归证明"

#: src/ch03-03-provers.md:58
#, fuzzy
msgid ""
"One of the most powerful features of SHARP is its use of recursive\n"
"proofs. Rather than directly sending the generated proofs to the\n"
"Solidity Verifier, they are first sent to a STARK Verifier program\n"
"written in Cairo. This Verifier, which is also a Cairo Program, receives\n"
"the proof and creates a new Cairo job that is sent to the Prover. The\n"
"Prover then generates a new proof to confirm that the initial proofs\n"
"were verified. These new proofs can be sent back into SHARP and the\n"
"STARK Verifier, restarting the process."
msgstr ""
"SHARP 最强大的功能之一是使用递归证明。\n"
"证明。它不是直接将生成的证明发送给\n"
"Solidity验证器，而是先将它们发送到用Cairo语言编写的STARK验证器程序中。\n"
"Cairo编写的 STARK 校验程序。该验证程序也是一个Cairo程序，它接收证明并创建新的Cairo任务。\n"
"并创建一个新的 Cairo 作业，然后发送给验证器。验证者\n"
"证明者随后生成一个新的证明，以确认初始证明\n"
"已被验证。这些新的证明可以发送回 SHARP 和\n"
"STARK 校验器，重新启动流程。"

#: src/ch03-03-provers.md:67
#, fuzzy
msgid ""
"This process continues recursively, with each new proof being sent to\n"
"the Cairo Verifier until a trigger is reached. At this point, the last\n"
"proof in the series is sent to the Solidity Verifier on Ethereum. This\n"
"approach allows for greater parallelization of the computation and\n"
"reduces the time and cost associated with generating and verifying\n"
"proofs."
msgstr ""
"这个过程不断递归，每个新的证明都会被发送到\n"
"Cairo验证器，直到达到触发点。此时，系列中的最后一个\n"
"证明被发送到以太坊上的 Solidity 校验器。这种\n"
"这种方法可以提高计算的并行化程度，并\n"
"减少与生成和验证证明相关的时间和成本。\n"
"证明的时间和成本。"

#: src/ch03-03-provers.md:74
#, fuzzy
msgid ""
"     Generated Proofs\n"
"                 |\n"
"                 V\n"
"    STARK Verifier program (in Cairo)\n"
"                 |\n"
"                 V\n"
"            Cairo Job\n"
"                 |\n"
"                 V\n"
"                Prover\n"
"                 |\n"
"                 V\n"
"      New Proof Generated\n"
"                 |\n"
"                 V\n"
"           Repeat Process\n"
"                 |\n"
"                 V\n"
"     Trigger Reached (last proof)\n"
"                 |\n"
"                 V\n"
"        Solidity Verifier"
msgstr ""
"     生成的证明\n"
"                 |\n"
"                 V\n"
"    STARK 验证程序（Cairo语）\n"
"                 |\n"
"                 V\n"
"            Cairo工作\n"
"                 |\n"
"                 V\n"
"                证明者\n"
"                 |\n"
"                 V\n"
"      生成新证明\n"
"                 |\n"
"                 V\n"
"           重复过程\n"
"                 |\n"
"                 V\n"
"     达到触发器（最后一次证明）\n"
"                 |\n"
"                 V\n"
"        稳固性验证器"

#: src/ch03-03-provers.md:97
#, fuzzy
msgid ""
"At first glance, recursive proofs may seem more complex and\n"
"time-consuming. However, there are several benefits to this approach:"
msgstr ""
"乍一看，递归证明似乎更复杂、更耗时。\n"
"费时。然而，这种方法有几个好处："

#: src/ch03-03-provers.md:100
#, fuzzy
msgid ""
"1.  **Parallelization**: Recursive proofs allow for work\n"
"    parallelization, reducing user latency and improving SHARP\n"
"    efficiency.\n"
"\n"
"2.  **Cheaper on-chain costs**: Parallelization enables SHARP to create\n"
"    larger proofs, which would have previously been limited by the\n"
"    availability of large cloud machines (which are rare and limited).\n"
"    As a result, on-chain costs are reduced.\n"
"\n"
"3.  **Lower cloud costs**: Since each job is shorter, the required\n"
"    memory for processing is reduced, resulting in lower cloud costs.\n"
"\n"
"4.  **Optimization**: Recursive proofs enable SHARP to optimize for\n"
"    various factors, including latency, on-chain costs, and time to\n"
"    proof.\n"
"\n"
"5.  **Cairo support**: Recursive proofs only require support in Cairo,\n"
"    without the need to add support in the Solidity Verifier."
msgstr ""
"1.  **并行化**：递归证明允许工作\n"
"    并行化，减少用户延迟，提高 SHARP\n"
"    效率。\n"
"\n"
"2.  **降低链上成本**：并行化使 SHARP 能够创建\n"
"    更大的证明，而这在以前是受限于\n"
"    大型云计算机器的可用性（云计算机器稀少且有限）。\n"
"    因此，链上成本得以降低。\n"
"\n"
"3.  **降低云成本**：由于每个作业的时间较短，处理所需的\n"
"    内存，从而降低了云成本。\n"
"\n"
"4.  **优化**：递归证明使 SHARP 能够针对各种因素进行优化。\n"
"    各种因素进行优化，包括延迟、链上成本和证明时间。\n"
"    证明。\n"
"\n"
"5.  **Cairo支持**：递归证明只需Cairo支持、\n"
"    无需在 Solidity 校验器中添加支持。"

#: src/ch03-03-provers.md:119
#, fuzzy
msgid ""
"Latency in Starknet encompasses the time taken for processing,\n"
"confirming, and including transactions in a block. It is affected by\n"
"factors like network congestion, transaction fees, and system\n"
"efficiency. Minimizing latency ensures faster transaction processing and\n"
"user feedback."
msgstr ""
"Starknet的延迟包括处理、确认和包含区块中的交易所需的时间、\n"
"确认以及将交易纳入区块所需的时间。它受\n"
"网络拥堵、交易费用和系统效率等因素的影响。\n"
"效率等因素的影响。最大限度地减少延迟可确保更快的交易处理和用户反馈。\n"
"用户反馈。"

#: src/ch03-03-provers.md:125
#, fuzzy
msgid ""
"Time to proof, however, specifically pertains to the duration required\n"
"to generate and verify cryptographic proofs for transactions or\n"
"operations."
msgstr ""
"不过，证明所需时间具体指的是\n"
"生成和验证交易或操作的加密证明所需的时间。\n"
"操作所需的时间。"

#: src/ch03-03-provers.md:129
#, fuzzy
msgid "## SHARP Backend Architecture and Data Pipeline"
msgstr "## SHARP 后端架构和数据管道"

#: src/ch03-03-provers.md:131
#, fuzzy
msgid ""
"SHARP back end architecture consists of several services that work\n"
"together to process Cairo jobs and generate proofs. These services\n"
"include:"
msgstr ""
"SHARP 后端架构由多个服务组成，它们共同\n"
"共同处理Cairo作业并生成证明。这些服务\n"
"包括"

#: src/ch03-03-provers.md:135
#, fuzzy
msgid ""
"1.  **Gateway**: Cairo jobs enter SHARP through the gateway.\n"
"\n"
"2.  **Job Creator**: It prevents job duplication and ensures that the\n"
"    system operates consistently, regardless of multiple identical\n"
"    requests.\n"
"\n"
"3.  **Validator**: This is the first important step. The validator\n"
"    service runs validation checks on each job, ensuring they meet the\n"
"    requirements and can fit within the prover machines. Invalid jobs\n"
"    are tagged as such and do not proceed to the Prover.\n"
"\n"
"4.  **Scheduler**: The scheduler service creates \"trains\" that aggregate\n"
"    jobs and send them to the Prover. Recursive jobs are paired and sent\n"
"    to the Prover together.\n"
"\n"
"5.  **Cairo Runner**: This service runs Cairo for the Prover’s needs.\n"
"    The Cairo Runner service runs Cairo programs, executing the\n"
"    necessary computations and generating the execution trace as an\n"
"    intermediate result. The Prover then uses this execution trace.\n"
"\n"
"6.  **Prover**: The Prover computes the proofs for each train (that\n"
"    contains a few jobs).\n"
"\n"
"7.  **Dispatcher**: The Dispatcher serves two functions in the SHARP\n"
"    system.\n"
"\n"
"    1.  In the case of a recursive proof, the Dispatcher runs the Cairo\n"
"        Verifier program on the proof it has received from the Prover,\n"
"        resulting in a new Cairo job that goes back to the Validator.\n"
"\n"
"    2.  In the case of a proof that needs to go on chain (e.g., to\n"
"        Ethereum), the Dispatcher creates \"packages\" from the proof,\n"
"        which can then be sent to the Blockchain Writer.\n"
"\n"
"8.  **Blockchain Writer**: Once the packages have been created by the\n"
"    Dispatcher, they are sent to the Blockchain Writer. The Blockchain\n"
"    Writer is responsible for sending the packages to the appropriate\n"
"    blockchain (e.g., Ethereum) for verification. This is an important\n"
"    step in the SHARP system, as it ensures that the proofs are properly\n"
"    verified and that the transactions are securely recorded on the\n"
"    blockchain.\n"
"\n"
"9.  **Catcher**: The Catcher monitors blockchain (e.g., Ethereum)\n"
"    transactions to ensure that they have been accepted. While the\n"
"    Catcher is relevant for internal monitoring purposes, it is\n"
"    important to note that if a transaction fails, the fact won’t be\n"
"    registered on-chain in the fact registry. As a result, the soundness\n"
"    of the system is still preserved even without the catcher."
msgstr ""
"1.  **网关**：Cairo作业通过网关进入夏普。\n"
"\n"
"2.  **Job Creator**：它可防止作业重复，并确保\n"
"    系统运行的一致性，无论是否有多个相同的\n"
"    请求。\n"
"\n"
"3.  **验证器**：这是重要的第一步。验证器\n"
"    服务对每个任务进行验证检查，确保它们符合\n"
"    要求，并能适应验证器机器。无效作业\n"
"    将被标记为无效，并不会进入验证器。\n"
"\n"
"4.  **调度程序**：调度器服务创建 \"列车\"，将作业汇总并发送到验证器。\n"
"    作业，并将它们发送到验证程序。递归作业配对后\n"
"    一起发送到验证器。\n"
"\n"
"5.  **Cairo运行程序**：该服务根据验证者的需要运行Cairo程序。\n"
"    Cairo Runner 服务运行 Cairo 程序，执行必要的计算，并以\n"
"    必要的计算，并生成执行轨迹作为中间结果。\n"
"    作为中间结果。验证者随后使用该执行跟踪。\n"
"\n"
"6.  **证明者**：证明者**：证明者为每一列火车（包含几个作业）计算证明。\n"
"    包含几个作业）的证明。\n"
"\n"
"7.  **调度器**：调度程序在 SHARP\n"
"    系统中的两个功能。\n"
"\n"
"    1.  在递归证明的情况下，调度器在从证明者收到的证明上运行Cairo\n"
"        验证程序、\n"
"        从而产生一个新的Cairo作业，并返回验证器。\n"
"\n"
"    2.  如果证明需要上链（例如，上链到\n"
"        以太坊），调度程序会根据证明创建 \"包\"、\n"
"        然后发送给区块链写入器。\n"
"\n"
"8.  **区块链写入器**：一旦\n"
"    调度器创建后，就会将其发送给区块链写入器。区块链\n"
"    写入器负责将数据包发送到相应的\n"
"    区块链（如以太坊）进行验证。这是 SHARP 系统的一个重要\n"
"    这一步在 SHARP 系统中非常重要，因为它可以确保证明得到正确的\n"
"    验证，并确保交易安全地记录在区块链上。\n"
"    区块链上。\n"
"\n"
"9.  **捕获器**：捕获器监控区块链（如以太坊）上的\n"
"    交易，以确保它们已被接受。虽然\n"
"    捕获器与内部监控目的相关，但重要的是\n"
"    需要注意的是，如果交易失败，事实将不会在链上的事实注册中心注册。\n"
"    在链上的事实注册表中注册。因此\n"
"    因此，即使没有捕获器，系统的稳健性仍然可以保持。"

#: src/ch03-03-provers.md:184
#, fuzzy
msgid ""
"SHARP is designed to be stateless (each Cairo job is executed in its own\n"
"context and has no dependency on other jobs), allowing for greater\n"
"flexibility in processing jobs."
msgstr ""
"SHARP 的设计是无状态的（每个 Cairo 作业都在自己的上下文中执行，不依赖于其他作业。\n"
"上下文中执行，不依赖于其他作业），使作业处理更加灵活。\n"
"处理作业的灵活性。"

#: src/ch03-03-provers.md:188
#, fuzzy
msgid "## Current SHARP Users"
msgstr "## 目前的夏普用户"

#: src/ch03-03-provers.md:190
#, fuzzy
msgid "Currently, the primary users of SHARP include:"
msgstr "目前，SHARP 的主要用户包括"

#: src/ch03-03-provers.md:192
#, fuzzy
msgid ""
"- StarkEx\n"
"\n"
"- Starknet\n"
"\n"
"- External users who use the Cairo Playground"
msgstr ""
"- StarkEx\n"
"\n"
"- Starknet\n"
"\n"
"- 使用Cairo游乐场的外部用户"

#: src/ch03-03-provers.md:198
#, fuzzy
msgid "## Challenges and Optimization"
msgstr "## 挑战与优化"

#: src/ch03-03-provers.md:200
#, fuzzy
msgid ""
"Optimizing the Prover involves numerous challenges and potential\n"
"projects on which the Starkware team and the community are currently\n"
"working:"
msgstr ""
"优化 Prover 涉及许多挑战和潜在项目，Starkware 团队和社区目前正在开展这些挑战和项目。\n"
"项目，Starkware 团队和社区目前正在开展以下工作\n"
"工作："

#: src/ch03-03-provers.md:204
#, fuzzy
msgid ""
"- Exploring more efficient hash functions: SHARP is constantly\n"
"  exploring more efficient hash functions for Cairo, the Prover, and\n"
"  Solidity.\n"
"\n"
"- Investigating smaller fields: Investigating smaller fields for\n"
"  recursive proof steps could lead to more efficient computations.\n"
"\n"
"- Adjusting various parameters: SHARP is continually adjusting various\n"
"  parameters of the STARK protocol, such as FRI parameters and block\n"
"  factors.\n"
"\n"
"- Optimizing the Cairo code: SHARP is optimizing the Cairo code to\n"
"  make it faster, resulting in a faster recursive prover.\n"
"\n"
"- Developing dynamic layouts: This will allow Cairo programs to scale\n"
"  resources depending on their needs.\n"
"\n"
"- Improving scheduling algorithm: This is another optimization path\n"
"  that can be taken. It is not within the Prover itself."
msgstr ""
"- 探索更高效的散列函数夏普不断\n"
"  为 Cairo、Prover 和\n"
"  Solidity。\n"
"\n"
"- 研究更小的字段：研究更小的字段\n"
"  可以提高计算效率。\n"
"\n"
"- 调整各种参数：SHARP 正在不断调整 STARK 协议的各种\n"
"  STARK协议的各种参数，如FRI参数和块\n"
"  系数。\n"
"\n"
"- 优化Cairo代码：夏普正在优化Cairo代码，使其更快\n"
"  使其更快，从而加快递归证明器的速度。\n"
"\n"
"- 开发动态布局：这将使Cairo程序能够根据需要\n"
"  资源。\n"
"\n"
"- 改进调度算法：这是另一条优化途径\n"
"  可以采取的另一条优化途径。它不属于 Prover 本身。"

#: src/ch03-03-provers.md:224
#, fuzzy
msgid ""
"In particular, dynamic layouts (you can learn more about layouts here\n"
"(TODO)) will allow Cairo programs to scale resources depending on their\n"
"needs. This can lead to more efficient computation and better\n"
"utilization of resources. Dynamic layouts allow SHARP to determine the\n"
"required resources for a specific job and adjust the layout accordingly\n"
"instead of relying on predefined layouts with fixed resources. This\n"
"approach can provide tailored solutions for each job, improving overall\n"
"efficiency."
msgstr ""
"尤其是动态布局（点击此处了解更多关于布局的信息\n"
"(TODO)）将允许Cairo程序根据自己的需要来扩展资源。\n"
"资源。这将提高计算效率和资源利用率。\n"
"利用资源。动态布局允许SHARP确定特定作业所需的资源，并对资源进行调整。\n"
"特定作业所需的资源，并相应调整布局\n"
"而不是依赖带有固定资源的预定义布局。这种\n"
"这种方法可为每项工作提供量身定制的解决方案，从而提高整体效率。\n"
"效率。"

#: src/ch03-03-provers.md:245
#, fuzzy
msgid ""
"In conclusion, SHARP is a critical component of Starknet’s architecture,\n"
"providing a more efficient and cost-effective solution for processing\n"
"Cairo programs and verifying their proofs. By leveraging the power of\n"
"STARK technology and incorporating recursive proofs, SHARP plays a vital\n"
"role in improving the overall performance and scalability of the\n"
"Starknet network. The stateless nature of SHARP and the reliance on the\n"
"cryptographic soundness of the STARK proving system make it an\n"
"innovative and valuable addition to the blockchain ecosystem."
msgstr ""
"总之，SHARP 是Starknet架构的重要组成部分、\n"
"为处理Cairo程序和验证其证明提供了更高效、更具成本效益的解决方案。\n"
"Cairo程序并验证其证明。通过利用\n"
"通过利用 STARK 技术和递归证明，SHARP 在提高整体性能和扩展性方面发挥了重要作用。\n"
"在提高Starknet的整体性能和可扩展性方面发挥了重要作用。\n"
"Starknet网络的整体性能和可扩展性方面发挥着至关重要的作用。SHARP 的无状态特性和对 STARK 技术的密码健全性的依赖\n"
"证明系统的加密稳健性，使其成为区块链技术的一个创新和宝贵的补充。\n"
"区块链生态系统的创新和宝贵补充。"

#: src/ch03-04-nodes.md:1
#, fuzzy
msgid "# Nodes"
msgstr "节点 🚧"

#: src/ch03-04-nodes.md:3
#, fuzzy
msgid ""
"This chapter will guide you through setting up and running a Starknet\n"
"node, illustrating the layered tech stack concept, and explaining how to\n"
"operate these protocols locally. Starknet, as a Layer 2 Validity Rollup,\n"
"operates on top of Ethereum Layer 1, creating a protocol stack that each\n"
"addresses different functionalities, similar to the OSI model for\n"
"internet connections. This chapter is an edit of\n"
"[drspacemn](https://medium.com/starknet-edu/the-starknet-stack-7b0d70a7e1d4)'s\n"
"blog."
msgstr ""
"本章将指导您设置和运行一个Starknet节点。\n"
"节点，说明分层技术栈概念，并解释如何在本地操作这些协议。\n"
"如何在本地运行这些协议。Starknet 作为第二层有效性卷积（Layer 2 Validity Rollup）、\n"
"在以太坊第一层之上运行，创建了一个协议栈，每个协议栈都\n"
"解决不同的功能，类似于互联网连接的 OSI 模型。\n"
"互联网连接。本章是对\n"
"[drspacemn](https://medium.com/starknet-edu/the-starknet-stack-7b0d70a7e1d4)的\n"
"博客的编辑。"

#: src/ch03-04-nodes.md:12
#, fuzzy
msgid ""
"CONTRIBUTE: This guide shows how to run a Starknet node locally with a\n"
"particular setup. You can contribute to this guide by adding more\n"
"options for hardware and software, as well as other ways to run a\n"
"Starknet nod (for example using\n"
"[Beerus](https://github.com/keep-starknet-strange/beerus)). You can also\n"
"contribute by adding more information about the Starknet stack and the\n"
"different layers. Feel free to [open a\n"
"PR](https://github.com/starknet-edu/starknetbook)."
msgstr ""
"贡献： 本指南介绍了如何在本地运行一个 Starknet 节点，并进行特定设置。\n"
"特定设置运行Starknet节点。您可以为本指南添加更多\n"
"硬件和软件选项，以及运行Starknet节点的其他方法（例如使用\n"
"Starknet节点的其他方法（例如使用\n"
"[Beerus](https://github.com/keep-starknet-strange/beerus)).您还可以\n"
"添加更多有关Starknet堆栈和不同层的信息。\n"
"层的更多信息。请随时在\n"
"PR](https://github.com/starknet-edu/starknetbook)."

#: src/ch03-04-nodes.md:21
#, fuzzy
msgid "## What is a Node in the Context of Ethereum and Blockchain?"
msgstr "##以太坊和区块链背景下的节点是什么？"

#: src/ch03-04-nodes.md:23
#, fuzzy
msgid ""
"In the context of Ethereum and blockchain, a node is an integral part of\n"
"the network that validates and relays transactions. Nodes download a\n"
"copy of the entire blockchain and are interconnected with other nodes to\n"
"maintain and update the blockchain state. There are different types of\n"
"nodes, such as full nodes, light nodes, and mining nodes, each having\n"
"different roles and responsibilities within the network."
msgstr ""
"在以太坊和区块链中，节点是网络不可分割的一部分。\n"
"在以太坊和区块链中，节点是验证和转发交易的网络组成部分。节点下载整个区块链的\n"
"整个区块链的副本，并与其他节点互联，以维护和更新区块链状态。\n"
"维护和更新区块链状态。有不同类型的\n"
"节点，每种节点在网络中都有不同的角色和责任。\n"
"在网络中扮演不同的角色，承担不同的责任。"

#: src/ch03-04-nodes.md:30
#, fuzzy
msgid "## Overview of Starknet Technology"
msgstr "## Starknet技术概览"

#: src/ch03-04-nodes.md:32
#, fuzzy
msgid ""
"Starknet is a permissionless, zk-STARK-based Layer-2 network, aiming for\n"
"full decentralization. It enables developers to build scalable\n"
"decentralized applications (dApps) and utilizes Ethereum’s Layer 1 for\n"
"proof verification and data availability. Key aspects of Starknet\n"
"include:"
msgstr ""
"Starknet是一个无权限、基于 zk-STARK 的第 2 层网络，旨在实现完全的去中心化。\n"
"完全去中心化。它使开发者能够构建可扩展的\n"
"去中心化应用程序（dApps），并利用以太坊的第 1 层进行\n"
"证明验证和数据可用性。Starknet的主要方面\n"
"包括"

#: src/ch03-04-nodes.md:38
#, fuzzy
msgid ""
"- **Cairo execution environment**: Cairo, the execution environment of\n"
"  Starknet, facilitates writing and execution of complex smart\n"
"  contracts.\n"
"\n"
"- **Scalability**: Starknet achieves scalability through zk-STARK\n"
"  proofs, minimizing the data needed to be posted on-chain.\n"
"\n"
"- **Node network**: The Starknet network comprises nodes that\n"
"  synchronize and process transactions, contributing to the network’s\n"
"  overall security and decentralization."
msgstr ""
"- **Cairo的执行环境**：Cairo是Starknet的执行环境。\n"
"  Cairo是Starknet的执行环境，有助于编写和执行复杂的智能合约。\n"
"  合约。\n"
"\n"
"- **可扩展性**：Starknet通过zk-STARK\n"
"  证明来实现可扩展性，从而最大限度地减少需要在链上发布的数据。\n"
"\n"
"- **节点网络**：Starknet由节点组成，这些节点可\n"
"  节点同步和处理交易，有助于网络的\n"
"  整体安全性和去中心化。"

#: src/ch03-04-nodes.md:49
#, fuzzy
msgid "## Starknet Stack"
msgstr "## Starknet堆栈"

#: src/ch03-04-nodes.md:51
#, fuzzy
msgid ""
"The Starknet stack can be divided into various layers, similar to OSI or\n"
"TCP/IP models. The most appropriate model depends on your understanding\n"
"and requirements. A simplified version of the modular blockchain stack\n"
"might look like this:"
msgstr ""
"Starknet堆栈可分为不同的层，类似于 OSI 或\n"
"TCP/IP 模型。最合适的模型取决于您对\n"
"和要求而定。模块化区块链堆栈的简化版\n"
"可能是这样的"

#: src/ch03-04-nodes.md:56
#, fuzzy
msgid ""
"- Layer 1: Data Layer\n"
"\n"
"- Layer 2: Execution Layer\n"
"\n"
"- Layer 3: Application Layer\n"
"\n"
"- Layer 4: Transport Layer"
msgstr ""
"- 第 1 层：数据层\n"
"\n"
"- 第 2 层：执行层\n"
"\n"
"- 第 3 层：应用层\n"
"\n"
"- 第 4 层：传输层"

#: src/ch03-04-nodes.md:64
msgid "<img alt=\"Modular blockchain layers\" src=\"img/ch03-modular-blockcahain-layers.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Modular blockchain layers\" src=\"img/ch03-modular-blockcahain-layers.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-04-nodes.md:66
msgid "<span class=\"caption\">Modular blockchain layers</span>"
msgstr "<span class=\"caption\">Modular blockchain layers</span>"

#: src/ch03-04-nodes.md:70
#, fuzzy
msgid ""
"There are various hardware specifications, including packaged options,\n"
"that will enable you to run an Ethereum node from home. The goal here is\n"
"to build the most cost-efficient Starknet stack possible ([see here more\n"
"options](https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md))."
msgstr ""
"有各种硬件规格，包括打包选项、\n"
"可以让你在家里运行以太坊节点。我们的目标是\n"
"构建最具成本效益的Starknet堆栈（[查看此处的更多\n"
"选项](https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md)）。"

#: src/ch03-04-nodes.md:75
#, fuzzy
msgid "**Minimum Requirements:**"
msgstr "**最低要求：**"

#: src/ch03-04-nodes.md:77
#, fuzzy
msgid ""
"- CPU: 2+ cores\n"
"\n"
"- RAM: 4 GB\n"
"\n"
"- Disk: 600 GB\n"
"\n"
"- Connection Speed: 8 mbps/sec"
msgstr ""
"- CPU：2+ 内核\n"
"\n"
"- 内存： 4 GB\n"
"\n"
"- 磁盘： 600 GB\n"
"\n"
"- 连接速度： 8 mbps/秒"

#: src/ch03-04-nodes.md:85
#, fuzzy
msgid "**Recommended Specifications:**"
msgstr "**建议规格：**"

#: src/ch03-04-nodes.md:87
#, fuzzy
msgid ""
"- CPU: 4+ cores\n"
"\n"
"- RAM: 16 GB+\n"
"\n"
"- Disk 2 TB\n"
"\n"
"- Connection Speed: 25+ mbps/sec"
msgstr ""
"- CPU：4+ 内核\n"
"\n"
"- 内存： 16 GB+\n"
"\n"
"- 磁盘 2 TB\n"
"\n"
"- 连接速度： 25+ mbps/秒"

#: src/ch03-04-nodes.md:95
#, fuzzy
msgid "**You can refer to these links for the hardware:**"
msgstr "**您可以参考这些硬件链接：**"

#: src/ch03-04-nodes.md:97
#, fuzzy
msgid ""
"- [CPU](https://a.co/d/iAWpTzQ) — $193\n"
"\n"
"- [Board](https://a.co/d/cTUk9Kd) (can attempt w/ Raspberry Pi) — $110\n"
"\n"
"- [Disk](https://a.co/d/0US61Y5) — $100\n"
"\n"
"- [RAM](https://a.co/d/br867sk) — $60\n"
"\n"
"- [PSU](https://a.co/d/2k3Gn40) — $40\n"
"\n"
"- [Case](https://a.co/d/apCBGwF) — $50"
msgstr ""
"- [CPU](https://a.co/d/iAWpTzQ) - 193 美元\n"
"\n"
"- [电路板](https://a.co/d/cTUk9Kd) （可尝试使用 Raspberry Pi） - $110\n"
"\n"
"- [磁盘](https://a.co/d/0US61Y5) - $100\n"
"\n"
"- [内存](https://a.co/d/br867sk) - $60\n"
"\n"
"- [PSU](https://a.co/d/2k3Gn40) - $40\n"
"\n"
"- [机箱](https://a.co/d/apCBGwF) - $50"

#: src/ch03-04-nodes.md:109
#, fuzzy
msgid "Total — $553"
msgstr "共计 - 553 美元"

#: src/ch03-04-nodes.md:111
#, fuzzy
msgid ""
"Recommended operating system and software: Ubuntu LTS,\n"
"[Docker](https://docs.docker.com/engine/install/ubuntu), and [Docker\n"
"Compose](https://docs.docker.com/compose/install/linux). Ensure you have\n"
"the necessary tools installed with:"
msgstr ""
"建议使用的操作系统和软件Ubuntu LTS、\n"
"[Docker](https://docs.docker.com/engine/install/ubuntu) 和 [Docker\n"
"Compose](https://docs.docker.com/compose/install/linux)。确保\n"
"安装了必要的工具："

#: src/ch03-04-nodes.md:116
#, fuzzy
msgid "sudo apt install -y jq curl net-tools"
msgstr "sudo apt install -y jq curl net-tools"

#: src/ch03-04-nodes.md:118
#, fuzzy
msgid "## Layer 1: Data Layer"
msgstr "## 第 1 层：数据层"

#: src/ch03-04-nodes.md:120
#, fuzzy
msgid ""
"The bottom-most layer of the stack is the data layer. Here, Starknet’s\n"
"L2 leverages Ethereum’s L1 for proof verification and data availability.\n"
"Starknet utilizes Ethereum as its L1, so the first step is setting up an\n"
"Ethereum Full Node. As this is the data layer, the hardware bottleneck\n"
"is usually the disk storage. It’s crucial to have a high capacity I/O\n"
"SSD over an HDD because Ethereum Nodes require both an Execution Client\n"
"and a Consensus Client for communication."
msgstr ""
"堆栈的最底层是数据层。在这里，Starknet的\n"
"L2 利用以太坊的 L1 进行证明验证和数据可用性。\n"
"Starknet 利用以太坊作为其 L1，因此第一步是建立一个\n"
"以太坊全节点。由于这是数据层，硬件瓶颈\n"
"通常是磁盘存储。拥有一个大容量 I/O\n"
"固态硬盘比硬盘更重要，因为以太坊节点既需要执行客户端\n"
"和共识客户端进行通信。"

#: src/ch03-04-nodes.md:128
#, fuzzy
msgid ""
"Ethereum provides several options for Execution and Consensus clients.\n"
"Execution clients include Geth, Erigon, Besu (used here), Nethermind,\n"
"and Akula. Consensus clients include Prysm, Lighthouse (used here),\n"
"Lodestar, Nimbus, and Teku."
msgstr ""
"以太坊为执行和共识客户端提供了多种选择。\n"
"执行客户端包括 Geth、Erigon、Besu（此处使用）、Nethermind、\n"
"和 Akula。共识客户端包括 Prysm、Lighthouse（此处使用）、\n"
"Lodestar、Nimbus 和 Teku。"

#: src/ch03-04-nodes.md:133
#, fuzzy
msgid ""
"Your Besu/Lighthouse node will take approximately 600 GB of disk space.\n"
"Navigate to a partition on your machine with sufficient capacity and run\n"
"the following commands:"
msgstr ""
"Besu/Lighthouse节点将占用大约600 GB的磁盘空间。\n"
"导航到计算机上容量足够大的分区，运行\n"
"命令："

#: src/ch03-04-nodes.md:137
#, fuzzy
msgid ""
"git clone https://github.com/starknet-edu/starknet-stack.git\n"
"    cd starknet-stack\n"
"    docker-compose -f dc-l1.yaml up -d"
msgstr ""
"git clone https://github.com/starknet-edu/starknet-stack.git\n"
"    cd starknet-stack\n"
"    docker-compose -f dc-l1.yaml up -d"

#: src/ch03-04-nodes.md:141
#, fuzzy
msgid ""
"This will begin the fairly long process of spinning up our Consensus\n"
"Client, Execution Client, and syncing them to the current state of the\n"
"Goerli Testnet. If you would like to see the logs from either process\n"
"you can run:"
msgstr ""
"这将开始一个相当漫长的过程，即启动我们的共识\n"
"客户端、执行客户端，并将它们同步到 Goerli 测试网的当前状态。\n"
"Goerli Testnet 的当前状态。如果您想查看这两个过程的日志\n"
"您可以运行"

#: src/ch03-04-nodes.md:146
#, fuzzy
msgid ""
"# tail besu logs\n"
"    docker container logs -f $(docker ps | grep besu | awk '{print $1}')\n"
"\n"
"    # tail lighthouse logs\n"
"    docker container logs -f $(docker ps | grep lighthouse | awk '{print $1}')"
msgstr ""
"# tail besu logs\n"
"    docker container logs -f $(docker ps | grep besu | awk '{print $1}')\n"
"\n"
"    # 尾随灯塔日志\n"
"    docker 容器日志 -f $(docker ps | grep lighthouse | awk '{print $1}')"

#: src/ch03-04-nodes.md:152
#, fuzzy
msgid "Lets make sure that everything that should be listening is listening:"
msgstr "让我们确保所有应该倾听的东西都在倾听："

#: src/ch03-04-nodes.md:154
#, fuzzy
msgid ""
"# should see all ports in command output\n"
"\n"
"    # besu ports\n"
"    sudo netstat -lpnut | grep -E '30303|8551|8545'\n"
"\n"
"    # lighthouse ports\n"
"    sudo netstat -lpnut | grep -E '5054|9000'"
msgstr ""
"# 命令输出中应显示所有端口\n"
"\n"
"    # besu 端口\n"
"    sudo netstat -lpnut | grep -E \"30303|8551|8545\n"
"\n"
"    # 灯塔端口\n"
"    sudo netstat -lpnut | grep -E '5054|9000' # lighthouse 端口"

#: src/ch03-04-nodes.md:162
#, fuzzy
msgid ""
"We’ve used docker to abstract a lot of the nuance of running an Eth L1\n"
"node, but the important things to note are how the two processes EL/CL\n"
"point to each other and communicate via JSON-RPC:"
msgstr ""
"我们使用 docker 来抽象运行 Eth L1\n"
"节点，但需要注意的是两个进程 EL/CL\n"
"是如何相互指向并通过 JSON-RPC 进行通信的："

#: src/ch03-04-nodes.md:166
#, fuzzy
msgid ""
"services:\n"
"      lighthouse:\n"
"          image: sigp/lighthouse:latest\n"
"          container_name: lighthouse\n"
"          volumes:\n"
"            - ./l1_consensus/data:/root/.lighthouse\n"
"            - ./secret:/root/secret\n"
"          network_mode: \"host\"\n"
"          command:\n"
"            - lighthouse\n"
"            - beacon\n"
"            - --network=goerli\n"
"            - --metrics\n"
"            - --checkpoint-sync-url=https://goerli.beaconstate.info\n"
"            - --execution-endpoint=http://127.0.0.1:8551\n"
"            - --execution-jwt=/root/secret/jwt.hex\n"
"\n"
"      besu:\n"
"        image: hyperledger/besu:latest\n"
"        container_name: besu\n"
"        volumes:\n"
"          - ./l1_execution/data:/var/lib/besu\n"
"          - ./secret:/var/lib/besu/secret\n"
"        network_mode: \"host\"\n"
"        command:\n"
"          - --network=goerli\n"
"          - --rpc-http-enabled=true\n"
"          - --data-path=/var/lib/besu\n"
"          - --data-storage-format=BONSAI\n"
"          - --sync-mode=X_SNAP\n"
"          - --engine-rpc-enabled=true\n"
"          - --engine-jwt-enabled=true\n"
"          - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex"
msgstr ""
"服务：\n"
"      lighthouse：\n"
"          image: sigp/lighthouse:latest\n"
"          container_name: 灯塔\n"
"          卷\n"
"            - ./l1_consensus/data:/root/.lighthouse\n"
"            - ./secret:/root/secret\n"
"          network_mode：主机\n"
"          command：\n"
"            - 灯塔\n"
"            - 信标\n"
"            - --网络=goerli\n"
"            - --参数\n"
"            - --检查点同步url=https://goerli.beaconstate.info\n"
"            - --execution-endpoint=http://127.0.0.1:8551\n"
"            - --执行-jwt=/root/secret/jwt.hex\n"
"\n"
"      besu：\n"
"        镜像： hyperledger/besu:latest\n"
"        container_name: besu\n"
"        volumes：\n"
"          - ./l1_execution/data:/var/lib/besu\n"
"          - ./secret:/var/lib/besu/secret\n"
"        network_mode：主机\n"
"        command：\n"
"          - --network=goerli\n"
"          - --rpc-http-enabled=true\n"
"          - --数据路径=/var/lib/besu\n"
"          - --数据存储格式=BONSAI\n"
"          - --同步模式=X_SNAP\n"
"          - --engine-rpc-enabled=true\n"
"          - --engine-jwt-enabled=true\n"
"          - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex"

#: src/ch03-04-nodes.md:200
#, fuzzy
msgid ""
"Once this is done, your Ethereum node should be up and running, and it\n"
"will start syncing with the Ethereum network."
msgstr ""
"完成这些操作后，你的以太坊节点就可以开始运行了，并且\n"
"将开始与以太坊网络同步。"

#: src/ch03-04-nodes.md:203
#, fuzzy
msgid "## Layer 2: Execution Layer"
msgstr "## 第 2 层：执行层"

#: src/ch03-04-nodes.md:205
#, fuzzy
msgid ""
"The next layer in our Starknet stack is the Execution Layer. This layer\n"
"is responsible for running the Cairo VM, which executes Starknet smart\n"
"contracts. The Cairo VM is a deterministic virtual machine that allows\n"
"developers to write complex smart contracts in the Cairo language.\n"
"Starknet uses a similar [JSON-RPC\n"
"spec](https://github.com/starkware-libs/starknet-specs) as\n"
"[Ethereum](https://ethereum.org/en/developers/docs/apis/json-rpc) in\n"
"order to interact with the execution layer."
msgstr ""
"Starknet堆栈的下一层是执行层。这一层\n"
"负责运行Cairo虚拟机，Cairo虚拟机执行Starknet智能\n"
"合约。Cairo虚拟机是一个确定性虚拟机，允许\n"
"开发人员使用Cairo语言编写复杂的智能合约。\n"
"Starknet 使用类似于 [JSON-RPC\n"
"规范](https://github.com/starkware-libs/starknet-specs)\n"
"[以太坊](https://ethereum.org/en/developers/docs/apis/json-rpc)\n"
"与执行层进行交互。"

#: src/ch03-04-nodes.md:214
#, fuzzy
msgid ""
"In order to stay current with the propagation of the Starknet blockchain\n"
"we need a client similar to Besu that we are using for L1. The efforts\n"
"to provide full nodes for the Starknet ecosystem are:\n"
"[Pathfinder](https://github.com/eqlabs/pathfinder) (used here),\n"
"[Papyrus](https://github.com/starkware-libs/papyrus), and\n"
"[Juno](https://github.com/NethermindEth/juno). However, different\n"
"implementations are still in development and not yet ready for\n"
"production."
msgstr ""
"为了与Starknet区块链的传播保持同步\n"
"我们需要一个类似于用于 L1 的 Besu 的客户端。我们\n"
"为 Starknet 生态系统提供完整节点的有\n"
"[Pathfinder](https://github.com/eqlabs/pathfinder) （此处使用）、\n"
"[Papyrus](https://github.com/starkware-libs/papyrus) 和\n"
"[Juno](https://github.com/NethermindEth/juno)。然而，不同的\n"
"实现仍在开发中，尚未准备好投入生产。\n"
"生产。"

#: src/ch03-04-nodes.md:223
#, fuzzy
msgid "Check that your L1 has completed its sync:"
msgstr "检查 L1 是否已完成同步："

#: src/ch03-04-nodes.md:225
#, fuzzy
msgid ""
"# check goerli etherscan to make sure you have the latest block https://goerli.etherscan.io\n"
"\n"
"    curl --location --request POST 'http://localhost:8545' \\\n"
"    --header 'Content-Type: application/json' \\\n"
"    --data-raw '{\n"
"        \"jsonrpc\":\"2.0\",\n"
"        \"method\":\"eth_blockNumber\",\n"
"        \"params\":[],\n"
"        \"id\":83\n"
"    }'\n"
"\n"
"    # Convert the result, which is hex (remove 0x) to decimal. Example:\n"
"    echo $(( 16#246918 ))"
msgstr ""
"# 检查 goerli etherscan，确保有最新的块 https://goerli.etherscan.io\n"
"\n"
"    curl --location --request POST 'http://localhost:8545'\\\n"
"    --header 'Content-Type: application/json' （内容类型：应用程序/json\n"
"    --data-raw '{\n"
"        \"jsonrpc\": \"2.0\"、\n"
"        \"method\": \"eth_blockNumber\"、\n"
"        \"params\":[]、\n"
"        \"id\":83\n"
"    }'\n"
"\n"
"    # 将结果（十六进制，去掉 0x）转换为十进制。例如\n"
"    echo $(( 16#246918 ))"

#: src/ch03-04-nodes.md:239
#, fuzzy
msgid ""
"Start your L2 Execution Client and note that we are syncing Starknet’s\n"
"state from our LOCAL ETH L1 NODE!"
msgstr ""
"启动您的 L2 执行客户端，注意我们正在从本地 ETH L1 节点同步 Starknet 的状态。\n"
"状态！"

#: src/ch03-04-nodes.md:242
#, fuzzy
msgid "PATHFINDER_ETHEREUM_API_URL=http://127.0.0.1:8545"
msgstr "pathfinder_ethereum_api_url=http://127.0.0.1:8545"

#: src/ch03-04-nodes.md:244
#, fuzzy
msgid ""
"# from starknet-stack project root\n"
"    docker-compose -f dc-l2.yaml up -d"
msgstr ""
"# 从 starknet-stack 项目根目录\n"
"    docker-compose -f dc-l2.yaml up -d"

#: src/ch03-04-nodes.md:247
#, fuzzy
msgid "To follow the sync:"
msgstr "跟随同步："

#: src/ch03-04-nodes.md:249
#, fuzzy
msgid "docker container logs -f $(docker ps | grep pathfinder | awk '{print $1}')"
msgstr "docker container logs -f $(docker ps | grep pathfinder | awk '{print $1}')"

#: src/ch03-04-nodes.md:251
#, fuzzy
msgid ""
"Starknet [Testnet_1](https://testnet.starkscan.co) currently comprises\n"
"800,000+ blocks so this will take some time (days) to sync fully. To\n"
"check L2 sync:"
msgstr ""
"Starknet [Testnet_1](https://testnet.starkscan.co)目前包括\n"
"800,000 多个区块，因此需要一些时间（几天）才能完全同步。要\n"
"检查 L2 同步："

#: src/ch03-04-nodes.md:255
#, fuzzy
msgid ""
"# compare `current_block_num` with `highest_block_num`\n"
"\n"
"    curl --location --request POST 'http://localhost:9545' \\\n"
"    --header 'Content-Type: application/json' \\\n"
"    --data-raw '{\n"
"     \"jsonrpc\":\"2.0\",\n"
"     \"method\":\"starknet_syncing\",\n"
"     \"params\":[],\n"
"     \"id\":1\n"
"    }'"
msgstr ""
"# 将 `current_block_num` 与 `highest_block_num` 进行比较\n"
"\n"
"    curl --location --request POST 'http://localhost:9545'\\\n"
"    --header 'Content-Type: application/json' （内容类型：应用程序/json\n"
"    --data-raw '{\n"
"     \"jsonrpc\": \"2.0\"、\n"
"     \"method\": \"starknet_syncing\"、\n"
"     \"params\":[]、\n"
"     \"id\":1\n"
"    }'"

#: src/ch03-04-nodes.md:266
#, fuzzy
msgid "To check data sizes:"
msgstr "检查数据大小："

#: src/ch03-04-nodes.md:268
#, fuzzy
msgid "sudo du -sh ./* | sort -rh"
msgstr "sudo du -sh ./* | sort -rh"

#: src/ch03-04-nodes.md:270
#, fuzzy
msgid "## Layer 3: Application Layer"
msgstr "## 第 3 层：应用层"

#: src/ch03-04-nodes.md:272
#, fuzzy
msgid ""
"We see the same need for data refinement as we did in the OSI model. On\n"
"L1 packets come over the wire in a raw stream of bytes and are then\n"
"processed and filtered by higher-level protocols. When designing a\n"
"decentralized application Bob will need to be cognizant of interactions\n"
"with his contract on chain, but doesn’t need to be aware of all the\n"
"information occurring on Starknet."
msgstr ""
"我们认为，与 OSI 模型一样，也需要对数据进行细化。在\n"
"L1 数据包是以原始字节流的形式通过网络传输的，然后由更高级别的协议进行处理和过滤。\n"
"由更高级别的协议进行处理和过滤。在设计分散式应用时\n"
"在设计去中心化应用时，鲍勃需要考虑到与他在链上的合约的交互。\n"
"与链上合约的交互，但不需要了解Starknet上发生的所有信息。\n"
"信息。"

#: src/ch03-04-nodes.md:279
#, fuzzy
msgid ""
"This is the role of an indexer. To process and filter useful information\n"
"for an application. Information that an application MUST be opinionated\n"
"about and the underlying layer MUST NOT be opinionated about."
msgstr ""
"这就是索引器的作用。处理和过滤有用信息\n"
"信息。应用程序必须对信息有自己的看法\n"
"而底层不得有意见的信息。"

#: src/ch03-04-nodes.md:283
#, fuzzy
msgid ""
"Indexers provide applications flexibility as they can be written in any\n"
"programming language and have any data layout that suits the\n"
"application."
msgstr ""
"索引器为应用程序提供了灵活性，因为它们可以用任何编程语言编写，也可以有任何适合的数据布局。\n"
"编程语言编写，并拥有适合应用程序的任何数据布局。\n"
"应用。"

#: src/ch03-04-nodes.md:287
#, fuzzy
msgid ""
"To start our toy\n"
"[indexer](https://github.com/starknet-edu/starknet-stack/blob/main/indexer/indexer.sh)\n"
"run:"
msgstr ""
"启动我们的玩具\n"
"[索引器](https://github.com/starknet-edu/starknet-stack/blob/main/indexer/indexer.sh)\n"
"运行："

#: src/ch03-04-nodes.md:291
#, fuzzy
msgid "./indexer/indexer.sh"
msgstr "./indexer/indexer.sh"

#: src/ch03-04-nodes.md:293
#, fuzzy
msgid ""
"Again notice that we don’t need to leave our local setup for these\n"
"interactions (<http://localhost:9545>)."
msgstr ""
"请再次注意，我们不需要离开本地设置来进行这些\n"
"交互 (<http://localhost:9545>)。"

#: src/ch03-04-nodes.md:296
#, fuzzy
msgid "## Layer 4: Transport Layer"
msgstr "## 第 4 层：传输层"

#: src/ch03-04-nodes.md:298
#, fuzzy
msgid ""
"The transport layer comes into play when the application has parsed and\n"
"indexed critical information, often leading to some state change based\n"
"on this information. This is where the application communicates the\n"
"desired state change to the Layer 2 sequencer to get that change into a\n"
"block. This is achieved using the same full-node/RPC spec\n"
"implementation, in our case, Pathfinder."
msgstr ""
"当应用程序对关键信息进行解析和索引时，传输层就会发挥作用。\n"
"索引关键信息时，传输层就会发挥作用。\n"
"状态变化。这时，应用程序将\n"
"将所需的状态变化传递给第 2 层定序器，以便将该变化转化为数据块。\n"
"块。这是使用相同的全节点/RPC 规范实现的。\n"
"实现的，在我们的例子中，使用的是 Pathfinder。"

#: src/ch03-04-nodes.md:305
#, fuzzy
msgid ""
"When working with our local Starknet stack, invoking a transaction\n"
"locally might look like this:"
msgstr ""
"使用本地 Starknet 堆栈时，在本地调用事务\n"
"时，本地调用的事务可能是这样的"

#: src/ch03-04-nodes.md:308
#, fuzzy
msgid ""
"curl --location --request POST 'http://localhost:9545' \\\n"
"    --header 'Content-Type: application/json' \\\n"
"    --data-raw '{\n"
"        \"jsonrpc\": \"2.0\",\n"
"        \"method\": \"starknet_addInvokeTransaction\",\n"
"        \"params\": {\n"
"            \"invoke_transaction\": {\n"
"                \"type\": \"INVOKE\",\n"
"                \"max_fee\": \"0x4f388496839\",\n"
"                \"version\": \"0x0\",\n"
"                \"signature\": [\n"
"                    \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
"                    \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
"                ],\n"
"                \"contract_address\": \"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
"                \"calldata\": [\n"
"                    \"0x1\",\n"
"                    \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
"                    \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
"                    \"0x0\",\n"
"                    \"0x1\",\n"
"                    \"0x1\",\n"
"                    \"0x2b\",\n"
"                    \"0x0\"\n"
"                ],\n"
"                \"entry_point_selector\": \"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
"            }\n"
"        },\n"
"        \"id\": 0\n"
"    }'"
msgstr ""
"curl --location --request POST 'http://localhost:9545'\\\n"
"    --header 'Content-Type: application/json' （内容类型：应用程序/json\n"
"    --data-raw '{\n"
"        \"jsonrpc\"：\"2.0\",\n"
"        \"method\"：\"starknet_addInvokeTransaction\"、\n"
"        参数{\n"
"            \"invoke_transaction\"：{\n"
"                \"类型\"：\"INVOKE\"、\n"
"                \"max_fee\"：\"0x4f388496839\"、\n"
"                \"版本\"：\"0x0\",\n"
"                \"签名\"：[\n"
"                    \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
"                    \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
"                ],\n"
"                \"合约地址\"：\"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
"                \"calldata\"：[\n"
"                    \"0x1\",\n"
"                    \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
"                    \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
"                    \"0x0\",\n"
"                    \"0x1\",\n"
"                    \"0x1\",\n"
"                    \"0x2b\"、\"0x0\n"
"                    \"0x0\"\n"
"                ],\n"
"                \"entry_point_selector\"（输入点选择器）：\"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
"            }\n"
"        },\n"
"        \"id\"：0\n"
"    }'"

#: src/ch03-04-nodes.md:339
#, fuzzy
msgid ""
"However, this process involves setting up a local wallet and signing the\n"
"transaction. For simplicity, we will use a browser wallet and StarkScan."
msgstr ""
"不过，这个过程涉及到建立本地钱包和签署\n"
"交易。为简单起见，我们将使用浏览器钱包和 StarkScan。"

#: src/ch03-04-nodes.md:342
msgid "Steps:"
msgstr "步骤:"

#: src/ch03-04-nodes.md:344
#, fuzzy
msgid ""
"1.  Navigate to the contract on StarkScan and connect to your wallet.\n"
"\n"
"2.  Enter a new value and write the transaction:"
msgstr ""
"1.  导航到 StarkScan 上的合约并连接到您的钱包。\n"
"\n"
"2.  输入新值并写入交易："

#: src/ch03-04-nodes.md:348
msgid "<img alt=\"Starkscan block explorer\" src=\"img/ch03-starkscan-block-explorer.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starkscan block explorer\" src=\"img/ch03-starkscan-block-explorer.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-04-nodes.md:350
msgid "<span class=\"caption\">Starkscan block explorer</span>"
msgstr "<span class=\"caption\">Starkscan block explorer</span>"

#: src/ch03-04-nodes.md:352
#, fuzzy
msgid ""
"Once the transaction is accepted on the Layer 2 execution layer, the\n"
"event data should come through our application layer indexer."
msgstr ""
"一旦事务在第 2 层执行层被接受，事件数据就会通过我们的应用层索引器传输。\n"
"事件数据应通过我们的应用层索引器传输。"

#: src/ch03-04-nodes.md:355
#, fuzzy
msgid "Example Indexer Output:"
msgstr "索引器输出示例："

#: src/ch03-04-nodes.md:357
#, fuzzy
msgid ""
"Pulled Block #: 638703\n"
"    Found transaction: 0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
"    Events to Index:\n"
"    [\n"
"      {\n"
"        \"from_address\": \"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
"        \"keys\": [\n"
"          \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
"        ],\n"
"        \"data\": [\n"
"          \"0xa\"\n"
"        ]\n"
"      },\n"
"      {\n"
"        \"from_address\": \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"        \"keys\": [\n"
"          \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
"        ],\n"
"        \"data\": [\n"
"          \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
"          \"0x0\"\n"
"        ]\n"
"      },\n"
"      {\n"
"        \"from_address\": \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
"        \"keys\": [\n"
"          \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
"        ],\n"
"        \"data\": [\n"
"          \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"          \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
"          \"0x17c1e31c270\",\n"
"          \"0x0\"\n"
"        ]\n"
"      }\n"
"    ]"
msgstr ""
"提取的区块编号： 638703\n"
"    找到交易0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
"    事件索引：\n"
"    [\n"
"      {\n"
"        \"from_address\"：\"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
"        \"键\"：[\n"
"          \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
"        ],\n"
"        \"数据\"：[\n"
"          \"0xa\n"
"        ]\n"
"      },\n"
"      {\n"
"        \"来自地址\"：\"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"        \"键\"：[\n"
"          \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
"        ],\n"
"        \"数据\"：[\n"
"          \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
"          \"0x0\"\n"
"        ]\n"
"      },\n"
"      {\n"
"        \"from_address\"：\"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
"        \"键\"：[\n"
"          \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
"        ],\n"
"        \"数据\"：[\n"
"          \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"          \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
"          \"0x17c1e31c270\"、\n"
"          \"0x0\"\n"
"        ]\n"
"      }\n"
"    ]"

#: src/ch03-04-nodes.md:394
#, fuzzy
msgid ""
"Once the transaction is accepted on Layer 1, we can query the Starknet\n"
"Core Contracts from our Layer 1 node to see the storage keys that have\n"
"been updated on our data layer!"
msgstr ""
"一旦第一层接受了交易，我们就可以从第一层节点查询 Starknet\n"
"核心合约，以查看数据层上已更新的存储密钥\n"
"数据层上已更新的存储密钥！"

#: src/ch03-04-nodes.md:398
#, fuzzy
msgid ""
"You have successfully navigated through the entire Starknet stack, from\n"
"setting up your node, through executing and monitoring a transaction, to\n"
"inspecting its effects on the data layer. This journey has equipped you\n"
"with the understanding and the skills to interact with Starknet on a\n"
"deeper level."
msgstr ""
"您已成功浏览了整个 Starknet 堆栈，从\n"
"设置节点、执行和监控事务，到\n"
"检查其对数据层的影响。这段旅程使您\n"
"与 Starknet 进行更深层次交互的理解和技能。\n"
"更深层次的交互。"

#: src/ch03-04-nodes.md:404
#, fuzzy
msgid "## Conclusion: Understanding the Modular Nature of Starknet"
msgstr "## 结论：了解Starknet的模块性质"

#: src/ch03-04-nodes.md:406
#, fuzzy
msgid ""
"Conceptual models, such as the ones used in this guide, are incredibly\n"
"useful in helping us understand complex systems. They can be refactored,\n"
"reformed, and nested to provide a clear and comprehensive view of how a\n"
"platform like Starknet operates. For instance, the OSI Model, a\n"
"foundational model for understanding network interactions, underpins our\n"
"modular stack."
msgstr ""
"概念模型，如本指南中使用的概念模型，在帮助我们理解复杂系统方面非常有用。\n"
"在帮助我们理解复杂系统方面非常有用。它们可以被重构\n"
"重构和嵌套，以提供一个清晰而全面的视图，让我们了解像 Starknet 这样的平台是如何运行的。\n"
"像Starknet这样的平台是如何运行的。例如，OSI 模型是\n"
"例如，OSI 模型是理解网络交互的基础模型，它是我们模块化堆栈的基础。\n"
"模块化堆栈的基础。"

#: src/ch03-04-nodes.md:413
#, fuzzy
msgid ""
"A key concept to grasp is _Fractal Scaling._ This concept allows us to\n"
"extend our model to include additional layers beyond Layer 2, such as\n"
"Layer 3. In this extended model, the entire stack recurs above our\n"
"existing stack, as shown in the following diagram:"
msgstr ""
"要掌握的一个关键概念是_分形缩放。\n"
"这一概念使我们能够扩展我们的模型，使其包括第 2 层以外的其他层，例如第\n"
"第 3 层。在这个扩展模型中，整个堆栈在我们现有的堆栈之上重复出现，如下图所示\n"
"如下图所示："

#: src/ch03-04-nodes.md:418
msgid "<img alt=\"Fractal scaling in a modular blockchain environment\" src=\"img/ch03-fractal-scaling.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Fractal scaling in a modular blockchain environment\" src=\"img/ch03-fractal-scaling.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-04-nodes.md:420
msgid "<span class=\"caption\">Fractal scaling in a modular blockchain environment</span>"
msgstr "<span class=\"caption\">Fractal scaling in a modular blockchain environment</span>"

#: src/ch03-04-nodes.md:422
msgid ""
"Just as Layer 2 compresses its transaction throughput into a proof and\n"
"state change that is written to Layer 1, we can apply the same\n"
"compression principle at Layer 3, proving and writing to Layer 2. This\n"
"not only gives us more control over the protocol rules but also allows\n"
"us to achieve higher compression ratios, enhancing the scalability of\n"
"our applications."
msgstr ""

#: src/ch03-04-nodes.md:429
msgid ""
"In essence, Starknet’s modular and layered design, combined with the\n"
"power of Fractal Scaling, offers a robust and scalable framework for\n"
"building decentralized applications. Understanding this structure is\n"
"fundamental to effectively leveraging Starknet’s capabilities and\n"
"contributing to its ecosystem."
msgstr ""

#: src/ch03-04-nodes.md:435
#, fuzzy
msgid ""
"This concludes our journey into running a Starknet node and traversing\n"
"its layered architecture. We hope that you now feel equipped to explore,\n"
"experiment with, and innovate within the Starknet ecosystem."
msgstr ""
"至此，我们结束了运行Starknet节点和穿越其分层架构的旅程。\n"
"分层架构的旅程。我们希望您现在已经具备了在 Starknet 生态系统中探索、实验和创新的能力、\n"
"实验和创新。"

#: src/ch03-05-layer-3.md:1
#, fuzzy
msgid "# Layer 3 (App Chains)"
msgstr "Layer 3 和应用链 🚧  "

#: src/ch03-05-layer-3.md:3
msgid ""
"Appchains let you create a blockchain designed precisely for your\n"
"application’s needs. These specialized blockchains allow customization\n"
"in various aspects, such as hash functions and consensus algorithms.\n"
"Moreover, they inherit the security features of the Layer 1 or Layer 2\n"
"blockchains they are built upon."
msgstr ""

#: src/ch03-05-layer-3.md:11
msgid ""
"Layer 3 blockchains can exist on top of Layer 2 blockchains. You can\n"
"even build additional layers (Layer 4 and so on) on top of Layer 3 for\n"
"more complex solutions. A sample layout is shown in the following\n"
"diagram."
msgstr ""

#: src/ch03-05-layer-3.md:16
msgid "<img alt=\"Example of an environment with a Layers 3 and 4\" src=\"img/ch03-layer-3-ecosystem.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Example of an environment with a Layers 3 and 4\" src=\"img/ch03-layer-3-ecosystem.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-05-layer-3.md:18
msgid "<span class=\"caption\">Example of an environment with a Layers 3 and 4</span>"
msgstr "<span class=\"caption\">Example of an environment with a Layers 3 and 4</span>"

#: src/ch03-05-layer-3.md:20
#, fuzzy
msgid "In this example ecosystem, Layer 3 options include:"
msgstr "在此示例生态系统中，第 3 层选项包括"

#: src/ch03-05-layer-3.md:22
msgid ""
"- The Public Starknet (L2), which is a general-purpose blockchain for\n"
"  decentralized applications.\n"
"\n"
"- A L3 Starknet optimized for cost-sensitive applications.\n"
"\n"
"- Customized L3 Starknet systems designed for enhanced performance,\n"
"  using specific storage structures or data compression techniques.\n"
"\n"
"- StarkEx systems used by platforms like dYdX and Sorare, offering\n"
"  proven scalability through data availability solutions like Validium\n"
"  or Rollup.\n"
"\n"
"- Privacy-focused Starknet instances, which could also function as a\n"
"  Layer 4, for conducting transactions without including them in\n"
"  public Starknets."
msgstr ""

#: src/ch03-05-layer-3.md:38
#, fuzzy
msgid "## Benefits of Layer 3"
msgstr "## 第 3 层的优势"

#: src/ch03-05-layer-3.md:40
msgid ""
"Layer 3 app chains (with\n"
"[Madara](https://github.com/keep-starknet-strange/madara) as an apt\n"
"sequencer or other option), offer a variety of advantages due to its\n"
"modularity and flexibility. Here’s an overview of the key benefits:"
msgstr ""

#: src/ch03-05-layer-3.md:45
msgid ""
"- **Quick Iteration**: App chains enable rapid protocol changes,\n"
"  freeing you from the constraints of the public Layer 2 roadmap. For\n"
"  example, you could rapidly deploy new DeFi algorithms tailored to\n"
"  your user base.\n"
"\n"
"- **Governance Independence**: You maintain complete control over\n"
"  feature development and improvements, avoiding the need for\n"
"  decentralized governance consensus. This enables, for example, quick\n"
"  implementation of user-suggested features.\n"
"\n"
"- **Cost Efficiency**: Layer 3 offers substantial cost reductions,\n"
"  potentially up to 1 million times compared to Layer 1, making it\n"
"  economically feasible to run more complex applications.\n"
"\n"
"- **Security**: While there may be some trade-offs, such as reduced\n"
"  censorship resistance, the core security mechanisms remain strong.\n"
"\n"
"- **Congestion Avoidance**: App chains are shielded from network\n"
"  congestion, providing a more stable transaction environment, crucial\n"
"  for real-time applications like gaming.\n"
"\n"
"- **Privacy Enhancements**: Layer 3 can serve as a testing ground for\n"
"  privacy-centric features, which could include anonymous transactions\n"
"  or encrypted messaging services.\n"
"\n"
"- **Innovation Platform**: App chains act as experimental fields where\n"
"  novel features can be developed and tested. For instance, they could\n"
"  serve as a testbed for new consensus algorithms before these are\n"
"  considered for Layer 2."
msgstr ""

#: src/ch03-05-layer-3.md:75
msgid ""
"In summary, Layer 3 provides the flexibility, cost-efficiency, and\n"
"environment conducive for innovation, without significant compromise on\n"
"security."
msgstr ""

#: src/ch03-05-layer-3.md:79
msgid "## Madara as a Sequencer for Layer 3 App Chains"
msgstr ""

#: src/ch03-05-layer-3.md:81
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a\n"
"specialized sequencer developed to execute transactions and group them\n"
"into batches. Created by the StarkWare Exploration Team, it functions as\n"
"a starting point for building Layer 3 Starknet appchains. This expands\n"
"the possibilities for innovation within the Starknet ecosystem."
msgstr ""

#: src/ch03-05-layer-3.md:87
msgid ""
"Madara’s flexibility allows for the creation of Layer 3 appchains\n"
"optimized for various needs, foe example:"
msgstr ""

#: src/ch03-05-layer-3.md:90
msgid ""
"- Cost-Efficiency: Create an appchain for running a decentralized\n"
"  exchange (DEX) with lower fees compared to the public Starknet.\n"
"\n"
"- Performance: Build an appchain to operate a DEX with faster\n"
"  transaction times.\n"
"\n"
"- Privacy: Design an appchain to facilitate anonymous transactions or\n"
"  encrypted messaging services."
msgstr ""

#: src/ch03-05-layer-3.md:99
msgid ""
"For more information on Madara, refer to the subchapter with the same\n"
"title."
msgstr ""

#: src/ch03-06-solidity-verifier.md:1
#, fuzzy
msgid "# Solidity Verifier"
msgstr "Solidity 验证器 🚧"

#: src/ch03-06-solidity-verifier.md:3
msgid "Before exploring this chapter, review the Starknet Architecture chapter for foundational knowledge. Familiarity with concepts such as Sequencers, Provers, SHARP, and Sharp Jobs is assumed."
msgstr ""

#: src/ch03-06-solidity-verifier.md:5
msgid "Starknet's Solidity Verifier plays a pivotal role in the rollup landscape, ensuring the truth of transactions and smart contracts."
msgstr ""

#: src/ch03-06-solidity-verifier.md:7
msgid "## Quick Overview: SHARP and Sharp Jobs"
msgstr ""

#: src/ch03-06-solidity-verifier.md:9
msgid "NOTE: For a more detailed explanation of SHARP and Sharp Jobs, refer to the Provers subchapter in the Starknet Architecture chapter. This is a brief review."
msgstr ""

#: src/ch03-06-solidity-verifier.md:11
msgid ""
"SHARP, or Shared Prover, in Starknet, aggregates various Cairo programs from distinct users. These programs, each with unique logic, run together, producing a common proof for all, optimizing cost "
"and efficiency."
msgstr ""

#: src/ch03-06-solidity-verifier.md:13
msgid "<img alt=\"Sharp workflow\" src=\"img/ch03-06-shared-prover.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Sharp workflow\" src=\"img/ch03-06-shared-prover.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:15
msgid "<span class=\"caption\">Sharp Workflow</span>"
msgstr "<span class=\"caption\">Sharp Workflow</span>"

#: src/ch03-06-solidity-verifier.md:17
msgid "Furthermore, SHARP supports combining multiple proofs into one, enhancing its efficiency by allowing parallel proof processing and verification."
msgstr ""

#: src/ch03-06-solidity-verifier.md:19
msgid "SHARP verifies numerous Starknet transactions, like transfers, trades, and state updates. It also confirms smart contract executions."
msgstr ""

#: src/ch03-06-solidity-verifier.md:21
msgid ""
"To illustrate SHARP: Think of commuting by bus. The bus driver, the prover, transports passengers, the Cairo programs. The driver checks only the tickets of passengers alighting at the upcoming "
"stop, much like SHARP. The prover forms a single proof for all Cairo programs in a batch, but verifies only the proofs of programs executing in the succeeding block."
msgstr ""

#: src/ch03-06-solidity-verifier.md:23
msgid ""
"**Sharp Jobs**. Known as Shared Prover Jobs, Sharp Jobs let multiple users present their Cairo programs for combined execution, distributing the proof generation cost. This shared approach makes "
"Starknet more economical for users, enabling them to join ongoing jobs and leverage economies of scale."
msgstr ""

#: src/ch03-06-solidity-verifier.md:25
#, fuzzy
msgid "## Solidity Verifiers"
msgstr "Solidity 验证器 🚧"

#: src/ch03-06-solidity-verifier.md:27
msgid "A Solidity verifier is an L1 smart contract, crafted in Solidity, designed to validate STARK proofs from SHARP (Shared Prover)."
msgstr ""

#: src/ch03-06-solidity-verifier.md:29
msgid "### Previous Architecture: Monolothic Verifier"
msgstr ""

#: src/ch03-06-solidity-verifier.md:31
msgid ""
"Historically, the Solidity Verifier was a monolithic contract, both initiated and executed by the same contract. For illustration, the operator would invoke the `update state` function on the main "
"contract, providing the state to be modified and confirming its validity. Subsequently, the main contract would present the proof to both the verifier and the validium committee. Once they "
"validated the proof, the state would be updated in the main contract."
msgstr ""

#: src/ch03-06-solidity-verifier.md:33
msgid "<img alt=\"Previous Architecture\" src=\"img/ch03-06-prehistoric-architecture.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Previous Architecture\" src=\"img/ch03-06-prehistoric-architecture.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:35
msgid "<span class=\"caption\">Previous Architecture</span>"
msgstr "<span class=\"caption\">Previous Architecture</span>"

#: src/ch03-06-solidity-verifier.md:37
msgid "However, this architecture faced several constraints:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:39
msgid ""
"- Batching transactions frequently surpassed the original geth32kb transaction size limit (later adjusted to 128kb) due to accumulating excessive transactions.\n"
"- The gas required often outstripped the block size (e.g., 8 Mgas), as the block couldn't accommodate a complete batch of proof.\n"
"- A prospective constraint was that the verifier wouldn't support proof bundling, which is fundamental for SHARP."
msgstr ""

#: src/ch03-06-solidity-verifier.md:43
#, fuzzy
msgid "### Current Architecture: Multiple Smart Contracts"
msgstr "## Starknet智能合约简介"

#: src/ch03-06-solidity-verifier.md:45
msgid "The current verifier utilizes multiple smart contracts rather than being a singular, monolithic structure."
msgstr ""

#: src/ch03-06-solidity-verifier.md:47
msgid "Here are some key smart contracts associated with the verifier:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:49
msgid ""
"- [`GpsStatementVerifier`](https://etherscan.io/address/0x47312450b3ac8b5b8e247a6bb6d523e7605bdb60): This is the primary contract of the Sharp verifier. It verifies a proof and then registers the "
"related facts using `verifyProofAndRegister`. It acts as an umbrella for various layouts, each named `CpuFrilessVerifier`. Every layout has a unique combination of built-in resources."
msgstr ""

#: src/ch03-06-solidity-verifier.md:51
msgid "<img alt=\"Verifier Layouts\" src=\"img/ch03-06-verifier-layouts.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Verifier Layouts\" src=\"img/ch03-06-verifier-layouts.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:53
msgid "The system routes each proof to its relevant layout."
msgstr ""

#: src/ch03-06-solidity-verifier.md:55
msgid ""
"- [`MemoryPageFactRegistry`](https://etherscan.io/address/0xfd14567eaf9ba941cb8c8a94eec14831ca7fd1b4): This registry maintains facts for memory pages, primarily used to register outputs for data "
"availability in rollup mode. The Fact Registry is a separate smart contract ensuring the verification and validity of attestations or facts. The verifier function is separated from the main "
"contract to ensure each segment works optimally within its limits. The main proof segment relies on other parts, but these parts operate independently.\n"
"\n"
"- [`MerkleStatementContract`](https://etherscan.io/address/0x5899efea757e0dbd6d114b3375c23d7540f65fa4): This contract verifies merkle paths.\n"
"\n"
"- [`FriStatementContract`](https://etherscan.io/address/0x3e6118da317f7a433031f03bb71ab870d87dd2dd): It focuses on verifying the FRI layers."
msgstr ""

#: src/ch03-06-solidity-verifier.md:61
msgid "### Sharp Verifier Contract Map"
msgstr ""

#: src/ch03-06-solidity-verifier.md:63
msgid ""
"The Sharp Verifier Contract Map contains roughly 40 contracts, detailing various components of the Solidity verifier. The images below display the contracts and their Ethereum Mainnet addresses."
msgstr ""

#: src/ch03-06-solidity-verifier.md:65
msgid "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-1.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-1.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:67
msgid "<span class=\"caption\">Sharp Verifier Contract Map</span>"
msgstr "<span class=\"caption\">Sharp Verifier Contract Map</span>"

#: src/ch03-06-solidity-verifier.md:69
msgid "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-2.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-2.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:71
msgid "<span class=\"caption\">Sharp Verifier Contract Map (Continued)</span>"
msgstr "<span class=\"caption\">Sharp Verifier Contract Map (Continued)</span>"

#: src/ch03-06-solidity-verifier.md:73
msgid "These contracts function as follows:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:75
msgid ""
"- **Proxy**: This contract facilitates upgradability. It interacts with the `GpsStatementVerifier` contract using the `delegate_call` method. Notably, the state resides in the "
"`GpsStatementVerifier` contract, not in the proxy.\n"
"- **CallProxy**: Positioned between the `Proxy` and the `GpsStatementVerifier` contracts, it functions like a typical proxy. However, it avoids the `delegate_call` method and calls the function in "
"the implementation contract directly.\n"
"- **CairoBootloaderProgram**: Comprising numerical Cairo programs, it validates the Cairo program of a statement. The bootloader manages the logic executing Cairo programs to generate proof and "
"program hash.\n"
"- **PedersenHashPoints (X & Y Column)**: These lookup tables store vast amounts of data. Validation functions consult them to compute the Pedersen hash.\n"
"- **EcdsaPoints (X & Y Column)**: Similar to the Pedersen hash, these tables assist in calculating the elliptic curve.\n"
"- **CpuFrilessVerifier/CpuOods/CpuConstantPoly (0 - 7)**: These verifier contracts vary in layout as shown in the `GpsStatementVerifier` layout image. Each layout encompasses resources, built-ins, "
"constraints, and more, designed for a specific task. Each has unique parameters for its constructor.\n"
"- **PoseidonPoseidon**: These contracts back the new Poseidon built-in and contain Poseidon-specific lookup tables."
msgstr ""

#: src/ch03-06-solidity-verifier.md:83
#, fuzzy
msgid "### Constructor Parameters of Key Contracts"
msgstr "## Starknet智能合约简介"

#: src/ch03-06-solidity-verifier.md:85
msgid ""
"When constructing the primary verifier contracts, specific parameters are employed to facilitate functionality. These parameters reference other auxiliary contracts, decentralizing the logic and "
"ensuring the main contract remains under the 24kb deployment limit."
msgstr ""

#: src/ch03-06-solidity-verifier.md:87
msgid "Below is a visual representation of these parameters in relation to key contracts `CpuFrilessVerifiers` and `GpsStatementVerifier`:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:89
msgid ""
"<img alt=\"Constructor Parameters\" src=\"img/ch03-06-constructor-params.png\" class=\"center\" style=\"width: 50%;\" />\n"
"<span class=\"caption\">Constructor Parameters</span>"
msgstr ""
"<img alt=\"Constructor Parameters\" src=\"img/ch03-06-constructor-params.png\" class=\"center\" style=\"width: 50%;\" />\n"
"<span class=\"caption\">Constructor Parameters</span>"

#: src/ch03-06-solidity-verifier.md:92
msgid "#### CpuFrilessVerifier Constructor Parameters"
msgstr ""

#: src/ch03-06-solidity-verifier.md:94
msgid "`CpuFrilessVerifiers` is designed to handle a diverse range of tasks. Its parameters encompass:"
msgstr "`CpuFrilessVerifiers` is designed to handle a diverse range of tasks. Its parameters encompass:"

#: src/ch03-06-solidity-verifier.md:96
msgid ""
"- **Auxiliary Polynomial Contracts:** These include `CpuConstraintPoly`, `PedersenHashPointsxColumn`, `PedersenHashPointsYColumn`, `EcdsaPointsXColumn`, and `EcdsaPointsYColumn`.\n"
"- **Poseidon-Related Contracts:** Several `PoseidonPoseidonFullRoundKey` and `PoseidonPoseidonPartialRoundKey` contracts.\n"
"- **Sampling and Memory:** The contract uses `CpuOods` for out-of-domain sampling and `MemoryPageFactRegistry` for memory-related tasks.\n"
"- **Verification:** It integrates with `MerkleStatementContract` for merkle verification and `FriStatementContract` for Fri-related tasks.\n"
"- **Security:** The `num_security_bits` and `min_proof_of_work_bits` contracts ensure secure operation."
msgstr ""

#: src/ch03-06-solidity-verifier.md:102
msgid "**NOTE:** For instances like `CpuFrilessVerifier0`, specific contracts (e.g., `CpuConstraintPoly0`, `PoseidonPoseidonFullRoundKeyColumn0`, `CpuOods0`) become particularly relevant."
msgstr ""

#: src/ch03-06-solidity-verifier.md:104
msgid "#### GpsStatementVerifier Constructor Parameters"
msgstr ""

#: src/ch03-06-solidity-verifier.md:106
msgid "The `GpsStatementVerifier` functions as the hub of verifier operations, necessitating various parameters for effective functioning:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:108
msgid ""
"- **Bootloader:** It references the `CairoBootloaderProgram` to initiate the system.\n"
"- **Memory Operations:** This is facilitated by the `MemoryPageFactRegistry` contract.\n"
"- **Sub-Verifiers:** It integrates a series of sub-verifiers (`CpuFrilessVerifier0` through `CpuFrilessVerifier7`) to decentralize tasks.\n"
"- **Verification:** The hashes, `hashed_supported_cairo_verifiers` and `simple_bootloader_program_hash`, are essential for validation processes."
msgstr ""

#: src/ch03-06-solidity-verifier.md:113
#, fuzzy
msgid "### Interconnection of Contracts"
msgstr "## 与合约的交互"

#: src/ch03-06-solidity-verifier.md:115
msgid "The `GpsStatementVerifier` serves as the primary verifier contract, optimized for minimal logic to fit within deployment size constraints. To function effectively:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:117
msgid ""
"- It relies on smaller verifier contracts, which are already deployed and contain varied verification logic.\n"
"- These smaller contracts, in turn, depend on other contracts, established during their construction."
msgstr ""

#: src/ch03-06-solidity-verifier.md:120
msgid "In essence, while the diverse functionalities reside in separate contracts for clarity and size efficiency, they are all interlinked within the `GpsStatementVerifier`."
msgstr ""

#: src/ch03-06-solidity-verifier.md:122
msgid ""
"For future enhancements or adjustments, the proxy and callproxy contracts facilitate upgradability, allowing seamless updates to the `GpsStatementVerifier` without compromising its foundational "
"logic."
msgstr ""

#: src/ch03-06-solidity-verifier.md:124
msgid "### Sharp Verification Flow"
msgstr ""

#: src/ch03-06-solidity-verifier.md:126
msgid "<img alt=\"Sharp Verification Flow\" src=\"img/ch03-06-new-sharp-flow.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Sharp Verification Flow\" src=\"img/ch03-06-new-sharp-flow.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:128
msgid "<span class=\"caption\">Sharp Verification Flow</span>"
msgstr "<span class=\"caption\">Sharp Verification Flow</span>"

#: src/ch03-06-solidity-verifier.md:130
msgid ""
"1. The Sharp dispatcher transmits all essential transactions for verification, including:\n"
"   a. `MemoryPages` (usually many).\n"
"   b. `MerkleStatements` (typically between 3 and 5).\n"
"   c. `FriStatements` (generally ranging from 5 to 15).\n"
"\n"
"2. The Sharp dispatcher then forwards the proof using `verifyProofAndRegister`.\n"
"\n"
"3. Applications, such as the Starknet monitor, validate the status. Once verification completes, they send an `updateState` transaction."
msgstr ""

#: src/ch03-06-solidity-verifier.md:141
msgid ""
"Starknet transformed the Solidity Verifier from a single unit to a flexible, multi-contract system, highlighting its focus on scalability and efficiency. Using SHARP and refining verification "
"steps, Starknet makes sure the Solidity Verifier stays a strong cornerstone in its setup."
msgstr ""

#: src/ch03-07-decentralization.md:1
#, fuzzy
msgid "# Decentralization 🚧"
msgstr "去中心化 🚧"

#: src/ch04-00-account-abstraction.md:1
#, fuzzy
msgid "# Account Abstraction"
msgstr "4: 账户抽象"

#: src/ch04-00-account-abstraction.md:3
msgid ""
"Account Abstraction (AA) is a paradigm shift in how accounts and\n"
"transactions are managed in blockchain networks. To break it down, AA\n"
"refers to two intertwined notions:"
msgstr ""

#: src/ch04-00-account-abstraction.md:7
msgid ""
"1.  Transaction Flexibility: This gives the power to each smart contract\n"
"    to validate its transactions, rather than enforcing a\n"
"    one-size-fits-all validation process. This can lead to a variety of\n"
"    potential benefits such as enabling smart contracts to pay for gas\n"
"    fees, allowing multiple signers for a single account, and even\n"
"    introducing advanced cryptographic signatures.\n"
"\n"
"2.  User Experience Optimization: AA provides a more intuitive\n"
"    experience for end-users. It allows developers to create a more\n"
"    flexible security model, for instance, allowing different keys for\n"
"    everyday use and high-value transactions. Additionally, it\n"
"    eliminates, if wished, the need for seed phrases, instead opting for\n"
"    easier recovery methods."
msgstr ""

#: src/ch04-00-account-abstraction.md:21
msgid ""
"At a technical level, AA replaces Externally Owned Accounts (EOA) with a\n"
"generalized concept of accounts. Under this model, accounts can be\n"
"represented by a smart contract that dictates their specific rules and\n"
"behaviors. This means the user or contract account could dictate rules\n"
"about transaction ordering, signatures, access controls, and more,\n"
"providing a high level of customization."
msgstr ""

#: src/ch04-00-account-abstraction.md:28
msgid "Here are two commonly cited definitions of AA:"
msgstr ""

#: src/ch04-00-account-abstraction.md:30
msgid ""
"> Definition 1: Account Abstraction (AA) is when a **smart contract can\n"
"> pay for its own transactions** (Martin Triay, Devcon 6)\\[1\\]. In other\n"
"> words, abstract contracts (or account smart contracts) can pay for\n"
"> transactions. This is a departure from the traditional Externally\n"
"> Owned Accounts or Smart Wallets."
msgstr ""

#: src/ch04-00-account-abstraction.md:36
msgid ""
"> Definition 2: AA is **validation abstraction**. Instead of relying on\n"
"> a single method of transaction validation, as with Ethereum’s Layer 1,\n"
"> AA enables an abstraction of the validation process. This implies the\n"
"> possibility of using different types of signatures, cryptographic\n"
"> primitives, execution processes, etc. (lightclient, Devcon 6)\\[3\\]."
msgstr ""

#: src/ch04-00-account-abstraction.md:42
msgid ""
"AA is positioned as the cornerstone of the next generation blockchain\n"
"technologies, with significant improvements in scalability, user\n"
"experience, and security. It is currently being pioneered by Layer 2\n"
"solutions, including Starknet, as they aim to revolutionize the way we\n"
"approach security, user experience, and self-custody in the crypto\n"
"space."
msgstr ""

#: src/ch04-00-account-abstraction.md:49
msgid "## Applications of Account Abstraction"
msgstr ""

#: src/ch04-00-account-abstraction.md:51
msgid ""
"Having defined Account Abstraction, let’s delve into its practical\n"
"applications. Account Abstraction aims to improve both the accessibility\n"
"and security of self-custody. Here are a few of the key features that AA\n"
"enables:"
msgstr ""

#: src/ch04-00-account-abstraction.md:56
msgid ""
"1.  **Hardware Signer:** With AA, you could sign transactions using a\n"
"    key generated and safeguarded by your smartphone’s secure enclave.\n"
"    This use of biometric identity makes the process more secure and\n"
"    user-friendly (Starkware)\\[4\\], (Braavos)\\[7\\].\n"
"\n"
"2.  **Social recovery:** With the integration of AA, if you lose or\n"
"    compromise your key, you could securely replace it, thus eliminating\n"
"    the need for seed phrases. This change not only enhances security\n"
"    but also simplifies the user experience (Julien Niset, 2022)\\[5\\].\n"
"\n"
"3.  **Key rotation:** If a key controlling your account is compromised,\n"
"    you can easily replace it, negating the need to transfer your\n"
"    assets.\n"
"\n"
"4.  **Session keys:** AA can enhance the usability of web3 applications\n"
"    by allowing a _sign in once_ feature. This would enable websites to\n"
"    execute transactions on your behalf, reducing the need for\n"
"    continuous approvals.\n"
"\n"
"5.  **Custom transaction validation schemes:** AA enables the use of\n"
"    various signature schemes, multisignatures, and other security\n"
"    rules. This flexibility allows for customizable security measures to\n"
"    meet individual user’s needs (Martin Triay, Devcon 6)\\[1\\], (Julien\n"
"    Niset, 2022)\\[5\\], (Motty Lavie)\\[7\\]."
msgstr ""

#: src/ch04-00-account-abstraction.md:81
msgid "Moreover, AA provides enhanced security in several ways:"
msgstr ""

#: src/ch04-00-account-abstraction.md:83
msgid ""
"1.  **Improved key management:** With AA, you can associate multiple\n"
"    devices with your wallet, so if one device is lost, you still have\n"
"    access to your account.\n"
"\n"
"2.  **Various signature and validation schemes:** AA supports additional\n"
"    security measures, like two-factor authentication for large\n"
"    transactions, providing a more secure environment that adapts to\n"
"    individual user’s needs.\n"
"\n"
"3.  **Custom security policies:** Tailor security schemes to suit\n"
"    different types of users or devices and adapt good practices from\n"
"    the banking and web2 sectors."
msgstr ""

#: src/ch04-00-account-abstraction.md:96
msgid ""
"AA opens up new possibilities for both developers and users in the\n"
"Ethereum ecosystem. It offers a promising pathway for a more secure,\n"
"user-friendly experience and lays the groundwork for widespread\n"
"adoption."
msgstr ""

#: src/ch04-00-account-abstraction.md:101
msgid "## Ethereum Account System"
msgstr ""

#: src/ch04-00-account-abstraction.md:103
msgid ""
"To fully understand the benefits of Account Abstraction (AA), let’s\n"
"delve into Ethereum’s current account system. The system is split into\n"
"two types of accounts:"
msgstr ""

#: src/ch04-00-account-abstraction.md:107
msgid ""
"- **Externally Owned Accounts** (EOAs)\n"
"\n"
"- **Contract Accounts** (CAs)."
msgstr ""

#: src/ch04-00-account-abstraction.md:111
msgid ""
"EOAs are the accounts used by individuals, wallets, or any entity\n"
"external to the Ethereum network. These accounts are identified by their\n"
"address, which is derived from the public key of an associated\n"
"cryptographic object called a signer. This signer, or keypair, consists\n"
"of a private key and a public key."
msgstr ""

#: src/ch04-00-account-abstraction.md:117
msgid ""
"The private key, also known as the secret key, is used to digitally sign\n"
"transactions or messages, establishing proof of ownership. The\n"
"corresponding public key is used to verify this signature, ensuring it\n"
"was indeed signed by the respective private key."
msgstr ""

#: src/ch04-00-account-abstraction.md:122
msgid ""
"This means, in order to modify the state of an account, a transaction\n"
"must be initiated and signed by the corresponding private key of the\n"
"account’s EOA. This design choice ensures security by associating each\n"
"account with a unique cryptographic identity."
msgstr ""

#: src/ch04-00-account-abstraction.md:127
msgid ""
"On the other hand, CAs are smart contracts living on the Ethereum\n"
"blockchain. Unlike EOAs, they do not have a private key. They are\n"
"triggered through transactions or messages initiated by EOAs, and their\n"
"behavior is determined by their associated code."
msgstr ""

#: src/ch04-00-account-abstraction.md:132
msgid "However, the current account model presents some challenges:"
msgstr ""

#: src/ch04-00-account-abstraction.md:134
msgid ""
"1.  **Key Management:** The loss of a private key is catastrophic. Given\n"
"    that the private key represents the ownership of the account, if it\n"
"    is lost, all the assets within the account are lost too. Similarly,\n"
"    if it gets stolen, the perpetrator gains full control over the\n"
"    account and its assets.\n"
"\n"
"2.  **User Experience:** Currently, the Ethereum account model lacks\n"
"    user-friendly methods for key recovery or account recovery, which\n"
"    can discourage non-technical users. Additionally, user interfaces,\n"
"    such as crypto wallets, can be overwhelming and difficult to use,\n"
"    presenting barriers for wider adoption.\n"
"\n"
"3.  **Lack of Flexibility:** The traditional model doesn’t allow for\n"
"    custom transaction validation schemes, limiting the possible\n"
"    security and access control improvements."
msgstr ""

#: src/ch04-00-account-abstraction.md:150
msgid ""
"Account Abstraction proposes to improve upon these limitations, offering\n"
"new possibilities in terms of security, scalability, and user\n"
"experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:154
msgid "## The Need for Account Abstraction"
msgstr ""

#: src/ch04-00-account-abstraction.md:156
msgid ""
"As the crypto ecosystem matures and attracts a broader user base, it\n"
"faces pivotal challenges that demand innovative solutions. Among these,\n"
"the question of Account Abstraction (AA) has taken center stage.\n"
"Ethereum, one of the leading platforms for smart contracts and\n"
"Decentralized Applications (dApps), is in a precarious position: it must\n"
"embrace Account Abstraction or risk its position in the crypto world."
msgstr ""

#: src/ch04-00-account-abstraction.md:163
msgid ""
"Without AA, Ethereum’s ability to provide a seamless, empowering, and\n"
"secure experience for its users is hampered. This could lead to users\n"
"abandoning the platform for centralized exchanges and wallets, a trend\n"
"that would undermine the very ethos of decentralization that\n"
"cryptocurrency and blockchain technology espouse."
msgstr ""

#: src/ch04-00-account-abstraction.md:169
msgid ""
"There are several compelling reasons why Ethereum, and the larger crypto\n"
"ecosystem, need Account Abstraction:"
msgstr ""

#: src/ch04-00-account-abstraction.md:172
msgid ""
"- **Risk of Centralization:** The inefficiencies and limitations of\n"
"  the current account model may push users towards centralized\n"
"  exchanges and wallets. These entities defy the principles of\n"
"  decentralization, presenting familiar risks such as censorship,\n"
"  discrimination, and potential abuse of power. Account Abstraction,\n"
"  by enabling easier and more secure account management, can help\n"
"  uphold the principles of decentralization.\n"
"\n"
"- **Quantum Threat:** Quantum computing poses a potential threat to\n"
"  cryptographic systems, with its ability to break traditional\n"
"  security measures. Account Abstraction can address this by enabling\n"
"  the use of different signature schemes, including quantum-resistant\n"
"  ones, enhancing the security of assets on the blockchain.\n"
"\n"
"- **Scaling Self-Custody:** As the next billion users approach the\n"
"  crypto ecosystem, the importance of scaling self-custody becomes\n"
"  paramount. AA can improve the scalability of self-custody, which is\n"
"  essential for onboarding these new users.\n"
"\n"
"- **User Experience:** Simplifying the onboarding process and user\n"
"  experience is essential for widespread adoption. The complexity\n"
"  associated with current wallets and key management systems can be\n"
"  daunting for newcomers. Account Abstraction promises to simplify\n"
"  these aspects, paving the way for a more intuitive user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:197
msgid ""
"Starknet is currently leading the efforts to implement Account\n"
"Abstraction at the protocol level. Many consider it to be the \"proving\n"
"ground\" for the future of AA. With numerous experts from different\n"
"organizations collaborating, Starknet aims to redefine the approach to\n"
"security, user experience, and self-custody in the crypto space."
msgstr ""

#: src/ch04-00-account-abstraction.md:203
msgid ""
"The stakes are high. The future of Ethereum, and by extension, the\n"
"crypto ecosystem, is deeply intertwined with the success of Account\n"
"Abstraction. If Ethereum cannot adapt, it risks losing its prominence to\n"
"other, more adaptable platforms."
msgstr ""

#: src/ch04-00-account-abstraction.md:208
msgid "## Why Isn’t Account Abstraction Implemented in Ethereum’s Layer 1 Yet?"
msgstr ""

#: src/ch04-00-account-abstraction.md:210
msgid ""
"Ethereum’s Layer 1 (L1) doesn’t yet support Account Abstraction (AA) at\n"
"a protocol level, not due to lack of desire or understanding of its\n"
"importance, but rather due to the complexity of its implementation."
msgstr ""

#: src/ch04-00-account-abstraction.md:214
msgid ""
"The most prominent roadblock in integrating AA is the entrenched nature\n"
"of Externally Owned Accounts (EOAs) in Ethereum’s architecture. These\n"
"accounts, as fundamental elements of the Ethereum core protocol, would\n"
"need significant alteration to support AA, an undertaking that becomes\n"
"more daunting as the value secured by Ethereum continues to rise."
msgstr ""

#: src/ch04-00-account-abstraction.md:220
msgid ""
"One key aspect that complicates the integration of AA into Ethereum’s L1\n"
"is the Ethereum Virtual Machine (EVM). The EVM, as the runtime\n"
"environment for smart contracts in Ethereum, has limitations that hinder\n"
"the implementation of AA. While there have been several proposals for AA\n"
"since Ethereum’s inception, they have been consistently delayed due to\n"
"other pressing updates and improvements to the Ethereum network."
msgstr ""

#: src/ch04-00-account-abstraction.md:227
msgid ""
"However, the emergence of Layer 2 (L2) solutions provides a new pathway\n"
"for the implementation of AA. With their focus on scalability and\n"
"performance enhancements, these new virtual machines can better\n"
"accommodate AA. Starknet and ZKSync are examples of platforms that have\n"
"native AA inspired by EIP4337 – a proposal deemed superior by industry\n"
"experts like Argent’s Julien Niset."
msgstr ""

#: src/ch04-00-account-abstraction.md:234
msgid ""
"The repeated postponements and challenges in implementing AA on\n"
"Ethereum’s L1 have led many proponents, including Niset, to shift their\n"
"focus. Instead of hoping for EOAs to be phased out and AA integrated at\n"
"Ethereum’s core, they are now advocating for the broad adoption of AA\n"
"through L2 solutions like Starknet. This strategy could bring the\n"
"benefits of AA to users sooner and help the Ethereum network remain\n"
"competitive in the rapidly evolving crypto landscape."
msgstr ""

#: src/ch04-00-account-abstraction.md:242
msgid "## (OPTIONAL) ERC-4337 Components Explained"
msgstr ""

#: src/ch04-00-account-abstraction.md:244
msgid "ERC-4337 brings a new transaction layer to Ethereum without altering the core consensus mechanism. It's comprised of several components: `UserOperation`, `Bundler`, `Wallet`, and `Paymaster`."
msgstr ""

#: src/ch04-00-account-abstraction.md:246
#, fuzzy
msgid "### UserOperation Component"
msgstr "### 转账组件"

#: src/ch04-00-account-abstraction.md:248
msgid "`UserOperation` is a structured definition that encapsulates user transaction details. Unlike a conventional transaction, it encompasses several fields:"
msgstr "`UserOperation` is a structured definition that encapsulates user transaction details. Unlike a conventional transaction, it encompasses several fields:"

#: src/ch04-00-account-abstraction.md:250
msgid ""
"- `sender`: Ethereum address initiating the operation.\n"
"- `nonce`: A sequential number preventing transaction replay, critical for security.\n"
"- `initCode`: Initialization code for account creation when the account doesn't exist on the blockchain.\n"
"- `callData`: Data payload for the execution call to the `sender` address.\n"
"- `callGasLimit`: Gas allocation for the execution call.\n"
"- `verificationGasLimit`: Gas allocation for the verification process.\n"
"- `preVerificationGas`: Gas paid to the bundler for pre-execution verification efforts.\n"
"- `maxFeePerGas` and `maxPriorityFeePerGas`: Fees per gas unit, aligning with EIP-1559 standards.\n"
"- `paymasterAndData`: Information about any third-party paymaster responsible for transaction fees."
msgstr ""

#: src/ch04-00-account-abstraction.md:260
msgid ""
"`UserOperation` objects are submitted by users, encapsulating their intended actions, signatures, and required validation data. Bundlers collect these objects into bundles, which are then "
"incorporated into Ethereum blocks as singular transactions."
msgstr ""
"`UserOperation` objects are submitted by users, encapsulating their intended actions, signatures, and required validation data. Bundlers collect these objects into bundles, which are then "
"incorporated into Ethereum blocks as singular transactions."

#: src/ch04-00-account-abstraction.md:262
msgid "<img width=\"837\" alt=\"image\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/037cdd3a-ec80-41a1-84d4-f71bce5bda0e\">"
msgstr "<img width=\"837\" alt=\"image\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/037cdd3a-ec80-41a1-84d4-f71bce5bda0e\">"

#: src/ch04-00-account-abstraction.md:264
#, fuzzy
msgid "### Bundler Component"
msgstr "### 余额组件"

#: src/ch04-00-account-abstraction.md:266
msgid ""
"The Bundler serves as the keystone in ERC-4337, enabling account abstraction across EVM-compatible networks without consensus layer alterations. It manages a specialized mempool of `UserOperation` "
"objects, ensuring transactions are added on-chain efficiently. The Bundler is responsible for:"
msgstr ""

#: src/ch04-00-account-abstraction.md:268
msgid ""
"- Paying the ETH fee for the bundled transaction.\n"
"- Receiving compensation through execution fees from `UserOperation` executions.\n"
"- Selecting `UserOperation` objects for inclusion based on fee-prioritization logic, mirroring traditional miner operations in the Ethereum mempool."
msgstr ""

#: src/ch04-00-account-abstraction.md:272
msgid "`UserOperation` objects are ABI-encoded structures containing:"
msgstr "`UserOperation` objects are ABI-encoded structures containing:"

#: src/ch04-00-account-abstraction.md:274
msgid ""
"- `sender`: The wallet initiating the operation.\n"
"- `nonce` and `signature`: Critical for the wallet's verification function to authenticate operations.\n"
"- `initCode`: Necessary for creating the wallet if it does not already exist.\n"
"- `callData`: The data invoked for the wallet's execution step."
msgstr ""

#: src/ch04-00-account-abstraction.md:279
msgid ""
"Bundlers balance the `UserOperation` inclusion based on potential fee earnings against the computational and financial costs, analogous to how miners select transactions for block inclusion. The "
"remaining fields have to do with gas and fee management; a complete list of fields can be found in the [ERC 4337](#https://eips.ethereum.org/EIPS/eip-4337) spec."
msgstr ""

#: src/ch04-00-account-abstraction.md:281
#, fuzzy
msgid "## Wallet Component"
msgstr "### 余额组件"

#: src/ch04-00-account-abstraction.md:283
msgid ""
"The Wallet in the ERC-4337 framework is a critical interface for managing user operations, which includes executing the `validateUserOp` function. This function is central to ensuring transactional "
"integrity and security. It's designed with several restrictions that enforce deterministic transaction validation:"
msgstr ""

#: src/ch04-00-account-abstraction.md:285
msgid ""
"- The function is prohibited from reading or writing the storage of other contracts, maintaining each contract's state integrity.\n"
"- It cannot use environment opcodes like `TIMESTAMP`, which prevents non-determinism in validation.\n"
"- Interaction with other contracts is restricted to those that cannot self-destruct, mitigating potential vulnerabilities and ensuring contract interaction stability."
msgstr ""

#: src/ch04-00-account-abstraction.md:289
msgid "These limitations are essential for ensuring that a simulated execution of `validateUserOp` by bundlers and mempool nodes aligns with its actual execution upon inclusion in a future block."
msgstr ""

#: src/ch04-00-account-abstraction.md:291
msgid ""
"Once a `UserOperation` has been successfully validated, it is assured of inclusion in the blockchain until the sender's account undergoes an internal state change. This change could be triggered by "
"another `UserOperation` or contract interaction, each requiring a substantial amount of gas (over 7500) to modify the account state."
msgstr ""

#: src/ch04-00-account-abstraction.md:293
msgid ""
"Additionally, the `UserOperation` must specify a conservative gas limit for the `validateUserOp` process. Mempool nodes and bundlers are required to enforce this limit strictly, rejecting any "
"operation that proposes a gas limit beyond an established threshold, such as 200,000 gas. This policy mirrors the protective measures in Ethereum's current transaction system to protect against DoS "
"attacks."
msgstr ""

#: src/ch04-00-account-abstraction.md:295
msgid ""
"By adopting transactional models akin to Ethereum's current system, the Wallet ensures the secure and predictable handling of `UserOperation` objects. Bundlers and mempool nodes utilize this logic "
"to make informed decisions on including or forwarding operations, thus maintaining the network's resilience to potential threats and ensuring the trustworthiness of the system's stability."
msgstr ""

#: src/ch04-00-account-abstraction.md:297
msgid "<img width=\"647\" alt=\"image2\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/02fb5b75-2169-4bc2-bf96-47ae8be9d190\">"
msgstr "<img width=\"647\" alt=\"image2\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/02fb5b75-2169-4bc2-bf96-47ae8be9d190\">"

#: src/ch04-00-account-abstraction.md:299
#, fuzzy
msgid "### Paymaster Component"
msgstr "### 转账组件"

#: src/ch04-00-account-abstraction.md:301
msgid "Paymasters in ERC-4337 address the challenge of obtaining ETH for transaction fees by allowing gas payment abstraction. This enables:"
msgstr ""

#: src/ch04-00-account-abstraction.md:303
msgid ""
"- Developers to sponsor transaction fees for their users.\n"
"- Users to pay fees with ERC20 tokens via an intermediary contract converting tokens to ETH."
msgstr ""

#: src/ch04-00-account-abstraction.md:306
msgid ""
"The Paymaster is an optional role within a `UserOperation`, determined during the verification step. If a Paymaster agrees to cover the operation fees, they are deducted from the Paymaster's staked "
"ETH. Following execution, the Paymaster may be further involved during the `postOp` call."
msgstr ""

#: src/ch04-00-account-abstraction.md:308
msgid "Key workflows include:"
msgstr ""

#: src/ch04-00-account-abstraction.md:310
msgid ""
"- Validating sponsor signatures within `paymasterData` to confirm fee sponsorship.\n"
"- Ensuring sufficient ERC20 token balances for transaction fee coverage, with the Paymaster converting and claiming these tokens as compensation during `postOp`."
msgstr ""

#: src/ch04-00-account-abstraction.md:313
msgid ""
"Paymasters can operate passively, requiring minimal active management, which is a substantial advancement over previous sponsorship models that demanded continuous online presence and active "
"transaction wrapping."
msgstr ""

#: src/ch04-00-account-abstraction.md:315
msgid ""
"The Paymaster system significantly reduces the entry barrier for users by offloading the necessity of holding ETH for transaction fees, promoting inclusivity and flexibility in the Ethereum "
"ecosystem."
msgstr ""

#: src/ch04-00-account-abstraction.md:317
msgid "<img width=\"676\" alt=\"Paymaster Flow\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/b7deae91-56a8-4361-9697-ca4793546b1e\">"
msgstr "<img width=\"676\" alt=\"Paymaster Flow\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/b7deae91-56a8-4361-9697-ca4793546b1e\">"

#: src/ch04-00-account-abstraction.md:319
msgid "### ERC-4337 Design Properties"
msgstr ""

#: src/ch04-00-account-abstraction.md:321
msgid "ERC-4337 updates the Ethereum transaction process while preserving core aspects of the current mempool:"
msgstr ""

#: src/ch04-00-account-abstraction.md:323
msgid "**Maintained Properties:**"
msgstr ""

#: src/ch04-00-account-abstraction.md:325
msgid ""
"- Decentralization: Transactions remain peer-to-peer without centralized control.\n"
"- DoS Protection: `UserOperation` objects, once validated, are includable until the sender's state changes, safeguarding against denial-of-service attacks.\n"
"- Simplified Wallet Setup: Wallets are automatically created at deterministic addresses without user intervention.\n"
"- EIP 1559 Compliance: This design supports fee structures that allow users to be included in blocks quickly and at fair prices.\n"
"- Fee Replacement: Users can expedite transactions by increasing the fee premium through a new `UserOperation`."
msgstr ""

#: src/ch04-00-account-abstraction.md:331
msgid "**Design Advantages:**"
msgstr ""

#: src/ch04-00-account-abstraction.md:333
msgid ""
"- Flexible Verification: The `validateUserOp` function supports various signature and nonce verification methods.\n"
"- Quantum-Resilient: This design sets the stage for a quantum-resistant execution layer. Users can upgrade wallets for enhanced security.\n"
"- Wallet Upgradability: Wallets can adapt over time, changing public keys or code as needed.\n"
"- Execution Flexibility: Wallets can execute complex operations, such as atomic multi-operations, aligning with EIP 3074 goals."
msgstr ""

#: src/ch04-00-account-abstraction.md:338
msgid ""
"**Limitations:**\n"
"The design also introduces certain trade-offs:"
msgstr ""

#: src/ch04-00-account-abstraction.md:341
msgid ""
"- DoS Risk: The complex verification logic introduces a minor increase in DoS vulnerability.\n"
"- Gas Usage: The gas costs are slightly higher, offset by the efficiency of multi-operation transactions.\n"
"- Single Transaction Queueing: Multiple transactions cannot be queued simultaneously, but the design's support for atomic multi-operations compensates for this limitation."
msgstr ""

#: src/ch04-00-account-abstraction.md:347
msgid ""
"To bring it all home, imagine the Ethereum account system as a kind of\n"
"multifunctional Swiss Army knife, currently under renovation. What we’re\n"
"doing with Account Abstraction is swapping out a few tools - while it\n"
"was once a knife and a corkscrew, we’re making it into a magnifying\n"
"glass and a set of tweezers."
msgstr ""

#: src/ch04-00-account-abstraction.md:353
msgid ""
"Why the change? The original tools served us well, but they didn’t fit\n"
"every task we found ourselves up against. Some jobs required precision;\n"
"others needed a broader lens. That’s where Account Abstraction shines.\n"
"It expands Ethereum’s capabilities, adjusting and adapting to our\n"
"ever-evolving requirements."
msgstr ""

#: src/ch04-00-account-abstraction.md:359
msgid ""
"Remember the complications of Ethereum’s current account system? Account\n"
"Abstraction seeks to transform those by offering more flexible,\n"
"personalized, and safer solutions. It’s like tailoring the tools of your\n"
"Swiss Army knife to your unique needs."
msgstr ""

#: src/ch04-00-account-abstraction.md:364
msgid ""
"However, it’s not yet implemented into Ethereum’s Layer 1. And why? The\n"
"kitchen is bustling, and the chefs are wary of spilling the soup. The\n"
"implementation process has its challenges, it’s true. But the cook who\n"
"never dropped a pan never learned to make an omelette. That’s why\n"
"research and development continue relentlessly."
msgstr ""

#: src/ch04-00-account-abstraction.md:370
msgid ""
"Through the lens of Account Abstraction, we see Ethereum’s\n"
"future—secure, accessible, flexible. It’s an exciting, transformative\n"
"prospect that’s redefining what we thought possible. And though the path\n"
"may be fraught with complexities and risks, it’s a journey well worth\n"
"taking."
msgstr ""

#: src/ch04-00-account-abstraction.md:376
msgid ""
"After all, the Swiss Army knife was once just a knife. Imagine what it\n"
"could become next."
msgstr ""

#: src/ch04-00-account-abstraction.md:379
#, fuzzy
msgid "# References:"
msgstr "## 参考文献"

#: src/ch04-00-account-abstraction.md:381
msgid ""
"- \\[1\\] Martin Triay, Devcon 6:\n"
"  <https://www.youtube.com/watch?v=Osc_gwNW3Fw>\n"
"\n"
"- \\[2\\] Julien Niset: <https://www.youtube.com/watch?v=OwppworJGzs>\n"
"\n"
"- \\[3\\] lightclient, Devcon 6:\n"
"  <https://app.devcon.org/schedule/9mvqce>\n"
"\n"
"- \\[4\\] Starkware:\n"
"  <https://medium.com/@starkware/how-starknet-is-revolutionizing-crypto-signing-ba3724077a79>\n"
"\n"
"- \\[5\\] Julien Niset, 2022:\n"
"  <https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/>\n"
"\n"
"- \\[6\\] Yoav, Devcon 6: <https://app.devcon.org/schedule/9mvqce>\n"
"\n"
"- \\[7\\] Motty Lavie, 2023:\n"
"  <https://www.youtube.com/watch?v=FrxAdJYhSY8>"
msgstr ""

#: src/ch04-01-accounts.md:1
msgid "# Account Contracts"
msgstr ""

#: src/ch04-01-accounts.md:3
msgid "With a clearer understanding of the AA concept, let's proceed to code it in Starknet."
msgstr ""

#: src/ch04-01-accounts.md:5
msgid "## Account Contract Interface"
msgstr ""

#: src/ch04-01-accounts.md:7
msgid ""
"Account contracts, being a type of smart contracts, are distinguished by specific methods. A smart contract becomes an account contract when it follows the public interface outlined in SNIP-6 "
"([Starknet Improvement Proposal-6: Standard Account Interface](https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md)). This standard draws inspiration from SRC-6 and "
"SRC-5, similar to Ethereum's ERCs, which establish application conventions and contract standards."
msgstr ""

#: src/ch04-01-accounts.md:9
msgid ""
"```rust\n"
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"/// @title SRC-6 Standard Account\n"
"trait ISRC6 {\n"
"    /// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    /// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"\n"
"    /// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"/// @title SRC-5 Standard Interface Detection\n"
"trait ISRC5 {\n"
"    /// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"/// @title SRC-6 Standard Account\n"
"trait ISRC6 {\n"
"    /// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    /// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"\n"
"    /// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"/// @title SRC-5 Standard Interface Detection\n"
"trait ISRC5 {\n"
"    /// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"```"

#: src/ch04-01-accounts.md:49
msgid "From the proposal, an account contract should have the `__execute__`, `__validate__`, and `is_valid_signature` methods from the `ISRC6` trait."
msgstr ""

#: src/ch04-01-accounts.md:51
#, fuzzy
msgid "The provided functions serve these purposes:"
msgstr "提供者充当以下活动的媒介："

#: src/ch04-01-accounts.md:53
msgid ""
"- `__validate__`: Validates a list of calls intended for execution based on the contract's rules. Instead of a boolean, it returns a short string like 'VALID' within a `felt252` to convey "
"validation results. In Cairo, this short string is the ASCII representation of a single felt. If verification fails, any felt other than 'VALID' can be returned. Often, `0` is chosen.\n"
"- `is_valid_signature`: Confirms the authenticity of a transaction's signature. It takes a transaction data hash and a signature, and compares it against a public key or another method chosen by "
"the contract's author. The result is a short 'VALID' string within a `felt252`.\n"
"- `__execute__`: After validation, `__execute__` carries out a series of contract calls (as `Call` structs). It gives back an array of `Span<felt252>` structs, showing the return values of those "
"calls."
msgstr ""

#: src/ch04-01-accounts.md:57
msgid ""
"Moreover, the `SNIP-5` (Standard Interface Detection) trait needs to be\n"
"defined with a function called `supports_interface`. This function\n"
"verifies whether a contract supports a specific interface, receiving an\n"
"interface ID and returning a boolean."
msgstr ""

#: src/ch04-01-accounts.md:62
msgid ""
"```rust\n"
"    trait ISRC5 {\n"
"        fn supports_interface(interface_id: felt252) -> bool;\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    trait ISRC5 {\n"
"        fn supports_interface(interface_id: felt252) -> bool;\n"
"    }\n"
"```"

#: src/ch04-01-accounts.md:68
msgid ""
"In essence, when a user dispatches an `invoke` transaction, the protocol initiates by invoking the `__validate__` method. This verifies the associated signer's authenticity. For security reasons, "
"particularly to safeguard the Sequencer from Denial of Service (DoS) attacks [1], there are constraints on the operations within the `__validate__` method. If the signature is verified, the method "
"yields a `'VALID'` `felt252` value. If not, it returns 0."
msgstr ""

#: src/ch04-01-accounts.md:70
msgid ""
"After the protocol verifies the signer, it proceeds to invoke the `__execute__` function, passing an array of all desired operations—referred to as \"calls\"—as an argument. Each of these calls "
"specifies a target smart contract address (`to`), the method to be executed (`selector`), and the arguments this method requires (`calldata`)."
msgstr ""

#: src/ch04-01-accounts.md:72
msgid ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"\n"
"    ....\n"
"\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    ....\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"\n"
"    ....\n"
"\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    ....\n"
"\n"
"}\n"
"```"

#: src/ch04-01-accounts.md:90
msgid ""
"Executing a `Call` may yield a return value from the target smart contract. Whether it's a felt252, boolean, or a more intricate data structure like a struct or array, Starknet protocol serializes "
"the return using `Span<felt252>`. Since `Span` captures a segment of an Array [2], the `__execute__` function outputs an array of `Span<felt252>` elements. This array signifies the serialized "
"feedback from every operation in the multicall."
msgstr ""

#: src/ch04-01-accounts.md:92
msgid ""
"The `is_valid_signature` method isn't mandated or employed by the Starknet protocol. Instead, it's a convention within the Starknet developer community. Its purpose is to facilitate user "
"authentication in web3 applications. For instance, consider a user attempting to log into an NFT marketplace using their digital wallet. The web application prompts the user to sign a message, then "
"it uses the `is_valid_signature` function to confirm the authenticity of the associated wallet address."
msgstr ""

#: src/ch04-01-accounts.md:94
msgid ""
"To ensure other smart contracts recognize the compliance of an account contract with the SNIP-6 public interface, developers should incorporate the `supports_interface` method from the `ISRC5` "
"introspection trait. This method requires the Interface ID of SNIP-6 as its argument."
msgstr ""

#: src/ch04-01-accounts.md:96
msgid ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    // Implementations for __execute__, __validate__, and is_valid_signature go here.\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    // Implementations for __execute__, __validate__, and is_valid_signature go here.\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"

#: src/ch04-01-accounts.md:112
msgid ""
"The `interface_id` corresponds to the aggregated hash of the trait's selectors, as detailed in Ethereum's ERC165 [3]. Developers can either compute the ID using the `src5-rs` utility [4] or rely on "
"the pre-calculated ID: `1270010605630597976495846281167968799381097569185364931397797212080166453709`."
msgstr ""

#: src/ch04-01-accounts.md:114
msgid "The fundamental structure for the account contract, aligning with the SNIP-G Interface standard, looks like this:"
msgstr ""

#: src/ch04-01-accounts.md:116
msgid ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"

#: src/ch04-01-accounts.md:134
#, fuzzy
msgid "## Expanding the Interface"
msgstr "### 从合约读取数据"

#: src/ch04-01-accounts.md:136
msgid ""
"While the components mentioned earlier lay the foundation for an account contract in alignment with the SNIP-6 standard, developers can introduce more features to enhance the contract's "
"capabilities."
msgstr ""

#: src/ch04-01-accounts.md:138
msgid ""
"For example, integrate the `__validate_declare__` function if the contract declares other contracts and handles the corresponding gas fees. This offers a way to authenticate the contract "
"declaration. For those keen on counterfactual smart contract deployment, the `__validate_deploy__` function can be included."
msgstr ""

#: src/ch04-01-accounts.md:140
msgid ""
"Counterfactual deployment lets developers set up an account contract without depending on another account contract for gas fees. This method is valuable when there's no desire to link a new account "
"contract with its deploying address, ensuring a fresh start."
msgstr ""

#: src/ch04-01-accounts.md:142
msgid "This approach involves:"
msgstr ""

#: src/ch04-01-accounts.md:144
msgid ""
"1. Locally determining the potential address of our account contract without actual deployment, feasible with the Starkli [5] tool.\n"
"2. Transferring sufficient ETH to the predicted address to cover the deployment costs.\n"
"3. Sending a `deploy_account` transaction to Starknet containing our contract's compiled code. The sequencer then activates the account contract at the estimated address, compensating its gas fees "
"from the transferred ETH. No `declare` action is needed beforehand."
msgstr ""

#: src/ch04-01-accounts.md:148
msgid "For better compatibility with tools like Starkli later on, expose the signer's `public_key` through a view function in the public interface. Below is the augmented account contract interface:"
msgstr ""

#: src/ch04-01-accounts.md:150
msgid ""
"```rust\n"
"/// @title IAccountAddon - Extended account contract interface\n"
"trait IAccountAddon {\n"
"    /// @notice Validates if a declare transaction can proceed\n"
"    /// @param class_hash Hash of the smart contract under declaration\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"\n"
"    /// @notice Validates if counterfactual deployment can proceed\n"
"    /// @param class_hash Hash of the account contract under deployment\n"
"    /// @param salt Modifier for account address\n"
"    /// @param public_key Account signer's public key\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"\n"
"    /// @notice Fetches the signer's public key\n"
"    /// @return Public key\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// @title IAccountAddon - Extended account contract interface\n"
"trait IAccountAddon {\n"
"    /// @notice Validates if a declare transaction can proceed\n"
"    /// @param class_hash Hash of the smart contract under declaration\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"\n"
"    /// @notice Validates if counterfactual deployment can proceed\n"
"    /// @param class_hash Hash of the account contract under deployment\n"
"    /// @param salt Modifier for account address\n"
"    /// @param public_key Account signer's public key\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"\n"
"    /// @notice Fetches the signer's public key\n"
"    /// @return Public key\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"

#: src/ch04-01-accounts.md:171
msgid "In conclusion, a comprehensive account contract incorporates the **SNIP-5**, **SNIP-6**, and the Addon interfaces."
msgstr ""

#: src/ch04-01-accounts.md:173
msgid ""
"```rust\n"
"// Cheat sheet\n"
"\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"trait IAccountAddon {\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    fn public_key() -> felt252;\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"// Cheat sheet\n"
"\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"trait IAccountAddon {\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    fn public_key() -> felt252;\n"
"}\n"
"\n"
"```"

#: src/ch04-01-accounts.md:200
msgid "## Recap"
msgstr ""

#: src/ch04-01-accounts.md:202
msgid "We've broken down the distinctions between account contracts and basic smart contracts, particularly focusing on the methods laid out in SNIP-6."
msgstr ""

#: src/ch04-01-accounts.md:204
msgid ""
"- Introduced the `ISRC6` trait, spotlighting essential functions:\n"
"\n"
"  - `__validate__`: Validates transactions.\n"
"  - `is_valid_signature`: Verifies signatures.\n"
"  - `__execute__`: Executes contract calls.\n"
"\n"
"- Discussed the `ISRC5` trait and highlighted the importance of the `supports_interface` function in confirming interface support.\n"
"\n"
"- Detailed the `Call` struct to represent a single contract call, explaining its components: `to`, `selector`, and `calldata`.\n"
"\n"
"- Touched on advanced features for account contracts, such as the `__validate_declare__` and `__validate_deploy__` functions."
msgstr ""

#: src/ch04-01-accounts.md:216
msgid "Coming up, we'll craft a basic account contract and deploy it on Starknet, offering hands-on insight into their functionality and interactions."
msgstr ""

#: src/ch04-02-hello-account.md:1
msgid "# Hello World! Account Contract"
msgstr ""

#: src/ch04-02-hello-account.md:3
msgid "This section guides you through the creation of an account contract, adhering to the SNIP-6 and SRC-5 standards."
msgstr ""

#: src/ch04-02-hello-account.md:5
#, fuzzy
msgid "## Setting Up Your Project"
msgstr "## 设置新的 React 项目"

#: src/ch04-02-hello-account.md:7
msgid ""
"For deploying an account contract to Starknet's testnet or mainnet, use Scarb version 2.3.1, which is compatible with the Sierra 1.3.0 target supported by both networks. For the latest information, "
"review the [Starknet Release Notes](https://docs.starknet.io/documentation/starknet_versions/version_notes/). As of November 2023, Scarb version 2.3.1 is the recommended choice."
msgstr ""

#: src/ch04-02-hello-account.md:9
msgid "To check your current Scarb version, run:"
msgstr ""

#: src/ch04-02-hello-account.md:15
msgid "To install or update Scarb, refer to the Basic Installation instructions in Chapter 2, covering macOS and Linux environments:"
msgstr ""

#: src/ch04-02-hello-account.md:21
#, fuzzy
msgid "## Starting a New Scarb Project"
msgstr "## 启动新的Starknet项目"

#: src/ch04-02-hello-account.md:23
msgid "Begin by creating a new project (more details in the Scarb subchapter in Chapter 2):"
msgstr ""

#: src/ch04-02-hello-account.md:25
msgid ""
"```bash\n"
"scarb new aa\n"
"```"
msgstr ""
"```bash\n"
"scarb new aa\n"
"```"

#: src/ch04-02-hello-account.md:29
msgid "Check the generated project structure:"
msgstr ""

#: src/ch04-02-hello-account.md:31
msgid ""
"```bash\n"
"$ tree .\n"
".\n"
"└── aa\n"
"    ├── Scarb.toml\n"
"    └── src\n"
"        └── lib.cairo\n"
"```"
msgstr ""
"```bash\n"
"$ tree .\n"
".\n"
"└── aa\n"
"    ├── Scarb.toml\n"
"    └── src\n"
"        └── lib.cairo\n"
"```"

#: src/ch04-02-hello-account.md:40
msgid "By default, Scarb sets up for vanilla Cairo. Add Starknet capacities by editing `Scarb.toml` to include the `starknet` dependency:"
msgstr ""

#: src/ch04-02-hello-account.md:42
msgid ""
"```bash\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.3.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"
msgstr ""
"```bash\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.3.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"

#: src/ch04-02-hello-account.md:56
msgid "Replace the code in `src/lib.cairo` with an account contract scaffold:"
msgstr ""

#: src/ch04-02-hello-account.md:58
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        public_key: felt252\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        public_key: felt252\n"
"    }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:69
msgid "To validate signatures, store the public key associated with the signer's private key."
msgstr ""

#: src/ch04-02-hello-account.md:71
msgid ""
"```rust\n"
"#[storage]\n"
"struct Storage {\n"
"    public_key: felt252\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[storage]\n"
"struct Storage {\n"
"    public_key: felt252\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:78
msgid "Compile your project to ensure the setup is correct:"
msgstr ""

#: src/ch04-02-hello-account.md:84
msgid "## Implementing SNIP-6 Standard"
msgstr ""

#: src/ch04-02-hello-account.md:86
msgid "To define an account contract, implement the `ISRC6` trait:"
msgstr ""

#: src/ch04-02-hello-account.md:88
msgid ""
"```rust\n"
"trait ISRC6 {\n"
"  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait ISRC6 {\n"
"  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:96
msgid ""
"The `#[external(v0)]` attribute marks functions with unique selectors for external interaction. The Starknet protocol exclusively uses `__execute__` and `__validate__`, whereas `is_valid_signature` "
"is available for web3 applications to validate signatures."
msgstr ""

#: src/ch04-02-hello-account.md:98
msgid ""
"The `trait IAccount<T>`\\*\\* with `#[starknet::interface]` attribute groups publicly accessible functions, like `is_valid_signature`. Functions `__execute__` and `__validate__`, though public, are "
"accessible only indirectly."
msgstr ""

#: src/ch04-02-hello-account.md:100
msgid ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::Call;\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl for super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 { ... }\n"
"  }\n"
"\n"
"  // These functions are protocol-specific and not intended for direct external use.\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl for ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 { ... }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::Call;\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl for super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 { ... }\n"
"  }\n"
"\n"
"  // These functions are protocol-specific and not intended for direct external use.\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl for ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 { ... }\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:132
msgid "## Restricted Function Access for Security"
msgstr ""

#: src/ch04-02-hello-account.md:134
msgid ""
"The `__execute__` and `__validate__` functions are designed for exclusive use by the Starknet protocol to enhance account security. Despite their public accessibility, only the Starknet protocol "
"can invoke these functions, identified by using the zero address."
msgstr ""

#: src/ch04-02-hello-account.md:136
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use starknet::get_caller_address;\n"
"  use zeroable::Zeroable;\n"
"\n"
"  // Enforces Starknet protocol-only access to specific functions\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Executes protocol-specific operations\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
"    }\n"
"\n"
"    // Validates protocol-specific operations\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol(); // Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
"    }\n"
"  }\n"
"\n"
"  // Defines a private function to check for protocol-level access\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    fn only_protocol(self: @ContractState) {\n"
"      // ... (access validation logic)\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use starknet::get_caller_address;\n"
"  use zeroable::Zeroable;\n"
"\n"
"  // Enforces Starknet protocol-only access to specific functions\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Executes protocol-specific operations\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
"    }\n"
"\n"
"    // Validates protocol-specific operations\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol(); // Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
"    }\n"
"  }\n"
"\n"
"  // Defines a private function to check for protocol-level access\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    fn only_protocol(self: @ContractState) {\n"
"      // ... (access validation logic)\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:169
msgid "## Enhanced Security Through Protocol-Exclusive Functions"
msgstr ""

#: src/ch04-02-hello-account.md:171
msgid ""
"Starknet enhances the security of accounts by restricting the callability of certain functions. The `__execute__` and `__validate__` functions, though publicly visible, are callable solely by the "
"Starknet protocol. This protocol asserts its unique calling rights by using a designated zero address—a special value that signifies protocol-level operations."
msgstr ""

#: src/ch04-02-hello-account.md:173
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use starknet::get_caller_address;\n"
"  use zeroable::Zeroable;\n"
"\n"
"  // Implements function access control for Starknet protocol\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function is a protocol-exclusive operation\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Validates the caller as the Starknet protocol\n"
"      // ... (execution logic)\n"
"    }\n"
"\n"
"    // The __validate__ function ensures the integrity of protocol-level calls\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol(); // Ensures the caller is the Starknet protocol\n"
"      // ... (validation logic)\n"
"    }\n"
"  }\n"
"\n"
"  // A private function, only_protocol, to enforce protocol-level access\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // only_protocol checks the caller's address against the zero address\n"
"    fn only_protocol(self: @ContractState) {\n"
"      // If the caller is not the zero address, access is denied\n"
"      // This guarantees that only the Starknet protocol can call the function\n"
"      // ... (access control logic)\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use starknet::get_caller_address;\n"
"  use zeroable::Zeroable;\n"
"\n"
"  // Implements function access control for Starknet protocol\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function is a protocol-exclusive operation\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Validates the caller as the Starknet protocol\n"
"      // ... (execution logic)\n"
"    }\n"
"\n"
"    // The __validate__ function ensures the integrity of protocol-level calls\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol(); // Ensures the caller is the Starknet protocol\n"
"      // ... (validation logic)\n"
"    }\n"
"  }\n"
"\n"
"  // A private function, only_protocol, to enforce protocol-level access\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // only_protocol checks the caller's address against the zero address\n"
"    fn only_protocol(self: @ContractState) {\n"
"      // If the caller is not the zero address, access is denied\n"
"      // This guarantees that only the Starknet protocol can call the function\n"
"      // ... (access control logic)\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:209
msgid "The `is_valid_signature` function, by contrast, is not bounded by `only_protocol`, maintaining its availability for broader use."
msgstr ""

#: src/ch04-02-hello-account.md:211
msgid "## Transaction Signature Validation"
msgstr ""

#: src/ch04-02-hello-account.md:213
msgid "To verify transaction signatures, the account contract stores the public key of the signer. The `constructor` method initializes this public key during the contract's deployment."
msgstr ""

#: src/ch04-02-hello-account.md:215
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Persistent storage for account-related data\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252  // Stores the public key for signature validation\n"
"  }\n"
"\n"
"  // Sets the public key during contract deployment\n"
"  #[constructor]\n"
"  fn constructor(ref self: ContractState, public_key: felt252) {\n"
"    self.public_key.write(public_key);  // Records the signer's public key\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Persistent storage for account-related data\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252  // Stores the public key for signature validation\n"
"  }\n"
"\n"
"  // Sets the public key during contract deployment\n"
"  #[constructor]\n"
"  fn constructor(ref self: ContractState, public_key: felt252) {\n"
"    self.public_key.write(public_key);  // Records the signer's public key\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:233
msgid ""
"The `is_valid_signature` function outputs `VALID` for an authentic signature and `0` for an invalid one. Additionally, the `is_valid_signature_bool` internal function provides a Boolean result for "
"the signature's validity."
msgstr ""

#: src/ch04-02-hello-account.md:235
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import relevant cryptographic and data handling modules\n"
"  use array::ArrayTrait;\n"
"  use ecdsa::check_ecdsa_signature;\n"
"  use array::SpanTrait;  // Facilitates the use of the span() method\n"
"\n"
"  // External function to validate the transaction signature\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
"      // Converts the signature array into a span for processing\n"
"      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
"      if is_valid { 'VALID' } else { 0 }  // Returns 'VALID' or '0' based on signature validity\n"
"    }\n"
"  }\n"
"\n"
"  // Private function to check the signature validity and return a Boolean\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Validates the signature using a span of elements\n"
"    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
"      // Checks if the signature has the correct length\n"
"      let is_valid_length = signature.len() == 2_u32;\n"
"\n"
"      // If the signature length is incorrect, returns false\n"
"      if !is_valid_length {\n"
"        return false;\n"
"      }\n"
"\n"
"      // Verifies the signature using the stored public key\n"
"      check_ecdsa_signature(\n"
"        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
"      )\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import relevant cryptographic and data handling modules\n"
"  use array::ArrayTrait;\n"
"  use ecdsa::check_ecdsa_signature;\n"
"  use array::SpanTrait;  // Facilitates the use of the span() method\n"
"\n"
"  // External function to validate the transaction signature\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
"      // Converts the signature array into a span for processing\n"
"      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
"      if is_valid { 'VALID' } else { 0 }  // Returns 'VALID' or '0' based on signature validity\n"
"    }\n"
"  }\n"
"\n"
"  // Private function to check the signature validity and return a Boolean\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Validates the signature using a span of elements\n"
"    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
"      // Checks if the signature has the correct length\n"
"      let is_valid_length = signature.len() == 2_u32;\n"
"\n"
"      // If the signature length is incorrect, returns false\n"
"      if !is_valid_length {\n"
"        return false;\n"
"      }\n"
"\n"
"      // Verifies the signature using the stored public key\n"
"      check_ecdsa_signature(\n"
"        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
"      )\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"\n"
"```"

#: src/ch04-02-hello-account.md:277
msgid "In the `__validate__` function, the `is_valid_signature_bool` method is utilized to confirm the integrity of transaction signatures."
msgstr ""

#: src/ch04-02-hello-account.md:279
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import modules for transaction information retrieval\n"
"  use box::BoxTrait;\n"
"  use starknet::get_tx_info;\n"
"\n"
"  // Protocol implementation for transaction validation\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Validates the signature of a transaction\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();  // Ensures protocol-only access\n"
"\n"
"      // Retrieves transaction information and unpacks it\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      // Validates the signature and asserts its correctness\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');  // Stops execution if the signature is invalid\n"
"      'VALID'  // Indicates a valid signature\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import modules for transaction information retrieval\n"
"  use box::BoxTrait;\n"
"  use starknet::get_tx_info;\n"
"\n"
"  // Protocol implementation for transaction validation\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Validates the signature of a transaction\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();  // Ensures protocol-only access\n"
"\n"
"      // Retrieves transaction information and unpacks it\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      // Validates the signature and asserts its correctness\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');  // Stops execution if the signature is invalid\n"
"      'VALID'  // Indicates a valid signature\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:309
msgid "## Unified Signature Validation for Contract Operations"
msgstr ""

#: src/ch04-02-hello-account.md:311
msgid ""
"The `__validate_declare__` function is responsible for validating the signature\n"
"of the `declare` function. On the other hand, `__validate_deploy__` facilitates\n"
"counterfactual deployment,a method to deploy an account contract without\n"
"associating it to a specific deployer address."
msgstr ""

#: src/ch04-02-hello-account.md:316
msgid ""
"To streamline the validation process, we'll unify the behavior of the three\n"
"validation functions `__validate__`,`__validate_declare__` and `__validate_deploy__`.\n"
"The core logic from `__validate__` is abstracted to `validate_transaction` private\n"
"function, which is then invoked by the other two validation functions."
msgstr ""

#: src/ch04-02-hello-account.md:321
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Protocol implementation for the account contract\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"\n"
"    // Validates general contract function calls\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      self.validate_transaction()  // Centralized validation logic\n"
"    }\n"
"\n"
"    // Validates the 'declare' function signature\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      self.validate_transaction()  // Reuses the validation logic\n"
"    }\n"
"\n"
"    // Validates counterfactual contract deployment\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      // Even though public_key is provided, it uses the one stored from the constructor\n"
"      self.validate_transaction()  // Applies the same validation logic\n"
"    }\n"
"  }\n"
"\n"
"  // Private trait implementation that contains shared validation logic\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Abstracted core logic for validating transactions\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();  // Extracts transaction information\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      // Validates the transaction signature using an internal boolean function\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');  // Ensures signature correctness\n"
"      'VALID'  // Returns 'VALID' if the signature checks out\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Protocol implementation for the account contract\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"\n"
"    // Validates general contract function calls\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      self.validate_transaction()  // Centralized validation logic\n"
"    }\n"
"\n"
"    // Validates the 'declare' function signature\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      self.validate_transaction()  // Reuses the validation logic\n"
"    }\n"
"\n"
"    // Validates counterfactual contract deployment\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      // Even though public_key is provided, it uses the one stored from the constructor\n"
"      self.validate_transaction()  // Applies the same validation logic\n"
"    }\n"
"  }\n"
"\n"
"  // Private trait implementation that contains shared validation logic\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Abstracted core logic for validating transactions\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();  // Extracts transaction information\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      // Validates the transaction signature using an internal boolean function\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');  // Ensures signature correctness\n"
"      'VALID'  // Returns 'VALID' if the signature checks out\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:367
msgid ""
"It's important to note that the `__validate_deploy__` function receives the public key\n"
"as an argument. While this key is captured during the constructor phase before this function\n"
"is invoked, it remains crucial to provide it when initiating the transaction.\n"
"Alternatively, the public key can be directly utilized within the `__validate_deploy__` function,\n"
"bypassing the constructor."
msgstr ""

#: src/ch04-02-hello-account.md:373
#, fuzzy
msgid "## Efficient Multicall Transaction Execution"
msgstr "### 多重调用合约交互"

#: src/ch04-02-hello-account.md:375
msgid ""
"The `__execute__` function within the `Account` module of a Starknet contract is designed to process an array of `Call` structures. This multicall feature consolidates several user operations into "
"a single transaction, significantly improving the user experience by enabling batched operations."
msgstr ""

#: src/ch04-02-hello-account.md:377
msgid ""
"````rust\n"
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Protocol implementation to handle execution of calls\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function processes an array of calls\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Ensures Starknet protocol level access\n"
"      self.execute_multiple_calls(calls) // Invokes batch processing of calls\n"
"    }\n"
"    // ... Additional implementation details\n"
"  }\n"
"}\n"
"````"
msgstr ""
"````rust\n"
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Protocol implementation to handle execution of calls\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function processes an array of calls\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Ensures Starknet protocol level access\n"
"      self.execute_multiple_calls(calls) // Invokes batch processing of calls\n"
"    }\n"
"    // ... Additional implementation details\n"
"  }\n"
"}\n"
"````"

#: src/ch04-02-hello-account.md:395
msgid "Each `Call` represents the details required for executing a single operation by the smart contract:"
msgstr ""

#: src/ch04-02-hello-account.md:397
msgid ""
"```rust\n"
"// Data structure encapsulating a contract call\n"
"#[derive(Drop, Serde)]\n"
"struct Call {\n"
"  to: ContractAddress,       // The target contract address\n"
"  selector: felt252,         // The function selector\n"
"  calldata: Array<felt252>   // The parameters for the function call\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Data structure encapsulating a contract call\n"
"#[derive(Drop, Serde)]\n"
"struct Call {\n"
"  to: ContractAddress,       // The target contract address\n"
"  selector: felt252,         // The function selector\n"
"  calldata: Array<felt252>   // The parameters for the function call\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:407
msgid "The contract defines a private function `execute_single_call` to handle individual calls. It utilizes the `call_contract_syscall` to directly invoke a function on another contract:"
msgstr ""

#: src/ch04-02-hello-account.md:409
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import syscall for contract function invocation\n"
"  use starknet::call_contract_syscall;\n"
"\n"
"  // Private trait implementation for individual call execution\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Executes a single call to another contract\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call; // Destructures the Call struct\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap_syscall() // Performs the contract call\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import syscall for contract function invocation\n"
"  use starknet::call_contract_syscall;\n"
"\n"
"  // Private trait implementation for individual call execution\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Executes a single call to another contract\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call; // Destructures the Call struct\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap_syscall() // Performs the contract call\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:428
msgid "For the execution of multiple calls, `execute_multiple_calls` iterates over the array of Call structures, invoking `execute_single_call` for each and collecting the responses:"
msgstr ""

#: src/ch04-02-hello-account.md:430
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Private trait implementation for batch call execution\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Handles an array of calls and accumulates the results\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new(); // Initializes the result array\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let response = self.execute_single_call(call); // Executes each call individually\n"
"            res.append(response); // Appends the result of the call to the result array\n"
"          },\n"
"          Option::None(_) => {\n"
"            break (); // Exits the loop when no more calls are left\n"
"          },\n"
"        };\n"
"      };\n"
"      res // Returns the array of results\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Private trait implementation for batch call execution\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Handles an array of calls and accumulates the results\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new(); // Initializes the result array\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let response = self.execute_single_call(call); // Executes each call individually\n"
"            res.append(response); // Appends the result of the call to the result array\n"
"          },\n"
"          Option::None(_) => {\n"
"            break (); // Exits the loop when no more calls are left\n"
"          },\n"
"        };\n"
"      };\n"
"      res // Returns the array of results\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:457
msgid ""
"In summary, the `__execute__` function orchestrates the execution of multiple calls within a single transaction. It leverages these internal functions to handle each call efficiently and return the "
"collective results:"
msgstr ""

#: src/ch04-02-hello-account.md:459
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // External function definition within the protocol implementation\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function takes an array of Call structures and processes them\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Verifies that the function caller is the Starknet protocol\n"
"      self.execute_multiple_calls(calls) // Delegates to a function for processing multiple calls\n"
"    }\n"
"    // ... Additional implementation details may follow\n"
"  }\n"
"  // ... Further module code may be present\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // External function definition within the protocol implementation\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function takes an array of Call structures and processes them\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Verifies that the function caller is the Starknet protocol\n"
"      self.execute_multiple_calls(calls) // Delegates to a function for processing multiple calls\n"
"    }\n"
"    // ... Additional implementation details may follow\n"
"  }\n"
"  // ... Further module code may be present\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:477
msgid ""
"The `__execute__` function first ensures that it is being called by the Starknet protocol itself, a security measure to prevent unauthorized access. It then calls the `execute_multiple_calls` "
"function to handle the actual execution of the calls."
msgstr ""

#: src/ch04-02-hello-account.md:479
msgid "## Ensuring Compatibility with Transaction Versioning"
msgstr ""

#: src/ch04-02-hello-account.md:481
msgid ""
"Starknet incorporates a versioning system for transactions to maintain backward compatibility while introducing new functionalities. The account contract tutorial showcases support for the latest "
"transaction versions through a specific module, ensuring smooth operation of both legacy and updated transaction structures."
msgstr ""

#: src/ch04-02-hello-account.md:483
msgid ""
"To accommodate the evolution of Starknet and its enhanced functionalities,\n"
"a versioning system was introduced for transactions. This ensures backward compatibility,\n"
"allowing both old and new transaction structures to operate concurrently."
msgstr ""

#: src/ch04-02-hello-account.md:487
msgid ""
"- Version 1 for `invoke` transactions\n"
"- Version 1 for `deploy_account` transactions\n"
"- Version 2 for `declare` transactions"
msgstr ""

#: src/ch04-02-hello-account.md:491
msgid "These supported versions are logically grouped in a module called `SUPPORTED_TX_VERSION`:"
msgstr ""

#: src/ch04-02-hello-account.md:493
msgid ""
"```rust\n"
"// Module defining supported transaction versions\n"
"mod SUPPORTED_TX_VERSION {\n"
"  // Constants representing the supported versions\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;  // Supported version for deploy_account transactions\n"
"  const DECLARE: felt252 = 2;         // Supported version for declare transactions\n"
"  const INVOKE: felt252 = 1;          // Supported version for invoke transactions\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // The rest of the account contract module code\n"
"  ...\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Module defining supported transaction versions\n"
"mod SUPPORTED_TX_VERSION {\n"
"  // Constants representing the supported versions\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;  // Supported version for deploy_account transactions\n"
"  const DECLARE: felt252 = 2;         // Supported version for declare transactions\n"
"  const INVOKE: felt252 = 1;          // Supported version for invoke transactions\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // The rest of the account contract module code\n"
"  ...\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:509
msgid ""
"To handle the version checking, the account contract includes a private function `only_supported_tx_version`. This function compares the version of an incoming transaction against the specified "
"supported versions, halting execution with an error if a discrepancy is found."
msgstr ""

#: src/ch04-02-hello-account.md:511
msgid "The critical contract functions such as `__execute__`, `__validate__`, `__validate_declare__`, and `__validate_deploy__` implement this version check to confirm transaction compatibility."
msgstr ""

#: src/ch04-02-hello-account.md:513
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Importing constants from the SUPPORTED_TX_VERSION module\n"
"  use super::SUPPORTED_TX_VERSION;\n"
"\n"
"  // Protocol implementation for Starknet functions\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Function to execute multiple calls with version check\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Checks if the function caller is the Starknet protocol\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE); // Ensures the transaction is the supported version\n"
"      self.execute_multiple_calls(calls) // Processes the calls if version check passes\n"
"    }\n"
"\n"
"    // Each of the following functions also includes the version check to ensure compatibility\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  // Private implementation for checking supported transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to assert the transaction version is supported\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves transaction details\n"
"      let version = tx_info.version; // Extracts the version from the transaction\n"
"      assert(\n"
"        version == supported_tx_version,\n"
"        'Account: Unsupported tx version' // Error message for unsupported versions\n"
"      );\n"
"    }\n"
"    // ... Additional private functions\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Importing constants from the SUPPORTED_TX_VERSION module\n"
"  use super::SUPPORTED_TX_VERSION;\n"
"\n"
"  // Protocol implementation for Starknet functions\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Function to execute multiple calls with version check\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Checks if the function caller is the Starknet protocol\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE); // Ensures the transaction is the supported version\n"
"      self.execute_multiple_calls(calls) // Processes the calls if version check passes\n"
"    }\n"
"\n"
"    // Each of the following functions also includes the version check to ensure compatibility\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  // Private implementation for checking supported transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to assert the transaction version is supported\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves transaction details\n"
"      let version = tx_info.version; // Extracts the version from the transaction\n"
"      assert(\n"
"        version == supported_tx_version,\n"
"        'Account: Unsupported tx version' // Error message for unsupported versions\n"
"      );\n"
"    }\n"
"    // ... Additional private functions\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:567
msgid ""
"By integrating transaction version control, the contract ensures it operates consistently with the network's current standards, providing a clear path for upgrading and maintaining compatibility "
"with Starknet's evolving ecosystem."
msgstr ""

#: src/ch04-02-hello-account.md:569
#, fuzzy
msgid "## Handling Simulated Transactions"
msgstr "## 跟踪交易"

#: src/ch04-02-hello-account.md:571
msgid ""
"Starknet's simulation feature allows developers to estimate the gas cost of transactions without actually committing them to the network. This is particularly useful during development and testing "
"phases. The `estimate-only` flag available in tools like Starkli triggers the simulation process. To differentiate between actual transaction execution and simulation, Starknet uses a version "
"offset strategy."
msgstr ""

#: src/ch04-02-hello-account.md:573
msgid ""
"Simulated transactions are assigned a version number that is the sum of \\(2^{128}\\) and the version number of the actual transaction type. For example, if the latest version of a `declare` "
"transaction is 2, then a simulated `declare` transaction would have a version number of \\(2^{128} + 2\\). The same logic applies to other transaction types like `invoke` and `deploy_account`."
msgstr ""

#: src/ch04-02-hello-account.md:575
msgid "Here's how the `only_supported_tx_version` function is adjusted to accommodate both actual and simulated transaction versions:"
msgstr ""

#: src/ch04-02-hello-account.md:577
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant representing the version offset for simulated transactions\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // This is 2^128\n"
"\n"
"  // Private trait implementation updated to validate transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to check for supported transaction versions, accounting for simulations\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves the transaction metadata\n"
"      let version = tx_info.version; // Extracts the version for comparison\n"
"\n"
"      // Validates whether the transaction version matches either the supported actual version or the simulated version\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version' // Assertion message for version mismatch\n"
"      );\n"
"    }\n"
"    // Additional private functions may follow\n"
"  }\n"
"  // Remaining contract code may continue here\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant representing the version offset for simulated transactions\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // This is 2^128\n"
"\n"
"  // Private trait implementation updated to validate transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to check for supported transaction versions, accounting for simulations\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves the transaction metadata\n"
"      let version = tx_info.version; // Extracts the version for comparison\n"
"\n"
"      // Validates whether the transaction version matches either the supported actual version or the simulated version\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version' // Assertion message for version mismatch\n"
"      );\n"
"    }\n"
"    // Additional private functions may follow\n"
"  }\n"
"  // Remaining contract code may continue here\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:604
msgid ""
"The code snippet showcases the account contract's capability to recognize and process both actual and simulated versions of transactions by incorporating the large numerical offset. This ensures "
"that the system can seamlessly operate with and adjust to the estimation process without affecting the actual transaction processing logic."
msgstr ""

#: src/ch04-02-hello-account.md:606
#, fuzzy
msgid "## SRC-5 Standard and Contract Introspection"
msgstr "## 合约交互"

#: src/ch04-02-hello-account.md:608
msgid ""
"Contract introspection is a feature that allows Starknet contracts to self-report the interfaces they support, in compliance with the SRC-5 standard. The `supports_interface` function is a "
"fundamental part of this introspection process, enabling contracts to communicate their capabilities to others."
msgstr ""

#: src/ch04-02-hello-account.md:610
msgid ""
"For a contract to be SRC-5 compliant, it must return `true` when the `supports_interface` function is called with a specific `interface_id`. This unique identifier is chosen to represent the SRC-6 "
"standard's interface, which the contract claims to support. The identifier is a large integer specifically chosen to minimize the chance of accidental collisions with other identifiers."
msgstr ""

#: src/ch04-02-hello-account.md:612
msgid "In the account contract, the `supports_interface` function is part of the public interface, allowing other contracts to query its support for the SRC-6 standard:"
msgstr ""

#: src/ch04-02-hello-account.md:614
msgid ""
"```rust\n"
"// SRC-5 trait defining the introspection method\n"
"trait ISRC5 {\n"
"  // Function to check interface support\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// Extension of the account contract's interface for SRC-5 compliance\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  // ... Additional methods\n"
"  // Method to validate interface support\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant identifier for the SRC-6 trait\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  // Public interface implementation for the account contract\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    // ... Other function implementations\n"
"    // Implementation of the interface support check\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      // Compares the provided interface ID with the SRC-6 trait ID\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  // ... Additional account contract code\n"
"}\n"
"// SRC-5 trait defining the introspection method\n"
"trait ISRC5 {\n"
"  // Function to check interface support\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// Extension of the account contract's interface for SRC-5 compliance\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  // ... Additional methods\n"
"  // Method to validate interface support\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant identifier for the SRC-6 trait\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  // Public interface implementation for the account contract\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    // ... Other function implementations\n"
"    // Implementation of the interface support check\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      // Compares the provided interface ID with the SRC-6 trait ID\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  // ... Additional account contract code\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// SRC-5 trait defining the introspection method\n"
"trait ISRC5 {\n"
"  // Function to check interface support\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// Extension of the account contract's interface for SRC-5 compliance\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  // ... Additional methods\n"
"  // Method to validate interface support\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant identifier for the SRC-6 trait\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  // Public interface implementation for the account contract\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    // ... Other function implementations\n"
"    // Implementation of the interface support check\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      // Compares the provided interface ID with the SRC-6 trait ID\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  // ... Additional account contract code\n"
"}\n"
"// SRC-5 trait defining the introspection method\n"
"trait ISRC5 {\n"
"  // Function to check interface support\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// Extension of the account contract's interface for SRC-5 compliance\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  // ... Additional methods\n"
"  // Method to validate interface support\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant identifier for the SRC-6 trait\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  // Public interface implementation for the account contract\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    // ... Other function implementations\n"
"    // Implementation of the interface support check\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      // Compares the provided interface ID with the SRC-6 trait ID\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  // ... Additional account contract code\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:679
msgid ""
"By implementing this function, the account contract declares its ability to interact with other contracts expecting SRC-6 features, thus adhering to the standards of the Starknet protocol and "
"enhancing interoperability within the network."
msgstr ""

#: src/ch04-02-hello-account.md:681
msgid "## Public Key Accessibility"
msgstr ""

#: src/ch04-02-hello-account.md:683
msgid ""
"For enhanced transparency and debugging purposes, it's recommended to make the public key\n"
"of the account contract's signer accessible. This allows users to verify the correct deployment\n"
"of the account contract by comparing the stored public key with the signer's public key offline."
msgstr ""

#: src/ch04-02-hello-account.md:687
msgid ""
"```rust\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    ...\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    ...\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:704
#, fuzzy
msgid "## Final Implementation"
msgstr "### 费用计算"

#: src/ch04-02-hello-account.md:706
msgid "We now have a fully functional account contract. Here's the final implementation;"
msgstr ""

#: src/ch04-02-hello-account.md:708
msgid ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"mod SUPPORTED_TX_VERSION {\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;\n"
"  const DECLARE: felt252 = 2;\n"
"  const INVOKE: felt252 = 1;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"  fn public_key(self: @T) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::{Call, IAccount, SUPPORTED_TX_VERSION};\n"
"  use starknet::{get_caller_address, call_contract_syscall, get_tx_info, VALIDATED};\n"
"  use zeroable::Zeroable;\n"
"  use array::{ArrayTrait, SpanTrait};\n"
"  use ecdsa::check_ecdsa_signature;\n"
"  use box::BoxTrait;\n"
"\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[constructor]\n"
"  fn constructor(ref self: ContractState, public_key: felt252) {\n"
"    self.public_key.write(public_key);\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
"      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
"      if is_valid { VALIDATED } else { 0 }\n"
"    }\n"
"\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.execute_multiple_calls(calls)\n"
"    }\n"
"\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    fn only_protocol(self: @ContractState) {\n"
"      let sender = get_caller_address();\n"
"      assert(sender.is_zero(), 'Account: invalid caller');\n"
"    }\n"
"\n"
"    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
"      let is_valid_length = signature.len() == 2_u32;\n"
"\n"
"      if !is_valid_length {\n"
"        return false;\n"
"      }\n"
"\n"
"      check_ecdsa_signature(\n"
"        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
"      )\n"
"    }\n"
"\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');\n"
"      VALIDATED\n"
"    }\n"
"\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call;\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap()\n"
"    }\n"
"\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new();\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let _res = self.execute_single_call(call);\n"
"            res.append(_res);\n"
"          },\n"
"          Option::None(_) => {\n"
"            break ();\n"
"          },\n"
"        };\n"
"      };\n"
"      res\n"
"    }\n"
"\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let version = tx_info.version;\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version'\n"
"      );\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"mod SUPPORTED_TX_VERSION {\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;\n"
"  const DECLARE: felt252 = 2;\n"
"  const INVOKE: felt252 = 1;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"  fn public_key(self: @T) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::{Call, IAccount, SUPPORTED_TX_VERSION};\n"
"  use starknet::{get_caller_address, call_contract_syscall, get_tx_info, VALIDATED};\n"
"  use zeroable::Zeroable;\n"
"  use array::{ArrayTrait, SpanTrait};\n"
"  use ecdsa::check_ecdsa_signature;\n"
"  use box::BoxTrait;\n"
"\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[constructor]\n"
"  fn constructor(ref self: ContractState, public_key: felt252) {\n"
"    self.public_key.write(public_key);\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
"      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
"      if is_valid { VALIDATED } else { 0 }\n"
"    }\n"
"\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.execute_multiple_calls(calls)\n"
"    }\n"
"\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    fn only_protocol(self: @ContractState) {\n"
"      let sender = get_caller_address();\n"
"      assert(sender.is_zero(), 'Account: invalid caller');\n"
"    }\n"
"\n"
"    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
"      let is_valid_length = signature.len() == 2_u32;\n"
"\n"
"      if !is_valid_length {\n"
"        return false;\n"
"      }\n"
"\n"
"      check_ecdsa_signature(\n"
"        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
"      )\n"
"    }\n"
"\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');\n"
"      VALIDATED\n"
"    }\n"
"\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call;\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap()\n"
"    }\n"
"\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new();\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let _res = self.execute_single_call(call);\n"
"            res.append(_res);\n"
"          },\n"
"          Option::None(_) => {\n"
"            break ();\n"
"          },\n"
"        };\n"
"      };\n"
"      res\n"
"    }\n"
"\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let version = tx_info.version;\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version'\n"
"      );\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/ch04-02-hello-account.md:853
#, fuzzy
msgid "## Account Contract Creation Summary"
msgstr "4: 账户抽象"

#: src/ch04-02-hello-account.md:855
msgid ""
"- **SNIP-6 Implementation**\n"
"\n"
"  - Implements the `ISRC6` trait, defining the account contract's structure.\n"
"\n"
"- **Protocol-Only Function Access**\n"
"\n"
"  - Restricts `__validate__` and `__execute__` to StarkNet protocol access.\n"
"  - Makes `is_valid_signature` available for external calls.\n"
"  - Adds a `only_protocol` private function to enforce access rules.\n"
"\n"
"- **Signature Validation Process**\n"
"\n"
"  - Stores a public key to verify the signer's transactions.\n"
"  - Initializes with a `constructor` to set the public key.\n"
"  - Validates signatures with `is_valid_signature`, returning `VALID` or `0`.\n"
"  - Uses `is_valid_signature_bool` to return a true or false validation result.\n"
"\n"
"- **Declare and Deploy Function Validation**\n"
"\n"
"  - Sets up `__validate_declare__` to check the `declare` function's signature.\n"
"  - Designs `__validate_deploy__` for counterfactual deployments.\n"
"  - Abstracts core validation to `validate_transaction`.\n"
"\n"
"- **Transaction Execution Logic**\n"
"\n"
"  - Enables multicall capability with `__execute__`.\n"
"  - Handles calls individually with `execute_single_call` and in batches with `execute_multiple_calls`.\n"
"\n"
"- **Transaction Version Compatibility**\n"
"\n"
"  - Ensures compatibility with StarkNet updates using a versioning system.\n"
"  - Defines supported transaction types in `SUPPORTED_TX_VERSION`.\n"
"  - Checks transaction versions with `only_supported_tx_version`.\n"
"\n"
"- **Simulated Transaction Handling**\n"
"\n"
"  - Adapts `only_supported_tx_version` to recognize both actual and simulated versions.\n"
"\n"
"- **Contract Self-Identification**\n"
"\n"
"  - Allows self-identification with the SRC-5 standard via `supports_interface`.\n"
"\n"
"- **Public Key Visibility**\n"
"\n"
"  - Provides public key access for transparency.\n"
"\n"
"- **Complete Implementation**\n"
"  - Presents the final account contract code."
msgstr ""

#: src/ch04-02-hello-account.md:904
msgid "Next, we will deploy the account using Starkli to the testnet and interact with other smart contracts."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:1
#, fuzzy
msgid "# Deploying Account Contracts"
msgstr "### 部署合约"

#: src/ch04-03-deploy-hello-account.md:3
msgid "After building our account contract, we'll now deploy it using Starkli on the testnet and interact with other contracts."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:5
msgid ""
"Ensure you've installed [starkli](https://github.com/xJonathanLEI/starkli) and [scarb](https://docs.swmansion.com/scarb/download.html). Review the Basic Installation subchapter in Chapter 2 if you "
"haven't."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:7
#, fuzzy
msgid "## Account Contract Configuration Files"
msgstr "## 合约交互"

#: src/ch04-03-deploy-hello-account.md:9
msgid "Starkli requires two key configuration files:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:11
msgid ""
"- `keystore.json`: A secure file that holds the private key.\n"
"- `account.json`: An open file with the account's public details like public key, class hash, and address."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:14
msgid "Optionally, Starkli can use:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:16
msgid "- `envars.sh`: A script to set environment variables for Starkli commands."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:18
msgid "For multiple wallets, keep a clean directory structure. Each wallet should have its own folder with the three files inside. Group these under a `~/.starkli-wallets` directory."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:20
msgid "Here's a suggested structure:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:22
msgid ""
"```bash\n"
"tree ~/.starkli-wallets\n"
"\n"
".starkli-wallets\n"
"├── wallet-a\n"
"│   ├── account.json\n"
"│   ├── envars.sh\n"
"│   └── keystore.json\n"
"└── wallet-b\n"
"    ├── account.json\n"
"    ├── envars.sh\n"
"    └── keystore.json\n"
"```"
msgstr ""
"```bash\n"
"tree ~/.starkli-wallets\n"
"\n"
".starkli-wallets\n"
"├── wallet-a\n"
"│   ├── account.json\n"
"│   ├── envars.sh\n"
"│   └── keystore.json\n"
"└── wallet-b\n"
"    ├── account.json\n"
"    ├── envars.sh\n"
"    └── keystore.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:36
msgid "This setup promotes better organization."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:38
msgid "We'll make a custom folder in `.starkli-wallets` for our contract wallet:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:40
msgid ""
"```bash\n"
"mkdir ~/.starkli-wallets/custom\n"
"```"
msgstr ""
"```bash\n"
"mkdir ~/.starkli-wallets/custom\n"
"```"

#: src/ch04-03-deploy-hello-account.md:44
msgid "Next, we use Starkli to create `keystore.json` and `account.json`, then write `envars.sh` by hand."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:46
msgid "## Creating the Keystore File with Starkli"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:48
msgid "Starkli simplifies creating a `keystore.json` file. This encrypted file holds your private key and sits in the `custom` directory. You can create this with one command:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:50
msgid ""
"```bash\n"
"starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
"```"
msgstr ""
"```bash\n"
"starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:54
msgid "When you run this, you'll enter a password to secure the file. The resulting `keystore.json` is essential for setting up the `envars.sh` file, which stores environment variables."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:56
msgid "Create `envars.sh` like this:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:58
msgid ""
"```bash\n"
"touch ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"touch ~/.starkli-wallets/custom/envars.sh\n"
"```"

#: src/ch04-03-deploy-hello-account.md:62
msgid "Open the file and insert:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:64
msgid ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"```"
msgstr ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:69
msgid "Activate the variable by sourcing the file:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:71 src/ch04-03-deploy-hello-account.md:170 src/ch04-03-deploy-hello-account.md:236
msgid ""
"```bash\n"
"source ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"source ~/.starkli-wallets/custom/envars.sh\n"
"```"

#: src/ch04-03-deploy-hello-account.md:75
msgid "Now, your environment is ready for the next step: creating the `account.json` file."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:77
#, fuzzy
msgid "## Generating the Account Configuration File"
msgstr "## 与合约交互"

#: src/ch04-03-deploy-hello-account.md:79
msgid ""
"Our account contract's signature validation mirrors that in [Open Zeppelin's default account contract](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.7.0-rc.0/src/account/account."
"cairo), using a single signer and a STARK-compatible elliptic curve. Despite building our contract independently, we'll use Starkli's command for Open Zeppelin accounts to create our configuration:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:81
msgid ""
"```bash\n"
"starkli account oz init ~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"starkli account oz init ~/.starkli-wallets/custom/account.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:85
msgid ""
"After entering your keystore password, `account.json` is created. This file includes a class hash for OpenZeppelin's contract, not ours. Since the class hash influences the deployment address, the "
"shown address won't match our contract."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:87
#, fuzzy
msgid "Here's what account.json looks like:"
msgstr "下面是一个典型的描述符："

#: src/ch04-03-deploy-hello-account.md:89
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"open_zeppelin\",\n"
"    \"version\": 1,\n"
"    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
"    \"legacy\": false\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"undeployed\",\n"
"    \"class_hash\": \"0x4c6d6cf894f8bc96bb9c525e6853e5483177841f7388f74a46cfda6f028c755\",\n"
"    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"open_zeppelin\",\n"
"    \"version\": 1,\n"
"    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
"    \"legacy\": false\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"undeployed\",\n"
"    \"class_hash\": \"0x4c6d6cf894f8bc96bb9c525e6853e5483177841f7388f74a46cfda6f028c755\",\n"
"    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
"  }\n"
"}\n"
"```"

#: src/ch04-03-deploy-hello-account.md:106
msgid "To deploy our unique contract, we must compile our project to obtain the correct class hash and update `account.json` accordingly."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:108
#, fuzzy
msgid "## Finding the Class Hash"
msgstr "## 撰写测试 "

#: src/ch04-03-deploy-hello-account.md:110
msgid "Previously, we set up a `aa` directory for our account contract's Cairo code. If you don't have it, clone the repository:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:112
msgid ""
"```bash\n"
"git clone git@github.com:starknet-edu/aa-workshop.git aa\n"
"```"
msgstr ""
"```bash\n"
"git clone git@github.com:starknet-edu/aa-workshop.git aa\n"
"```"

#: src/ch04-03-deploy-hello-account.md:116
msgid "To compile the contract with Scarb, enter the project directory:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:118
msgid ""
"```bash\n"
"cd aa\n"
"scarb build\n"
"```"
msgstr ""
"```bash\n"
"cd aa\n"
"scarb build\n"
"```"

#: src/ch04-03-deploy-hello-account.md:123
msgid "The compiled contract lies in `target/dev`. Use Starkli to get the class hash:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:125
msgid ""
"```bash\n"
"starkli class-hash target/dev/aa_Account.sierra.json\n"
"```"
msgstr ""
"```bash\n"
"starkli class-hash target/dev/aa_Account.sierra.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:129
msgid "Next, edit `account.json` to insert the correct class hash:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:131
msgid ""
"```bash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:135
msgid "Ensure the `class_hash` is updated:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:137
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"open_zeppelin\",\n"
"    \"version\": 1,\n"
"    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
"    \"legacy\": false\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"undeployed\",\n"
"    \"class_hash\": \"0x03480253c19b447b1d7e7a6422acf80b73866522de03126fa55796a712d9f092\",\n"
"    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"open_zeppelin\",\n"
"    \"version\": 1,\n"
"    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
"    \"legacy\": false\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"undeployed\",\n"
"    \"class_hash\": \"0x03480253c19b447b1d7e7a6422acf80b73866522de03126fa55796a712d9f092\",\n"
"    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
"  }\n"
"}\n"
"```"

#: src/ch04-03-deploy-hello-account.md:154
msgid "To point to the updated `account.json`, modify `envars.sh`:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:156
msgid ""
"```bash\n"
"code ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"code ~/.starkli-wallets/custom/envars.sh\n"
"```"

#: src/ch04-03-deploy-hello-account.md:160
msgid "Add the account path:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:162
msgid ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:168
msgid "Source `envars.sh` to apply the changes:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:174
#, fuzzy
msgid "Now, we're ready to declare the contract on the testnet."
msgstr "当设置完成后，您就可以将智能合约部署到Starknet测试网络了。"

#: src/ch04-03-deploy-hello-account.md:176
#, fuzzy
msgid "## Establishing an RPC Provider"
msgstr "### 选择 RPC 提供商"

#: src/ch04-03-deploy-hello-account.md:178
msgid ""
"For transactions on Starknet, an RPC provider is essential. This guide uses [Alchemy](https://www.alchemy.com/), but [Infura](https://www.infura.io/) or a personal node are viable alternatives."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:180
msgid "Steps for Alchemy or Infura:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:182
msgid ""
"- Create an account.\n"
"- Start a new project for Starknet Goerli.\n"
"- Obtain the RPC URL.\n"
"- Add this URL to `envars.sh`:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:187
msgid ""
"```bash\n"
"aa $ code ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"aa $ code ~/.starkli-wallets/custom/envars.sh\n"
"```"

#: src/ch04-03-deploy-hello-account.md:191
#, fuzzy
msgid "The file should now include:"
msgstr "Prover 的职责包括"

#: src/ch04-03-deploy-hello-account.md:193
msgid ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
"```"
msgstr ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
"```"

#: src/ch04-03-deploy-hello-account.md:200
msgid "Replace `your-api-key` with the actual API key provided by Alchemy."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:202
#, fuzzy
msgid "## Declaring the Account Contract"
msgstr "### 声明合约"

#: src/ch04-03-deploy-hello-account.md:204
msgid ""
"You'll need a funded account to pay gas fees. Configure Starkli with a [Braavos](https://braavos.app/) or [Argent X](https://www.argent.xyz/argent-x/) wallet as the deployer. Instructions are "
"available [here](https://medium.com/starknet-edu/starkli-the-new-starknet-cli-86ea914a2933)."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:206
#, fuzzy
msgid "After setting up, your Starkli wallet structure will be:"
msgstr "创建项目后，您可以发现其结构如下："

#: src/ch04-03-deploy-hello-account.md:208
msgid ""
"```bash\n"
"tree .\n"
"\n"
".\n"
"├── custom\n"
"│   ├── account.json\n"
"│   ├── envars.sh\n"
"│   └── keystore.json\n"
"└── deployer\n"
"    ├── account.json\n"
"    ├── envars.sh\n"
"    └── keystore.json\n"
"```"
msgstr ""
"```bash\n"
"tree .\n"
"\n"
".\n"
"├── custom\n"
"│   ├── account.json\n"
"│   ├── envars.sh\n"
"│   └── keystore.json\n"
"└── deployer\n"
"    ├── account.json\n"
"    ├── envars.sh\n"
"    └── keystore.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:222
msgid "Source the deployer's environment file in the `aa` directory to use it:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:224
msgid ""
"```bash\n"
"source ~/.starkli-wallets/deployer/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"source ~/.starkli-wallets/deployer/envars.sh\n"
"```"

#: src/ch04-03-deploy-hello-account.md:228
msgid "Declare the contract with the deployer covering gas:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:230
msgid ""
"```bash\n"
"starkli declare target/dev/aa_Account.sierra.json\n"
"```"
msgstr ""
"```bash\n"
"starkli declare target/dev/aa_Account.sierra.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:234
msgid "After reaching \"Accepted on L2,\" status (less than a minute) switch back to the account's environment:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:240
msgid "Deploy the account with Starkli:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:242
msgid ""
"```bash\n"
"starkli account deploy ~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"starkli account deploy ~/.starkli-wallets/custom/account.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:246
msgid "Starkli will wait for you to fund the address displayed with at least the estimated fee from Starknet's [faucet](https://faucet.goerli.starknet.io/)."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:248
msgid "Once funded, press **`ENTER`** to deploy:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:250
msgid ""
"```bash\n"
"...\n"
"Deployment transaction confirmed\n"
"```"
msgstr ""
"```bash\n"
"...\n"
"Deployment transaction confirmed\n"
"```"

#: src/ch04-03-deploy-hello-account.md:255
msgid "Your account contract is now live on the Starknet testnet."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:257
#, fuzzy
msgid "## Using the Account Contract"
msgstr "### 声明合约"

#: src/ch04-03-deploy-hello-account.md:259
msgid "To test our account contract, we can send 100 gwei to the wallet `0x070a...52d1` by calling the `transfer` function of the WETH smart contract on Starknet's testnet."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:261
msgid "Invoke the transfer with Starkli (more details on Starkli's in Chapter 2):"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:263
msgid ""
"```bash\n"
"starkli invoke eth transfer 0x070a012... u256:100\n"
"```"
msgstr ""
"```bash\n"
"starkli invoke eth transfer 0x070a012... u256:100\n"
"```"

#: src/ch04-03-deploy-hello-account.md:267
msgid "A successful invoke confirms that our account contract has authenticated the signature, executed the transfer, and managed the gas fees."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:269
msgid "Here's a summary of all the steps from declaration to interaction:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:271
msgid ""
"```bash\n"
"# Quick Guide: Declare, Deploy, and Interact with a Custom Account Contract\n"
"\n"
"# [1] Set up environment variables in envars.sh\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
"\n"
"# [2] Generate keystore.json\n"
"starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
"\n"
"# [3] Initialize account.json\n"
"starkli account oz init ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [4] Build the contract with Scarb\n"
"scarb build\n"
"\n"
"# [5] Get the class hash\n"
"starkli class-hash target/dev/aa_Account.sierra.json\n"
"\n"
"# [6] Update account.json with the real class hash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [7] Set deployer wallet environment\n"
"source ~/.starkli-wallets/deployer/envars.sh\n"
"\n"
"# [8] Declare the contract using the deployer\n"
"starkli declare target/dev/aa_Account.sierra.json\n"
"\n"
"# [9] Switch to the custom wallet\n"
"source ~/.starkli-wallets/custom/envars.sh\n"
"\n"
"# [10] Deploy the contract\n"
"starkli account deploy ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [11] Test the contract by transferring ETH\n"
"starkli invoke eth transfer 0x070a012... u256:100\n"
"\n"
"# [bonus] Recommended directory structure\n"
".\n"
"├── account.json\n"
"├── envars.sh\n"
"└── keystore.json\n"
"```"
msgstr ""
"```bash\n"
"# Quick Guide: Declare, Deploy, and Interact with a Custom Account Contract\n"
"\n"
"# [1] Set up environment variables in envars.sh\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
"\n"
"# [2] Generate keystore.json\n"
"starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
"\n"
"# [3] Initialize account.json\n"
"starkli account oz init ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [4] Build the contract with Scarb\n"
"scarb build\n"
"\n"
"# [5] Get the class hash\n"
"starkli class-hash target/dev/aa_Account.sierra.json\n"
"\n"
"# [6] Update account.json with the real class hash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [7] Set deployer wallet environment\n"
"source ~/.starkli-wallets/deployer/envars.sh\n"
"\n"
"# [8] Declare the contract using the deployer\n"
"starkli declare target/dev/aa_Account.sierra.json\n"
"\n"
"# [9] Switch to the custom wallet\n"
"source ~/.starkli-wallets/custom/envars.sh\n"
"\n"
"# [10] Deploy the contract\n"
"starkli account deploy ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [11] Test the contract by transferring ETH\n"
"starkli invoke eth transfer 0x070a012... u256:100\n"
"\n"
"# [bonus] Recommended directory structure\n"
".\n"
"├── account.json\n"
"├── envars.sh\n"
"└── keystore.json\n"
"```"

#: src/ch04-03-deploy-hello-account.md:316 src/ch04-04-standard-account.md:363
msgid "## Summary"
msgstr "## 总结"

#: src/ch04-03-deploy-hello-account.md:318
msgid "We've successfully deployed and used our custom account contract on Starknet with Starkli. Here's what we accomplished:"
msgstr ""

#: src/ch04-03-deploy-hello-account.md:320
msgid ""
"- Set environment variables in `envars.sh`.\n"
"- Created `keystore.json` to securely store the private key.\n"
"- Initialized `account.json` as the account descriptor file.\n"
"- Used Braavos smart wallet to set up the deployer environment.\n"
"- Declared and deployed our account contract to the Starknet testnet.\n"
"- Conducted a transfer to another wallet."
msgstr ""

#: src/ch04-03-deploy-hello-account.md:327
msgid ""
"We matched the Open Zeppelin's contract in terms of signature methods for the `constructor` and `__declare_deploy__` functions, which allowed us to use Starkli's Open Zeppelin preset. Should there "
"be a need for signature modification, Starknet JS SDK would be the tool of choice."
msgstr ""

#: src/ch04-04-standard-account.md:1
msgid "# Standard Account Contract"
msgstr ""

#: src/ch04-04-standard-account.md:3 src/ch04-05-01-multicaller.md:3 src/ch04-05-02-multisig.md:3
msgid ""
"**NOTE:**\n"
"**THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS NOTE IS REMOVED.**"
msgstr ""

#: src/ch04-04-standard-account.md:6 src/ch04-05-01-multicaller.md:6 src/ch04-05-02-multisig.md:6
msgid "**CONTRIBUTE: This subchapter is missing an example of declaration, deployment and interaction with the contract. We would love to see your contribution! Please submit a PR.**"
msgstr ""

#: src/ch04-04-standard-account.md:8
msgid ""
"In this chapter, we build upon our exploration of account contracts in\n"
"Starknet by introducing a more complex account contract. This Standard\n"
"Account Contract includes additional features such as signature\n"
"validation, providing a more robust example of an account contract in\n"
"Cairo language. You can find the full code for this contract in the Book\n"
"repository (todo: add link). You can interact and compile the contract\n"
"using Scarb (review the Scarb subchapter in Chapter 2 of the Book for\n"
"more information)."
msgstr ""

#: src/ch04-04-standard-account.md:17
msgid ""
"```rust\n"
"    // Import necessary modules and traits\n"
"    use serde::Serde;\n"
"    use starknet::ContractAddress;\n"
"    use array::ArrayTrait;\n"
"    use array::SpanTrait;\n"
"    use option::OptionTrait;\n"
"\n"
"    // Define the Account contract\n"
"    #[account_contract]\n"
"    mod Account {\n"
"        use array::ArrayTrait;\n"
"        use array::SpanTrait;\n"
"        use box::BoxTrait;\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use option::OptionTrait;\n"
"        use super::Call;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use serde::ArraySerde;\n"
"\n"
"        // Define the contract's storage variables\n"
"        struct Storage {\n"
"            public_key: felt252\n"
"        }\n"
"\n"
"        // Constructor function for initializing the contract\n"
"        #[constructor]\n"
"        fn constructor(public_key_: felt252) {\n"
"            public_key::write(public_key_);\n"
"        }\n"
"\n"
"        // Internal function to validate the transaction signature\n"
"        fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"\n"
"        // Validate contract deployment\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract declaration\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract execution\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array<felt252>\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Execute a contract call\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"\n"
"    // Define the Call struct\n"
"    #[derive(Drop, Serde)]\n"
"    struct Call {\n"
"        to: ContractAddress,\n"
"        selector: felt252,\n"
"        calldata: Array<felt252>\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    // Import necessary modules and traits\n"
"    use serde::Serde;\n"
"    use starknet::ContractAddress;\n"
"    use array::ArrayTrait;\n"
"    use array::SpanTrait;\n"
"    use option::OptionTrait;\n"
"\n"
"    // Define the Account contract\n"
"    #[account_contract]\n"
"    mod Account {\n"
"        use array::ArrayTrait;\n"
"        use array::SpanTrait;\n"
"        use box::BoxTrait;\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use option::OptionTrait;\n"
"        use super::Call;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use serde::ArraySerde;\n"
"\n"
"        // Define the contract's storage variables\n"
"        struct Storage {\n"
"            public_key: felt252\n"
"        }\n"
"\n"
"        // Constructor function for initializing the contract\n"
"        #[constructor]\n"
"        fn constructor(public_key_: felt252) {\n"
"            public_key::write(public_key_);\n"
"        }\n"
"\n"
"        // Internal function to validate the transaction signature\n"
"        fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"\n"
"        // Validate contract deployment\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract declaration\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract execution\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array<felt252>\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Execute a contract call\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"\n"
"    // Define the Call struct\n"
"    #[derive(Drop, Serde)]\n"
"    struct Call {\n"
"        to: ContractAddress,\n"
"        selector: felt252,\n"
"        calldata: Array<felt252>\n"
"    }\n"
"```"

#: src/ch04-04-standard-account.md:120
msgid "## Grasping ECDSA Signature"
msgstr ""

#: src/ch04-04-standard-account.md:122
msgid ""
"Elliptic Curve Digital Signature Algorithm (ECDSA) is a cryptographic\n"
"protocol extensively utilized across various blockchains to ensure data\n"
"integrity and verify the sender’s authenticity. As a variant of the\n"
"Digital Signature Algorithm (DSA), ECDSA leverages elliptic curve\n"
"cryptography, offering superior security with shorter keys than the\n"
"traditional DSA."
msgstr ""

#: src/ch04-04-standard-account.md:129
msgid ""
"An ECDSA signature comprises two components, commonly referred to as _r_\n"
"and _s_. These two values, generated using the signer’s private key and\n"
"the hash of the message (or transaction) being signed, collectively form\n"
"the signature for a given input."
msgstr ""

#: src/ch04-04-standard-account.md:134
msgid "### Deciphering signature_r and signature_s"
msgstr ""

#: src/ch04-04-standard-account.md:136
msgid ""
"Within the context of the Standard Account Contract, _signature_r_ and\n"
"_signature_s_ represent the two constituents of the ECDSA signature.\n"
"These are utilized in the _check_ecdsa_signature_ function to\n"
"authenticate the transaction’s legitimacy."
msgstr ""

#: src/ch04-04-standard-account.md:141
msgid ""
"- `signature_r (r)`: A random number generated during the signing\n"
"  process, unique for each signature. Reusing _r_ across different\n"
"  messages may lead to private key exposure.\n"
"\n"
"- `signature_s (s)`: This is computed using _r_, the private key, and\n"
"  the hash of the message. Like _r_, _s_ is also unique for each\n"
"  signature."
msgstr ""

#: src/ch04-04-standard-account.md:149
msgid ""
"The function _check_ecdsa_signature_ takes these two values, the\n"
"public key of the signer, and the hash of the message to authenticate\n"
"the signature. A valid signature indicates that the message was indeed\n"
"signed by the private key owner and remains unaltered."
msgstr ""

#: src/ch04-04-standard-account.md:154
msgid ""
"```rust\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"```"
msgstr ""
"```rust\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"```"

#: src/ch04-04-standard-account.md:166
msgid ""
"The above code snippet employs _check_ecdsa_signature_ function to\n"
"assert the legitimacy of the transaction signature. If the signature is\n"
"not valid, the assertion fails, returning _INVALID_SIGNATURE_."
msgstr ""

#: src/ch04-04-standard-account.md:170
msgid "## Contract Anatomy"
msgstr ""

#: src/ch04-04-standard-account.md:172
#, fuzzy
msgid "### Storage"
msgstr "**存储**:"

#: src/ch04-04-standard-account.md:174
msgid ""
"In the standard account contract, we declare a single storage variable:\n"
"_public_key_. This assists in transaction signature validation. The\n"
"public key, stored as a _felt252_ (a 252-bit unsigned integer), is\n"
"written to the storage in the constructor function and is accessed from\n"
"the storage in the _validate_transaction_ function."
msgstr ""

#: src/ch04-04-standard-account.md:180
msgid ""
"```rust\n"
"    struct Storage {\n"
"        public_key: felt252\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    struct Storage {\n"
"        public_key: felt252\n"
"    }\n"
"```"

#: src/ch04-04-standard-account.md:186
#, fuzzy
msgid "### Constructor"
msgstr "**构造函数**："

#: src/ch04-04-standard-account.md:188
msgid ""
"The constructor function serves to initialize the contract, storing the\n"
"supplied public key in the contract’s storage."
msgstr ""

#: src/ch04-04-standard-account.md:191
msgid ""
"```rust\n"
"    #[constructor]\n"
"    fn constructor(public_key_: felt252) {\n"
"        public_key::write(public_key_);\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[constructor]\n"
"    fn constructor(public_key_: felt252) {\n"
"        public_key::write(public_key_);\n"
"    }\n"
"```"

#: src/ch04-04-standard-account.md:198
msgid "### `validate_transaction`"
msgstr ""

#: src/ch04-04-standard-account.md:200
msgid ""
"This internal function validates the transaction signature. It retrieves\n"
"the signature from the transaction info, checks its length, and verifies\n"
"the ECDSA signature. If the signature is legitimate, it returns\n"
"starknet::VALIDATED, otherwise an error. This function is invoked by\n"
"**validate_deploy**, **validate_declare**, and **validate** functions."
msgstr ""

#: src/ch04-04-standard-account.md:206
msgid ""
"The inclusion of this function is optional. If transaction signature\n"
"validation is not required, it can be omitted. However, its inclusion in\n"
"your account contract is advised to ensure transaction validity and to\n"
"facilitate its reuse in all three validation functions."
msgstr ""

#: src/ch04-04-standard-account.md:211
msgid ""
"```rust\n"
"    fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"```"
msgstr ""
"```rust\n"
"    fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"```"

#: src/ch04-04-standard-account.md:232
msgid "### Call Struct"
msgstr ""

#: src/ch04-04-standard-account.md:234
msgid ""
"The Call struct outlines the parameters required for a contract call.\n"
"These parameters comprise the target contract address (to), the function\n"
"to be called (selector), and the function’s arguments (calldata). The\n"
"Call struct is utilized in the _execute_ function."
msgstr ""

#: src/ch04-04-standard-account.md:239
msgid ""
"```rust\n"
"    #[derive(Drop, Serde)]\n"
"    struct Call {\n"
"        to: ContractAddress,\n"
"        selector: felt252,\n"
"        calldata: Array<felt252>\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[derive(Drop, Serde)]\n"
"    struct Call {\n"
"        to: ContractAddress,\n"
"        selector: felt252,\n"
"        calldata: Array<felt252>\n"
"    }\n"
"```"

#: src/ch04-04-standard-account.md:248
#, fuzzy
msgid "### execute"
msgstr "执行"

#: src/ch04-04-standard-account.md:250
msgid ""
"This external function triggers a transaction post successful\n"
"validation. It ensures the caller’s validity, checks for a non-zero\n"
"transaction version, and supports only single calls. Post validation, it\n"
"forwards the call to the target contract. The contract creator can\n"
"incorporate multiple calls to different contracts or the same contract\n"
"(multicall) within this function. The function returns the output from\n"
"the target contract."
msgstr ""

#: src/ch04-04-standard-account.md:258
msgid ""
"```rust\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"
msgstr ""
"```rust\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"

#: src/ch04-04-standard-account.md:278
msgid "## Improvements to the Standard Account Contract"
msgstr ""

#: src/ch04-04-standard-account.md:280
msgid ""
"The implementation of the Standard Account Contract has a few\n"
"limitations:"
msgstr ""

#: src/ch04-04-standard-account.md:283
msgid ""
"- It currently supports only single calls. We could support multicalls\n"
"  to improve the flexibility and utility of the contract.\n"
"\n"
"- The ECDSA signature algorithm, while secure, can be computationally\n"
"  intensive. Future versions could explore using more efficient\n"
"  signature algorithms, such as Schnorr or BLS. Or quantum-resistant\n"
"  signature algorithms, such as the STARKs."
msgstr ""

#: src/ch04-04-standard-account.md:291
msgid ""
"Despite these limitations, the Standard Account Contract provides a\n"
"robust and secure foundation for creating and interacting with smart\n"
"contracts on Starknet."
msgstr ""

#: src/ch04-04-standard-account.md:295
msgid "## Declaring and Deploying the Hello World Account Contract"
msgstr ""

#: src/ch04-04-standard-account.md:297
msgid ""
"This time we have a constructor function that takes the public key as an\n"
"argument. We need to generate a private key with the corresponding\n"
"public key."
msgstr ""

#: src/ch04-04-standard-account.md:301
msgid "TODO: add section on how to generate a private key and public key."
msgstr ""

#: src/ch04-04-standard-account.md:303
msgid "- Export the required environment variables:"
msgstr ""

#: src/ch04-04-standard-account.md:307
msgid ""
"export STARKNET_NETWORK=alpha-goerli\n"
"    export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount"
msgstr ""

#: src/ch04-04-standard-account.md:310
msgid ""
"- Declare the contract (since the contract is already declared, you\n"
"  can skip this step. If you want to declare it anyway, run the\n"
"  following command but you will receive an error):"
msgstr ""

#: src/ch04-04-standard-account.md:316
msgid "starknet declare --contract target/release/starknetbook_chapter_7_Account.json --account vote_admin --max_fee 100000000000000000"
msgstr ""

#: src/ch04-04-standard-account.md:318
msgid ""
"The class hash is:\n"
"0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1"
msgstr ""

#: src/ch04-04-standard-account.md:321
msgid "- Deploy the contract:"
msgstr ""

#: src/ch04-04-standard-account.md:323
msgid "TODO: add section on how to deploy the contract."
msgstr ""

#: src/ch04-04-standard-account.md:325
msgid ""
"Elliptic Curve Digital Signature Algorithm (ECDSA) is a popular choice\n"
"for ensuring data integrity and sender authenticity in blockchain\n"
"networks, but it’s not the only option. Other alternatives include:"
msgstr ""

#: src/ch04-04-standard-account.md:329
msgid ""
"- EdDSA (Edwards-curve Digital Signature Algorithm): EdDSA is another\n"
"  form of elliptic curve cryptography that is designed to be faster\n"
"  and more secure than ECDSA. EdDSA uses twisted Edwards curves, which\n"
"  have strong security properties and allow for more efficient\n"
"  computations. An example of EdDSA in use is Monero.\n"
"\n"
"- Schnorr Signatures: Schnorr signatures offer a level of security\n"
"  similar to ECDSA but with shorter signatures. They have the\n"
"  additional property of being linear, which allows for signature\n"
"  aggregation and multi-signatures. This can lead to increased\n"
"  efficiency and privacy. Bitcoin developers have proposed adding\n"
"  Schnorr signatures to the Bitcoin protocol with the Taproot upgrade.\n"
"\n"
"- RSA (Rivest–Shamir–Adleman): RSA is an older cryptographic algorithm\n"
"  that is widely used for secure data transmission. However, RSA\n"
"  requires larger key sizes for equivalent security levels, making it\n"
"  less efficient than elliptic curve techniques. RSA is not commonly\n"
"  used in modern blockchain systems, but it is still used in many\n"
"  traditional secure communication protocols.\n"
"\n"
"- BLS (Boneh-Lynn-Shacham) Signatures: BLS signatures, like Schnorr,\n"
"  allow for signature aggregation, making them useful in systems that\n"
"  require a large number of signatures. This property makes BLS\n"
"  signatures particularly useful for consensus algorithms in\n"
"  distributed systems and blockchains, such as Ethereum 2.0.\n"
"\n"
"- Post-Quantum Cryptography: With the advent of quantum computing,\n"
"  researchers are developing new cryptographic algorithms that are\n"
"  resistant to quantum attacks. One example are the STARKs used in\n"
"  Starknet."
msgstr ""

#: src/ch04-04-standard-account.md:360
msgid ""
"Each of these alternatives has its strengths and weaknesses in terms of\n"
"security, efficiency, complexity, and mathematical properties."
msgstr ""

#: src/ch04-04-standard-account.md:365
msgid ""
"In this chapter, we expanded on our understanding of account contracts\n"
"in Starknet by examining a more complex \"Standard Account Contract\". We\n"
"dove into the various components of the contract and learned how they\n"
"work together to validate and execute transactions."
msgstr ""

#: src/ch04-05-examples.md:3
msgid ""
"Here, we will explore numerous examples, elucidating the principles and\n"
"techniques to effectively design and implement Account contracts."
msgstr ""

#: src/ch04-05-examples.md:6
msgid ""
"Before delving into the examples, we would like to issue a disclaimer:\n"
"the contracts discussed in this chapter are for illustrative and\n"
"educational purposes, and they have not undergone formal auditing. This\n"
"signifies that, while we strive to provide accurate and informative\n"
"content, the implementation of these contracts in a live environment\n"
"should be approached with due diligence. We encourage users to\n"
"thoroughly test and validate these contracts before their deployment on\n"
"the mainnet."
msgstr ""

#: src/ch04-05-examples.md:15
msgid ""
"The goal of this chapter is not only to furnish a library of contract\n"
"examples but also to foster collaboration and knowledge sharing among\n"
"the Starknet community. We believe that the exchange of ideas and\n"
"constructive feedback is instrumental in advancing our collective\n"
"understanding and expertise."
msgstr ""

#: src/ch04-05-examples.md:21
msgid ""
"If you’ve developed or come across an innovative contract that could\n"
"serve as a valuable learning resource for others, we invite you to\n"
"contribute. Here are a few guidelines for your contribution:"
msgstr ""

#: src/ch04-05-examples.md:25
msgid ""
"1.  **Open a PR:** To submit a contract example or suggest changes to\n"
"    existing ones, simply open a Pull Request. Ensure that your PR\n"
"    contains a thorough explanation of the contract, its use cases, and\n"
"    its functionality.\n"
"\n"
"2.  **Code Standards:** Please ensure that the submitted code is\n"
"    well-documented and adheres to the standard code conventions of\n"
"    Starknet. This will facilitate the review process and enhance the\n"
"    readability and comprehensibility of the contract.\n"
"\n"
"3.  **Detailed Explanation:** Accompany your code with a detailed\n"
"    explanation of the contract logic. Wherever possible, use diagrams,\n"
"    flowcharts, or pseudocode to illustrate complex mechanisms or\n"
"    workflows."
msgstr ""

#: src/ch04-05-examples.md:40
msgid ""
"As we expand this repertoire of contract examples, we hope to equip the\n"
"Starknet community with a robust toolset and inspire further exploration\n"
"and innovation in the realm of custom account contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:1
msgid "# MultiCaller Account"
msgstr ""

#: src/ch04-05-01-multicaller.md:8
msgid ""
"[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme)\n"
"is a powerful technique that allows multiple constant smart contract\n"
"function calls to be aggregated into a single call, resulting in a\n"
"consolidated output. With Starknet’s account abstraction feature,\n"
"multicalls can be seamlessly integrated into account contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:14
msgid "## Why Multicalls?"
msgstr ""

#: src/ch04-05-01-multicaller.md:16
msgid "Multicalls come handy in several scenarios. Here are some examples:"
msgstr ""

#: src/ch04-05-01-multicaller.md:18
msgid ""
"1.  **Token Swapping on Decentralized Exchanges**: In a typical token\n"
"    swap operation on a decentralized exchange (DEX), you first need to\n"
"    approve the spending of the tokens and then initiate the swap.\n"
"    Executing these operations separately could be cumbersome from a\n"
"    user experience perspective. With multicall, these calls can be\n"
"    combined into a single transaction, simplifying the user’s task.\n"
"\n"
"2.  **Fetching Blockchain Data**: When you want to query the prices of\n"
"    two different tokens from the blockchain, it’s beneficial to have\n"
"    them both come from the same block for consistency. Multicall\n"
"    returns the latest block number along with the aggregated results,\n"
"    providing this consistency."
msgstr ""

#: src/ch04-05-01-multicaller.md:31
msgid ""
"The benefits of multicall transactions can be realized more in the\n"
"context of account abstraction."
msgstr ""

#: src/ch04-05-01-multicaller.md:34
msgid "## Multicall Functionality in Account Contracts"
msgstr ""

#: src/ch04-05-01-multicaller.md:36
msgid ""
"To facilitate multicalls, we can introduce specific functions in the\n"
"account contract. Here are two core functions:"
msgstr ""

#: src/ch04-05-01-multicaller.md:39
msgid "### `_execute_calls` Function"
msgstr ""

#: src/ch04-05-01-multicaller.md:41
msgid ""
"The `_execute_calls` function is responsible for executing the\n"
"multicalls. It iterates over an array of calls, executes them, and\n"
"aggregates the results."
msgstr ""

#: src/ch04-05-01-multicaller.md:45
msgid ""
"```rust\n"
"    fn _execute_calls(mut calls: Array<AccountCall>, mut res:Array::<Array::<felt>>) -> Array::<Array::<felt>> {\n"
"        match calls.pop_front() {\n"
"            Option::Some(call) => {\n"
"                let _res = _call_contract(call);\n"
"                res.append(_res);\n"
"                return _execute_calls(calls, res);\n"
"            },\n"
"            Option::None(_) => {\n"
"                return res;\n"
"            },\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn _execute_calls(mut calls: Array<AccountCall>, mut res:Array::<Array::<felt>>) -> Array::<Array::<felt>> {\n"
"        match calls.pop_front() {\n"
"            Option::Some(call) => {\n"
"                let _res = _call_contract(call);\n"
"                res.append(_res);\n"
"                return _execute_calls(calls, res);\n"
"            },\n"
"            Option::None(_) => {\n"
"                return res;\n"
"            },\n"
"        }\n"
"    }\n"
"```"

#: src/ch04-05-01-multicaller.md:60
msgid ""
"Apart from the traditional **`execute`** function, adding the\n"
"**`_execute_calls`** function to your account contract can ensure that\n"
"you can make a multicall using your smart contract account."
msgstr ""

#: src/ch04-05-01-multicaller.md:64
msgid ""
"The above code is a simple example snippet where the **\"return\n"
"_execute_calls(calls, res);\"_ statement makes recursive calls to the\n"
"**`_execute_calls`** function thereby bundling the calls together.\n"
"The final result will be aggregated and returned in the \\***res\\*\\*\\*\n"
"variable."
msgstr ""

#: src/ch04-05-01-multicaller.md:70
msgid "### `_call_contract` Function"
msgstr ""

#: src/ch04-05-01-multicaller.md:72
msgid ""
"The `_call_contract` function is a helper function used to make\n"
"individual contract calls."
msgstr ""

#: src/ch04-05-01-multicaller.md:75
msgid ""
"```rust\n"
"    fn _call_contract(call: AccountCall) -> Array::<felt> {\n"
"        starknet::call_contract_syscall(\n"
"            call.to, call.selector, call.calldata\n"
"        ).unwrap_syscall()\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn _call_contract(call: AccountCall) -> Array::<felt> {\n"
"        starknet::call_contract_syscall(\n"
"            call.to, call.selector, call.calldata\n"
"        ).unwrap_syscall()\n"
"    }\n"
"```"

#: src/ch04-05-01-multicaller.md:85
msgid ""
"While multicall provides significant benefits in terms of UX and data\n"
"consistency, it’s important to note that it may not significantly reduce\n"
"gas fees compared to individual calls. However, the primary advantage of\n"
"using multicall is that it ensures results are derived from the same\n"
"block, providing a much-improved user experience."
msgstr ""

#: src/ch04-05-02-multisig.md:1
msgid "# Multi-Signature Accounts"
msgstr ""

#: src/ch04-05-02-multisig.md:8
msgid ""
"Multisignature (multisig) technology is an integral part of the modern\n"
"blockchain landscape. It enhances security by requiring multiple\n"
"signatures to confirm a transaction, hence reducing the risk of\n"
"fraudulent transactions and increasing control over asset management."
msgstr ""

#: src/ch04-05-02-multisig.md:13
msgid ""
"In Starknet, the concept of multisig accounts is abstracted at the\n"
"protocol level, allowing developers to implement custom account\n"
"contracts that embody this concept. In this chapter, we’ll delve into\n"
"the workings of a multisig account and see how it’s created in Starknet\n"
"using an account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:19
msgid "## What is a Multisig Account?"
msgstr ""

#: src/ch04-05-02-multisig.md:21
msgid ""
"A multisig account is an account that requires more than one signature\n"
"to authorize transactions. This significantly enhances security,\n"
"requiring multiple entities' consent to transact funds or perform\n"
"critical actions."
msgstr ""

#: src/ch04-05-02-multisig.md:26
msgid "Key specifications of a multisig account include:"
msgstr ""

#: src/ch04-05-02-multisig.md:28
msgid ""
"- Public keys that form the account\n"
"\n"
"- Threshold number of signatures required"
msgstr ""

#: src/ch04-05-02-multisig.md:32
msgid ""
"A transaction signed by a multisig account must be individually signed\n"
"by the different keys specified for the account. If fewer than the\n"
"threshold number of signatures needed are present, the resultant\n"
"multisignature is considered invalid."
msgstr ""

#: src/ch04-05-02-multisig.md:37
msgid ""
"In Starknet, accounts are abstractions provided at the protocol level.\n"
"Therefore, to create a multisig account, one needs to code the logic\n"
"into an account contract and deploy it."
msgstr ""

#: src/ch04-05-02-multisig.md:41
msgid ""
"The contract below serves as an example of a multisig account contract.\n"
"When deployed, it can create a native multisig account using the concept\n"
"of account abstraction. Please note that this is a simplified example\n"
"and lacks comprehensive checks and validations found in a\n"
"production-grade multisig contract."
msgstr ""

#: src/ch04-05-02-multisig.md:47
msgid "## Multisig Account Contract"
msgstr ""

#: src/ch04-05-02-multisig.md:49
msgid "This is the Rust code for a multisig account contract:"
msgstr ""

#: src/ch04-05-02-multisig.md:51
msgid ""
"```rust\n"
"    #[account_contract]\n"
"    mod MultisigAccount {\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use array::ArrayTrait;\n"
"        use starknet::get_caller_address;\n"
"        use box::BoxTrait;\n"
"        use array::SpanTrait;\n"
"\n"
"        struct Storage {\n"
"            index_to_owner: LegacyMap::<u32, felt252>,\n"
"            owner_to_index: LegacyMap::<felt252, u32>,\n"
"            num_owners: usize,\n"
"            threshold: usize,\n"
"            curr_tx_index: felt252,\n"
"            //Mapping between tx_index and num of confirmations\n"
"            tx_confirms: LegacyMap<felt252, usize>,\n"
"            //Mapping between tx_index and its execution state\n"
"            tx_is_executed: LegacyMap<felt252, bool>,\n"
"            //Mapping between a transaction index and its hash\n"
"            transactions: LegacyMap<felt252, felt252>,\n"
"            has_confirmed: LegacyMap::<(ContractAddress, felt252), bool>,\n"
"        }\n"
"\n"
"        #[constructor]\n"
"        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
"            assert(public_keys.len() <= 3_usize, 'public_keys.len <= 3');\n"
"            num_owners::write(public_keys.len());\n"
"            threshold::write(_threshold);\n"
"            _set_owners(public_keys.len(), public_keys);\n"
"        }\n"
"\n"
"        //GETTERS\n"
"        //Get number of confirmations for a given transaction index\n"
"        #[view]\n"
"        fn get_confirmations(tx_index : felt252) -> usize {\n"
"            tx_confirms::read(tx_index)\n"
"        }\n"
"\n"
"        //Get the number of owners of this account\n"
"        #[view]\n"
"        fn get_num_owners() -> usize {\n"
"            num_owners::read()\n"
"        }\n"
"\n"
"\n"
"        //Get the public key of the owners\n"
"        //TODO - Recursively add the owners into an array and return, maybe wait for loops to be enabled\n"
"\n"
"\n"
"        //EXTERNAL FUNCTIONS\n"
"\n"
"        #[external]\n"
"        fn submit_tx(public_key: felt252) {\n"
"\n"
"            //Need to check if caller is one of the owners.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //Updating the transaction index\n"
"            let tx_index = curr_tx_index::read();\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            transactions::write(tx_index, tx_info.transaction_hash);\n"
"            curr_tx_index::write(tx_index + 1);\n"
"\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"\n"
"\n"
"        }\n"
"\n"
"        //An example function to validate that there are at least two signatures\n"
"        fn validate_transaction(public_key: felt252) -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        //INTERNAL FUNCTION\n"
"        //Function to add the public keys of the multisig in permanent storage\n"
"        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"            if owners_len == 0_usize {\n"
"            }\n"
"\n"
"            index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
"            owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
"            _set_owners(owners_len - 1_u32, public_keys);\n"
"        }\n"
"\n"
"\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[account_contract]\n"
"    mod MultisigAccount {\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use array::ArrayTrait;\n"
"        use starknet::get_caller_address;\n"
"        use box::BoxTrait;\n"
"        use array::SpanTrait;\n"
"\n"
"        struct Storage {\n"
"            index_to_owner: LegacyMap::<u32, felt252>,\n"
"            owner_to_index: LegacyMap::<felt252, u32>,\n"
"            num_owners: usize,\n"
"            threshold: usize,\n"
"            curr_tx_index: felt252,\n"
"            //Mapping between tx_index and num of confirmations\n"
"            tx_confirms: LegacyMap<felt252, usize>,\n"
"            //Mapping between tx_index and its execution state\n"
"            tx_is_executed: LegacyMap<felt252, bool>,\n"
"            //Mapping between a transaction index and its hash\n"
"            transactions: LegacyMap<felt252, felt252>,\n"
"            has_confirmed: LegacyMap::<(ContractAddress, felt252), bool>,\n"
"        }\n"
"\n"
"        #[constructor]\n"
"        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
"            assert(public_keys.len() <= 3_usize, 'public_keys.len <= 3');\n"
"            num_owners::write(public_keys.len());\n"
"            threshold::write(_threshold);\n"
"            _set_owners(public_keys.len(), public_keys);\n"
"        }\n"
"\n"
"        //GETTERS\n"
"        //Get number of confirmations for a given transaction index\n"
"        #[view]\n"
"        fn get_confirmations(tx_index : felt252) -> usize {\n"
"            tx_confirms::read(tx_index)\n"
"        }\n"
"\n"
"        //Get the number of owners of this account\n"
"        #[view]\n"
"        fn get_num_owners() -> usize {\n"
"            num_owners::read()\n"
"        }\n"
"\n"
"\n"
"        //Get the public key of the owners\n"
"        //TODO - Recursively add the owners into an array and return, maybe wait for loops to be enabled\n"
"\n"
"\n"
"        //EXTERNAL FUNCTIONS\n"
"\n"
"        #[external]\n"
"        fn submit_tx(public_key: felt252) {\n"
"\n"
"            //Need to check if caller is one of the owners.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //Updating the transaction index\n"
"            let tx_index = curr_tx_index::read();\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            transactions::write(tx_index, tx_info.transaction_hash);\n"
"            curr_tx_index::write(tx_index + 1);\n"
"\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"\n"
"\n"
"        }\n"
"\n"
"        //An example function to validate that there are at least two signatures\n"
"        fn validate_transaction(public_key: felt252) -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        //INTERNAL FUNCTION\n"
"        //Function to add the public keys of the multisig in permanent storage\n"
"        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"            if owners_len == 0_usize {\n"
"            }\n"
"\n"
"            index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
"            owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
"            _set_owners(owners_len - 1_u32, public_keys);\n"
"        }\n"
"\n"
"\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"

#: src/ch04-05-02-multisig.md:248
msgid "## Multisig Transaction Flow"
msgstr ""

#: src/ch04-05-02-multisig.md:250
msgid "The flow of a multisig transaction includes the following steps:"
msgstr ""

#: src/ch04-05-02-multisig.md:252
msgid ""
"1.  Submitting a transaction: Any of the owners can submit a transaction\n"
"    from the account.\n"
"\n"
"2.  Confirming the transaction: The owner who hasn’t submitted a\n"
"    transaction can confirm the transaction."
msgstr ""

#: src/ch04-05-02-multisig.md:258
msgid ""
"The transaction will be successfully executed if the number of\n"
"confirmations (including the submitter’s signature) is greater than or\n"
"equal to the threshold number of signatures, else it fails. This\n"
"mechanism of confirmation ensures that no single party can unilaterally\n"
"perform critical actions, thereby enhancing the security of the account."
msgstr ""

#: src/ch04-05-02-multisig.md:264
msgid "## Exploring Multisig Functions"
msgstr ""

#: src/ch04-05-02-multisig.md:266
msgid ""
"Let’s take a closer look at the various functions associated with\n"
"multisig functionality in the provided contract."
msgstr ""

#: src/ch04-05-02-multisig.md:269
msgid "### `_set_owners` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:271
msgid ""
"This is an internal function designed to add the public keys of the\n"
"account owners to a permanent storage. Ideally, a multisig account\n"
"structure should permit adding and deleting owners as per the agreement\n"
"of the account owners. However, each change should be a transaction\n"
"requiring the threshold number of signatures."
msgstr ""

#: src/ch04-05-02-multisig.md:277
msgid ""
"```rust\n"
"    //INTERNAL FUNCTION\n"
"    //Function to add the public keys of the multisig in permanent storage\n"
"    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"        if owners_len == 0_usize {\n"
"        }\n"
"\n"
"        index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
"        owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
"        _set_owners(owners_len - 1_u32, public_keys);\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    //INTERNAL FUNCTION\n"
"    //Function to add the public keys of the multisig in permanent storage\n"
"    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"        if owners_len == 0_usize {\n"
"        }\n"
"\n"
"        index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
"        owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
"        _set_owners(owners_len - 1_u32, public_keys);\n"
"    }\n"
"```"

#: src/ch04-05-02-multisig.md:290
msgid "### `submit_tx` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:292
msgid ""
"This external function allows the owners of the account to submit\n"
"transactions. Upon submission, the function checks the validity of the\n"
"transaction, ensures the caller is one of the account owners, and adds\n"
"the transaction to the transactions map. It also increments the current\n"
"transaction index."
msgstr ""

#: src/ch04-05-02-multisig.md:298
msgid ""
"```rust\n"
"    #[external]\n"
"    fn submit_tx(public_key: felt252) {\n"
"\n"
"        //Need to check if caller is one of the owners.\n"
"        let tx_info = starknet::get_tx_info().unbox();\n"
"        let signature: Span<felt252> = tx_info.signature;\n"
"        let caller = get_caller_address();\n"
"        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"        //Updating the transaction index\n"
"        let tx_index = curr_tx_index::read();\n"
"\n"
"        //`true` if a signature is valid and `false` otherwise.\n"
"        assert(\n"
"            check_ecdsa_signature(\n"
"                message_hash: tx_info.transaction_hash,\n"
"                public_key: public_key,\n"
"                signature_r: *signature.at(0_u32),\n"
"                signature_s: *signature.at(1_u32),\n"
"            ),\n"
"            'INVALID_SIGNATURE',\n"
"        );\n"
"\n"
"        transactions::write(tx_index, tx_info.transaction_hash);\n"
"        curr_tx_index::write(tx_index + 1);\n"
"\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[external]\n"
"    fn submit_tx(public_key: felt252) {\n"
"\n"
"        //Need to check if caller is one of the owners.\n"
"        let tx_info = starknet::get_tx_info().unbox();\n"
"        let signature: Span<felt252> = tx_info.signature;\n"
"        let caller = get_caller_address();\n"
"        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"        //Updating the transaction index\n"
"        let tx_index = curr_tx_index::read();\n"
"\n"
"        //`true` if a signature is valid and `false` otherwise.\n"
"        assert(\n"
"            check_ecdsa_signature(\n"
"                message_hash: tx_info.transaction_hash,\n"
"                public_key: public_key,\n"
"                signature_r: *signature.at(0_u32),\n"
"                signature_s: *signature.at(1_u32),\n"
"            ),\n"
"            'INVALID_SIGNATURE',\n"
"        );\n"
"\n"
"        transactions::write(tx_index, tx_info.transaction_hash);\n"
"        curr_tx_index::write(tx_index + 1);\n"
"\n"
"    }\n"
"```"

#: src/ch04-05-02-multisig.md:328
msgid "### `confirm_tx` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:330
msgid ""
"Similarly, the **_`confirm_tx`_** function provides a way to record\n"
"confirmations for each transaction. An account owner, who did not submit\n"
"the transaction, can confirm it, increasing its confirmation count."
msgstr ""

#: src/ch04-05-02-multisig.md:334
msgid ""
"```rust\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"        }\n"
"```"
msgstr ""
"```rust\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"        }\n"
"```"

#: src/ch04-05-02-multisig.md:368
#, fuzzy
msgid "### _`execute`_ Function"
msgstr "#### 执行函数"

#: src/ch04-05-02-multisig.md:370
msgid ""
"The _execute_ function serves as the final step in the transaction\n"
"process. It checks the validity of the transaction, whether it has been\n"
"previously executed, and if the threshold number of signatures has been\n"
"reached. The transaction is executed if all the checks pass."
msgstr ""

#: src/ch04-05-02-multisig.md:375
msgid ""
"```rust\n"
"    #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"
msgstr ""
"```rust\n"
"    #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"

#: src/ch04-05-02-multisig.md:404
msgid "## Closing Thoughts"
msgstr ""

#: src/ch04-05-02-multisig.md:406
msgid ""
"This chapter has introduced you to the concept of multisig accounts in\n"
"Starknet and illustrated how they can be implemented using an account\n"
"contract. However, it’s important to note that this is a simplified\n"
"example, and a production-grade multisig contract should contain\n"
"additional checks and validations for robustness and security."
msgstr ""

#: src/ch04-05-03-auto-payments.md:1
#, fuzzy
msgid "# Auto-Payments 🚧"
msgstr "自动付款 🚧"

#: src/ch04-05-04-alternative-signature-schemes.md:1
#, fuzzy
msgid "# Alternative Signature Schemes 🚧"
msgstr "替代签名方案 🚧"

#~ msgid "Compile, Deploy, Interact"
#~ msgstr "编译、部署、交互"

#~ msgid "Starkli: A CLI interface 🚧"
#~ msgstr "Starkli：CLI 界面 🚧"

#~ msgid "Fee Mechanism 🚧"
#~ msgstr "费用机制 🚧"

#~ msgid "## Learning Resources"
#~ msgstr "## 学习资料"

#~ msgid "For deeper insights into Starknet and Cairo:"
#~ msgstr "更深入地了解Starknet和Cairo："

#~ msgid ""
#~ "- [The Starknet Book](https://book.starknet.io): For mastering\n"
#~ "  Starknet\n"
#~ "\n"
#~ "- [The Cairo Book](https://cairo-book.github.io/): For mastering Cairo\n"
#~ "\n"
#~ "- [Starklings](https://github.com/shramee/starklings-cairo1):\n"
#~ "  Practical tutorials and examples"
#~ msgstr ""
#~ "- [Starknet之书](https://book.starknet.io)：用于掌握Starknet\n"
#~ "\n"
#~ "- [Cairo之书](https://cairo-book.github.io/)：用于掌握Cairo\n"
#~ "\n"
#~ "- [Starklings](https://github.com/shramee/starklings-cairo1)：\n"
#~ "  实用教程和示例"

#~ msgid "# Compile, Deploy and Interact with a Contract"
#~ msgstr "# 编译、部署和交互合约"

#~ msgid "To find the compiler versions supported by Starkli, execute:"
#~ msgstr "要查找 Starkli 支持的编译器版本，请执行："

#~ msgid "You’ll see a list that contains scarb, cairo and sierra version."
#~ msgstr "你会看到一个包含 scarb、cairo 和 sierra 版本的列表。"

#~ msgid ""
#~ "1.  Use Braavos or Argent X browser extensions to create your smart\n"
#~ "    wallet.\n"
#~ "\n"
#~ "2.  Follow the provided instructions for your chosen wallet (Argent or\n"
#~ "    Braavos).\n"
#~ "\n"
#~ "3.  Fund your wallet with ETH. Use [Starknet Goerli\n"
#~ "    Faucet](https://faucet.goerli.starknet.io/) as needed."
#~ msgstr ""
#~ "1.  使用 Braavos 或 Argent X 浏览器扩展创建您的智能钱包。\n"
#~ "\n"
#~ "2.  按照所选钱包（Argent 或Braavos）。\n"
#~ "\n"
#~ "3.  用 ETH 为钱包充值。根据需要你可以使用[Starknet Goerli Faucet](https://faucet.goerli.starknet.io/)获取测试用ETH。"

#~ msgid "To see the details of your Account Descriptor, run:"
#~ msgstr "要查看账户描述符的详细信息，请运行："

#~ msgid "To install `katana` from its source code, run the following commands:"
#~ msgstr "要从源代码安装 `katana`，请运行以下命令："

#~ msgid "Once installed, confirm it with the version command:"
#~ msgstr "安装完成后，使用版本命令进行确认："

#~ msgid ""
#~ "Updating `katana` to its latest version involves going back to the\n"
#~ "`dojo` directory and running the following commands:"
#~ msgstr "将 `katana` 更新到最新版本需要返回 `dojo` 目录并运行以下命令："

#~ msgid ""
#~ "cd ~/.dojo/dojo\n"
#~ "    git pull\n"
#~ "\n"
#~ "    # If you are using a local Starknet node, ensure to stop it first.\n"
#~ "    cargo install --path ./crates/katana --locked --force"
#~ msgstr ""
#~ "cd ~/.dojo/dojo\n"
#~ "    git pull\n"
#~ "\n"
#~ "    # 如果使用本地 Starknet 节点，请确保先停止它。\n"
#~ "    cargo install --path ./crates/katana --locked --force"

#~ msgid "## Additional Resources"
#~ msgstr "## 其他资源"

#~ msgid ""
#~ "- Starknet.js GitHub Repository:\n"
#~ "  <https://github.com/0xs34n/starknet.js>\n"
#~ "\n"
#~ "- Official Starknet.js Website and documentation:\n"
#~ "  <https://www.starknetjs.com/>"
#~ msgstr ""
#~ "- Starknet.js GitHub 仓库：\n"
#~ "  <https://github.com/0xs34n/starknet.js>\n"
#~ "\n"
#~ "- Starknet.js 官方网站和文档：\n"
#~ "  <https://www.starknetjs.com/>"

#~ msgid ""
#~ "Stay tuned for more updates on Starknet.js, including detailed guides,\n"
#~ "examples, and comprehensive documentation."
#~ msgstr "请继续关注有关 Starknet.js 的更多更新，包括详细的指南、示例和全面的文档。"

#~ msgid "## Forge"
#~ msgstr "## Forge"

#~ msgid "## Creating a New Project"
#~ msgstr "## 创建新项目"

#~ msgid ""
#~ "- src/ contains the source code for all your contracts.\n"
#~ "- tests/ is where your test files are located.\n"
#~ "- Scarb.toml contains the project and `snforge` configuration.\n"
#~ "Make sure that the casm code generation is enabled in the Scarb.toml file:"
#~ msgstr ""
#~ "- src/ 包含所有合约的源代码。\n"
#~ "- tests/ 存放测试文件。\n"
#~ "- Scarb.toml 包含项目和 `snforge` 配置。\n"
#~ "确保在 Scarb.toml 文件中启用了 casm 代码生成："

#~ msgid "Make sure that the version in the tag matches the version of snforge. You can check the installed snforge version with the following command:"
#~ msgstr "确保标签中的版本与 snforge 的版本一致。您可以使用以下命令检查已安装的 snforge 版本："

#~ msgid "Now, you are ready to use `snforge` with your existing Scarb project."
#~ msgstr "现在，您可以在现有 Scarb 项目中使用 `snforge` 了。"

#~ msgid ""
#~ "To run tests using the Starknet Foundry `snforge` command, follow these instructions. We will cover `test execution`, `test filtering`, `running specific tests`, and `handling test execution "
#~ "failures`."
#~ msgstr "要使用 Starknet Foundry `snforge` 命令运行测试，请遵循以下说明。我们将介绍 `test execution`， `test filtering`， `running specific tests`和 `handling test execution failures`。"

#~ msgid "This command collects and runs tests within the specified package. Here's an example output:"
#~ msgstr "该命令收集并运行指定软件包内的测试。下面是一个输出示例："

#~ msgid "### Running a Specific Test"
#~ msgstr "### 运行特定测试"

#~ msgid "To run a specific test, you can use the `--exact` flag along with the filter string. Ensure that you use a fully qualified test name, including the module name:"
#~ msgstr "要运行特定测试，可以使用 `--exact` 标志和过滤器字符串。确保使用完全合格的测试名称，包括模块名称："

#~ msgid "### Stopping Test Execution After First Failed Test"
#~ msgstr "### 在首次测试失败后停止测试执行"

#~ msgid "## Testing Starknet contract with `snforge` (Example)"
#~ msgstr "## 使用 `snforge` 测试Starknet合约（示例）"

#~ msgid "It should be noted that the name written after `mod` is the contract name which would be referenced later on; in this case, it is `HelloStarknet`."
#~ msgstr "应该注意的是，写在 `mod` 后面的名称是稍后将引用的合约名称；在本例中，它是 `HelloStarknet`。"

#~ msgid "Now we are ready to run `snforge`. once you run the `snforge` command, you should get the below output"
#~ msgstr "现在，我们准备运行 `snforge`。运行 `snforge` 命令后，会得到以下输出结果"

#~ msgid "## snforge Commands"
#~ msgstr "## snforge 命令"

#~ msgid ""
#~ "- Running `snforge` in the Current Directory\n"
#~ "To run the snforge command in the current directory, simply execute the following command:"
#~ msgstr ""
#~ "- 在当前目录下运行 `snforge`\n"
#~ "要在当前目录下运行 snforge 命令，只需执行以下命令："

#~ msgid ""
#~ "- `-e, --exact`: Use the `-e` or `--exact` option to run a test with a name that exactly matches the provided test filter. The test filter should be a fully qualified test name, including the "
#~ "package name. For example, instead of specifying just `my_test`, use `package_name::my_test` as the test filter.\n"
#~ "\n"
#~ "- `--init` <NAME>: The `--init` <NAME> option allows you to create a new directory and forge project with the specified name <NAME>.\n"
#~ "\n"
#~ "- `-x`, `--exit-first`: By using the` -x` or `--exit-first` option, you can stop the execution of tests after the first test failure is encountered."
#~ msgstr ""
#~ "- `-e,--exact`：使用 `-e` 或 `--exact` 选项运行名称与所提供的测试过滤器完全匹配的测试。测试过滤器应该是一个完整的测试名称，包括软件包名称。例如，使用 `package_name::my_test` 作为测试过滤器，而不"
#~ "是只指定 `my_test`。\n"
#~ "\n"
#~ "- `--init`<NAME>: `--init`<NAME> 选项允许创建一个新目录，并以指定的名称创建项目<NAME> 。\n"
#~ "\n"
#~ "- `-x`, `--exit-first`：通过使用 ` -x` 或 `--exit-first` 选项，可以在第一次测试失败后停止执行测试。"

#~ msgid "### Package Selection"
#~ msgstr "### 包选择"

#~ msgid ""
#~ "- `-p`, `--package`: The `-p` or `--package` option is used to specify the packages on which to run the `snforge` command. You can either provide a concrete package name (e.g., foobar) or use a "
#~ "prefix glob (e.g., foo*) to match multiple packages.\n"
#~ "\n"
#~ "- `-w`, `--workspace`: Use the `-w` or `--workspace` option to run tests for all packages in the workspace."
#~ msgstr ""
#~ "- `-p`, `--package`：`-p`或\"--package \"选项用于指定运行 `snforge` 命令的软件包。你可以提供一个具体的软件包名称（例如，foobar），或者使用前缀 glob（例如，foo*）来匹配多个软件包。\n"
#~ "\n"
#~ "- w\"、\"--workspace\"：使用 `-w` 或 `--workspace` 选项可运行工作区中所有软件包的测试。"

#~ msgid ""
#~ "- `-r`, `--fuzzer-runs` <FUZZER_RUNS>: Specify the number of fuzzer runs using the `-r` or `--fuzzer-runs` option, followed by the desired number of runs <FUZZER_RUNS>.\n"
#~ "\n"
#~ "- `-s`, `--fuzzer-seed` <FUZZER_SEED>: Set the seed for the fuzzer by using the `-s` or `--fuzzer-seed` option, followed by the desired seed value <FUZZER_SEED>."
#~ msgstr ""
#~ "- `-r`、`--fuzzer-runs` <FUZZER_RUNS>：使用`-r`或`--fuzzer-runs`选项指定模糊器的运行次数，之后是所需的运行次数 <FUZZER_RUNS>。\n"
#~ "\n"
#~ "- `-s`, `--fuzzer-seed` <FUZZER_SEED>：使用`-s`或`-fuzzer-seed`选项设置模糊器的种子值，后面跟所需的种子值<FUZZER_SEED>。"

#~ msgid "### Cache Management"
#~ msgstr "### 缓存管理"

#~ msgid "- `-c`, `--clean-cache`: To clean the `snforge` cache directory, simply use the `-c` or `--clean-cache` option."
#~ msgstr "- `-c`、`--clean-cache`：要清理 `snforge` 缓存目录，只需使用 `-c` 或 `--clean-cache` 选项。"

#~ msgid "### Help and Version Information"
#~ msgstr "#### 帮助和版本信息"

#~ msgid ""
#~ "- `-h`,` --help`: Use the `-h` or `--help` option to print the help information, providing guidance on how to use `snforge`.\n"
#~ "\n"
#~ "- `-V`, `--version`: To display the current version of `snforge`, use the `-V` or `--version` option."
#~ msgstr ""
#~ "- `-h`, `--help`：使用 `-h` 或 `--help` 选项打印帮助信息，提供如何使用 `snforge` 的指导。\n"
#~ "\n"
#~ "- `-V`, `--version`：要显示 `snforge` 的当前版本，使用 `-V` 或 `--version` 选项。"

#~ msgid "Note: Replace <NAME>, <FUZZER_RUNS>, and <FUZZER_SEED> with your specific values when using the `snforge` command."
#~ msgstr "注意：在使用 `snforge` 命令时，请将<NAME> 、<FUZZER_RUNS> 和<FUZZER_SEED> 替换为您的特定值。"

#, fuzzy
#~ msgid "## External Functions"
#~ msgstr "**外部函数**："
