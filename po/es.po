msgid ""
msgstr ""
"Project-Id-Version: The Starknet Book\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2024-01-29 11:10+0000\n"
"Last-Translator: dami <pinonesdamian@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.4.2\n"

#: src/SUMMARY.md:1
msgid "The Starknet Book"
msgstr "El Libro de Starknet"

#: src/SUMMARY.md:4
msgid "Introduction"
msgstr "Introducci√≥n"

#: src/SUMMARY.md:8
msgid "Getting Started"
msgstr "Primeros pasos"

#: src/SUMMARY.md:10
msgid "Tooling"
msgstr "Herramientas"

#: src/SUMMARY.md:13
msgid "Basic Installation"
msgstr "Instalaci√≥n b√°sica"

#: src/SUMMARY.md:14
msgid "Introduction: Starkli, Scarb and Katana"
msgstr "Introducci√≥n: Starkli, Scarb y Katana"

#: src/SUMMARY.md:15
msgid "Scarb: The Package Manager"
msgstr "Scarb: El Gestor de Paquetes"

#: src/SUMMARY.md:16
msgid "Katana: A Local Node"
msgstr "Katana: Un Nodo Local"

#: src/SUMMARY.md:17
msgid "Testnet Deployment"
msgstr "Despliegue de Testnet"

#: src/SUMMARY.md:18
msgid "Get started with Sepolia"
msgstr "Comience con Sepolia"

#: src/SUMMARY.md:19
msgid "Starkli: Querying Starknet"
msgstr "Starkli: Consultando Starknet"

#: src/SUMMARY.md:20
msgid "Example - Beginner: Connection Script"
msgstr "Ejemplo - Principiante: Sript de Conexi√≥n"

#: src/SUMMARY.md:21
msgid "Starknet Devnet"
msgstr "Starknet Devnet"

#: src/SUMMARY.md:22
msgid "Foundry Cast: Interacting with Starknet"
msgstr "Foundry Cast: Interactuando con Starknet"

#: src/SUMMARY.md:23
msgid "Example - Intermediate: Deployment Script"
msgstr "Ejemplo - Intermedio: Script de Implementaci√≥n"

#: src/SUMMARY.md:24
msgid "Starknet-js: Javascript SDK"
msgstr "Starknet-js: Javascript SDK"

#: src/SUMMARY.md:25
msgid "Example - Beginner: Counter UI"
msgstr "Ejemplo - Principiante: Contador UI"

#: src/SUMMARY.md:26 src/SUMMARY.md:28
msgid "Example - Beginner: ERC-20 UI"
msgstr "Ejemplo - Principiante: ERC-20 UI"

#: src/SUMMARY.md:27
msgid "Starknet-React: React Integration"
msgstr "Starknet-React: Integraci√≥n de React"

#: src/SUMMARY.md:29
msgid "Example - Intermediate: Million Dollar Homepage"
msgstr "Ejemplo - Intermedio - P√°gina de inicio de Million Dollar"

#: src/SUMMARY.md:30
msgid "Starknet-py: Python SDK üöß"
msgstr "Starknet-py: Python SDK üöß"

#: src/SUMMARY.md:31
msgid "Starknet-rs: Rust SDK üöß"
msgstr "Starknet-py: Python SDK üöß"

#: src/SUMMARY.md:32
msgid "Foundry Forge: Testing"
msgstr "Foundry Forge: Testing"

#: src/SUMMARY.md:33
msgid "Security Considerations"
msgstr "Consideraciones de Seguridad"

#: src/SUMMARY.md:34
msgid "Security Tools"
msgstr "Herramientas de seguridad"

#: src/SUMMARY.md:35
msgid "Cairo-fuzzer"
msgstr "Cairo-fuzzer"

#: src/SUMMARY.md:36
msgid "Caracal"
msgstr "Caracal"

#: src/SUMMARY.md:37
msgid "Thoth"
msgstr "Thoth"

#: src/SUMMARY.md:39
msgid "Architecture"
msgstr "Arquitectura"

#: src/SUMMARY.md:42
msgid "Transactions"
msgstr "Transacciones"

#: src/SUMMARY.md:43
msgid "Transactions Lifecycle"
msgstr "Ciclo de vida de las transacciones"

#: src/SUMMARY.md:44
msgid "Fee Mechanism"
msgstr "Mecanismo de Fee"

#: src/SUMMARY.md:45
msgid "Data Availability"
msgstr "Data Availability"

#: src/SUMMARY.md:46
msgid "Sequencers"
msgstr "Secuenciadores"

#: src/SUMMARY.md:47
msgid "Madara üöß"
msgstr "Madara üöß"

#: src/SUMMARY.md:48
msgid "Provers üöß"
msgstr "Provers üöß"

#: src/SUMMARY.md:49
msgid "Nodes"
msgstr "Nodos"

#: src/SUMMARY.md:50
msgid "Example: Pathfinder Node"
msgstr "Ejemplo: Nodo Pathfinder"

#: src/SUMMARY.md:51
msgid "Layer 3 and App Chains üöß "
msgstr "Layer 3 y App Chains üöß "

#: src/SUMMARY.md:52
msgid "Solidity Verifier"
msgstr "Verificador de Solidity"

#: src/SUMMARY.md:53
msgid "Decentralization üöß"
msgstr "Descentralizaci√≥n üöß"

#: src/SUMMARY.md:54
msgid "Smart Contracts üöß"
msgstr "Smart Contracts üöß"

#: src/SUMMARY.md:55
msgid "Deployment and Interaction"
msgstr "Implementaci√≥n e Interacci√≥n"

#: src/SUMMARY.md:56
msgid "Important Methods"
msgstr "M√©todos Importantes"

#: src/SUMMARY.md:58
msgid "Account Abstraction"
msgstr "Abstracci√≥n de Cuenta"

#: src/SUMMARY.md:61
msgid "Accounts"
msgstr "Cuentas"

#: src/SUMMARY.md:62
msgid "Hello, Account Contract!"
msgstr "¬°Hola, Contrato de Cuenta!"

#: src/SUMMARY.md:63
msgid "Standard Account Contract"
msgstr "Contrato de Cuenta Est√°ndar"

#: src/SUMMARY.md:64
msgid "Deploy Standard Account"
msgstr "Implementar Cuenta Est√°ndar"

#: src/SUMMARY.md:65
msgid "Examples"
msgstr "Ejemplos"

#: src/SUMMARY.md:66
msgid "Multicaller"
msgstr "Multicaller"

#: src/SUMMARY.md:67
msgid "Multisig üöß"
msgstr "Multisig üöß"

#: src/SUMMARY.md:68
msgid "Auto-Payments üöß"
msgstr "Auto-Payments üöß"

#: src/SUMMARY.md:69
msgid "Alternative Signature Schemes üöß"
msgstr "Esquemas de Firma Alternativos üöß"

#: src/SUMMARY.md:70
msgid "Web Wallet: seedless, multi-device wallet"
msgstr "Web Wallet: wallet multidispositivo sin semillas"

#: src/SUMMARY.md:74
msgid "STARKs üöß"
msgstr "STARKs üöß"

#: src/SUMMARY.md:75
msgid "Basics üöß"
msgstr "B√°sicos üöß"

#: src/SUMMARY.md:76
msgid "Math Primer üöß"
msgstr "Manual de Matem√°ticas üöß"

#: src/SUMMARY.md:77
msgid "Number Theory üöß"
msgstr "Teor√≠a de N√∫meros üöß"

#: src/SUMMARY.md:78
msgid "Geometry üöß"
msgstr "Geometr√≠a üöß"

#: src/SUMMARY.md:79
msgid "Cryptographic Primitives üöß"
msgstr "Primitivas Criptogr√°ficas üöß"

#: src/SUMMARY.md:80
msgid "Arithimization üöß"
msgstr "Aritimizaci√≥n üöß"

#: src/SUMMARY.md:81
msgid "Low Degree Testing üöß"
msgstr "Pruebas de Bajo Grado üöß"

#: src/SUMMARY.md:82
msgid "FRI Protocol üöß"
msgstr "FRI  üöß"

#: src/SUMMARY.md:83
msgid "Efficient STARKs"
msgstr "STARK Eficientes"

#: src/SUMMARY.md:84
msgid "STARKs Protocol (Python) üöß"
msgstr "Protocolo STARK (Python) üöß"

#: src/SUMMARY.md:85 src/SUMMARY.md:90
msgid "Trace/Low Degree Extension üöß"
msgstr "Traza/Extensi√≥n de Bajo Grado üöß"

#: src/SUMMARY.md:86 src/SUMMARY.md:91
msgid "Constraints üöß"
msgstr "Restricciones üöß"

#: src/SUMMARY.md:87 src/SUMMARY.md:92
msgid "FRI Commitments üöß"
msgstr "Compromisos de FRI üöß"

#: src/SUMMARY.md:88 src/SUMMARY.md:93
msgid "Query Phase üöß"
msgstr "Fase de Consulta üöß"

#: src/SUMMARY.md:89
msgid "STARKs Protocol (Rust) üöß"
msgstr "Protocolo STARK (Rust) üöß"

#: src/title-page.md:1
msgid "# The Starknet Book"
msgstr "# El Libro de Starknet"

#: src/title-page.md:3
msgid ""
"The Starknet Book is a work in progress, shaped by ongoing community\n"
"input. Some sections may be incomplete or still under review and are\n"
"marked under a üöß emoji. We welcome your suggestions, feedback, and\n"
"content contributions to make this book a reliable guide for everyone."
msgstr ""
"El Libro de Starknet es un trabajo en progreso, moldeado por los aportes\n"
"continuos de la comunidad. Algunas secciones pueden estar incompletas o a√∫n bajo revisi√≥n y son\n"
"marcado debajo de un emoji üöß. Agradecemos sus sugerencias, comentarios y\n"
"contribuciones de contenido para hacer de este libro una gu√≠a confiable para todos."

#: src/title-page.md:8
msgid ""
"The Starknet Book is a step-by-step guide aimed at teaching you the\n"
"essentials of Starknet development. It‚Äôs a community effort, with each\n"
"chapter guiding you through the Starknet ecosystem."
msgstr ""
"El Libro de Starknet es una gu√≠a paso a paso destinada a ense√±arle los\n"
"Conceptos b√°sicos del desarrollo de Starknet. Es un esfuerzo comunitario, en el que cada\n"
"cap√≠tulo lo guiar√° a trav√©s del ecosistema Starknet."

#: src/title-page.md:12
msgid ""
"Understanding Cairo, the key programming language for Starknet smart\n"
"contracts, is crucial. That‚Äôs why this book works hand-in-hand with the\n"
"Cairo Book, another community resource. You can access the Cairo Book\n"
"[**here**](https://book.cairo-lang.org/)."
msgstr ""
"Entendiendo Cairo, el lenguaje de programaci√≥n clave para Smart Contract en\n"
"Starknet, es crucial. Es por eso que este libro trabaja de la mano con el\n"
"Libro de Cairo, otro recurso comunitario. Puedes acceder al Libro Cairo\n"
"[**aqu√≠**](https://book.cairo-lang.org/)."

#: src/title-page.md:17
msgid ""
"In short, the Cairo Book helps you master Cairo, while The Starknet Book\n"
"focuses on Starknet‚Äôs specific features. For a well-rounded\n"
"understanding, we recommend exploring both. This book will introduce you\n"
"to tools, architecture, account setups, STARKs, and Starknet-specific\n"
"apps."
msgstr ""
"En resumen, el Libro de Cairo te ayuda a dominar Cairo, mientras que El Libro de Starknet\n"
"se centra en las caracter√≠sticas espec√≠ficas de Starknet. Para una completa\n"
"comprensi√≥n, recomendamos explorar ambos. Este libro te presentar√°\n"
"herramientas, arquitectura, configuraciones de cuentas, STARK y aplicaciones espec√≠ficas\n"
"de Starknet."

#: src/title-page.md:23
msgid "## Table of Contents"
msgstr "## Tabla de Contenido"

#: src/title-page.md:25
msgid "**Chapter Titles**"
msgstr "**T√≠tulos de los Cap√≠tulos**"

#: src/title-page.md:27
msgid ""
"| Chapter                  | "
"Description                                                                                                                                                                                           "
"|\n"
"| ------------------------ | "
"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
"|\n"
"| 1: Starknet Introduction | Delve into the fundamental concepts of Starknet and acquaint yourself with the deployment of smart "
"contracts.                                                                                         |\n"
"| 2: Starknet Tooling      | Familiarize yourself with vital tools, such as Starkli, Katana, Scarb, Starknet-Foundry and more. Explore how languages like Javascript, Python, and Rust can be "
"leveraged for Starknet interactions. |\n"
"| 3: Starknet Architecture | Uncover Starknet‚Äôs core structure, gaining insights into the transaction lifecycle and the interplay between the Sequencer, Prover, and "
"Nodes.                                                        |\n"
"| 4: Account Abstraction   | Delve deep into Starknet‚Äôs unique approach to user accounts, and master the art of crafting custom "
"accounts.                                                                                          |\n"
"| 5: STARKs                | Dive into the intricacies of STARKs and their pivotal role in shaping Starknet‚Äôs "
"landscape.                                                                                                           |"
msgstr ""
"| Cap√≠tulo | Descripci√≥n |\n"
"| ------------------------ | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- "
"----------------------------------------- |\n"
"| 1: Introducci√≥n a Starknet | Profundice en los conceptos fundamentales de Starknet y familiar√≠cese con el despliegue de smart contracts.|\n"
"| 2: Herramientas Starknet | Familiar√≠cese con herramientas vitales, como Starkli, Katana, Scarb, Starknet-Foundry y m√°s. Explore c√≥mo se pueden aprovechar lenguajes como Javascript, Python y Rust "
"para las interacciones con Starknet. |\n"
"| 3: Arquitectura Starknet | Descubra la estructura central de Starknet y obtenga informaci√≥n sobre el ciclo de vida de las transacciones y la interacci√≥n entre el secuenciador, el prover y los "
"nodos. |\n"
"| 4: Abstracci√≥n de Cuenta | Profundice en el enfoque √∫nico de Starknet para las cuentas de usuario y domine el arte de crear cuentas personalizadas. |\n"
"| 5: STARK | Sum√©rgete en las complejidades de los STARK y su papel fundamental en la configuraci√≥n del paisaje de Starknet. |"

#: src/title-page.md:35
msgid "# Where to Start?"
msgstr "# ¬øDonde Empezar?"

#: src/title-page.md:37
msgid ""
"Depending on your goals and interests, you can choose different paths\n"
"through the Starknet Book. Here are some recommendations based on\n"
"various objectives:"
msgstr ""
"Dependiendo de tus objetivos e intereses, puedes elegir diferentes caminos\n"
"a trav√©s del Libro de Starknet. A continuaci√≥n se presentan algunas recomendaciones basadas en\n"
"varios objetivos:"

#: src/title-page.md:41
msgid ""
"- If you‚Äôre a **complete beginner** and want to start learning about\n"
"  Cairo and Starknet from scratch, follow the book in its entirety,\n"
"  starting with **Introduction to Starknet**.\n"
"\n"
"- If you‚Äôre an **experienced developer** looking to quickly dive into\n"
"  writing scalable and decentralized smart contracts, focus on the\n"
"  Cairo Book, particularly **chapter 12: Starknet Smart Contracts**\n"
"  ([link](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)).\n"
"\n"
"- If you‚Äôre a **frontend developer** wanting to integrate Starknet\n"
"  with a React frontend using Javascript, prioritize the\n"
"  **starknet-js** and **starknet-react** subchapters in **Starknet\n"
"  Tooling**\n"
"\n"
"- If you‚Äôre a **DevOps engineer** or **node operator** interested in\n"
"  running a Starknet node and indexer, head straight to **Starknet\n"
"  Architecture**.\n"
"\n"
"- If you‚Äôre a **security researcher** or **smart contract auditor**\n"
"  wanting to learn about the Account Abstraction feature and its\n"
"  implications, go for **Account Abstraction**.\n"
"\n"
"- If you‚Äôre a **blockchain enthusiast** curious about the underlying\n"
"  architecture and mechanics of Starknet and Cairo, explore **Starknet\n"
"  Architecture**.\n"
"\n"
"- If you‚Äôre a **cryptography expert** or **researcher** eager to\n"
"  understand the fundamentals of STARKs and their connection to the\n"
"  Starknet ecosystem, delve into **STARKs**."
msgstr ""
"- Si eres un **completo principiante** y quieres comenzar a aprender sobre\n"
"   Cairo y Starknet desde cero, sigue el libro en su totalidad,\n"
"   comenzando con **Introducci√≥n a Starknet**.\n"
"\n"
"- Si eres un **desarrollador experimentado** y buscas sumergirte r√°pidamente en\n"
"   escribir contratos inteligentes escalables y descentralizados, centrarse en el\n"
"   Libro de Cairo, en particular **cap√≠tulo 12: Smart Contracts en Starknet**\n"
"   ([enlace](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)).\n"
"\n"
"- Si eres un **desarrollador frontend** que desea integrar Starknet\n"
"   con una interfaz React usando Javascript, priorice la\n"
"   **starknet-js** y **starknet-react** subcap√≠tulos en **Starknet\n"
"   Tooling**\n"
"\n"
"- Si es un **ingeniero de DevOps** o un **operador de nodo** interesado en\n"
"   ejecutando un nodo Starknet y un indexador, dir√≠jase directamente a **Starknet\n"
"   Arquitectura**.\n"
"\n"
"- Si es un **investigador de seguridad** o un **auditor de contratos inteligentes**\n"
"   querer aprender sobre la funci√≥n de Abstracci√≥n de Cuenta y sus\n"
"   implicaciones, opte por **Abstracci√≥n de cuenta**.\n"
"\n"
"- Si eres un **entusiasta de blockchain** y tienes curiosidad sobre lo subyacente\n"
"   arquitectura y mec√°nica de Starknet y Cairo, explora **Starknet\n"
"   Arquitectura**.\n"
"\n"
"- Si eres un **experto en criptograf√≠a** o un **investigador** deseoso de\n"
"   comprender los fundamentos de STARK y su conexi√≥n con el\n"
"   Ecosistema Starknet, profundiza en **STARKs**."

#: src/title-page.md:71
msgid ""
"Feel free to mix and match these paths based on your unique interests\n"
"and requirements."
msgstr ""
"Si√©ntete libre de mezclar y combinar estos caminos seg√∫n tus intereses √∫nicos\n"
"y requisitos."

#: src/title-page.md:74
msgid "# Your Contributions Matter"
msgstr "# Tus Contribuciones Importan"

#: src/title-page.md:76
msgid ""
"Welcome aboard! By contributing to the Starknet Book, you‚Äôre doing more\n"
"than sharing expertise‚Äîyou‚Äôre shaping the future of decentralized tech.\n"
"Let‚Äôs build a guide that helps developers unlock Starknet‚Äôs potential."
msgstr ""
"¬°Bienvenido a bordo! Al contribuir al Libro de Starknet, est√°s haciendo m√°s\n"
"que compartir experiencia, est√°s dando forma al futuro de la tecnolog√≠a descentralizada.\n"
"Creemos una gu√≠a que ayude a los desarrolladores a desbloquear el potencial de Starknet."

#: src/title-page.md:80
msgid ""
"For detailed contribution guidelines, visit the [Contributors\n"
"Guide](https://github.com/starknet-edu/starknetbook/blob/main/README.md#contribution).\n"
"Every contribution counts. Your skills and passion will help make this\n"
"book an invaluable tool."
msgstr ""
"Para obtener pautas de contribuci√≥n detalladas, visite [Contributors\n"
"Gu√≠a](https://github.com/starknet-edu/starknetbook/blob/main/README.md#contribution).\n"
"Cada contribuci√≥n cuenta. Tus habilidades y pasi√≥n te ayudar√°n a lograrlo.\n"
"Reserve una herramienta invaluable."

#: src/title-page.md:85
msgid "## How You Can Help"
msgstr "## C√≥mo Puedes Ayudar"

#: src/title-page.md:87
msgid ""
"- Found an empty section? Fill it in!\n"
"\n"
"- Think we need a new section? Suggest one.\n"
"\n"
"- See room for improvement? Go ahead and tweak it.\n"
"\n"
"- Want to add code in a new programming language? Go for it.\n"
"\n"
"- Found a bug? Fix it.\n"
"\n"
"- Exercises unclear? Add explanations.\n"
"\n"
"- Show off your favorite Cairo features through new exercises."
msgstr ""
"- ¬øEncontraste una secci√≥n vac√≠a? ¬°Rellenalo!\n"
"\n"
"- ¬øCrees que necesitamos una nueva secci√≥n? Sugiere uno.\n"
"\n"
"- ¬øVes margen de mejora? Contin√∫e y modif√≠quelo.\n"
"\n"
"- ¬øQuieres agregar c√≥digo en un nuevo lenguaje de programaci√≥n? A por ello.\n"
"\n"
"- ¬øEncontraste un error? Arreglalo.\n"
"\n"
"- ¬øLos ejercicios no est√°n claros? A√±ade explicaciones.\n"
"\n"
"- Muestra tus caracter√≠sticas favoritas de Cairo a trav√©s de nuevos ejercicios."

#: src/title-page.md:101
msgid "# Additional Key Educational Resources"
msgstr "# Recursos Educativos Clave Adicionales"

#: src/title-page.md:103
msgid ""
"We‚Äôve compiled a list of valuable educational resources that will help\n"
"deepen your understanding and enhance your skills in coding with Cairo\n"
"and staying abreast with Starknet developments:"
msgstr ""
"Hemos compilado una lista de valiosos recursos educativos que le ayudar√°n\n"
"profundice su comprensi√≥n y mejore sus habilidades en codificaci√≥n con Cairo\n"
"y mantenerse al tanto de los desarrollos de Starknet:"

#: src/title-page.md:107
msgid ""
"1.  **Starklings**: A resource specifically designed to guide you\n"
"    through learning Cairo programming, ensuring that you reach a\n"
"    proficient level. You can access it\n"
"    [here](https://github.com/shramee/starklings-cairo1).\n"
"\n"
"2.  **Starknet Community Forum**: An online platform where you can\n"
"    engage in discussions about the latest developments in Starknet.\n"
"    Join the conversation [here](https://community.starknet.io/).\n"
"\n"
"3.  **Starknet Documentation**: You can browse through the documentation\n"
"    [here](https://docs.starknet.io/).\n"
"\n"
"4.  **Cairo Documentation**: Explore it\n"
"    [here](https://www.cairo-lang.org/docs).\n"
"\n"
"5.  **Starknet Developer Telegram (English)**: A community for\n"
"    English-speaking Starknet developers. This is a great platform for\n"
"    networking, sharing ideas, and troubleshooting together. Join us on\n"
"    Telegram [here](https://t.me/starknetna)."
msgstr ""
"1. **Starklings**: Un recurso dise√±ado espec√≠ficamente para guiarte\n"
"     a trav√©s del aprendizaje de la programaci√≥n de Cairo, asegur√°ndose de que alcance un\n"
"     nivel competente. Puedes acceder a √©l\n"
"     [aqu√≠](https://github.com/shramee/starklings-cairo1).\n"
"\n"
"2. **Foro de la comunidad Starknet**: Una plataforma en l√≠nea donde puedes\n"
"     participar en debates sobre los √∫ltimos desarrollos en Starknet.\n"
"     √önase a la conversaci√≥n [aqu√≠](https://community.starknet.io/).\n"
"\n"
"3. **Documentaci√≥n de Starknet**: Puedes navegar a trav√©s de la documentaci√≥n\n"
"     [aqu√≠](https://docs.starknet.io/).\n"
"\n"
"4. **Documentaci√≥n de Cairo**: Expl√≥rela\n"
"     [aqu√≠](https://www.cairo-lang.org/docs).\n"
"\n"
"5. **Starknet Developer Telegram (ingl√©s)**: una comunidad para\n"
"     Desarrolladores Starknet de habla inglesa. Esta es una gran plataforma para\n"
"     establecer contactos, compartir ideas y solucionar problemas juntos. √önete a nosotros\n"
"     Telegrama [aqu√≠](https://t.me/starknetna)."

#: src/ch00-00-introduction.md:1
msgid "# The Starknet Network"
msgstr "# La Red de Starknet"

#: src/ch00-00-introduction.md:3
msgid "## Preamble"
msgstr "## Pre√°mbulo"

#: src/ch00-00-introduction.md:5
msgid ""
"Historically, societal roles like currency, property rights, and social status titles have been governed by _protocols_ and _registries_. Their value stems from a widely accepted understanding of "
"their integrity. These functions have predominantly been overseen by centralized entities prone to challenges such as corruption, agency conflicts, and exclusion ([Eli Ben-Sasson, Bareli, Brandt, "
"Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"Hist√≥ricamente, los roles sociales como la moneda, los derechos de propiedad y los t√≠tulos de estatus social han estado gobernados por protocolos y registros. Su valor surge de una comprensi√≥n "
"ampliamente aceptada de su integridad. Estas funciones han sido supervisadas predominantemente por entidades centralizadas propensas a desaf√≠os como la corrupci√≥n, los conflictos de agencia y la "
"exclusi√≥n ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp) )."

#: src/ch00-00-introduction.md:7
msgid "Satoshi's creation, Bitcoin, introduced a novel approach for these functions, termed an _integrity web_. This is an infrastructure for societal roles that:"
msgstr "La creaci√≥n de Satoshi, Bitcoin, introdujo un enfoque novedoso para estas funciones, denominado _red de integridad_. Se trata de una infraestructura para roles sociales que:"

#: src/ch00-00-introduction.md:9
msgid ""
"1. Is openly described by a public protocol.\n"
"2. Operates over a wide, inclusive, peer-to-peer network.\n"
"3. Distributes value fairly and extensively to maintain societal consensus on its integrity."
msgstr ""
"1. Est√° descrito abiertamente por un protocolo p√∫blico.\n"
"2. Opera a trav√©s de una red peer-to-peer amplia e inclusiva.\n"
"3. Distribuye valor de manera justa y amplia para mantener el consenso social sobre su integridad."

#: src/ch00-00-introduction.md:13
msgid ""
"While Bitcoin addressed monetary functions, Ethereum expanded this to include any function that can be defined by computer programming. Both faced the challenge of balancing scalability with "
"decentralization. These integrity webs have often favored inclusivity over capacity, ensuring even those with limited resources can authenticate the system's integrity. Yet, this means they "
"struggle to meet global demand."
msgstr ""
"Mientras que Bitcoin abord√≥ las funciones monetarias, Ethereum ampli√≥ esto para incluir cualquier funci√≥n que pueda definirse mediante programaci√≥n inform√°tica. Ambos enfrentaron el desaf√≠o de "
"equilibrar la escalabilidad con la descentralizaci√≥n. Estas redes de integridad a menudo han favorecido la inclusi√≥n sobre la capacidad, asegurando que incluso aquellos con recursos limitados "
"puedan autenticar la integridad del sistema. Sin embargo, esto significa que tienen dificultades para satisfacer la demanda global."

#: src/ch00-00-introduction.md:15
msgid "## Defining \"Blockchain\""
msgstr "## Definici√≥n de \"Blockchain\""

#: src/ch00-00-introduction.md:17
msgid ""
"In the ever-evolving realm of technology, defining a term as multifaceted as \"Blockchain\" can be challenging. Based on current understandings and applications, a Blockchain can be characterized "
"by the following three properties ([Eli Ben-Sasson, 2023](https://twitter.com/EliBenSasson/status/1709272086504485265)):"
msgstr ""
"En el siempre cambiante √°mbito de la tecnolog√≠a, definir un t√©rmino tan polifac√©tico como \"Blockchain\" puede resultar complicado. Seg√∫n los conocimientos y aplicaciones actuales, una Blockchain "
"puede caracterizarse por las tres propiedades siguientes ([Eli Ben-Sasson, 2023](https://twitter.com/EliBenSasson/status/1709272086504485265)):"

#: src/ch00-00-introduction.md:19
msgid ""
"1. **Public Protocol:** The foundation of a Blockchain rests upon a protocol that is openly available. This transparency ensures that any interested party can understand its workings, fostering "
"trust and enabling wider adoption.\n"
"2. **Open P2P Network:** Instead of relying on a centralized entity, a Blockchain operates over a peer-to-peer (P2P) network. This decentralized approach ensures that operations are distributed "
"across various participants or nodes, making the system more resilient to failures and censorship.\n"
"3. **Value Distribution:** Central to the Blockchain's operation is the way it rewards its operators. The system autonomously distributes value in a manner that is wide-ranging and equitable. This "
"incentivization not only motivates participants to maintain the system's integrity but also ensures a broader societal consensus."
msgstr ""
"1. **Protocolo p√∫blico:** La base de una Blockchain es un protocolo que est√° disponible abiertamente. Esta transparencia garantiza que cualquier parte interesada pueda entender su funcionamiento, "
"fomentando la confianza y permitiendo una adopci√≥n m√°s amplia.\n"
"2. **Red abierta P2P:** En lugar de depender de una entidad centralizada, una Blockchain funciona a trav√©s de una red entre pares (P2P). Este enfoque descentralizado garantiza que las operaciones "
"se distribuyan entre varios participantes o nodos, lo que hace que el sistema sea m√°s resistente a los fallos y la censura.\n"
"3. **Distribuci√≥n de valor:** Un aspecto central del funcionamiento de la Blockchain es la forma en que recompensa a sus operadores. El sistema distribuye valor de forma aut√≥noma, amplia y "
"equitativa. Esta incentivaci√≥n no s√≥lo motiva a los participantes a mantener la integridad del sistema, sino que tambi√©n garantiza un consenso social m√°s amplio."

#: src/ch00-00-introduction.md:23
msgid ""
"While these properties capture the essence of many Blockchains, the term's definition might need refinement as the technology matures and finds new applications. Engaging in continuous dialogue and "
"revisiting definitions will be crucial in this dynamic landscape."
msgstr ""
"Aunque estas propiedades captan la esencia de muchas Blockchains, la definici√≥n del t√©rmino podr√≠a necesitar refinamiento a medida que la tecnolog√≠a madura y encuentra nuevas aplicaciones. En este "
"panorama din√°mico, ser√° crucial entablar un di√°logo continuo y revisar las definiciones."

#: src/ch00-00-introduction.md:25
msgid "## Starknet Definition"
msgstr "## Definici√≥n de Starknet"

#: src/ch00-00-introduction.md:27
msgid ""
"Starknet is a Layer-2 network that makes Ethereum transactions faster, cheaper, and more secure using zk-STARKs technology. Think of it as a boosted layer on top of Ethereum, optimized for speed "
"and cost."
msgstr ""
"Starknet es una red de capa 2 que hace que las transacciones de Ethereum sean m√°s r√°pidas, baratas y seguras utilizando la tecnolog√≠a de zk-STARK. Piense en ella como una capa reforzada sobre "
"Ethereum, optimizada para la velocidad y el coste."

#: src/ch00-00-introduction.md:29
msgid ""
"Starknet bridges the gap between scalability and broad consensus. It integrates a mathematical framework to navigate the balance between capacity and inclusivity. Its integrity hinges on the "
"robustness of succinct, transparent proofs of computational integrity. This method lets powerful operators enhance Starknet's capacity, ensuring everyone can authenticate Starknet's integrity using "
"universally accessible tools ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"Starknet tiende un puente entre la escalabilidad y el amplio consenso. Integra un marco matem√°tico para navegar por el equilibrio entre capacidad e inclusividad. Su integridad depende de la solidez "
"de las pruebas sucintas y transparentes de integridad computacional. Este m√©todo permite a los operadores potentes mejorar la capacidad de Starknet, garantizando que todo el mundo pueda autenticar "
"la integridad de Starknet utilizando herramientas universalmente accesibles ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."

#: src/ch00-00-introduction.md:31
msgid "## Starknet‚Äôs Mission"
msgstr "## Misi√≥n de Starknet"

#: src/ch00-00-introduction.md:33
msgid "_Starknet‚Äôs mission is to allow individuals to freely implement and use any social function they desire._"
msgstr "_La misi√≥n de Starknet es permitir a los individuos implantar y utilizar libremente cualquier funci√≥n social que deseen._"

#: src/ch00-00-introduction.md:35
msgid "## Starknet‚Äôs Values"
msgstr "## Valores de Starknet"

#: src/ch00-00-introduction.md:37
msgid "Starknet's ethos is anchored in core principles ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp)):"
msgstr "La √©tica de Starknet se basa en principios fundamentales ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp)):"

#: src/ch00-00-introduction.md:39
msgid ""
"- **Lasting Broadness.** Starknet continuously resists power consolidation. Key points include:\n"
"\n"
"  - Broad power distribution underpins Starknet's legitimacy and must persist across operations and decision-making. While centralized operation may be necessary at times, it should be short-"
"lived.\n"
"  - Starknet's protocol and governance should always be open and transparent.\n"
"  - Governance should bolster inclusivity, with a flexible structure that can evolve to ensure enduring inclusivity.\n"
"\n"
"- **Neutrality.** Starknet remains impartial to the societal functions it supports.\n"
"\n"
"  - The objectives and ethos of functions on Starknet lie with their creators.\n"
"  - **Censorship resistance:** Starknet remains agnostic to the nature and meaning of user transactions.\n"
"\n"
"- **Individual Empowerment.** At its core, Starknet thrives on a well-informed and autonomous user base. This is achieved by fostering a culture rooted in its core mission and values, with a strong "
"emphasis on education."
msgstr ""
"- **Amplitud duradera.** Starknet se resiste continuamente a la consolidaci√≥n de poder. Los puntos clave incluyen:\n"
"\n"
"   - La amplia distribuci√≥n del poder sustenta la legitimidad de Starknet y debe persistir en todas las operaciones y toma de decisiones. Si bien en ocasiones puede ser necesario el funcionamiento "
"centralizado, deber√≠a ser de corta duraci√≥n.\n"
"   - El protocolo y la gobernanza de Starknet siempre deben ser abiertos y transparentes.\n"
"   - La gobernanza deber√≠a reforzar la inclusi√≥n, con una estructura flexible que pueda evolucionar para garantizar una inclusi√≥n duradera.\n"
"\n"
"- **Neutralidad.** Starknet se mantiene imparcial con respecto a las funciones sociales que apoya.\n"
"\n"
"   - Los objetivos y el esp√≠ritu de las funciones de Starknet recaen en sus creadores.\n"
"   - **Resistencia a la censura:** Starknet permanece agn√≥stico respecto de la naturaleza y el significado de las transacciones de los usuarios.\n"
"\n"
"- **Empoderamiento individual.** En esencia, Starknet prospera con una base de usuarios aut√≥nomos y bien informados. Esto se logra fomentando una cultura arraigada en su misi√≥n y valores "
"fundamentales, con un fuerte √©nfasis en la educaci√≥n."

#: src/ch00-00-introduction.md:52
msgid "## Key Features"
msgstr "## Caracter√≠sticas Clave"

#: src/ch00-00-introduction.md:54
msgid "These are some key features of Starknet:"
msgstr "Estas son algunas de las caracter√≠sticas clave de Starknet:"

#: src/ch00-00-introduction.md:56
msgid ""
"- Low Costs: Transactions on Starknet cost less than on Ethereum.\n"
"  Future updates like Volition and EIP 4844 will make it even cheaper.\n"
"\n"
"- Developer-Friendly: Starknet lets developers easily build\n"
"  decentralized apps using its native language, Cairo.\n"
"\n"
"- Speed and Efficiency: Upcoming releases aim to make transactions\n"
"  even faster and cheaper.\n"
"\n"
"- CVM: Thanks to Cairo, Starknet runs on it¬¥s own VM, called Cairo VM\n"
"  (CVM), that allow us to innovate beyond the Ethereum Virtual Machine\n"
"  (EVM) and create a new paradigm for decentralized applications."
msgstr ""
"- **Bajos costos:** Las transacciones en Starknet cuestan menos que en Ethereum.\n"
"   Actualizaciones futuras como Volition y EIP 4844 lo har√°n a√∫n m√°s econ√≥mico.\n"
"\n"
"- **F√°cil de usar para desarrolladores:** Starknet permite a los desarrolladores crear f√°cilmente\n"
"   aplicaciones descentralizadas que utilizan su idioma nativo, El Cairo.\n"
"\n"
"- **Velocidad y eficiencia:** Los pr√≥ximos lanzamientos tienen como objetivo realizar transacciones\n"
"   incluso m√°s r√°pido y m√°s barato.\n"
"\n"
"- **CVM:** Gracias a Cairo, Starknet se ejecuta en su propia VM, llamada Cairo VM\n"
"   (CVM), que nos permiten innovar m√°s all√° de la M√°quina Virtual Ethereum\n"
"   (EVM) y crear un nuevo paradigma para aplicaciones descentralizadas."

#: src/ch00-00-introduction.md:69
msgid "Here are some of them:"
msgstr "Estas son algunas de ellas:"

#: src/ch00-00-introduction.md:71
msgid ""
"- Account Abstraction: Implemented at the protocol level, this\n"
"  facilitates diverse signing schemes while ensuring user security and\n"
"  self-custody of assets.\n"
"\n"
"- Volition: Will be implemented on testnet during Q4 2023 will allow\n"
"  developers to regulate data availability on Ethereum (L1) or on\n"
"  Starknet (L2). Reducing L1 onchain data can radically reduce costs.\n"
"\n"
"- Paymaster: Starknet will allow users to choose how to pay for\n"
"  transaction fee, follows the guidelines laid out in EIP 4337 and\n"
"  allows the transaction to specify a specific contract, a\n"
"  **Paymaster**, to pay for their transaction. Supports gasless\n"
"  transactions, enhancing user accessibility."
msgstr ""
"- **Abstracci√≥n de Cuenta:** Implementado a nivel de protocolo, esto\n"
"   facilita diversos esquemas de firma al tiempo que garantiza la seguridad del usuario y\n"
"   autocustodia de bienes.\n"
"\n"
"- **Volition:** Se implementar√° en testnet durante el cuarto trimestre de 2023 y permitir√°\n"
"   desarrolladores para regular la disponibilidad de datos en Ethereum (L1) o en\n"
"   Starknet (L2). Reducir los datos en cadena L1 puede reducir radicalmente los costos.\n"
"\n"
"- **Paymaster:** Starknet permitir√° a los usuarios elegir c√≥mo pagar\n"
"   tarifa de transacci√≥n, sigue las pautas establecidas en EIP 4337 y\n"
"   permite que la transacci√≥n especifique un contrato espec√≠fico, un\n"
"   **Paymaster**, para pagar su transacci√≥n. Soporta sin gas\n"
"   transacciones, mejorando la accesibilidad del usuario."

#: src/ch00-00-introduction.md:85
msgid "## Cairo: The Language of Starknet"
msgstr "## Cairo: El Lenguaje de Starknet"

#: src/ch00-00-introduction.md:87
msgid ""
"Cairo is tailor-made for creating STARK-based smart contracts. As\n"
"Starknet‚Äôs native language, it‚Äôs central to building scalable and secure\n"
"decentralized apps. To start learning now, check out the [Cairo\n"
"Book](https://cairo-book.github.io/) and\n"
"[Starklings](https://github.com/shramee/starklings-cairo1)."
msgstr ""
"Cairo est√° hecho a medida para crear contratos inteligentes basados en STARK. Como\n"
"El idioma nativo de Starknet es fundamental para construir plataformas escalables y seguras.\n"
"Aplicaciones descentralizadas. Para comenzar a aprender ahora, consulte el [Cairo\n"
"Libro](https://cairo-book.github.io/) y\n"
"[Starklings](https://github.com/shramee/starklings-cairo1)."

#: src/ch00-00-introduction.md:93
msgid ""
"Inspired by Rust, Cairo lets you write contracts safely and\n"
"conveniently."
msgstr ""
"Inspirado en Rust, Cairo le permite redactar contratos de forma segura y\n"
"convenientemente."

#: src/ch00-00-introduction.md:96
msgid "## Governance"
msgstr "## Gobernanza"

#: src/ch00-00-introduction.md:98
msgid ""
"The Starknet Foundation oversees Starknet‚Äôs governance. Its duties\n"
"include:"
msgstr ""
"La Fundaci√≥n Starknet supervisa la gobernanza de Starknet. Sus deberes\n"
"incluyen:"

#: src/ch00-00-introduction.md:101
msgid ""
"- Managing Starknet‚Äôs development and operations\n"
"\n"
"- Overseeing the Starknet DAO, which enables community involvement\n"
"\n"
"- Setting rules to maintain network integrity"
msgstr ""
"- Gestionar el desarrollo y las operaciones de Starknet\n"
"\n"
"- Supervisar Starknet DAO, que permite la participaci√≥n de la comunidad\n"
"\n"
"- Establecer reglas para mantener la integridad de la red"

#: src/ch00-00-introduction.md:107
msgid ""
"Our focus is on technical input and debate for improving the protocol.\n"
"While we value all perspectives, it‚Äôs often the technical insights that\n"
"steer us forward."
msgstr ""
"Nos centramos en los aportes t√©cnicos y el debate para mejorar el protocolo.\n"
"Si bien valoramos todas las perspectivas, a menudo son los conocimientos t√©cnicos los que\n"
"gu√≠anos hacia adelante."

#: src/ch00-00-introduction.md:111
msgid ""
"Members can influence Starknet by voting on changes. Here‚Äôs the process:\n"
"A new version is tested on the Goerli Testnet. Members then have six\n"
"days to review it. A Snapshot proposal is made, and the community votes.\n"
"A majority of _YES_ votes means an upgrade to the Mainnet."
msgstr ""
"Los miembros pueden influir en Starknet votando sobre los cambios. Aqu√≠ est√° el proceso:\n"
"Se prueba una nueva versi√≥n en Goerli Testnet. Los miembros tienen entonces seis\n"
"d√≠as para revisarlo. Se hace una propuesta de instant√°nea y la comunidad vota.\n"
"Una mayor√≠a de votos _S√ç_ significa una actualizaci√≥n a Mainnet."

#: src/ch00-00-introduction.md:116
msgid "In short, governance is key to Starknet‚Äôs evolution."
msgstr "En resumen, la gobernanza es clave para la evoluci√≥n de Starknet."

#: src/ch00-00-introduction.md:118
msgid "To propose an improvement, create a SNIP."
msgstr "Para proponer una mejora, cree un SNIP."

#: src/ch00-00-introduction.md:120
msgid "### SNIP: Starknet Improvement Proposals"
msgstr "### SNIP: Starknet Improvement Proposals"

#: src/ch00-00-introduction.md:122
msgid ""
"SNIP is short for Starknet Improvement Proposal. It‚Äôs essentially a\n"
"blueprint that details proposed enhancements or changes to the Starknet\n"
"ecosystem. A well-crafted SNIP includes both the technical\n"
"specifications of the change and the reasons behind it. If you‚Äôre\n"
"proposing a SNIP, it‚Äôs your job to rally community support and document\n"
"any objections (more details\n"
"[here](https://community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2)).\n"
"Once a SNIP is approved, it becomes a part of the Starknet protocol. All\n"
"the SNIPs can be found in [this\n"
"repository](https://github.com/starknet-io/SNIPs)."
msgstr ""
"SNIP es la abreviatura de Starknet Improvement Proposal. Es esencialmente un\n"
"plano que detalla las mejoras o cambios propuestos en el ecosistema de\n"
"Starknet. Un SNIP bien elaborado incluye tanto los aspectos t√©cnicos\n"
"especificaciones del cambio y las razones detr√°s del mismo. Si est√°s\n"
"proponiendo un SNIP, es su trabajo conseguir el apoyo de la comunidad y documentar\n"
"cualquier objeci√≥n (m√°s detalles\n"
"[aqu√≠](https://community.starknet.io/t/draft-simp-1-simp-Purpose-and-guidelines/1197#what-is-a-snip-2)).\n"
"Una vez que se aprueba un SNIP, pasa a formar parte del protocolo Starknet. Todos\n"
"los SNIP se pueden encontrar en [este\n"
"repositorio](https://github.com/starknet-io/SNIPs)."

#: src/ch00-00-introduction.md:133
msgid "SNIPs serve three crucial roles:"
msgstr "Los SNIP cumplen tres funciones cruciales:"

#: src/ch00-00-introduction.md:135
msgid ""
"1.  They are the main avenue for proposing new features or changes.\n"
"\n"
"2.  They act as a platform for technical discussions within the\n"
"    community.\n"
"\n"
"3.  They document the decision-making process, offering a historical\n"
"    view of how Starknet has evolved."
msgstr ""
"1. Son la v√≠a principal para proponer nuevas caracter√≠sticas o cambios.\n"
"\n"
"2. Act√∫an como plataforma para discusiones t√©cnicas dentro de la\n"
"    comunidad.\n"
"\n"
"3. Documentan el proceso de toma de decisiones y ofrecen una visi√≥n\n"
"    hist√≥rica de c√≥mo ha evolucionado Starknet."

#: src/ch00-00-introduction.md:143
msgid ""
"Because SNIPs are stored as text files in a [version-controlled\n"
"repository](https://github.com/starknet-io/SNIPs), you can easily track\n"
"changes and understand the history of proposals."
msgstr ""
"Debido a que los SNIP se almacenan como archivos de texto en un  [version-controlled\n"
"repository](https://github.com/starknet-io/SNIPs), puede rastrear f√°cilmente los\n"
"cambios y comprender la historia de las propuestas."

#: src/ch00-00-introduction.md:147
msgid ""
"For those who are building on Starknet, SNIPs aren‚Äôt just\n"
"suggestions‚Äîthey‚Äôre a roadmap. It‚Äôs beneficial for implementers to keep\n"
"a list of the SNIPs they‚Äôve executed. This transparency helps users\n"
"gauge the state of a particular implementation or software library."
msgstr ""
"Para aquellos que est√°n construyendo sobre Starknet, los SNIP no son solo\n"
"sugerencias: son una hoja de ruta. Es beneficioso para los implementadores mantener\n"
"una lista de los SNIP que han ejecutado. Esta transparencia ayuda a los usuarios\n"
"medir el estado de una implementaci√≥n o biblioteca de software en particular."

#: src/ch01-00-getting-started.md:1
msgid "# Getting Started"
msgstr "# Primeros Pasos"

#: src/ch01-00-getting-started.md:3
msgid ""
"Starknet is a scalable Layer-2 solution on Ethereum. This guide will walk you through the process of deploying and interacting with your first Starknet smart contract using the Cairo programming "
"language, a language tailored for creating validity proofs and that Starknet uses. For seasoned developers looking to understand the core concepts and get hands-on experience, this guide offers "
"step-by-step instructions and essential details."
msgstr ""
"Starknet es una soluci√≥n escalable de Capa 2 en Ethereum. Esta gu√≠a lo guiar√° a trav√©s del proceso de implementaci√≥n e interacci√≥n con su primer smart contract de Starknet utilizando el lenguaje de "
"programaci√≥n Cairo, un lenguaje dise√±ado para crear pruebas de validez y que utiliza Starknet. Para desarrolladores experimentados que buscan comprender los conceptos b√°sicos y adquirir experiencia "
"pr√°ctica, esta gu√≠a ofrece instrucciones paso a paso y detalles esenciales."

#: src/ch01-00-getting-started.md:5
msgid "We will use the Starknet Remix Plugin to compile, deploy and interact with our smart contract. It is a great tool to get started with Starknet development."
msgstr "Usaremos el complemento Starknet Remix para compilar, implementar e interactuar con nuestro contrato inteligente. Es una gran herramienta para comenzar con el desarrollo de Starknet."

#: src/ch01-00-getting-started.md:7
msgid ""
"1. Visit the [Remix IDE](https://remix.ethereum.org/) website.\n"
"2. Navigate to the ‚ÄòPlugin Manager‚Äô section in the bottom left corner."
msgstr ""
"1. Visite [Remix IDE](https://remix.ethereum.org/).\n"
"2. Navegue hasta la secci√≥n ‚ÄòPlugin Manager‚Äô en la esquina inferior izquierda."

#: src/ch01-00-getting-started.md:10
msgid "<img alt=\"Plugin Manager\" src=\"img/ch01-remix-plugin-manager.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Plugin Manager\" src=\"img/ch01-remix-plugin-manager.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch01-00-getting-started.md:12
msgid "3. Activate the ‚ÄúStarknet‚Äù plugin."
msgstr "3. Active el plugin \"Starknet\"."

#: src/ch01-00-getting-started.md:14
msgid "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch01-00-getting-started.md:16
msgid "4. Accept the permissions. Click \"Remember my choice\" to avoid this step in the future."
msgstr "4. Acepta los permisos. Haga clic en \"Remember my choice\" para evitar este paso en el futuro."

#: src/ch01-00-getting-started.md:18
msgid "<img alt=\"Accept Permissions\" src=\"img/ch01-remix-permission-box.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Accept Permissions\" src=\"img/ch01-remix-permission-box.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch01-00-getting-started.md:20
msgid "5. After enabling, the Starknet logo appears on the left sidebar. Click it to interact with opened Cairo files."
msgstr "5. Despu√©s de habilitarlo, el logotipo de Starknet aparece en la barra lateral izquierda. Haga clic en √©l para interactuar con los archivos abiertos de Cairo."

#: src/ch01-00-getting-started.md:22
msgid "<img alt=\"Starknet Plugin\" src=\"img/ch01-remix-starknet-plugin-icon.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />"
msgstr "<img alt=\"Starknet Plugin\" src=\"img/ch01-remix-starknet-plugin-icon.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />"

#: src/ch01-00-getting-started.md:24
msgid "## Introduction to Starknet Smart Contracts"
msgstr "## Introducci√≥n a los Smart Contracts de Starknet"

#: src/ch01-00-getting-started.md:26
msgid "The script below is a simple `Ownable` contract pattern written in Cairo for Starknet. It features:"
msgstr "El siguiente script es un patr√≥n de contrato simple `Ownable` escrito en Cairo para Starknet. Cuenta con:"

#: src/ch01-00-getting-started.md:28
msgid ""
"- An ownership system.\n"
"- A method to transfer ownership.\n"
"- A method to check the current owner.\n"
"- An event notification for ownership changes."
msgstr ""
"- Un sistema de propiedad.\n"
"- Un m√©todo para transferir la propiedad (ownership).\n"
"- Un m√©todo para comprobar el propietario (owner) actual.\n"
"- Una notificaci√≥n de evento para cambios de propiedad."

#: src/ch01-00-getting-started.md:33
msgid "### Cairo Example Contract"
msgstr "### Contrato de Ejemplo de Cairo"

#: src/ch01-00-getting-started.md:35
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait OwnableTrait<T> {\n"
"    fn transfer_ownership(ref self: T, new_owner: ContractAddress);\n"
"    fn get_owner(self: @T) -> ContractAddress;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Ownable {\n"
"    use super::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"      OwnershipTransferred1: OwnershipTransferred1,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred1 {\n"
"        #[key]\n"
"        prev_owner: ContractAddress,\n"
"        #[key]\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_owner: ContractAddress) {\n"
"        self.owner.write(init_owner);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl of super::OwnableTrait<ContractState> {\n"
"        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {\n"
"            self.only_owner();\n"
"            let prev_owner = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {\n"
"                prev_owner: prev_owner,\n"
"                new_owner: new_owner,\n"
"            }));\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateMethods of PrivateMethodsTrait {\n"
"        fn only_owner(self: @ContractState) {\n"
"            let caller = get_caller_address();\n"
"            assert(caller == self.owner.read(), 'Caller is not the owner');\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait OwnableTrait<T> {\n"
"    fn transfer_ownership(ref self: T, new_owner: ContractAddress);\n"
"    fn get_owner(self: @T) -> ContractAddress;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Ownable {\n"
"    use super::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"      OwnershipTransferred1: OwnershipTransferred1,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred1 {\n"
"        #[key]\n"
"        prev_owner: ContractAddress,\n"
"        #[key]\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_owner: ContractAddress) {\n"
"        self.owner.write(init_owner);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl of super::OwnableTrait<ContractState> {\n"
"        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {\n"
"            self.only_owner();\n"
"            let prev_owner = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {\n"
"                prev_owner: prev_owner,\n"
"                new_owner: new_owner,\n"
"            }));\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateMethods of PrivateMethodsTrait {\n"
"        fn only_owner(self: @ContractState) {\n"
"            let caller = get_caller_address();\n"
"            assert(caller == self.owner.read(), 'Caller is not the owner');\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:100
msgid "### Components Breakdown"
msgstr "### Desglose de Componentes"

#: src/ch01-00-getting-started.md:102
msgid ""
"The following is a brief description of the components in the contract. We will get into more details when we get deeper into Cairo so feel free to skip this section for now if you are not familiar "
"with smart contract development."
msgstr ""
"La siguiente es una breve descripci√≥n de los componentes del contrato. Entraremos en m√°s detalles cuando profundicemos en El Cairo, as√≠ que no dude en omitir esta secci√≥n por ahora si no est√° "
"familiarizado con el desarrollo de contratos inteligentes."

#: src/ch01-00-getting-started.md:104
msgid ""
"1. **Dependencies and Interface**:\n"
"   - **`starknet::ContractAddress`**: Represents a Starknet contract address.\n"
"   - **`OwnableTrait`**: Specifies functions for transferring and getting ownership.\n"
"2. **Events**:\n"
"   - **`OwnershipTransferred1`**: Indicates ownership change with previous and new owner details.\n"
"3. **Storage**:\n"
"   - **`Storage`**: Holds the contract's state with the current owner's address.\n"
"4. **Constructor**:\n"
"   - Initializes the contract with a starting owner.\n"
"5. **External Functions**:\n"
"   - Functions for transferring ownership and retrieving the current owner's details.\n"
"6. **Private Methods**:\n"
"   - **`only_owner`**: Validates if the caller is the current owner."
msgstr ""
"1. **Dependencias e Interfaz**:\n"
"    - **`starknet::ContractAddress`**: Representa una direcci√≥n de contrato de Starknet.\n"
"    - **`OwnableTrait`**: Especifica funciones para transferir y obtener propiedad.\n"
"2. **Eventos**:\n"
"    - **`OwnershipTransferred1`**: Indica cambio de propiedad con detalles del propietario anterior y nuevo.\n"
"3. **Storage**:\n"
"    - **`Storage`**: Mantiene el estado del contrato con la direcci√≥n del propietario actual.\n"
"4. **Constructor**:\n"
"    - Inicializa el contrato con un owner inicial.\n"
"5. **Funciones Externas**:\n"
"    - Funciones para transferir la propiedad y recuperar los datos del owner actual.\n"
"6. **M√©todos privados**:\n"
"    - **`only_owner`**: Valida si la persona que llama es el owner actual."

#: src/ch01-00-getting-started.md:118
msgid "## Compilation Process"
msgstr "## Proceso de Compilaci√≥n"

#: src/ch01-00-getting-started.md:120
msgid "To compile using Remix:"
msgstr "Para compilar usando Remix:"

#: src/ch01-00-getting-started.md:122
msgid ""
"1. **File Creation**\n"
"\n"
"   - Navigate to the \"File Explorer\" tab in Remix.\n"
"   - Create a new file named `Ownable.cairo` and paste the previous [code](#cairo-example-contract) into it.\n"
"\n"
"2. **Compilation**\n"
"\n"
"   - Choose the `Ownable.cairo` file.\n"
"   - In the \"Starknet\" tab, select \"Compile Ownable.cairo\"."
msgstr ""
"1. **Creaci√≥n de Archivos**\n"
"\n"
"    - Navega a la pesta√±a \"File Explorer\" en Remix.\n"
"    - Cree un nuevo archivo llamado `Ownable.cairo` y pegue el [c√≥digo anterior](#cairo-example-contract) en √©l.\n"
"\n"
"2. **Compilaci√≥n**\n"
"\n"
"    - Elija el archivo `Ownable.cairo`.\n"
"    - En la pesta√±a \"Starknet\", seleccione \"Compilar Ownable.cairo\"."

#: src/ch01-00-getting-started.md:132
msgid ""
"<img  alt=\"Compilation Process\" src=\"img/ch01-compile-contract.png\" class=\"center\"\n"
"style=\"width: 100%;\" />"
msgstr ""
"<img  alt=\"Compilation Process\" src=\"img/ch01-compile-contract.png\" class=\"center\"\n"
"style=\"width: 100%;\" />"

#: src/ch01-00-getting-started.md:135
msgid ""
"- Post-compilation, an \"artifacts\" folder emerges containing the compiled contract in two distinct formats: Sierra (JSON file) and CASM. For Starknet deployment, Remix will use the Sierra file. "
"Do not worry about this process for now; we will cover it in detail in a later chapter. For now, Remix will handle the compilation and deployment for us."
msgstr ""
"- Despu√©s de la compilaci√≥n, aparece una carpeta de \"artifacts\" que contiene el contrato compilado en dos formatos distintos: Sierra (archivo JSON) y CASM. Para la implementaci√≥n de Starknet, "
"Remix utilizar√° el archivo Sierra. No te preocupes por este proceso por ahora; Lo cubriremos en detalle en un cap√≠tulo posterior. Por ahora, Remix se encargar√° de la compilaci√≥n y la implementaci√≥n "
"por nosotros."

#: src/ch01-00-getting-started.md:137
msgid "<img alt=\"Artifacts folder after compilation\" src=\"img/ch01-remix-file.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Artifacts folder after compilation\" src=\"img/ch01-remix-file.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch01-00-getting-started.md:139
msgid "<span class=\"caption\">Artifacts folder after compilation</span>"
msgstr "<span class=\"caption\">Carpeta de artefactos despu√©s de la compilaci√≥n.</span>"

#: src/ch01-00-getting-started.md:141
msgid "## Deployment on the Development Network"
msgstr "## Despliegue en la Red de Desarrollo"

#: src/ch01-00-getting-started.md:143
msgid "To set your smart contract in motion, an initial owner must be defined. The Constructor function needs this information."
msgstr "Para poner en marcha su contrato inteligente, se debe definir un propietario inicial. La funci√≥n Constructor necesita esta informaci√≥n."

#: src/ch01-00-getting-started.md:145
msgid "Here's a step-by-step guide to deploying your smart contract on the development network:"
msgstr "Aqu√≠ hay una gu√≠a paso a paso para implementar su smart contract en la red de desarrollo:"

#: src/ch01-00-getting-started.md:147
msgid ""
"1. **Select the Appropriate Network**\n"
"\n"
"   - In the Starknet tab, click on the top button.\n"
"\n"
"   <img alt=\"Environment selection\" src=\"img/ch01-remix-choose-devnet.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"   - Choose \"Remote Devnet\" for deploying your inaugural contract on a development network.\n"
"\n"
"2. **Choose a Devnet Account**\n"
"\n"
"   - Under \"Devnet account selection\", a list of accounts specific to the chosen devnet is presented.\n"
"\n"
"   <img alt=\"Environment selection\" src=\"img/ch01-remix-remote-devnet.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"   - Pick any account and copy its address.\n"
"\n"
"3. **Initiating Deployment**\n"
"\n"
"   - Input the copied address into the `init_owner` variable.\n"
"\n"
"   <img alt=\"Environment selection\" src=\"img/ch01-remix-deploy-contract.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"   - Click on **\"Deploy\"**."
msgstr ""
"1. **Seleccione la Red Adecuada**\n"
"\n"
"    - En la pesta√±a Starknet, haz clic en el bot√≥n superior.\n"
"\n"
"    <img alt=\"Environment selection\" src=\"img/ch01-remix-choose-devnet.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"    - Elija \"Remote Devnet\" para implementar su contrato inaugural en una red de desarrollo.\n"
"\n"
"2. **Elija una Cuenta Devnet**\n"
"\n"
"    - En \"Devnet account selection\", se presenta una lista de cuentas espec√≠ficas del devnet elegido.\n"
"\n"
"    <img alt=\"Environment selection\" src=\"img/ch01-remix-remote-devnet.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"    - Elija cualquier cuenta y copie su direcci√≥n.\n"
"\n"
"3. **Iniciando Implementaci√≥n**\n"
"\n"
"    - Ingrese la direcci√≥n copiada en la variable `init_owner`.\n"
"\n"
"    <img alt=\"Environment selection\" src=\"img/ch01-remix-deploy-contract.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"    - Haga clic en **\"Deploy\"**."

#: src/ch01-00-getting-started.md:171
msgid "Post-deployment, Remix's terminal will send various logs. These logs provide crucial details, including:"
msgstr "Despu√©s de la implementaci√≥n, la terminal de Remix enviar√° varios registros. Estos registros proporcionan detalles cruciales, que incluyen:"

#: src/ch01-00-getting-started.md:173
msgid ""
"- `transaction_hash`: The unique hash of the transaction. This hash can be used to track the transaction's status.\n"
"- `contract_address`: The address of the deployed contract. Use this address to interact with your contract.\n"
"- `calldata`: Contains the `init_owner` address fed to the constructor."
msgstr ""
"- `transaction_hash`: El hash √∫nico de la transacci√≥n. Este hash se puede utilizar para rastrear el estado de la transacci√≥n.\n"
"- `contract_address`: La direcci√≥n del contrato implementado. Utilice esta direcci√≥n para interactuar con su contrato.\n"
"- `calldata`: Contiene la direcci√≥n `init_owner` enviada al constructor."

#: src/ch01-00-getting-started.md:177
msgid ""
"```bash\n"
"{\n"
"  \"transaction_hash\": \"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": \"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x1398224729985f8e76571285c6d936b5af4a88206a1dc54c0658b4e15045292\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"transaction_hash\": \"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": \"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x1398224729985f8e76571285c6d936b5af4a88206a1dc54c0658b4e15045292\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:189
msgid "By following the above process, you successfully deploy your smart contract on the development network."
msgstr "Si sigue el proceso anterior, implementar√° con √©xito su contrato inteligente en la red de desarrollo."

#: src/ch01-00-getting-started.md:191
msgid "## Interaction with the Contract"
msgstr "## Interacci√≥n con el Contrato"

#: src/ch01-00-getting-started.md:193
msgid "With the contract now active on the development network, interaction becomes possible. Here's a guide to effectively interact with your contract on Starknet:"
msgstr "Con el contrato ahora activo en la red de desarrollo, la interacci√≥n se hace posible. Aqu√≠ hay una gu√≠a para interactuar efectivamente con su contrato en Starknet:"

#: src/ch01-00-getting-started.md:195
msgid ""
"1. **Initiating Interaction**\n"
"\n"
"   - Navigate to the \"Starknet\" plugin tab.\n"
"   - Select the \"Interact\" option.\n"
"\n"
"2. **Calling the `get_owner` Function**\n"
"\n"
"   - Choose the `get_owner` function. Since this function doesn't require arguments, the calldata field remains blank. (This is a read function, hence calling it is termed as a \"call\".)\n"
"\n"
"   <img alt=\"Environment selection\" src=\"img/ch01-remix-interact.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"   - Press the **\"Call\"** button. Your terminal will display the result, revealing the owner's address provided during the contract's deployment as calldata for the constructor:"
msgstr ""
"1. **Iniciando Interacci√≥n**\n"
"\n"
"    - Vaya a la pesta√±a del complemento \"Starknet\".\n"
"    - Selecciona la opci√≥n \"Interact\".\n"
"\n"
"2. **Llamar a la funci√≥n `get_owner`**\n"
"\n"
"    - Elija la funci√≥n `get_owner`. Como esta funci√≥n no requiere argumentos, el campo calldata permanece en blanco. (Esta es una funci√≥n de lectura, por lo que llamarla se denomina \"call\").\n"
"\n"
"    <img alt=\"Environment selection\" src=\"img/ch01-remix-interact.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />\n"
"\n"
"    - Presione el bot√≥n **\"Call\"**. Su terminal mostrar√° el resultado, revelando la direcci√≥n del propietario proporcionada durante la implementaci√≥n del contrato como datos de llamada para el "
"constructor:"

#: src/ch01-00-getting-started.md:208
msgid ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x1398224729985f8e76571285c6d936b5af4a88206a1dc54c0658b4e15045292\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x1398224729985f8e76571285c6d936b5af4a88206a1dc54c0658b4e15045292\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:220
msgid "This call currently doesn't spend gas because the function does not change the state of the contract."
msgstr "Esta llamada actualmente no gasta gasolina porque la funci√≥n no cambia el estado del contrato."

#: src/ch01-00-getting-started.md:222
msgid "3. **Invoking the `transfer_ownership` Function**"
msgstr "3. **Invocando la funci√≥n `transfer_ownership`**"

#: src/ch01-00-getting-started.md:224
msgid "- Choose the **\"Write\"** in the interaction area. Here you can see the functions that alter the contract's state."
msgstr "- Elija **\"Write\"** en el √°rea de interacci√≥n. Aqu√≠ puedes ver las funciones que alteran el estado del contrato."

#: src/ch01-00-getting-started.md:226
msgid "<img alt=\"Environment selection\" src=\"img/ch01-remix-write-interaction.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />"
msgstr "<img alt=\"Environment selection\" src=\"img/ch01-remix-write-interaction.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />"

#: src/ch01-00-getting-started.md:228
msgid ""
"- In this case **`transfer_ownership`** function, which requires the new owner's address as input.\n"
"- Enter this address into the calldata field. (For this, use any address from the \"Devnet account selection\" listed in the Environment tab.)\n"
"- Click the **\"Call\"** button. The terminal then showcases the transaction hash indicating the contract's state alteration. Since we are altering the contract's state this typo of interaction is "
"called an \"invoke\" and needs to be signed by the account that is calling the function."
msgstr ""
"- En este caso, la funci√≥n **`transfer_ownership`**, que requiere la direcci√≥n del nuevo propietario como entrada.\n"
"- Ingrese esta direcci√≥n en el campo de datos de llamada. (Para esto, use cualquier direcci√≥n de la \"Devnet account selection\" que aparece en la pesta√±a Entorno).\n"
"- Haga clic en el bot√≥n **\"Call\"**. Luego, la terminal muestra el hash de la transacci√≥n que indica la alteraci√≥n del estado del contrato. Dado que estamos alterando el estado del contrato, este "
"tipo de interacci√≥n se denomina \"invoke\" y debe ser firmado por la cuenta que llama a la funci√≥n."

#: src/ch01-00-getting-started.md:232
msgid ""
"For these transactions, the terminal logs will exhibit a \"status\" variable, indicating the transaction's fate. If the status reads \"ACCEPTED_ON_L2\", the Sequencer has accepted the transaction, "
"pending block inclusion. However, a \"REJECTED\" status signifies the Sequencer's disapproval, and the transaction won't feature in the upcoming block. More often than not, this transaction gains "
"acceptance, leading to a contract state modification. On calling the **`get_owner`** function again we get this:"
msgstr ""
"Para estas transacciones, los registros de la terminal mostrar√°n una variable de \"status\", que indica el destino de la transacci√≥n. Si el estado es \"ACCEPTED_ON_L2\", el secuenciador ha aceptado "
"la transacci√≥n, pendiente de inclusi√≥n del bloque. Sin embargo, un estado \"REJECTED\" significa la desaprobaci√≥n del secuenciador y la transacci√≥n no aparecer√° en el siguiente bloque. La mayor√≠a "
"de las veces, esta transacci√≥n obtiene aceptaci√≥n, lo que lleva a una modificaci√≥n del estado del contrato. Al llamar nuevamente a la funci√≥n **`get_owner`** obtenemos esto:"

#: src/ch01-00-getting-started.md:234
msgid ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:246
msgid "You've now adeptly compiled, deployed, and interacted with your inaugural Starknet smart contract. Well done!"
msgstr "Ahora ha compilado, implementado e interactuado h√°bilmente con su contrato inteligente inaugural de Starknet. ¬°Bien hecho!"

#: src/ch01-00-getting-started.md:248
msgid "## Deploying on Starknet Testnet"
msgstr "## Implementaci√≥n en Starknet Testnet"

#: src/ch01-00-getting-started.md:250
msgid ""
"After testing your smart contract on a development network, it's time to deploy it to the Starknet Testnet. Starknet Testnet is a public platform available for everyone, ideal for testing smart "
"contracts and collaborating with fellow developers."
msgstr ""
"Despu√©s de probar su contrato inteligente en una red de desarrollo, es hora de implementarlo en Starknet Testnet. Starknet Testnet es una plataforma p√∫blica disponible para todos, ideal para probar "
"contratos inteligentes y colaborar con otros desarrolladores."

#: src/ch01-00-getting-started.md:252
msgid "First you need to create a Starknet account."
msgstr "Primero necesitas crear una cuenta Starknet."

#: src/ch01-00-getting-started.md:254
msgid "### Smart Wallet Setup"
msgstr "### Configuraci√≥n de Smart Wallet"

#: src/ch01-00-getting-started.md:256
msgid ""
"Before deploying your smart contract to Starknet, you must handle the transaction cost. While deploying to the Starknet Goerli Testnet is free, a smart wallet account is essential. You can set up a "
"smart wallet using either:"
msgstr ""
"Antes de implementar su smart contract en Starknet, debe manejar el costo de la transacci√≥n. Si bien la implementaci√≥n en Starknet Goerli Testnet es gratuita, una cuenta de billetera inteligente es "
"esencial. Puede configurar una billetera inteligente usando:"

#: src/ch01-00-getting-started.md:258
msgid ""
"- [Argent](https://www.argent.xyz/argent-x/)\n"
"- [Braavos](https://braavos.app/)"
msgstr ""
"- [Argent](https://www.argent.xyz/argent-x/)\n"
"- [Braavos](https://braavos.app/)"

#: src/ch01-00-getting-started.md:261
msgid ""
"Both are reliable Starknet wallets offering enhanced security and accessibility features thanks to the possibilities that the Cairo VM brings, such as Account Abstraction (keep reading the Book for "
"more on this)."
msgstr ""
"Ambas son billeteras Starknet confiables que ofrecen caracter√≠sticas mejoradas de seguridad y accesibilidad gracias a las posibilidades que ofrece Cairo VM, como Account Abstraction (siga leyendo "
"el libro para obtener m√°s informaci√≥n sobre esto)."

#: src/ch01-00-getting-started.md:263
msgid ""
"1. Install the recommended chrome/brave extension for your chosen wallet.\n"
"2. Follow your wallet provider's instructions to deploy your account.\n"
"3. Use the [Starknet Faucet](https://faucet.goerli.starknet.io/) to fund your account.\n"
"4. Deploy the account to the network. This usually takes around 10 seconds."
msgstr ""
"1. Instale la extensi√≥n Chrome/Brave recomendada para su wallet elegida.\n"
"2. Siga las instrucciones de su proveedor de billetera para implementar su cuenta.\n"
"3. Utilice [Starknet Faucet](https://faucet.goerli.starknet.io/) para depositar fondos en su cuenta.\n"
"4. Implemente la cuenta en la red. Esto suele tardar unos 10 segundos."

#: src/ch01-00-getting-started.md:268
msgid "Once set up, you're ready to deploy your smart contracts to the Starknet Testnet."
msgstr "Una vez configurado, estar√° listo para implementar sus contratos inteligentes en Starknet Testnet."

#: src/ch01-00-getting-started.md:270
msgid "### Deployment and Interaction"
msgstr "### Despliegue e Interacci√≥n"

#: src/ch01-00-getting-started.md:272
msgid ""
"1. Follow the previous deployment steps.\n"
"2. In the 'Environment selection' tab, choose 'Wallet'.\n"
"3. Select your Starknet account and continue with deploying and interacting with your contract."
msgstr ""
"1. Siga los pasos de implementaci√≥n anteriores.\n"
"2. En la pesta√±a 'Environment selection', elija 'Wallet'.\n"
"3. Seleccione su cuenta Starknet y contin√∫e con la implementaci√≥n e interactuando con su contrato."

#: src/ch01-00-getting-started.md:276
msgid "<img alt=\"Environment selection\" src=\"img/ch01-remix-wallet.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />"
msgstr "<img alt=\"Environment selection\" src=\"img/ch01-remix-wallet.png\" class=\"center\" style=\"width: 100%; max-width: 300px;\" />"

#: src/ch01-00-getting-started.md:278
msgid "You can monitor transaction hashes and addresses using any Starknet block explorers like:"
msgstr "Puede monitorear los hashes y las direcciones de las transacciones utilizando cualquier explorador de bloques de Starknet como:"

#: src/ch01-00-getting-started.md:280
msgid ""
"- [Starkscan](https://testnet.starkscan.co/)\n"
"- [Voyager](https://goerli.voyager.online/)\n"
"- [ViewBlock](https://viewblock.io.starknet/)\n"
"- [oklink](https://www.oklink.com/starknet)"
msgstr ""
"- [Starkscan](https://testnet.starkscan.co/)\n"
"- [Voyager](https://goerli.voyager.online/)\n"
"- [ViewBlock](https://viewblock.io.starknet/)\n"
"- [oklink](https://www.oklink.com/starknet)"

#: src/ch01-00-getting-started.md:285
msgid ""
"These tools provide a visual representation of transactions and contract state alterations. Notably, when you alter the contract ownership using the `transfer_ownership` function, the event emitted "
"by the contract appears in the block explorer. It's an effective method to track contract events."
msgstr ""
"Estas herramientas proporcionan una representaci√≥n visual de las transacciones y las alteraciones del estado del contrato. En particular, cuando modifica la propiedad del contrato utilizando la "
"funci√≥n `transfer_ownership`, el evento emitido por el contrato aparece en el explorador de bloques. Es un m√©todo eficaz para realizar un seguimiento de los eventos del contrato."

#: src/ch01-00-getting-started.md:287
msgid "## Your Next Steps"
msgstr "## Tus Pr√≥ximos Pasos"

#: src/ch01-00-getting-started.md:289
msgid "Decide your direction from the following choices:"
msgstr "Decide tu direcci√≥n entre las siguientes opciones:"

#: src/ch01-00-getting-started.md:291
msgid ""
"1. **Deepen Your Starknet Knowledge**: For an extensive grasp of Starknet's inner workings and potential use cases, delve into Chapter 3 of the Starknet Book. This chapter details Starknet‚Äôs "
"architectural nuances. Then go ahead from there.\n"
"\n"
"2. **Dive into Cairo**: If you're more attuned to coding and wish to craft Starknet contracts, then Cairo is essential. It stands as Starknet's core contract language. Begin with Chapters 1-6 of "
"the [Cairo Book](https://book.cairo-lang.org/title-page.html), ranging from basics in _Getting Started_ to more advanced aspects such as _Enums and Pattern Matching_. Conclude by navigating to the "
"[Starknet Smart Contracts chapter](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html), ensuring you have a well-rounded understanding."
msgstr ""
"1. **Profundice su conocimiento de Starknet**: Para obtener una comprensi√≥n amplia del funcionamiento interno de Starknet y los posibles casos de uso, profundice en el Cap√≠tulo 3 del Libro de "
"Starknet. Este cap√≠tulo detalla los matices arquitect√≥nicos de Starknet. Entonces contin√∫a desde all√≠.\n"
"\n"
"2. **Sum√©rgete en Cairo**: Si est√°s m√°s familiarizado con la codificaci√≥n y deseas crear contratos de Starknet, entonces Cairo es esencial. Es el lenguaje contractual central de Starknet. Comience "
"con los cap√≠tulos 1 a 6 del [Libro de Cairo](https://book.cairo-lang.org/title-page.html), que van desde conceptos b√°sicos de _Introducci√≥n_ hasta aspectos m√°s avanzados como _Enums y Pattern "
"Matching_. Concluya navegando al [cap√≠tulo Smart Contracts de Starknet](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html), asegur√°ndose de tener una comprensi√≥n completa."

#: src/ch02-00-starknet-tooling.md:1
msgid "# Starknet Tooling"
msgstr "# Herramientas en Starknet"

#: src/ch02-00-starknet-tooling.md:3 src/ch02-03-scarb.md:3
msgid ""
"To make the most of this chapter, a basic grasp of the Cairo programming\n"
"language is advised. We suggest reading chapters 1-6 of the [Cairo\n"
"Book](https://book.cairo-lang.org/title-page.html), covering topics from\n"
"_Getting Started_ to _Enums and Pattern Matching._ Follow this by\n"
"studying the [Starknet Smart Contracts\n"
"chapter](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)\n"
"in the same book. With this background, you‚Äôll be well-equipped to\n"
"understand the examples presented here."
msgstr ""
"Para aprovechar al m√°ximo este cap√≠tulo, se necesita una comprensi√≥n b√°sica de la programaci√≥n de Cairo.\n"
"Sugerimos leer los cap√≠tulos 1-6 del [El Libro de Cairo\n"
"](https://book.cairo-lang.org/title-page.html), que cubre temas de\n"
"_Comenzando_ a _Enums y Pattern Matching._ Siga esto\n"
"estudiando los [Smart Contract de Starknet\n"
"cap√≠tulo](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)\n"
"en el mismo libro. Con estos antecedentes, estar√° bien equipado para\n"
"entender los ejemplos presentados aqu√≠."

#: src/ch02-00-starknet-tooling.md:12
msgid ""
"Today, Starknet provides all essential tools for building decentralized\n"
"applications (dApps), compatible with multiple languages like\n"
"JavaScript, Rust, and Python. You can use the Starknet SDK for\n"
"development. Front-end developers can use Starknet.js with React, while\n"
"Rust and Python work well for back-end tasks."
msgstr ""
"Hoy, Starknet proporciona todas las herramientas esenciales para construir aplicaciones descentralizadas\n"
" (dApps), compatibles con m√∫ltiples idiomas como\n"
"JavaScript, Rust y Python. Puede utilizar el SDK de Starknet para\n"
"desarrollar. Los desarrolladores front-end pueden usar Starknet.js con React, mientras\n"
"Rust y Python funcionan bien para tareas de back-end."

#: src/ch02-00-starknet-tooling.md:18
msgid ""
"We welcome contributors to enhance existing tools or develop new\n"
"solutions."
msgstr ""
"Damos la bienvenida a los contribuyentes para mejorar las herramientas existentes o desarrollar nuevas\n"
"soluciones."

#: src/ch02-00-starknet-tooling.md:21
msgid "In this chapter, you‚Äôll explore:"
msgstr "En este cap√≠tulo, explorar√°:"

#: src/ch02-00-starknet-tooling.md:23
msgid ""
"- **Frameworks:** Build using Starknet-Foundry\n"
"\n"
"- **SDKs:** Discover multi-language support through Starknet.js,\n"
"  Starknet-rs, Starknet_py, and Caigo\n"
"\n"
"- **Front-end Development:** Use Starknet.js and React\n"
"\n"
"- **Testing:** Understand testing methods with Starknet-Foundry and the Devnet"
msgstr ""
"- **Frameworks:** Construir usando Starknet-Foundry\n"
"\n"
"- **SDK:** Descubra la compatibilidad con varios idiomas a trav√©s de Starknet.js,\n"
"   Starknet-rs, Starknet_py y Caigo\n"
"\n"
"- **Desarrollo front-end:** Utilice Starknet.js y React\n"
"\n"
"- **Pruebas:** Comprender los m√©todos de prueba con Starknet-Foundry y Devnet"

#: src/ch02-00-starknet-tooling.md:32
msgid ""
"By chapter‚Äôs end, you‚Äôll have a complete grasp of Starknet‚Äôs toolset,\n"
"enabling efficient dApp development."
msgstr ""
"Al final del cap√≠tulo, tendr√° una comprensi√≥n completa del conjunto de herramientas de Starknet,\n"
"permitiendo el desarrollo eficiente de dApps."

#: src/ch02-00-starknet-tooling.md:35
msgid ""
"Here‚Äôs a quick rundown of the tools that could be used for Starknet\n"
"development and that we‚Äôll cover in this chapter:"
msgstr ""
"Aqu√≠ hay un resumen r√°pido de las herramientas que podr√≠an usarse para \n"
"el desarrollo de Starknet y que cubriremos en este cap√≠tulo:"

#: src/ch02-00-starknet-tooling.md:38
msgid ""
"1.  **Scarb:** A package manager that compiles your contracts.\n"
"\n"
"2.  **Starkli:** A CLI tool for interacting with the Starknet network.\n"
"\n"
"3.  **Starknet Foundry:** For contract testing.\n"
"\n"
"4.  **Katana:** Creates a local test node.\n"
"\n"
"5.  **SDKs:** starknet.js, Starknet.py, and starknet.rs interface with\n"
"    Starknet using common programming languages.\n"
"\n"
"6.  **Starknet-react:** Builds front-end apps using React."
msgstr ""
"1. **Scarb:** Un administrador de paquetes que compila tus contratos.\n"
"\n"
"2. **Starkli:** Una herramienta CLI para interactuar con la red Starknet.\n"
"\n"
"3. **Starknet Foundry:** Para pruebas por contrato.\n"
"\n"
"4. **Katana:** Crea un nodo de prueba local.\n"
"\n"
"5. **SDK:** interfaz starknet.js, Starknet.py y starknet.rs con\n"
"     Starknet utilizando lenguajes de programaci√≥n comunes.\n"
"\n"
"6. **Starknet-react:** Crea aplicaciones front-end usando React."

#: src/ch02-01-basic-installation.md:1 src/ch02-03-scarb.md:34 src/ch02-09-starknet-js.md:13
msgid "# Installation"
msgstr "# Instalaci√≥n"

#: src/ch02-01-basic-installation.md:3
msgid ""
"This chapter walks you through setting up your Starknet development\n"
"tools."
msgstr ""
"Este cap√≠tulo lo guiar√° a trav√©s de la configuraci√≥n de sus herramientas\n"
"de desarrollo en Starknet."

#: src/ch02-01-basic-installation.md:6
msgid "Essential tools to install:"
msgstr "Herramientas esenciales para instalar:"

#: src/ch02-01-basic-installation.md:8
msgid ""
"1.  [Starkli](https://github.com/xJonathanLEI/starkli) - A CLI tool for\n"
"    interacting with Starknet. More tools are discussed in Chapter 2.\n"
"\n"
"2.  [Scarb](https://github.com/software-mansion/scarb) - Cairo‚Äôs package\n"
"    manager that compiles code to Sierra, a mid-level language between\n"
"    Cairo and CASM.\n"
"\n"
"3.  [Katana](https://github.com/dojoengine/dojo) - Katana is a Starknet node, built for local development."
msgstr ""
"1. [Starkli](https://github.com/xJonathanLEI/starkli): Una herramienta CLI para\n"
"     interactuar con Starknet. Se analizan m√°s herramientas en el Cap√≠tulo 2.\n"
"\n"
"2. [Scarb](https://github.com/software-mansion/scarb) - Paquete de Cairo\n"
"     administrador que compila c√≥digo para Sierra, un lenguaje de nivel medio entre\n"
"     Cairo y CASM.\n"
"\n"
"3. [Katana](https://github.com/dojoengine/dojo) - Katana es un nodo de Starknet, creado para el desarrollo local."

#: src/ch02-01-basic-installation.md:17
msgid ""
"For support or queries, visit our [GitHub\n"
"Issues](https://github.com/starknet-edu/starknetbook/issues) or contact\n"
"espejelomar on Telegram."
msgstr ""
"Para soporte o consultas, visite nuestro [GitHub\n"
"Issues](https://github.com/starknet-edu/starknetbook/issues) o p√≥ngase en contacto\n"
"espejelomar en Telegram."

#: src/ch02-01-basic-installation.md:21
msgid "## Starkli Installation"
msgstr "## Instalaci√≥n de Starkli"

#: src/ch02-01-basic-installation.md:23
msgid ""
"Easily install Starkli using Starkliup, an installer invoked through the\n"
"command line."
msgstr ""
"Instale Starkli f√°cilmente usando Starkliup, un instalador que se invoca\n"
"a trav√©s de la l√≠nea de comando."

#: src/ch02-01-basic-installation.md:26
msgid ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"
msgstr ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"

#: src/ch02-01-basic-installation.md:31
msgid "Restart your terminal and confirm installation:"
msgstr "Reinicia tu terminal y confirma la instalaci√≥n:"

#: src/ch02-01-basic-installation.md:33
msgid ""
"```bash\n"
"starkli --version\n"
"```"
msgstr ""
"```bash\n"
"starkli --version\n"
"```"

#: src/ch02-01-basic-installation.md:37
msgid "To upgrade Starkli, simply repeat the steps."
msgstr "Para actualizar Starkli, simplemente repita los pasos."

#: src/ch02-01-basic-installation.md:39
msgid "## Scarb Package Manager Installation"
msgstr "## Instalaci√≥n del Administrador de Paquetes Scarb"

#: src/ch02-01-basic-installation.md:41
msgid "We will get deeper into Scarb later in this chapter. For now, we will go over the installation process."
msgstr "Profundizaremos en Scarb m√°s adelante en este cap√≠tulo. Por ahora, repasaremos el proceso de instalaci√≥n."

#: src/ch02-01-basic-installation.md:43
msgid "For macOS and Linux:"
msgstr "Para macOS y Linux:"

#: src/ch02-01-basic-installation.md:45 src/ch04-02-hello-account.md:23 src/ch04-03-standard-account.md:17
msgid ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"

#: src/ch02-01-basic-installation.md:49
msgid ""
"For Windows, follow manual setup in the [Scarb\n"
"documentation](https://docs.swmansion.com/scarb/download.html#windows)."
msgstr ""
"Para Windows, siga la configuraci√≥n manual en [Scarb\n"
"Documentation](https://docs.swmansion.com/scarb/download.html#windows)."

#: src/ch02-01-basic-installation.md:52
msgid "Restart the terminal and run:"
msgstr "Reinicie la terminal y ejecute:"

#: src/ch02-01-basic-installation.md:54 src/ch04-02-hello-account.md:17 src/ch04-03-standard-account.md:11
msgid ""
"```bash\n"
"scarb --version\n"
"```"
msgstr ""
"```bash\n"
"scarb --version\n"
"```"

#: src/ch02-01-basic-installation.md:58
msgid "To upgrade Scarb, rerun the installation command."
msgstr "Para actualizar Scarb, vuelva a ejecutar el comando de instalaci√≥n."

#: src/ch02-01-basic-installation.md:60
msgid "## Katana Node Installation"
msgstr "## Instalaci√≥n del Nodo Katana"

#: src/ch02-01-basic-installation.md:62 src/ch02-04-katana.md:36
msgid "To install Katana, use the `dojoup` installer from the command line:"
msgstr "Para instalar Katana, use el instalador `dojoup` desde la l√≠nea de comando:"

#: src/ch02-01-basic-installation.md:64 src/ch02-04-katana.md:38
msgid ""
"```bash\n"
"curl -L https://install.dojoengine.org | bash\n"
"dojoup\n"
"```"
msgstr ""
"```bash\n"
"curl -L https://install.dojoengine.org | bash\n"
"dojoup\n"
"```"

#: src/ch02-01-basic-installation.md:69 src/ch02-04-katana.md:43
msgid "After restarting your terminal, verify the installation with:"
msgstr "Despu√©s de reiniciar tu terminal, verifica la instalaci√≥n con:"

#: src/ch02-01-basic-installation.md:71 src/ch02-04-katana.md:45
msgid ""
"```bash\n"
"katana --version\n"
"```"
msgstr ""
"```bash\n"
"katana --version\n"
"```"

#: src/ch02-01-basic-installation.md:75 src/ch02-04-katana.md:49
msgid "To upgrade Katana, rerun the installation command."
msgstr "Para actualizar Katana, vuelva a ejecutar el comando de instalaci√≥n."

#: src/ch02-01-basic-installation.md:77
msgid "You are now set to code in Cairo and deploy to Starknet."
msgstr "Ahora est√° configurado para codificar en Cairo y realizar la implementaci√≥n en Starknet."

#: src/ch02-02-starkli-scarb-katana.md:1
msgid "# Introduction to Starkli, Scarb and Katana"
msgstr "# Introducci√≥n a Starkli, Scarb y Katana"

#: src/ch02-02-starkli-scarb-katana.md:3
msgid ""
"In this chapter, you‚Äôll learn how to compile, deploy, and interact with\n"
"a Starknet smart contract written in Cairo using starkli, scarb and katana."
msgstr ""
"En este cap√≠tulo, aprender√° c√≥mo compilar, implementar e interactuar con\n"
"un smart contract de Starknet escrito en El Cairo usando Starkli, Scarb y Katana."

#: src/ch02-02-starkli-scarb-katana.md:6
msgid ""
"First, confirm that the following commands work on your system. If they\n"
"don‚Äôt, refer to Basic Installation in this chapter."
msgstr ""
"Primero, confirme que los siguientes comandos funcionan en su sistema. Si no es\n"
"as√≠, consulte Instalaci√≥n b√°sica en este cap√≠tulo."

#: src/ch02-02-starkli-scarb-katana.md:9
msgid ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"    katana --version # To declare and deploy on local development\n"
"```"
msgstr ""
"```bash\n"
"     scarb --version # Para la compilaci√≥n del c√≥digo Cairo\n"
"     starkli --version # Para interactuar con Starknet\n"
"     katana --version # Para declarar y desplegar en el desarrollo local\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:15
msgid "## Crafting a Starknet Smart Contract"
msgstr "## Elaboraci√≥n de un Smart Contract en Starknet"

#: src/ch02-02-starkli-scarb-katana.md:17
msgid "**Important:** Before we proceed with this example, please ensure that the versions of both `katana` and `starkli` match the specified versions provided below."
msgstr "**Importante:** Antes de continuar con este ejemplo, aseg√∫rese de que las versiones de `katana` y `starkli` coincidan con las versiones especificadas que se proporcionan a continuaci√≥n."

#: src/ch02-02-starkli-scarb-katana.md:19
msgid ""
"```console\n"
"    katana --version  # 0.4.4\n"
"    starkli --version  # 0.1.20 (e4d2307)\n"
"```"
msgstr ""
"```console\n"
"    katana --version  # 0.4.4\n"
"    starkli --version  # 0.1.20 (e4d2307)\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:24
msgid "Now begin by initiating a Scarb project:"
msgstr "Ahora comience iniciando un proyecto Scarb:"

#: src/ch02-02-starkli-scarb-katana.md:26
msgid ""
"```bash\n"
"scarb new my_contract\n"
"```"
msgstr ""
"```bash\n"
"scarb new my_contract\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:30
msgid "## Configure Environment Variables and the `Scarb.toml` File"
msgstr "## Configurar Variables de Entorno y el Archivo `Scarb.toml`"

#: src/ch02-02-starkli-scarb-katana.md:32
msgid "Review the `my_contract` project. Its structure appears as:"
msgstr "Revise el proyecto `my_contract`. Su estructura aparece como:"

#: src/ch02-02-starkli-scarb-katana.md:34
msgid ""
"```bash\n"
"    src/\n"
"      lib.cairo\n"
"    .gitignore\n"
"    Scarb.toml\n"
"```"
msgstr ""
"```bash\n"
"    src/\n"
"      lib.cairo\n"
"    .gitignore\n"
"    Scarb.toml\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:41
msgid "Amend the `Scarb.toml` file to integrate the `starknet` dependency and introduce the `starknet-contract` target:"
msgstr "Modifique el archivo `Scarb.toml` para integrar la dependencia `starknet` e introduzca el objetivo `starknet-contract`:"

#: src/ch02-02-starkli-scarb-katana.md:43
msgid ""
"```toml\n"
"    [dependencies]\n"
"    starknet = \">=2.3.0\"\n"
"\n"
"    [[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"    [dependencies]\n"
"    starknet = \">=2.3.0\"\n"
"\n"
"    [[target.starknet-contract]]\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:50
msgid "For streamlined Starkli command execution, establish environment variables. Two primary variables are essential:"
msgstr "Para una ejecuci√≥n optimizada del comando Starkli, establezca variables de entorno. Dos variables principales son esenciales:"

#: src/ch02-02-starkli-scarb-katana.md:52
msgid ""
"- One for your account, a pre-funded account on the local development network\n"
"- Another for designating the network, specifically the local katana devnet"
msgstr ""
"- Una para su cuenta, una cuenta prefinanciada en la red de desarrollo local\n"
"- Otro para designar la red, espec√≠ficamente el katana devnet local"

#: src/ch02-02-starkli-scarb-katana.md:55
msgid "In the `src/` directory, create a `.env` file with the following:"
msgstr "En el directorio `src/`, cree un archivo `.env` con lo siguiente:"

#: src/ch02-02-starkli-scarb-katana.md:57
msgid ""
"```bash\n"
"export STARKNET_ACCOUNT=katana-0\n"
"export STARKNET_RPC=http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"export STARKNET_ACCOUNT=katana-0\n"
"export STARKNET_RPC=http://0.0.0.0:5050\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:62
msgid "These settings streamline Starkli command operations."
msgstr "Estas configuraciones agilizan las operaciones de comando de Starkli."

#: src/ch02-02-starkli-scarb-katana.md:64 src/ch02-05-testnet-deployment.md:297
msgid "## Declaring Smart Contracts in Starknet"
msgstr "## Declarando Smart Contracts en Starknet"

#: src/ch02-02-starkli-scarb-katana.md:66
msgid "Deploying a Starknet smart contract requires two primary steps:"
msgstr "La implementaci√≥n de un smart contract en Starknet requiere dos pasos principales:"

#: src/ch02-02-starkli-scarb-katana.md:68
msgid ""
"- Declare the contract's code.\n"
"- Deploy an instance of that declared code."
msgstr ""
"- Declara el c√≥digo de tu contrato.\n"
"- Implementar una instancia del c√≥digo declarado."

#: src/ch02-02-starkli-scarb-katana.md:71
msgid "Begin with the `src/lib.cairo` file, which provides a foundational template. Remove its contents and insert the following:"
msgstr "Comience con el archivo `src/lib.cairo`, que proporciona una plantilla fundamental. Retire su contenido e inserte lo siguiente:"

#: src/ch02-02-starkli-scarb-katana.md:73
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod hello {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252) {\n"
"        self.name.write(name);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"    #[external(v0)]\n"
"        fn set_name(ref self: ContractState, name: felt252) {\n"
"            self.name.write(name);\n"
"        }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod hello {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252) {\n"
"        self.name.write(name);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"    #[external(v0)]\n"
"        fn set_name(ref self: ContractState, name: felt252) {\n"
"            self.name.write(name);\n"
"        }\n"
"}\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:97
msgid "This rudimentary smart contract serves as a starting point."
msgstr "Este smart contract rudimentario sirve como punto de partida."

#: src/ch02-02-starkli-scarb-katana.md:99
msgid "Compile the contract with the Scarb compiler. If Scarb isn't installed, consult the [Installation](ch02-01-basic-installation.md) section."
msgstr "Compile el contrato con el compilador Scarb. Si Scarb no est√° instalado, consulte la secci√≥n [Instalaci√≥n](ch02-01-basic-installation.md)."

#: src/ch02-02-starkli-scarb-katana.md:101 src/ch02-09-02-erc20-ui.md:109 src/ch02-10-01-erc20-ui.md:108 src/ch04-02-hello-account.md:113 src/ch04-03-standard-account.md:80
msgid ""
"```bash\n"
"scarb build\n"
"```"
msgstr ""
"```bash\n"
"scarb build\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:105
msgid "The above command results in a compiled contract under `target/dev/`, named \"`my_contract_hello.contract_class.json`\" (check Scarb's subchapter for more details)."
msgstr "El comando anterior da como resultado un contrato compilado en `target/dev/`, llamado \"`my_contract_hello.contract_class.json`\" (consulte el subcap√≠tulo de Scarb para obtener m√°s detalles)."

#: src/ch02-02-starkli-scarb-katana.md:107
msgid "Having compiled the smart contract, it's time to declare it with Starkli and katana. First, ensure your project acknowledges the environmental variables:"
msgstr "Habiendo compilado el smart contract, es hora de declararlo con Starkli y Katana. Primero, aseg√∫rese de que su proyecto reconozca las variables ambientales:"

#: src/ch02-02-starkli-scarb-katana.md:109
msgid ""
"```bash\n"
"source .env\n"
"```"
msgstr ""
"```bash\n"
"source .env\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:113
msgid "Next, launch Katana. In a separate terminal, run (more details in the Katan subchapter):"
msgstr "A continuaci√≥n, lanza Katana. En una terminal separada, ejecute (m√°s detalles en el subcap√≠tulo de Katana):"

#: src/ch02-02-starkli-scarb-katana.md:115 src/ch02-06-starkli.md:29 src/ch02-06-01-connection-script.md:11
msgid ""
"```bash\n"
"katana\n"
"```"
msgstr ""
"```bash\n"
"katana\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:119
msgid "To declare your contract, execute:"
msgstr "Para declarar su contrato, ejecute:"

#: src/ch02-02-starkli-scarb-katana.md:121 src/ch02-06-starkli.md:61
msgid ""
"```bash\n"
"starkli declare target/dev/my_contract_hello.contract_class.json\n"
"```"
msgstr ""
"```bash\n"
"starkli declare target/dev/my_contract_hello.contract_class.json\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:125
msgid ""
"Facing an \"Error: Invalid contract class\"? It indicates a version mismatch between Scarb's compiler and Starkli. Refer to the earlier steps to sync the versions. Typically, Starkli supports "
"compiler versions approved by mainnet, even if the most recent Scarb version isn't compatible."
msgstr ""
"¬øSe enfrenta a un \"Error: Invalid contract class\"? Indica una discrepancia de versiones entre el compilador de Scarb y Starkli. Consulte los pasos anteriores para sincronizar las versiones. "
"Normalmente, Starkli admite versiones del compilador aprobadas por la red principal, incluso si la versi√≥n m√°s reciente de Scarb no es compatible."

#: src/ch02-02-starkli-scarb-katana.md:127
msgid ""
"Upon successful command execution, you'll obtain a contract class hash: This\n"
"unique hash serves as the identifier for your contract class within\n"
"Starknet. For example:"
msgstr ""
"Tras la ejecuci√≥n exitosa del comando, obtendr√° un hash de clase de contrato: este\n"
"hash √∫nico sirve como identificador para su clase de contrato dentro\n"
"Starknet. Por ejemplo:"

#: src/ch02-02-starkli-scarb-katana.md:131 src/ch02-06-starkli.md:67
msgid ""
"```bash\n"
"Class hash declared: 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"
msgstr ""
"```bash\n"
"Class hash declared: 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:135
msgid "Consider this hash as the contract class's _address_."
msgstr "Considere este hash como la class's _address_ del contrato."

#: src/ch02-02-starkli-scarb-katana.md:137
msgid "If you try to declare an already existing contract class, don't fret. Just proceed. You might see:"
msgstr "Si intenta declarar una clase de contrato ya existente, no se preocupe. Simplemente contin√∫a. Es posible que vea:"

#: src/ch02-02-starkli-scarb-katana.md:139
msgid ""
"```bash\n"
"Not declaring class as its already declared. Class hash:\n"
"0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"
msgstr ""
"```bash\n"
"Not declaring class as its already declared. Class hash:\n"
"0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:144
msgid "## Deploying Starknet Smart Contracts"
msgstr "## Implementaci√≥n de Smart Contracts en Starknet"

#: src/ch02-02-starkli-scarb-katana.md:146
msgid "To deploy a smart contract on the katana local devnet, use the following command. It primarily requires:"
msgstr "Para implementar un smart contract en el devnet local de katana, utilice el siguiente comando. Requiere principalmente:"

#: src/ch02-02-starkli-scarb-katana.md:148
msgid ""
"1. Your contract's class hash.\n"
"2. Constructor arguments your contract needs (in our example, a _name_ of type `felt252`)."
msgstr ""
"1. El hash de clase de su contrato.\n"
"2. Argumentos del constructor que su contrato necesita (en nuestro ejemplo, a _name_ of type `felt252`)."

#: src/ch02-02-starkli-scarb-katana.md:151
msgid "Here's the command structure:"
msgstr "Aqu√≠ est√° la estructura de comando:"

#: src/ch02-02-starkli-scarb-katana.md:153 src/ch02-05-testnet-deployment.md:380
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        <CLASS_HASH> \\\n"
"        <CONSTRUCTOR_INPUTS>\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        <CLASS_HASH> \\\n"
"        <CONSTRUCTOR_INPUTS>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:159
msgid "Notice the constructor inputs are in felt format. So we need to convert a short string to a felt252 format. We can use the `to-cairo-string` command for this:"
msgstr "Observe que las entradas del constructor est√°n en formato felt. Entonces necesitamos convertir una string corta al formato Felt252. Podemos usar el comando `to-cairo-string` para esto:"

#: src/ch02-02-starkli-scarb-katana.md:161
msgid ""
"```bash\n"
"    starkli to-cairo-string <STRING>\n"
"```"
msgstr ""
"```bash\n"
"    starkli to-cairo-string <STRING>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:165
msgid "In this case, we'll use the string \"starknetbook\" as the name:"
msgstr "En este caso, usaremos la cadena \"starknetbook\" como nombre:"

#: src/ch02-02-starkli-scarb-katana.md:167
msgid ""
"```bash\n"
"    starkli to-cairo-string starknetbook\n"
"```"
msgstr ""
"```bash\n"
"    starkli to-cairo-string starknetbook\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:171
msgid "The output:"
msgstr "La salida:"

#: src/ch02-02-starkli-scarb-katana.md:173
msgid ""
"```bash\n"
"    0x737461726b6e6574626f6f6b\n"
"```"
msgstr ""
"```bash\n"
"    0x737461726b6e6574626f6f6b\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:177
msgid "Now deploy using a class hash and constructor input:"
msgstr "Ahora implemente usando un class hash y una entrada de constructor:"

#: src/ch02-02-starkli-scarb-katana.md:179
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
"        0x737461726b6e6574626f6f6b\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
"        0x737461726b6e6574626f6f6b\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:185
msgid "After running, expect an output similar to:"
msgstr "Despu√©s de ejecutar, espere un resultado similar a:"

#: src/ch02-02-starkli-scarb-katana.md:187
msgid ""
"```bash\n"
"    Deploying class 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 with salt 0x054645c0d1e766ddd927b3bde150c0a3dc0081af7fb82160c1582e05f6018794...\n"
"    The contract will be deployed at address 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"    Contract deployment transaction: 0x00413d9638fecb75eb07593b5c76d13a68e4af7962c368c5c2e810e7a310d54c\n"
"    Contract deployed: 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"```"
msgstr ""
"```bash\n"
"    Deploying class 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 with salt 0x054645c0d1e766ddd927b3bde150c0a3dc0081af7fb82160c1582e05f6018794...\n"
"    The contract will be deployed at address 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"    Contract deployment transaction: 0x00413d9638fecb75eb07593b5c76d13a68e4af7962c368c5c2e810e7a310d54c\n"
"    Contract deployed: 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:194
msgid "## Interacting with Starknet Contracts"
msgstr "## Interactuar con Contracts de Starknet"

#: src/ch02-02-starkli-scarb-katana.md:196
msgid "Using Starkli, you can interact with smart contracts through two primary methods:"
msgstr "Con Starkli, puede interactuar con contratos inteligentes a trav√©s de dos m√©todos principales:"

#: src/ch02-02-starkli-scarb-katana.md:198
msgid ""
"- `call`: For read-only functions.\n"
"- `invoke`: For functions that alter the state."
msgstr ""
"- `call`: Para funciones de solo lectura.\n"
"- `invoke`: Para funciones que alteran el estado."

#: src/ch02-02-starkli-scarb-katana.md:201
msgid "### Reading Data with `call`"
msgstr "### Leyendo Datos con `call`"

#: src/ch02-02-starkli-scarb-katana.md:203
msgid ""
"The `call` command let's you query contract functions without transacting. For instance, if you want to determine the current contract owner using the `get_name` function, which\n"
"requires no arguments:"
msgstr ""
"El comando `call` le permite consultar funciones de contrato sin realizar transacciones. Por ejemplo, si desea determinar el propietario del contrato actual utilizando la funci√≥n `get_name`, que\n"
"no requiere argumentos:"

#: src/ch02-02-starkli-scarb-katana.md:206
msgid ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        get_name\n"
"```"
msgstr ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        get_name\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:212
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of your contract. The\n"
"command will return the owner‚Äôs address, which was initially set during\n"
"the contract‚Äôs deployment:"
msgstr "Reemplace `<CONTRACT_ADDRESS>` con la direcci√≥n de su contrato. El comando devolver√° la direcci√≥n del owner, que se estableci√≥ inicialmente durante la implementaci√≥n del contrato:"

#: src/ch02-02-starkli-scarb-katana.md:216
msgid ""
"```bash\n"
"    [\n"
"        \"0x0000000000000000000000000000000000000000737461726b6e6574626f6f6b\"\n"
"    ]\n"
"```"
msgstr ""
"```bash\n"
"    [\n"
"        \"0x0000000000000000000000000000000000000000737461726b6e6574626f6f6b\"\n"
"    ]\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:222
msgid "But what is this lengthy output? In Starknet, we use the `felt252` data type to represent strings. This can be decoded into its string representation:"
msgstr "¬øPero qu√© es este largo resultado? En Starknet, utilizamos el tipo de datos `felt252` para representar cadenas. Esto se puede decodificar en su representaci√≥n de cadena:"

#: src/ch02-02-starkli-scarb-katana.md:224
msgid ""
"```bash\n"
"starkli parse-cairo-string 0x737461726b6e6574626f6f6b\n"
"```"
msgstr ""
"```bash\n"
"starkli parse-cairo-string 0x737461726b6e6574626f6f6b\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:228
msgid "The result:"
msgstr "El resultado:"

#: src/ch02-02-starkli-scarb-katana.md:230
msgid ""
"```bash\n"
"starknetbook\n"
"```"
msgstr ""
"```bash\n"
"starknetbook\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:234
msgid "## Modifying Contract State with `invoke`"
msgstr "## Modificando el Estado del Contrato con `invoke`"

#: src/ch02-02-starkli-scarb-katana.md:236
msgid "To alter the contract's state, use the `invoke` command. For instance, if you want to update the name field in the storage, utilize the `set_name` function:"
msgstr "Para alterar el estado del contrato, use el comando `invoke`. Por ejemplo, si desea actualizar el campo de nombre en el almacenamiento, utilice la funci√≥n `set_name`:"

#: src/ch02-02-starkli-scarb-katana.md:238
msgid ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        set_name \\\n"
"        <felt252>\n"
"```"
msgstr ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        set_name \\\n"
"        <felt252>\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:245
msgid "Where:"
msgstr "D√≥nde:"

#: src/ch02-02-starkli-scarb-katana.md:247
msgid ""
"- **`<CONTRACT_ADDRESS>`** is the address of your contract.\n"
"- **`<felt252>`** is the new value for the **`name`** field, in felt252 format."
msgstr ""
"- **`<CONTRACT_ADDRESS>`** es la direcci√≥n de su contrato.\n"
"- **`<felt252>`** es el nuevo valor para el campo **`name`**, en formato felt252."

#: src/ch02-02-starkli-scarb-katana.md:250
msgid "For example, to update the name to \"Omar\", first convert the string \"Omar\" to its felt252 representation:"
msgstr "Por ejemplo, para actualizar el nombre a \"Omar\", primero convierta la cadena \"Omar\" a su representaci√≥n felt252:"

#: src/ch02-02-starkli-scarb-katana.md:252
msgid ""
"```bash\n"
"    starkli to-cairo-string Omar\n"
"```"
msgstr ""
"```bash\n"
"    starkli to-cairo-string Omar\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:256
msgid "This will return:"
msgstr "Esto devolver√°:"

#: src/ch02-02-starkli-scarb-katana.md:258
msgid ""
"```bash\n"
"    0x4f6d6172\n"
"```"
msgstr ""
"```bash\n"
"    0x4f6d6172\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:262
msgid "Now, proceed with the `invoke` command:"
msgstr "Ahora, contin√∫a con el comando `invoke`:"

#: src/ch02-02-starkli-scarb-katana.md:264
msgid ""
"```bash\n"
"    starkli invoke 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44 set_name 0x4f6d6172\n"
"```"
msgstr ""
"```bash\n"
"    starkli invoke 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44 set_name 0x4f6d6172\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:268
msgid "Bravo! You've adeptly modified and interfaced with your Starknet contract."
msgstr "¬°Bravo! Ha modificado e interactuado h√°bilmente con su contrato Starknet."

#: src/ch02-03-scarb.md:1
msgid "# Scarb: The Package Manager"
msgstr "# Scarb: El Administrador de Paquetes"

#: src/ch02-03-scarb.md:12
msgid ""
"Scarb is Cairo‚Äôs package manager designed for both Cairo and Starknet\n"
"projects. It handles dependencies, compiles projects, and integrates\n"
"with tools like Foundry. It is built by the same team that created\n"
"Foundry for Starknet."
msgstr ""
"Scarb es el administrador de paquetes de Cairo dise√±ado para proyectos de Cairo y Starknet. Maneja dependencias, compila proyectos y se integra con herramientas como Foundry. Est√° construido por el "
"mismo equipo que cre√≥ Foundry para Starknet."

#: src/ch02-03-scarb.md:17
msgid "# Scarb Workflow"
msgstr "# Scarb Workflow"

#: src/ch02-03-scarb.md:19
msgid "Follow these steps to develop a Starknet contract using Scarb:"
msgstr "Siga estos pasos para desarrollar un contrato Starknet usando Scarb:"

#: src/ch02-03-scarb.md:21
msgid ""
"1.  **Initialize:** Use `scarb new` to set up a new project, generating\n"
"    a `Scarb.toml` file and initial `src/lib.cairo`.\n"
"\n"
"2.  **Code:** Add your Cairo code in the `src` directory.\n"
"\n"
"3.  **Dependencies:** Add external libraries using `scarb add`.\n"
"\n"
"4.  **Compile:** Execute `scarb build` to convert your contract into\n"
"    Sierra code."
msgstr ""
"1. **Inicializar:** Utilice `scarb new` para configurar un nuevo proyecto, generando un archivo `Scarb.toml` y un `src/lib.cairo` inicial.\n"
"\n"
"2. **C√≥digo:** Agregue su c√≥digo de Cairo en el directorio `src`.\n"
"\n"
"3. **Dependencias:** Agregue bibliotecas externas usando `scarb add`.\n"
"\n"
"4. **Compilar:** Ejecute `scarb build` para convertir su contrato en c√≥digo Sierra."

#: src/ch02-03-scarb.md:31
msgid ""
"Scarb simplifies your development workflow, making it efficient and\n"
"streamlined."
msgstr "Scarb simplifica su flujo de trabajo de desarrollo, haci√©ndolo eficiente y optimizado."

#: src/ch02-03-scarb.md:36
msgid ""
"Scarb is cross-platform, supporting macOS, Linux, and Windows. For\n"
"installation, refer to the [Basic installation guide](./ch02-01-basic-installation)."
msgstr ""
"Scarb es multiplataforma y admite macOS, Linux y Windows. Para\n"
"instalaci√≥n, consulte la [Gu√≠a de instalaci√≥n b√°sica](./ch02-01-basic-installation)."

#: src/ch02-03-scarb.md:39
msgid "# Cairo Project Structure"
msgstr "# Estructura del Proyecto de Cairo"

#: src/ch02-03-scarb.md:41
msgid "Next, we‚Äôll dive into the key components that make up a Cairo project."
msgstr "A continuaci√≥n, profundizaremos en los componentes clave que conforman un proyecto de Cairo."

#: src/ch02-03-scarb.md:43
msgid "## Cairo Packages"
msgstr "## Paquetes en Cairo"

#: src/ch02-03-scarb.md:45
msgid ""
"Cairo packages, also referred to as \"crates\" in some contexts, are the\n"
"building blocks of a Cairo project. Each package must follow several\n"
"rules:"
msgstr "Los paquetes de Cairo, tambi√©n denominados \"crates\" en algunos contextos, son los componentes b√°sicos de un proyecto de Cairo. Cada paquete debe seguir varias reglas:"

#: src/ch02-03-scarb.md:49
msgid ""
"- A package must include a `Scarb.toml` file, which is Scarb‚Äôs\n"
"  manifest file. It contains the dependencies for your package.\n"
"\n"
"- A package must include a `src/lib.cairo` file, which is the root of\n"
"  the package tree. It allows you to define functions and declare used\n"
"  modules."
msgstr ""
"- Un paquete debe incluir un archivo `Scarb.toml`, que es el archivo de manifiesto de Scarb. Contiene las dependencias de su paquete.\n"
"\n"
"- Un paquete debe incluir un archivo `src/lib.cairo`, que es la ra√≠z del √°rbol de paquetes. Le permite definir funciones y declarar m√≥dulos usados."

#: src/ch02-03-scarb.md:56
msgid ""
"Package structures might look like the following case where we have a\n"
"package named `my_package`, which includes a `src` directory with the\n"
"`lib.cairo` file inside, a `snips` directory which in itself a package\n"
"we can use, and a `Scarb.toml` file in the top-level directory."
msgstr ""
"Las estructuras de los paquetes podr√≠an parecerse al siguiente caso donde tenemos un paquete llamado `my_package`, que incluye un directorio `src` con el archivo `lib.cairo` dentro, un directorio "
"`snips` que en s√≠ mismo es un paquete que podemos usar, y un archivo `Scarb.toml` en el directorio de nivel superior."

#: src/ch02-03-scarb.md:61
msgid ""
"my_package/\n"
"    ‚îú‚îÄ‚îÄ src/\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ module1.cairo\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ module2.cairo\n"
"    ‚îÇ   ‚îî‚îÄ‚îÄ lib.cairo\n"
"    ‚îú‚îÄ‚îÄ snips/\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ src/\n"
"    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib.cairo\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ Scarb.toml\n"
"    ‚îî‚îÄ‚îÄ Scarb.toml"
msgstr ""
"my_package/\n"
"    ‚îú‚îÄ‚îÄ src/\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ module1.cairo\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ module2.cairo\n"
"    ‚îÇ   ‚îî‚îÄ‚îÄ lib.cairo\n"
"    ‚îú‚îÄ‚îÄ snips/\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ src/\n"
"    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib.cairo\n"
"    ‚îÇ   ‚îú‚îÄ‚îÄ Scarb.toml\n"
"    ‚îî‚îÄ‚îÄ Scarb.toml"

#: src/ch02-03-scarb.md:72
msgid "Within the `Scarb.toml` file, you might have:"
msgstr "Dentro del archivo `Scarb.toml`, es posible que tengas:"

#: src/ch02-03-scarb.md:74
msgid ""
"[package]\n"
"    name = \"my_package\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    [dependencies]\n"
"    starknet = \">=2.0.1\"\n"
"    snips = { path = \"snips\" }"
msgstr ""
"[package]\n"
"    name = \"my_package\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    [dependencies]\n"
"    starknet = \">=2.0.1\"\n"
"    snips = { path = \"snips\" }"

#: src/ch02-03-scarb.md:82
msgid ""
"Here starknet and snips are the dependencies of the package. The\n"
"`starknet` dependency is hosted on the Scarb registry (we do not need to\n"
"download it), while the `snips` dependency is located in the `snips`\n"
"directory."
msgstr ""
"Aqu√≠ starknet y snips son las dependencias del paquete. La dependencia `starknet` est√° alojada en el registro Scarb (no necesitamos desc√°rgarlo), mientras que la dependencia `snips` se encuentra en "
"el directorio `snips`."

#: src/ch02-03-scarb.md:87
msgid "# Setting Up a Project with Scarb"
msgstr "# Configurar un Proyecto con Scarb"

#: src/ch02-03-scarb.md:89
msgid ""
"To create a new project using Scarb, navigate to your desired project\n"
"directory and execute the following command:"
msgstr "Para crear un nuevo proyecto usando Scarb, navegue hasta el directorio del proyecto que desee y ejecute el siguiente comando:"

#: src/ch02-03-scarb.md:92
msgid "$ scarb new hello_scarb"
msgstr "$ scarb new hello_scarb"

#: src/ch02-03-scarb.md:94
msgid ""
"This command will create a new project directory named `hello_scarb`,\n"
"including a `Scarb.toml` file, a `src` directory with a `lib.cairo` file\n"
"inside, and initialize a new Git repository with a `.gitignore` file."
msgstr ""
"Este comando crear√° un nuevo directorio de proyecto llamado `hello_scarb`, que incluye un archivo `Scarb.toml`, un directorio `src` con un archivo `lib.cairo` dentro e inicializar√° un nuevo "
"repositorio Git con un archivo `.gitignore` ."

#: src/ch02-03-scarb.md:98
msgid ""
"hello_scarb/\n"
"    ‚îú‚îÄ‚îÄ src/\n"
"    ‚îÇ   ‚îî‚îÄ‚îÄ lib.cairo\n"
"    ‚îî‚îÄ‚îÄ Scarb.toml"
msgstr ""
"hello_scarb/\n"
"    ‚îú‚îÄ‚îÄ src/\n"
"    ‚îÇ   ‚îî‚îÄ‚îÄ lib.cairo\n"
"    ‚îî‚îÄ‚îÄ Scarb.toml"

#: src/ch02-03-scarb.md:103
msgid ""
"Upon opening `Scarb.toml` in a text editor, you should see something\n"
"similar to the code snippet below:"
msgstr "Al abrir `Scarb.toml` en un editor de texto, deber√≠a ver algo similar al fragmento de c√≥digo a continuaci√≥n:"

#: src/ch02-03-scarb.md:106
msgid ""
"[package]\n"
"    name = \"hello_scarb\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"    [dependencies]\n"
"    # foo = { path = \"vendor/foo\" }"
msgstr ""
"[package]\n"
"    name = \"hello_scarb\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"    [dependencies]\n"
"    # foo = { path = \"vendor/foo\" }"

#: src/ch02-03-scarb.md:114
msgid "# Building a Scarb Project"
msgstr "# Construyendo un Proyecto Scarb"

#: src/ch02-03-scarb.md:116
msgid "Clear all content in `src/lib.cairo` and replace with the following:"
msgstr "Borre todo el contenido en `src/lib.cairo` y reempl√°celo con lo siguiente:"

#: src/ch02-03-scarb.md:118
msgid ""
"// src/lib.cairo\n"
"    mod hello_scarb;"
msgstr ""
"// src/lib.cairo\n"
"    mod hello_scarb;"

#: src/ch02-03-scarb.md:121
msgid ""
"Next, create a new file titled `src/hello_scarb.cairo` and add the\n"
"following:"
msgstr "A continuaci√≥n, cree un nuevo archivo titulado `src/hello_scarb.cairo` y agregue lo siguiente:"

#: src/ch02-03-scarb.md:124
msgid ""
"// src/hello_scarb.cairo\n"
"    use debug::PrintTrait;\n"
"    fn main() {\n"
"        'Hello, Scarb!'.print();\n"
"    }"
msgstr ""
"// src/hello_scarb.cairo\n"
"    use debug::PrintTrait;\n"
"    fn main() {\n"
"        'Hello, Scarb!'.print();\n"
"    }"

#: src/ch02-03-scarb.md:130
msgid ""
"In this instance, the `lib.cairo` file contains a module declaration\n"
"referencing _hello_scarb_, which includes the _hello_scarb.cairo_\n"
"file‚Äôs implementation. For more on modules, imports, and the `lib.cairo`\n"
"file, please refer to the cairo-book on [Managing Cairo Projects in Chapter\n"
"7](https://book.cairo-lang.org/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html)."
msgstr ""
"En este caso, el archivo `lib.cairo` contiene una declaraci√≥n de m√≥dulo\n"
"haciendo referencia a _hello_scarb_, que incluye _hello_scarb.cairo_\n"
"implementaci√≥n del archivo. Para obtener m√°s informaci√≥n sobre m√≥dulos, importaciones y `lib.cairo`,\n"
"consulte el libro de Cairo sobre [Gesti√≥n de proyectos de Cairo en el Cap√≠tulo\n"
"7](https://book.cairo-lang.org/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html)."

#: src/ch02-03-scarb.md:136
msgid ""
"Scarb mandates that your source files be located within the `src`\n"
"directory."
msgstr "Scarb exige que sus archivos fuente est√©n ubicados dentro del directorio `src`."

#: src/ch02-03-scarb.md:139
msgid ""
"To build (compile) your project from your `hello_scarb` directory, use\n"
"the following command:"
msgstr "Para construir (compilar) su proyecto desde su directorio `hello_scarb`, use el siguiente comando:"

#: src/ch02-03-scarb.md:142
msgid "scarb build"
msgstr "scarb build"

#: src/ch02-03-scarb.md:144
msgid ""
"This command compiles your project and produces the Sierra code in the\n"
"`target/dev/hello_scarb.sierra.json` file. Sierra serves as an intermediate\n"
"layer between high-level Cairo and compilation targets such as Cairo\n"
"Assembly (CASM). To understand more about Sierra, check out this\n"
"[article](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)."
msgstr ""
"Este comando compila su proyecto y produce el c√≥digo Sierra en el\n"
"archivo `target/dev/hello_scarb.sierra.json`. Sierra sirve como intermediario\n"
"de capa entre Cairo de alto nivel y objetivos de compilaci√≥n como Cairo\n"
"Assembly (CASM). Para comprender m√°s sobre Sierra, consulte esto\n"
"[art√≠culo](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)."

#: src/ch02-03-scarb.md:150
msgid ""
"To remove the build artifacts and delete the target directory, use the\n"
"`scarb clean` command."
msgstr "Para eliminar los artefactos de compilaci√≥n y eliminar el directorio de destino, use el comando `scarb clean`."

#: src/ch02-03-scarb.md:153
msgid "## Adding Dependencies"
msgstr "## Agregar Dependencias"

#: src/ch02-03-scarb.md:155
msgid ""
"Scarb facilitates the seamless management of dependencies for your Cairo\n"
"packages. Here are two methods to add dependencies to your project:"
msgstr "Scarb facilita la gesti√≥n perfecta de las dependencias de sus paquetes de Cairo. Aqu√≠ hay dos m√©todos para agregar dependencias a su proyecto:"

#: src/ch02-03-scarb.md:158
msgid "- Edit Scarb.toml File"
msgstr "- Editar Scarb.toml File"

#: src/ch02-03-scarb.md:160
msgid ""
"Open the Scarb.toml file in your project directory and locate the\n"
"`[dependencies]` section. If it doesn‚Äôt exist, add it. To include a\n"
"dependency hosted on a Git repository, use the following format:"
msgstr ""
"Abra el archivo Scarb.toml en el directorio de su proyecto y busque la secci√≥n `[dependencies]`. Si no existe, agr√©guelo. Para incluir una dependencia alojada en un repositorio Git, utilice el "
"siguiente formato:"

#: src/ch02-03-scarb.md:164
msgid ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }"
msgstr ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }"

#: src/ch02-03-scarb.md:167
msgid ""
"For consistency, it‚Äôs recommended to pin Git dependencies to specific\n"
"commits. This can be done by adding the `rev` field with the commit\n"
"hash:"
msgstr "Para mantener la coherencia, se recomienda fijar las dependencias de Git a confirmaciones espec√≠ficas. Esto se puede hacer agregando el campo `rev` con el commit hash:"

#: src/ch02-03-scarb.md:171
msgid ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", rev = \"81bb93c\" }"
msgstr ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", rev = \"81bb93c\" }"

#: src/ch02-03-scarb.md:174
msgid "After adding the dependency, remember to save the file."
msgstr "Despu√©s de agregar la dependencia, recuerde guardar el archivo."

#: src/ch02-03-scarb.md:176
msgid "- Use the scarb add Command"
msgstr "- Utilice el comando scarb add"

#: src/ch02-03-scarb.md:178
msgid ""
"Alternatively, you can use the `scarb add` command to add dependencies\n"
"to your project. Open your terminal and execute the following command:"
msgstr "Alternativamente, puedes usar el comando `scarb add` para agregar dependencias a tu proyecto. Abre tu terminal y ejecuta el siguiente comando:"

#: src/ch02-03-scarb.md:181
msgid "$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git"
msgstr "$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git"

#: src/ch02-03-scarb.md:183
msgid ""
"This command will add the alexandria_math dependency from the specified\n"
"Git repository to your project."
msgstr "Este comando agregar√° la dependencia alexandria_math del repositorio Git especificado a su proyecto."

#: src/ch02-03-scarb.md:186
msgid "To remove a dependency, you can use the `scarb rm` command."
msgstr "Para eliminar una dependencia, puede utilizar el comando `scarb rm`."

#: src/ch02-03-scarb.md:188
msgid ""
"Once a dependency is added, the Scarb.toml file will be automatically\n"
"updated with the new dependency information."
msgstr "Una vez que se agrega una dependencia, el archivo Scarb.toml se actualizar√° autom√°ticamente con la nueva informaci√≥n de dependencia."

#: src/ch02-03-scarb.md:191
msgid "## Using Dependencies in Your Code"
msgstr "## Usando Dependencias en su C√≥digo"

#: src/ch02-03-scarb.md:193
msgid ""
"After dependencies are added to your project, you can start utilizing\n"
"them in your Cairo code."
msgstr "Despu√©s de agregar dependencias a su proyecto, puede comenzar a utilizarlas en su c√≥digo de Cairo."

#: src/ch02-03-scarb.md:196
msgid ""
"For example, let‚Äôs assume you have added the alexandria_math\n"
"dependency. Now, you can import and utilize functions from the\n"
"alexandria_math library in your `src/hello_scarb.cairo` file:"
msgstr "Por ejemplo, supongamos que ha agregado la dependencia alexandria_math. Ahora, puedes importar y utilizar funciones de la biblioteca alexandria_math en tu archivo `src/hello_scarb.cairo`:"

#: src/ch02-03-scarb.md:200
msgid ""
"// src/hello_scarb.cairo\n"
"    use alexandria_math::fibonacci;\n"
"\n"
"    fn main() -> felt252 {\n"
"        fibonacci::fib(0, 1, 10)\n"
"    }"
msgstr ""
"// src/hello_scarb.cairo\n"
"    use alexandria_math::fibonacci;\n"
"\n"
"    fn main() -> felt252 {\n"
"        fibonacci::fib(0, 1, 10)\n"
"    }"

#: src/ch02-03-scarb.md:207
msgid ""
"In the above example, we import the fibonacci function from the\n"
"alexandria_math library and utilize it in the main function."
msgstr "En el ejemplo anterior, importamos la funci√≥n Fibonacci de la biblioteca alexandria_math y la utilizamos en la funci√≥n principal."

#: src/ch02-03-scarb.md:210
msgid "# Scarb Cheat Sheet"
msgstr "# Scarb Cheat Sheet"

#: src/ch02-03-scarb.md:212
msgid ""
"Here‚Äôs a quick cheat sheet of some of the most commonly used Scarb\n"
"commands:"
msgstr "Aqu√≠ hay una hoja de referencia r√°pida de algunos de los comandos Scarb m√°s utilizados:"

#: src/ch02-03-scarb.md:215
msgid ""
"- `scarb new <project_name>`: Initialize a new project with the given\n"
"  project name.\n"
"\n"
"- `scarb build`: Compile your Cairo code into Sierra code.\n"
"\n"
"- `scarb add <dependency> --git <repository>`: Add a dependency to\n"
"  your project from a specified Git repository.\n"
"\n"
"- `scarb rm <dependency>`: Remove a dependency from your project.\n"
"\n"
"- `scarb run <script>`: Run a custom script defined in your\n"
"  `Scarb.toml` file."
msgstr ""
"- `scarb new <project_name>`: Inicializa un nuevo proyecto con el nombre de proyecto proporcionado.\n"
"\n"
"- `scarb build`: Compila tu c√≥digo Cairo en c√≥digo Sierra.\n"
"\n"
"- `scarb add <dependencia> --git <repositorio>`: Agrega una dependencia a tu proyecto desde un repositorio Git espec√≠fico.\n"
"\n"
"- `scarb rm <dependencia>`: Elimina una dependencia de tu proyecto.\n"
"\n"
"- `scarb run <script>`: Ejecuta un script personalizado definido en su archivo `Scarb.toml`."

#: src/ch02-03-scarb.md:228
msgid "# What is new since version 2.3.0"
msgstr "# Novedades desde la versi√≥n 2.3.0"

#: src/ch02-03-scarb.md:230
msgid ""
"- JSON containing Sierra code of Starknet contract class becomes: `contract.contract_class.json`.\n"
"- JSON containing CASM code of Starknet contract class becomes: `contract.compiled_contract_class.json`.\n"
"- Now cairo supports `Components`. They are modular add-ons encapsulating reusable logic, storage, and events that can be incorporated into multiple contracts. They can be used to extend a "
"contract's functionality, without having to reimplement the same logic over and over again."
msgstr ""
"- El JSON que contiene el c√≥digo Sierra de la clase de contrato Starknet se convierte en: `contract.contract_class.json`.\n"
"- El JSON que contiene el c√≥digo CASM de la clase de contrato Starknet se convierte en: `contract.compiled_contract_class.json`.\n"
"- Ahora Cairo admite `Components`. Son complementos modulares que encapsulan l√≥gica, almacenamiento y eventos reutilizables que se pueden incorporar en m√∫ltiples contratos. Se pueden utilizar para "
"ampliar la funcionalidad de un contrato, sin tener que volver a implementar la misma l√≥gica una y otra vez."

#: src/ch02-03-scarb.md:234
msgid "## Project using Components"
msgstr "## Proyecto usando Componentes"

#: src/ch02-03-scarb.md:236
msgid ""
"One of the most important features since `scarb 2.3.0` version is `Components`. Think of components as Lego blocks. They allow you to enrich your contracts by plugging in a module that you or "
"someone else wrote."
msgstr ""
"Una de las caracter√≠sticas m√°s importantes desde la versi√≥n `scarb 2.3.0` son los `Components`. Piense en los componentes como bloques de Lego. Le permiten enriquecer sus contratos conectando un "
"m√≥dulo que usted u otra persona escribi√≥."

#: src/ch02-03-scarb.md:238
msgid ""
"Lets see and example. Recover our project from [Testnet Deployment](./ch02-05-testnet-deployment.md) section. We used the `Ownable-Starknet` example to interact with the blockchain, now we are "
"going to use the same project, but we will refactor the code in order to use `components`"
msgstr ""
"Veamos un ejemplo. Recupere nuestro proyecto de la secci√≥n [Testnet Deployment](./ch02-05-testnet-deployment.md). Usamos el ejemplo `Ownable-Starknet` para interactuar con la blockchain, ahora "
"vamos a usar el mismo proyecto, pero refactorizaremos el c√≥digo para usar `components`"

#: src/ch02-03-scarb.md:240
msgid "This is how our smart contract looks now"
msgstr "As√≠ luce ahora nuestro smart contract"

#: src/ch02-03-scarb.md:242
msgid ""
"```rust\n"
"// ...rest of the code\n"
"\n"
"#[starknet::component]\n"
"mod ownable_component {\n"
"    use super::{ContractAddress, IOwnable};\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnershipTransferred: OwnershipTransferred\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred {\n"
"        previous_owner: ContractAddress,\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of IOwnable<ComponentState<TContractState>> {\n"
"        fn transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            self.only_owner();\n"
"            self._transfer_ownership(new_owner);\n"
"        }\n"
"        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of InternalTrait<TContractState> {\n"
"        fn only_owner(self: @ComponentState<TContractState>) {\n"
"            let owner: ContractAddress = self.owner.read();\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            assert(!caller.is_zero(), 'ZERO_ADDRESS_CALLER');\n"
"            assert(caller == owner, 'NOT_OWNER');\n"
"        }\n"
"\n"
"        fn _transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            let previous_owner: ContractAddress = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self\n"
"                .emit(\n"
"                    OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner }\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ownable_contract {\n"
"    use ownable_project::ownable_component;\n"
"    use super::{ContractAddress, IData};\n"
"\n"
"    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        data: felt252,\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnableEvent: ownable_component::Event\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, initial_owner: ContractAddress) {\n"
"        self.ownable.owner.write(initial_owner);\n"
"        self.data.write(1);\n"
"    }\n"
"    #[external(v0)]\n"
"    impl OwnableDataImpl of IData<ContractState> {\n"
"        fn get_data(self: @ContractState) -> felt252 {\n"
"            self.data.read()\n"
"        }\n"
"        fn set_data(ref self: ContractState, new_value: felt252) {\n"
"            self.ownable.only_owner();\n"
"            self.data.write(new_value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// ...rest of the code\n"
"\n"
"#[starknet::component]\n"
"mod ownable_component {\n"
"    use super::{ContractAddress, IOwnable};\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnershipTransferred: OwnershipTransferred\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferred {\n"
"        previous_owner: ContractAddress,\n"
"        new_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of IOwnable<ComponentState<TContractState>> {\n"
"        fn transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            self.only_owner();\n"
"            self._transfer_ownership(new_owner);\n"
"        }\n"
"        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of InternalTrait<TContractState> {\n"
"        fn only_owner(self: @ComponentState<TContractState>) {\n"
"            let owner: ContractAddress = self.owner.read();\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            assert(!caller.is_zero(), 'ZERO_ADDRESS_CALLER');\n"
"            assert(caller == owner, 'NOT_OWNER');\n"
"        }\n"
"\n"
"        fn _transfer_ownership(\n"
"            ref self: ComponentState<TContractState>, new_owner: ContractAddress\n"
"        ) {\n"
"            let previous_owner: ContractAddress = self.owner.read();\n"
"            self.owner.write(new_owner);\n"
"            self\n"
"                .emit(\n"
"                    OwnershipTransferred { previous_owner: previous_owner, new_owner: new_owner }\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ownable_contract {\n"
"    use ownable_project::ownable_component;\n"
"    use super::{ContractAddress, IData};\n"
"\n"
"    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        data: felt252,\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnableEvent: ownable_component::Event\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, initial_owner: ContractAddress) {\n"
"        self.ownable.owner.write(initial_owner);\n"
"        self.data.write(1);\n"
"    }\n"
"    #[external(v0)]\n"
"    impl OwnableDataImpl of IData<ContractState> {\n"
"        fn get_data(self: @ContractState) -> felt252 {\n"
"            self.data.read()\n"
"        }\n"
"        fn set_data(ref self: ContractState, new_value: felt252) {\n"
"            self.ownable.only_owner();\n"
"            self.data.write(new_value);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-03-scarb.md:349
msgid ""
"Basically we decided to apply `components` on the section related to `ownership` and created a separated module `ownable_component`. Then we kept the `data` section in our main module "
"`ownable_contract`."
msgstr ""
"B√°sicamente, decidimos aplicar `components` en la secci√≥n relacionada con `ownership` y creamos un m√≥dulo separado `ownable_component`. Luego mantuvimos la secci√≥n `data` en nuestro m√≥dulo "
"principal `ownable_contract`."

#: src/ch02-03-scarb.md:351
msgid ""
"To get the full implementation of this project, navigate to the `src/` directory in the [examples/Ownable-Components](https://github.com/starknet-edu/starknetbook/examples/Ownable-Components) "
"directory of the Starknet Book repo. The `src/lib.cairo` file contains the contract to practice with."
msgstr ""
"Para obtener la implementaci√≥n completa de este proyecto, navegue hasta el directorio `src/` en el directorio [examples/Ownable-Components](https://github.com/starknet-edu/starknetbook/examples/"
"Ownable-Components) del Repositorio de libros de Starknet. El archivo `src/lib.cairo` contiene el contrato con el que practicar."

#: src/ch02-03-scarb.md:353
msgid "After you get the full code on your machine, open your terminal, input `scarb build` to compile it, deploy your contract and call functions."
msgstr "Despu√©s de obtener el c√≥digo completo en su m√°quina, abra su terminal, ingrese `scarb build` para compilarlo, implemente su contrato y llame a las funciones."

#: src/ch02-03-scarb.md:355
msgid "You can learn more about components in [Chapter 12 of The Cairo Book](https://book.cairo-lang.org/ch99-01-05-00-components.html)."
msgstr "Puede obtener m√°s informaci√≥n sobre los componentes en el [Cap√≠tulo 12 del Libro de Cairo](https://book.cairo-lang.org/ch99-01-05-00-components.html)."

#: src/ch02-03-scarb.md:357
msgid ""
"Scarb is a versatile tool, and this is just the beginning of what you\n"
"can achieve with it. As you gain more experience in the Cairo language\n"
"and the Starknet platform, you‚Äôll discover how much more you can do with\n"
"Scarb."
msgstr ""
"Scarb es una herramienta vers√°til y esto es solo el comienzo de lo que puedes lograr con ella. A medida que adquieras m√°s experiencia en el idioma de  Cairo y la plataforma Starknet, descubrir√°s "
"cu√°nto m√°s puedes hacer con Scarb."

#: src/ch02-03-scarb.md:362
msgid ""
"To stay updated on Scarb and its features, be sure to check the\n"
"[official Scarb\n"
"documentation](https://docs.swmansion.com/scarb/docs.html) regularly.\n"
"Happy coding!"
msgstr ""
"Para mantenerse actualizado sobre Scarb y sus funciones, aseg√∫rese de consultar la [documentaci√≥n oficial de Scarb] (https://docs.swmansion.com/scarb/docs.html) con regularidad. ¬°Feliz codificaci√≥n!"

#: src/ch02-03-scarb.md:367 src/ch04-05-01-multicaller.md:605
msgid "The Book is a community-driven effort created for the community."
msgstr "El Libro es un esfuerzo impulsado por la comunidad y creado para la comunidad."

#: src/ch02-03-scarb.md:369
msgid ""
"- If you‚Äôve learned something, or not, please take a moment to provide\n"
"  feedback through [this 3-question\n"
"  survey](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=).\n"
"\n"
"- If you discover any errors or have additional suggestions, don‚Äôt\n"
"  hesitate to open an [issue on our GitHub\n"
"  repository](https://github.com/starknet-edu/starknetbook/issues)."
msgstr ""
"- Si ha aprendido algo, o no, t√≥mese un momento para brindar comentarios a trav√©s de [esta encuesta de 3 preguntas](https://a.sprig.com/"
"WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=).\n"
"\n"
"- Si descubre alg√∫n error o tiene sugerencias adicionales, no dude en abrir un [problema en nuestro repositorio de GitHub](https://github.com/starknet-edu/starknetbook/issues)."

#: src/ch02-04-katana.md:1
msgid "# Katana: A Local Node"
msgstr "# Katana: A Local Node"

#: src/ch02-04-katana.md:3
msgid ""
"`Katana` is designed to aid in local development.\n"
"This creation by the [Dojo\n"
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)\n"
"enables you to perform all Starknet-related activities in a local\n"
"environment, thus serving as an efficient platform for development and\n"
"testing."
msgstr ""
"`Katana` est√° dise√±ado para ayudar en el desarrollo local.\n"
"Esta creaci√≥n por el [equipo\n"
"Dojo](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)\n"
"le permite realizar todas las actividades relacionadas con Starknet en un ambiente\n"
"local, sirviendo as√≠ como una plataforma eficiente para el desarrollo y\n"
"pruebas."

#: src/ch02-04-katana.md:10
msgid ""
"We suggest employing either `katana` or `starknet-devnet` for testing\n"
"your contracts, with the latter discussed in another\n"
"subchapter. The `starknet-devnet` is a public testnet, maintained by the\n"
"[Shard Labs team](https://github.com/0xSpaceShard/starknet-devnet-rs). Both\n"
"these tools offer an effective environment for development and testing."
msgstr ""
"Sugerimos emplear `katana` o `starknet-devnet` para realizar pruebas\n"
"en sus contratos, este √∫ltimo discutido en otro\n"
"subcap√≠tulo. El `starknet-devnet` es un testnet p√∫blico, mantenido por el\n"
"[Equipo de Shard Labs](https://github.com/0xSpaceShard/starknet-devnet-rs). Ambas\n"
"herramientas ofrecen un entorno eficaz para el desarrollo y las pruebas."

#: src/ch02-04-katana.md:16
msgid ""
"For an example of how to use `katana` to deploy and interact with a\n"
"contract, see the introduction subchapter of this Chapter or a voting contract example in [The Cairo Book](https://book.cairo-lang.org/ch99-01-04-01-voting-contract.html)."
msgstr ""
"Para ver un ejemplo de c√≥mo usar `katana` para implementar e interactuar con un\n"
"contrato, consulte el subcap√≠tulo de introducci√≥n de este Cap√≠tulo o un ejemplo de contrato de votaci√≥n en [El Libro de Cairo](https://book.cairo-lang.org/ch99-01-04-01-voting-contract.html)."

#: src/ch02-04-katana.md:19
msgid "## Understanding RPC in Starknet"
msgstr "## Entendiendo RPC en Starknet"

#: src/ch02-04-katana.md:21
msgid ""
"Remote Procedure Call (RPC) establishes the communication between nodes\n"
"in the Starknet network. Essentially, it allows us to interact with a\n"
"node in the Starknet network. The RPC server is responsible for\n"
"receiving these calls."
msgstr ""
"La llamada a procedimiento remoto (RPC) establece la comunicaci√≥n entre nodos en la red Starknet. B√°sicamente, nos permite interactuar con un nodo de la red Starknet. El servidor RPC es responsable "
"de recibir estas llamadas."

#: src/ch02-04-katana.md:26
msgid ""
"RPC can be obtained from various sources: . To support the\n"
"decentralization of the Network, you can use your own local Starknet\n"
"node. For ease of access, consider using a provider such as\n"
"[Infura](https://docs.infura.io/networks/starknet/how-to) or\n"
"[Alchemy](https://www.alchemy.com/starknet) to get an RPC client. For\n"
"development and testing, a temporary local node such as `katana` can be\n"
"used."
msgstr ""
"RPC se puede obtener de varias fuentes: . Para apoyar la\n"
"descentralizaci√≥n de la Red, puedes usar tu propio nodo local de\n"
"Starknet. Para facilitar el acceso, considere utilizar un proveedor como\n"
"[Infura](https://docs.infura.io/networks/starknet/how-to) o\n"
"[Alchemy](https://www.alchemy.com/starknet) para obtener un cliente RPC. Para\n"
"desarrollo y pruebas, se puede crear un nodo local temporal como `katana`."

#: src/ch02-04-katana.md:34
msgid "## Getting Started with Katana"
msgstr "## Primeros Pasos con Katana"

#: src/ch02-04-katana.md:51
msgid "To initialize a local Starknet node, execute the following command:"
msgstr "Para inicializar un nodo Starknet local, ejecute el siguiente comando:"

#: src/ch02-04-katana.md:53
msgid ""
"```bash\n"
"katana --accounts 3 --seed 0 --gas-price 250\n"
"```"
msgstr ""
"```bash\n"
"katana --accounts 3 --seed 0 --gas-price 250\n"
"```"

#: src/ch02-04-katana.md:57
msgid ""
"The `--accounts` flag determines the number of accounts to be created,\n"
"while the `--seed` flag sets the seed for the private keys of these\n"
"accounts. This ensures that initializing the node with the same seed\n"
"will always yield the same accounts. Lastly, the `--gas-price` flag\n"
"specifies the transaction gas price."
msgstr ""
"El indicador `--accounts` determina el n√∫mero de cuentas que se crear√°n, mientras que el indicador `--seed` establece la semilla para las claves privadas de estas cuentas. Esto garantiza que "
"inicializar el nodo con la misma semilla siempre generar√° las mismas cuentas. Por √∫ltimo, el indicador `--gas-price` especifica el precio del gas de transacci√≥n."

#: src/ch02-04-katana.md:63
msgid "Running the command produces output similar to this:"
msgstr "La ejecuci√≥n del comando produce un resultado similar a este:"

#: src/ch02-04-katana.md:65
msgid ""
"‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó\n"
"    ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó\n"
"    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë\n"
"    ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë\n"
"    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë\n"
"    ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù\n"
"\n"
"\n"
"    PREFUNDED ACCOUNTS\n"
"    ==================\n"
"\n"
"    | Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"    | Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"    | Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"    | Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"    | Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"    | Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"    | Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"    | Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"    | Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"    ACCOUNTS SEED\n"
"    =============\n"
"    0\n"
"\n"
"\n"
"    üöÄ JSON-RPC server started: http://0.0.0.0:5050"
msgstr ""
"‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó\n"
"    ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó\n"
"    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë\n"
"    ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë\n"
"    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë\n"
"    ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù\n"
"\n"
"\n"
"    PREFUNDED ACCOUNTS\n"
"    ==================\n"
"\n"
"    | Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"    | Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"    | Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"    | Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"    | Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"    | Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"    | Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"    | Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"    | Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"    ACCOUNTS SEED\n"
"    =============\n"
"    0\n"
"\n"
"\n"
"    üöÄ JSON-RPC server started: http://0.0.0.0:5050"

#: src/ch02-04-katana.md:96
msgid ""
"The output includes the addresses, private keys, and public keys of the\n"
"created accounts. It also contains the seed used to generate the\n"
"accounts. This seed can be reused to create identical accounts in future\n"
"runs. Additionally, the output provides the URL of the JSON-RPC server.\n"
"This URL can be used to establish a connection to the local Starknet\n"
"node."
msgstr ""
"El resultado incluye las direcciones, claves privadas y claves p√∫blicas de las cuentas creadas. Tambi√©n contiene la semilla utilizada para generar las cuentas. Esta semilla se puede reutilizar para "
"crear cuentas id√©nticas en ejecuciones futuras. Adem√°s, el resultado proporciona la URL del servidor JSON-RPC. Esta URL se puede utilizar para establecer una conexi√≥n con el nodo Starknet local."

#: src/ch02-04-katana.md:103
msgid "To stop the local Starknet node, simply press `Ctrl+C`."
msgstr "Para detener el nodo Starknet local, simplemente presione `Ctrl+C`."

#: src/ch02-04-katana.md:105
msgid ""
"The local Starknet node does not persist data. Hence, once it‚Äôs stopped,\n"
"all data will be erased."
msgstr "El nodo Starknet local no conserva datos. Por lo tanto, una vez que se detenga, se borrar√°n todos los datos."

#: src/ch02-04-katana.md:108
msgid ""
"For a practical demonstration of `katana` to deploy and interact with a\n"
"contract, see [Chapter 2‚Äôs Voting contract\n"
"example](https://book.starknet.io/chapter_2/deploy_call_invoke.html)."
msgstr ""
"Para ver una demostraci√≥n pr√°ctica de `katana` para implementar e interactuar con un contrato, consulte [Ejemplo de contrato de votaci√≥n del Cap√≠tulo 2](https://book.starknet.io/chapter_2/"
"deploy_call_invoke.html)."

#: src/ch02-05-testnet-deployment.md:1
msgid "# Testnet Deployment"
msgstr "# Implementaci√≥n de la red de Testnet"

#: src/ch02-05-testnet-deployment.md:3
msgid ""
"This chapter guides developers through the process of compiling, deploying, and interacting with a Starknet smart contract written in Cairo on the testnet. Earlier, the focus was on deploying "
"contracts using a local node, Katana. This time, the deployment and interaction target the Starknet testnet."
msgstr ""
"Este cap√≠tulo gu√≠a a los desarrolladores a trav√©s del proceso de compilaci√≥n, implementaci√≥n e interacci√≥n con un smart contract de Starknet escrito en Cairo en la red de testnet. Anteriormente, la "
"atenci√≥n se centr√≥ en implementar contratos utilizando un nodo local, Katana. Esta vez, el despliegue y la interacci√≥n tienen como objetivo la red de prueba Starknet."

#: src/ch02-05-testnet-deployment.md:5
msgid "Ensure the following commands run successfully on your system. If not, see the [Basic Installation](ch02-01-basic-installation.md) section:"
msgstr "Aseg√∫rese de que los siguientes comandos se ejecuten correctamente en su sistema. De lo contrario, consulte la secci√≥n [Instalaci√≥n b√°sica](ch02-01-basic-installation.md):"

#: src/ch02-05-testnet-deployment.md:7
msgid ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"```"
msgstr ""
"```bash\n"
"    scarb --version  # For Cairo code compilation\n"
"    starkli --version  # To interact with Starknet\n"
"```"

#: src/ch02-05-testnet-deployment.md:12
msgid "## Smart Wallet Setup"
msgstr "## Configuraci√≥n de Smart Wallet"

#: src/ch02-05-testnet-deployment.md:14
msgid ""
"A smart wallet comprises a Signer and an Account Descriptor. The Signer\n"
"is a smart contract with a private key for signing transactions, while\n"
"the Account Descriptor is a JSON file detailing the wallet‚Äôs address and\n"
"public key."
msgstr ""
"Una billetera inteligente comprende un firmante (Signer) y un descriptor de cuenta. El Signer\n"
"es un smart contract con una clave privada para firmar transacciones, mientras que el\n"
"descriptor de cuenta es un archivo JSON que detalla la direcci√≥n y la clave p√∫blica de\n"
"la billetera."

#: src/ch02-05-testnet-deployment.md:19
msgid ""
"In order for an account to be used as a signer it must be deployed to the appropriate network,\n"
"Starknet Goerli, Sepolia or mainnet, and funded. For this example we are going to use Goerli Testnet. To deploy your wallet, visit [Smart Wallet Setup](https://book.starknet.io/ch01-00-getting-"
"started.html#smart-wallet-setup).\n"
"Now you‚Äôre ready to interact with Starknet smart contracts."
msgstr ""
"Para que una cuenta pueda ser utilizada como firmante debe estar desplegada en la red apropiada,\n"
"Starknet Sepolia o mainnet, y financiada. Para este ejemplo vamos a utilizar Sepolia Testnet. Para desplegar tu wallet, visita [Smart Wallet Setup](https://book.starknet.io/ch01-00-getting-started."
"html#smart-wallet-setup).\n"
"Ahora est√°s listo para interactuar con los smart contracts de Starknet."

#: src/ch02-05-testnet-deployment.md:23
msgid "### Creating a Signer"
msgstr "### Creando un Signer"

#: src/ch02-05-testnet-deployment.md:25
msgid ""
"The Signer is an essential smart contract capable of signing\n"
"transactions in Starknet. You‚Äôll need the private key from your smart\n"
"wallet to create one, from which the public key can be derived."
msgstr ""
"El Signer es un contrato inteligente esencial capaz de firmar\n"
"transacciones en Starknet. Necesitar√° la clave privada de su smart\n"
"wallet para crear una, de la cual se puede derivar la clave p√∫blica."

#: src/ch02-05-testnet-deployment.md:29
msgid ""
"Starkli enables secure storage of your private key through a keystore\n"
"file. This encrypted file can be accessed using a password and is\n"
"generally stored in the default Starkli directory."
msgstr ""
"Starkli permite el almacenamiento seguro de su clave privada a trav√©s de un archivo\n"
"de almac√©n de claves (keystore). Se puede acceder a este archivo cifrado mediante una\n"
"contrase√±a y generalmente se almacena en el directorio predeterminado de Starkli."

#: src/ch02-05-testnet-deployment.md:33
msgid "First, create the default directory:"
msgstr "Primero, cree el directorio predeterminado:"

#: src/ch02-05-testnet-deployment.md:35
msgid ""
"```bash\n"
"    mkdir -p ~/.starkli-wallets/deployer\n"
"```"
msgstr ""
"```bash\n"
"    mkdir -p ~/.starkli-wallets/deployer\n"
"```"

#: src/ch02-05-testnet-deployment.md:39
msgid ""
"Then generate the keystore file. The signer command contains subcommands\n"
"for creating a keystore file from a private key or completely create a\n"
"new one. In this tutorial, we‚Äôll use the private key option which is the\n"
"most common use case. You need to provide the path to the keystore file\n"
"you want to create. You can give any name to the keystore file, you will\n"
"likely have several wallets. In this tutorial, we will use the name\n"
"`my_keystore_ 1.json`."
msgstr ""
"Luego genere el archivo del keystore. El comando del signer contiene subcomandos\n"
"para crear un archivo de keystore a partir de una clave privada o crear completamente uno\n"
"nuevo. En este tutorial, usaremos la opci√≥n de clave privada, que es el\n"
"caso de uso m√°s com√∫n. Debe proporcionar la ruta al archivo del keystore que\n"
"quieres crear. Puede darle cualquier nombre al archivo del keystore, probablemente\n"
"tenga varias billeteras. En este tutorial, usaremos el nombre\n"
"`my_keystore_ 1.json`."

#: src/ch02-05-testnet-deployment.md:47
msgid ""
"```bash\n"
"    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"    Enter private key:\n"
"    Enter password:\n"
"```"
msgstr ""
"```bash\n"
"    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"    Enter private key:\n"
"    Enter password:\n"
"```"

#: src/ch02-05-testnet-deployment.md:53
msgid ""
"In the private key prompt, paste the private key of your smart wallet.\n"
"In the password prompt, enter a password of your choice. You will need\n"
"this password to sign transactions using Starkli."
msgstr ""
"En el mensaje de clave privada, pegue la clave privada de su billetera inteligente. En la solicitud de contrase√±a, ingrese la contrase√±a de su elecci√≥n. Necesitar√° esta contrase√±a para firmar "
"transacciones utilizando Starkli."

#: src/ch02-05-testnet-deployment.md:57
msgid "### How to get the private key?"
msgstr "### ¬øC√≥mo obtener la private key?"

#: src/ch02-05-testnet-deployment.md:59
msgid ""
"Export the private key from your Braavos or Argent wallet. For Argent X,\n"
"you can find it in the \"Settings\" section ‚Üí Select your Account ‚Üí\n"
"\"Export Private Key\". For Braavos, you can find it in the \"Settings\"\n"
"section ‚Üí \"Privacy and Security\" ‚Üí \"Export Private Key\"."
msgstr ""
"Exporte la clave privada desde su billetera Braavos o Argent. Para Argent X, puede encontrarlo en la secci√≥n\"Settings\" section ‚Üí Select your Account ‚Üí \"Export Private Key\". Para Braavos, puede "
"encontrarlo en la secci√≥n \"Settings\" section ‚Üí \"Privacy and Security\" ‚Üí \"Export Private Key\"."

#: src/ch02-05-testnet-deployment.md:64
msgid ""
"While knowing the private key of a smart wallet is necessary to sign\n"
"transactions, it‚Äôs not sufficient. We also need to inform Starkli about\n"
"the signing mechanism employed by our smart wallet created by Braavos or\n"
"Argent X. Does it use an elliptic curve? If yes, which one? This is the\n"
"reason why we need an account descriptor file."
msgstr ""
"Si bien es necesario conocer la clave privada de una billetera inteligente para firmar transacciones, no es suficiente. Tambi√©n debemos informar a Starkli sobre el mecanismo de firma empleado por "
"nuestra billetera inteligente creada por Braavos o Argent X. ¬øUtiliza una curva el√≠ptica? ¬øSi s√≠, cual? √âsta es la raz√≥n por la que necesitamos un archivo descriptor de cuenta."

#: src/ch02-05-testnet-deployment.md:70
msgid "#### [OPTIONAL] The Architecture of the Starknet Signer"
msgstr "#### [OPCIONAL] La arquitectura del Signer en Starknet"

#: src/ch02-05-testnet-deployment.md:72
msgid "This section is optional and is intended for those who want to learn more about the Starknet Signer. If you are not interested in the details, you can skip it."
msgstr "Esta secci√≥n es opcional y est√° destinada a aquellos que quieran aprender m√°s sobre Starknet Signer. Si no est√° interesado en los detalles, puede omitirlo."

#: src/ch02-05-testnet-deployment.md:74
msgid ""
"The Starknet Signer plays an instrumental role in securing your\n"
"transactions. Let‚Äôs demystify what goes on under the hood."
msgstr "Starknet Signer desempe√±a un papel fundamental a la hora de proteger sus transacciones. Desmitifiquemos lo que sucede bajo el cap√≥."

#: src/ch02-05-testnet-deployment.md:77
msgid "Key Components:"
msgstr "Componentes Clave:"

#: src/ch02-05-testnet-deployment.md:79
msgid ""
"1.  **Private Key**: A 256-bit/32-byte/64-character (ignoring the _0x_\n"
"    prefix) hexadecimal key that is the cornerstone of your wallet‚Äôs\n"
"    security.\n"
"\n"
"2.  **Public Key**: Derived from the private key, it‚Äôs also a\n"
"    256-bit/32-byte/64-character hexadecimal key.\n"
"\n"
"3.  **Smart Wallet Address**: Unlike Ethereum, the address here is\n"
"    influenced by the public key, class hash, and a salt. **[Learn more\n"
"    in Starknet\n"
"    Documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/)**."
msgstr ""
"1. **Private Key**: una clave hexadecimal de 256 bits/32 bytes/64 caracteres (ignorando el prefijo _0x_) que es la piedra angular de la seguridad de su wallet.\n"
"\n"
"2. **Public Key**: Derivada de la clave privada, tambi√©n es una clave hexadecimal de 256 bits/32 bytes/64 caracteres.\n"
"\n"
"3. **Direcci√≥n de la Smart Wallet**: A diferencia de Ethereum, la direcci√≥n aqu√≠ est√° influenciada por la publick key, el class hash y una salt. **[Obtenga m√°s informaci√≥n en la documentaci√≥n de "
"Starknet](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/)**."

#: src/ch02-05-testnet-deployment.md:91
msgid "To view the details of the previously created keystore file:"
msgstr "Para ver los detalles del archivo de keystore creado anteriormente:"

#: src/ch02-05-testnet-deployment.md:93
msgid ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:97
msgid "Anatomy of the `keystore.json` File:"
msgstr "Anatom√≠a del archivo `keystore.json`:"

#: src/ch02-05-testnet-deployment.md:99
msgid ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": \"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": \"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": \"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": \"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": \"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": \"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"

#: src/ch02-05-testnet-deployment.md:122
msgid ""
"- **`version`**: The version of the smart wallet implementation.\n"
"\n"
"- **`id`**: A randomly generated identification string.\n"
"\n"
"- **`crypto`**: Houses all encryption details."
msgstr ""
"- **`version`**: La versi√≥n de la implementaci√≥n de la billetera inteligente.\n"
"\n"
"- **`id`**: Una cadena de identificaci√≥n generada aleatoriamente.\n"
"\n"
"- **`crypto`**: Alberga todos los detalles de cifrado."

#: src/ch02-05-testnet-deployment.md:128
msgid "Inside **`crypto`**:"
msgstr "Dentro de **`crypto`**:"

#: src/ch02-05-testnet-deployment.md:130
msgid ""
"- **`cipher`**: Specifies the encryption algorithm used, which in this\n"
"  case is AES-128-CTR.\n"
"\n"
"  - **AES (Advanced Encryption Standard)**: A globally accepted\n"
"    encryption standard.\n"
"\n"
"  - **128**: Refers to the key size in bits, making it a 128-bit\n"
"    key.\n"
"\n"
"  - **CTR (Counter Mode)**: A specific mode of operation for the AES\n"
"    cipher.\n"
"\n"
"- **`cipherparams`**: Contains an Initialization Vector (IV), which\n"
"  ensures that encrypting the same plaintext with the same key will\n"
"  produce different ciphertexts.\n"
"\n"
"  - **`iv` (Initialization Vector)**: A 16-byte hex string that\n"
"    serves as a random and unique starting point for each encryption\n"
"    operation.\n"
"\n"
"- **`ciphertext`**: This is the private key after encryption, securely\n"
"  stored so that only the correct password can reveal it.\n"
"\n"
"- **`kdf` and `kdfparams`**: KDF stands for Key Derivation Function.\n"
"  This adds a layer of security by requiring computational work,\n"
"  making brute-force attacks harder.\n"
"\n"
"  - **`dklen`**: The length (in bytes) of the derived key. Typically\n"
"    32 bytes.\n"
"\n"
"  - **`n`**: A cost factor representing CPU/memory usage. A higher\n"
"    value means more computational work is needed, thus increasing\n"
"    security.\n"
"\n"
"  - **`p`**: Parallelization factor, affecting the computational\n"
"    complexity.\n"
"\n"
"  - **`r`**: Block size for the hash function, again affecting\n"
"    computational requirements.\n"
"\n"
"  - **`salt`**: A random value that is combined with the password to\n"
"    deter dictionary attacks.\n"
"\n"
"- **`mac` (Message Authentication Code)**: This is a cryptographic\n"
"  code that ensures the integrity of the message (the encrypted\n"
"  private key in this case). It is generated using a hash of both the\n"
"  ciphertext and a portion of the derived key."
msgstr ""
"- **`cipher`**: Especifica el algoritmo de cifrado utilizado, que en este caso es AES-128-CTR.\n"
"\n"
"   - **AES (Est√°ndar de cifrado avanzado)**: Un est√°ndar de cifrado aceptado globalmente.\n"
"\n"
"   - **128**: Hace referencia al tama√±o de la clave en bits, por lo que es una clave de 128 bits.\n"
"\n"
"   - **CTR (Modo Contador)**: Un modo de operaci√≥n espec√≠fico para el cifrado AES.\n"
"\n"
"- **`cipherparams`**: Contiene un vector de inicializaci√≥n (IV), que garantiza que cifrar el mismo texto sin formato con la misma clave producir√° textos cifrados diferentes.\n"
"\n"
"   - **`iv` (Vector de inicializaci√≥n)**: Una cadena hexadecimal de 16 bytes que sirve como punto de partida aleatorio y √∫nico para cada operaci√≥n de cifrado.\n"
"\n"
"- **`ciphertext`**: Esta es la clave privada despu√©s del cifrado, almacenada de forma segura para que solo la contrase√±a correcta pueda revelarla.\n"
"\n"
"- **`kdf` y `kdfparams`**: KDF significa Funci√≥n de derivaci√≥n de claves. Esto a√±ade una capa de seguridad al requerir trabajo computacional,\n"
"   haciendo que los ataques de fuerza bruta sean m√°s dif√≠ciles.\n"
"\n"
"   - **`dklen`**: La longitud (en bytes) de la clave derivada. Normalmente 32 bytes.\n"
"\n"
"   - **`n`**: un factor de costo que representa el uso de CPU/memoria. Un valor m√°s alto significa que se necesita m√°s trabajo computacional, lo que aumenta la seguridad.\n"
"\n"
"   - **`p`**: Factor de paralelizaci√≥n, que afecta la complejidad computacional.\n"
"\n"
"   - **`r`**: Tama√±o de bloque para la funci√≥n hash, lo que nuevamente afecta los requisitos computacionales.\n"
"\n"
"   - **`salt`**: Un valor aleatorio que se combina con la contrase√±a para disuadir ataques de diccionario.\n"
"\n"
"- **`mac` (C√≥digo de autenticaci√≥n de mensaje)**: Este es un c√≥digo criptogr√°fico que asegura la integridad del mensaje (el mensaje cifrado\n"
"   clave privada en este caso). Se genera utilizando un hash tanto del texto cifrado como de una parte de la clave derivada."

#: src/ch02-05-testnet-deployment.md:178
msgid "Before to continue, we have to choose a rpc provider"
msgstr "Antes de continuar, tenemos que elegir un proveedor de rpc"

#: src/ch02-05-testnet-deployment.md:180
msgid "### Choosing an RPC Provider"
msgstr "### Elegir un Proveedor de RPC"

#: src/ch02-05-testnet-deployment.md:182
msgid "There are three main options for RPC providers, sorted by ease of use:"
msgstr "Hay tres opciones principales para los proveedores de RPC, ordenadas por facilidad de uso:"

#: src/ch02-05-testnet-deployment.md:184
msgid ""
"1.  **Infura or Alchemy**: A step up in complexity. You‚Äôll need to set\n"
"    up an API key and choose an endpoint. For Infura, it would look like\n"
"    `https://starknet-sepolia.infura.io/v3/<API_KEY>`. Learn more in the\n"
"    [Infura\n"
"    documentation](https://docs.infura.io/networks/starknet/how-to/choose-a-network).\n"
"\n"
"2.  **Your Own Node**: For those who want full control. It‚Äôs the most\n"
"    complex but offers the most freedom. Check out [Chapter 4 of the\n"
"    Starknet Book](https://book.starknet.io/chapter_4/node.html) or\n"
"    [Kasar](https://www.kasar.io/) for setup guides.\n"
"\n"
"3.  **Free RPC vendor**: These 3 networks are eligible for free RPC vendors: mainet, goerli, sepolia.\n"
"    You can choose [Blast](https://blastapi.io/public-api/starknet) or [Nethermind](https://data.voyager.online/)"
msgstr ""
"1.  **Infura o Alchemy**: Un paso adelante en complejidad. Tendr√° que configurar\n"
"    una clave API y elegir un punto final. Para Infura, ser√≠a algo as√≠\n"
"    `https://starknet-sepolia.infura.io/v3/<API_KEY>`. M√°s informaci√≥n en\n"
"    [Infura\n"
"    documentaci√≥n](https://docs.infura.io/networks/starknet/how-to/choose-a-network).\n"
"\n"
"2.  **Tu Propio Nodo**: Para los que quieren control total. Es el m√°s\n"
"    complejo pero ofrece la mayor libertad. Consulta el [Cap√≠tulo 4 del\n"
"    Libro Starknet](https://book.starknet.io/chapter_4/node.html) o\n"
"    [Kasar](https://www.kasar.io/) para obtener gu√≠as de configuraci√≥n.\n"
"\n"
"3.  **Proveedor RPC gratuito**: Estas 3 redes son elegibles para proveedores RPC gratuitos: mainet, goerli, sepolia.\n"
"    Puedes elegir [Blast](https://blastapi.io/public-api/starknet) o [Nethermind](https://data.voyager.online/)"

#: src/ch02-05-testnet-deployment.md:198
msgid "### Creating an Account Descriptor"
msgstr "### Creaci√≥n de un Descriptor de Cuenta"

#: src/ch02-05-testnet-deployment.md:200
msgid ""
"An Account Descriptor informs Starkli about your smart wallet‚Äôs unique\n"
"features, such as its signing mechanism. You can generate this\n"
"descriptor using Starkli‚Äôs `fetch` subcommand under the `account`\n"
"command. The `fetch` subcommand takes your on-chain wallet address as\n"
"input and generates the account descriptor file. The account descriptor\n"
"file is a JSON file that contains the details of your smart wallet. We also have to pass the rpc provider here."
msgstr ""
"Un Descriptor de Cuenta informa a Starkli sobre las caracter√≠sticas √∫nicas de su smart wallet,\n"
"como su mecanismo de firma. Puedes generar este\n"
"descriptor usando el subcomando `fetch` de Starkli bajo el comando `account`.\n"
"El subcomando `fetch` toma la direcci√≥n de su billetera en cadena como\n"
"entrada y genera el archivo descriptor de cuenta. El descriptor de cuenta\n"
"es un archivo JSON que contiene los detalles de su billetera inteligente. Tambi√©n tenemos que pasar el proveedor rpc aqu√≠."

#: src/ch02-05-testnet-deployment.md:207
msgid ""
"```bash\n"
"    starkli account fetch <SMART_WALLET_ADDRESS> --output ~/.starkli-wallets/deployer/my_account_1.json --rpc https://starknet-testnet.public.blastapi.io/rpc/v0_6\n"
"```"
msgstr ""
"```bash\n"
"    starkli account fetch <SMART_WALLET_ADDRESS> --output ~/.starkli-wallets/deployer/my_account_1.json --rpc https://starknet-testnet.public.blastapi.io/rpc/v0_6\n"
"```"

#: src/ch02-05-testnet-deployment.md:211
msgid ""
"Note: Here we used the Public RPC Endpoint v0.6 Starknet (Goerli) Testnet from **Blast**. If you don't specify the rpc provider, Starkli will use Goerli, which will be deprecated in the upcoming "
"months. Thus you can check the rpc url for Sepolia network on [Blast](https://blastapi.io/public-api/starknet)."
msgstr ""
"Nota: Aqu√≠ usamos el Public RPC Endpoint v0.6 Starknet (Goerli) Testnet de **Blast**. Si no especifica el proveedor rpc, Starkli utilizar√° Goerli, que ser√° obsoleto en los pr√≥ximos meses. Por lo "
"tanto, puede consultar la url rpc para la red Sepolia en [Blast](https://blastapi.io/public-api/starknet)."

#: src/ch02-05-testnet-deployment.md:213
msgid ""
"> ‚ö†Ô∏è **Contract not found?**\n"
">\n"
"> In case you face an error like this:\n"
">\n"
"> ```bash\n"
">     Error: ContractNotFound\n"
"> ```\n"
">\n"
"> #### üü© Solution:\n"
">\n"
"> It means you probably just created a new wallet and it has **not been deployed yet**. To accomplish this you have to fund your wallet with tokens and **transfer tokens** to a **different** wallet "
"address. For goerli tokens you can check this [faucet](https://faucet.goerli.starknet.io/). For Sepolia tokens detailed intructons can be found in the [Get Sepolia Tokens](./ch02-05-01-start-with-"
"sepolia.md) section.\n"
">\n"
"> **Still doesn't work?**\n"
">\n"
"> Check if your wallet's testnet network isn't yet set with Goerli or Sepolia, try again with your blast rpc url.\n"
">\n"
"> ```bash\n"
"> starknet account fetch ... --rpc https://starknet-testnet.public.blastapi.io/rpc/\n"
"> ```\n"
">\n"
"> ‚ö†Ô∏è And if you use Goerli, make sure you use it in subsequent commands as well."
msgstr ""
"> ‚ö†Ô∏è **¬øContrato no encontrado?**\n"
">\n"
"> En caso de que te encuentres con un error como este:\n"
">\n"
"> ``bash\n"
"> Error: ContractNotFound\n"
"> ```\n"
">\n"
"> #### üü© Soluci√≥n:\n"
">\n"
"> Significa que probablemente acabas de crear un nuevo monedero y **todav√≠a no ha sido desplegado**. Para ello tienes que financiar tu monedero con tokens y **transferir tokens** a una direcci√≥n de "
"monedero **diferente**. Para los tokens goerli puedes consultar este [faucet](https://faucet.goerli.starknet.io/). Para los tokens Sepolia puedes encontrar instrucciones detalladas en la secci√≥n "
"[Get Sepolia Tokens](./ch02-05-01-start-with-sepolia.md).\n"
">\n"
"> ¬øSigue sin funcionar?\n"
">\n"
"> Comprueba si la red testnet de tu wallet a√∫n no est√° configurada con Goerli o Sepolia, int√©ntalo de nuevo con tu url rpc blast.\n"
">\n"
"> ``bash\n"
"> starknet account fetch ... --rpc https://starknet-testnet.public.blastapi.io/rpc/\n"
"> ```\n"
">\n"
"> ‚ö†Ô∏è Y si usas Goerli, aseg√∫rate de usarlo tambi√©n en los comandos siguientes."

#: src/ch02-05-testnet-deployment.md:235
msgid ""
"After this process, search your wallet address on the Starknet explorer. To see the details, go back to [Smart Wallet Setup](https://book.starknet.io/ch01-00-getting-started.html#smart-wallet-"
"setup)."
msgstr ""
"Despu√©s de este proceso, busque la direcci√≥n de su billetera en el explorador Starknet. Para ver los detalles, regrese a [Configuraci√≥n de Smart Wallet](https://book.starknet.io/ch01-00-getting-"
"started.html#smart-wallet-setup)."

#: src/ch02-05-testnet-deployment.md:237
msgid ""
"After running the command, you‚Äôll see a message like the one below.\n"
"We‚Äôre using a Braavos wallet as an example, but the steps are the same\n"
"for an Argent wallet."
msgstr "Despu√©s de ejecutar el comando, ver√° un mensaje como el siguiente. Estamos usando una billetera Braavos como ejemplo, pero los pasos son los mismos para una billetera Argent."

#: src/ch02-05-testnet-deployment.md:241
msgid ""
"```bash\n"
"    Account contract type identified as: Braavos\n"
"    Description: Braavos official proxy account\n"
"    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"
msgstr ""
"```bash\n"
"    Account contract type identified as: Braavos\n"
"    Description: Braavos official proxy account\n"
"    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:247
msgid "After the acount descriptor file is generated, you can see its details, run:"
msgstr "Una vez generado el archivo descriptor de la cuenta, puede ver sus detalles y ejecutar:"

#: src/ch02-05-testnet-deployment.md:249
msgid ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:253
msgid "Here‚Äôs what a typical descriptor might look like:"
msgstr "As√≠ es como podr√≠a verse un descriptor t√≠pico:"

#: src/ch02-05-testnet-deployment.md:255
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": \"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": \"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": \"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": \"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"

#: src/ch02-05-testnet-deployment.md:280
msgid "Note: The structure will differ if you use an Argent wallet."
msgstr "Note: The structure will differ if you use an Argent wallet."

#: src/ch02-05-testnet-deployment.md:282
msgid "## Setting up Environment Variables"
msgstr "## Configuraci√≥n de Variables de Entorno"

#: src/ch02-05-testnet-deployment.md:284
msgid ""
"To simplify Starkli commands, you can set environment variables. Two key\n"
"variables are crucial: one for the Signer‚Äôs keystore file location and\n"
"another for the Account Descriptor file."
msgstr ""
"Para simplificar los comandos de Starkli, puede configurar variables de entorno. Dos variables clave son cruciales: una para la ubicaci√≥n del archivo del keystore del firmante y otra para el "
"archivo del descriptor de cuenta."

#: src/ch02-05-testnet-deployment.md:288
msgid ""
"```bash\n"
"    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"    export STARKNET_RPC=https://starknet-testnet.public.blastapi.io/rpc/v0_6\n"
"```"
msgstr ""
"```bash\n"
"    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"    export STARKNET_RPC=https://starknet-testnet.public.blastapi.io/rpc/v0_6\n"
"```"

#: src/ch02-05-testnet-deployment.md:294
msgid ""
"Setting these variables makes running Starkli commands easier and more\n"
"efficient."
msgstr "Configurar estas variables hace que la ejecuci√≥n de comandos Starkli sea m√°s f√°cil y eficiente."

#: src/ch02-05-testnet-deployment.md:299
msgid "Deploying a smart contract on Starknet involves two steps:"
msgstr "Implementar un contrato inteligente en Starknet implica dos pasos:"

#: src/ch02-05-testnet-deployment.md:301
msgid ""
"- Declare your contract‚Äôs code.\n"
"- Deploy an instance of the declared code."
msgstr ""
"- Declara el c√≥digo de tu contrato.\n"
"- Implementar una instancia del c√≥digo declarado."

#: src/ch02-05-testnet-deployment.md:304
msgid ""
"To get started, navigate to the `src/` directory in the [examples/Ownable-Starknet](https://github.com/starknet-edu/starknetbook/tree/main/examples/Ownable-Starknet) directory\n"
"of the Starknet Book repo. The `src/lib.cairo` file contains a basic\n"
"contract to practice with."
msgstr ""
"Para comenzar, navegue hasta el directorio `src/` en el directorio [examples/Ownable-Starknet](https://github.com/starknet-edu/starknetbook/tree/main/examples/Ownable-Starknet)\n"
"del repositorio de Starknet Book. El archivo `src/lib.cairo` contiene un contrato b√°sico\n"
"para practicar."

#: src/ch02-05-testnet-deployment.md:308
msgid ""
"First, compile the contract using the Scarb compiler. If you haven‚Äôt\n"
"installed Scarb, follow the installation guide in the [basic installation](./ch02-01-basic-installation)\n"
"section."
msgstr ""
"Primero, compila el contrato usando el compilador Scarb. Si no has instalado\n"
"Scarb, siga la gu√≠a de instalaci√≥n en la secci√≥n [instalaci√≥n b√°sica](./ch02-01-basic-installation)."

#: src/ch02-05-testnet-deployment.md:312
msgid ""
"```bash\n"
"    scarb build\n"
"```"
msgstr ""
"```bash\n"
"    scarb build\n"
"```"

#: src/ch02-05-testnet-deployment.md:316
msgid ""
"This creates a compiled contract in `target/dev/` as\n"
"`ownable_starknet_ownable.compiled_contract_class.json` (in Chapter 2 of the book we will learn\n"
"more details about Scarb)."
msgstr ""
"Esto crea un contrato compilado en `target/dev/` como\n"
"`ownable_starknet_ownable.compiled_contract_class.json` (en el Cap√≠tulo 2 del libro aprenderemos\n"
"m√°s detalles sobre Scarb)."

#: src/ch02-05-testnet-deployment.md:320
msgid "### Declaring Your Contract"
msgstr "### Declarando su Contrato"

#: src/ch02-05-testnet-deployment.md:322
msgid ""
"Run this command to declare your contract using the default Starknet\n"
"Sequencer‚Äôs Gateway:"
msgstr "Ejecute este comando para declarar su contrato utilizando la puerta de enlace predeterminada del secuenciador Starknet:"

#: src/ch02-05-testnet-deployment.md:325
msgid ""
"```bash\n"
"    starkli declare ./target/dev/ownable_starknet_ownable.contract_class.json\n"
"```"
msgstr ""
"```bash\n"
"    starkli declare ./target/dev/ownable_starknet_ownable.contract_class.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:329
msgid ""
"According to the `STARKNET_RPC` url, starkli can recognize the target\n"
"blockchain network, in this case \"goerli\", so it is not necessary\n"
"explicitly specify it."
msgstr ""
"De acuerdo con la url `STARKNET_RPC`, starkli puede reconocer la red blockchain\n"
"de destino, en este caso \"goerli\", por lo que no es necesario\n"
"especificarlo expl√≠citamente."

#: src/ch02-05-testnet-deployment.md:333
msgid ""
"Unless you‚Äôre working with custom networks where it‚Äôs infeasible for\n"
"Starkli to detect the right compiler version, you shouldn‚Äôt need to\n"
"manually choose a version with `--network` and `--compiler-version`."
msgstr ""
"A menos que est√© trabajando con redes personalizadas donde a Starkli no le resulta factible detectar la versi√≥n correcta del compilador, no deber√≠a necesitar elegir manualmente una versi√≥n con `--"
"network` y `--compiler-version`."

#: src/ch02-05-testnet-deployment.md:337
msgid ""
"If you encounter an \"Error: Invalid contract class,\" it likely means\n"
"your Scarb‚Äôs compiler version is incompatible with Starkli. Follow the\n"
"steps above to align the versions. Starkli usually supports compiler\n"
"versions accepted by mainnet, even if Scarb‚Äôs latest version is not yet\n"
"compatible."
msgstr ""
"Si encuentra un \"Error: Invalid contract class\", probablemente significa que la versi√≥n del compilador de Scarb no es compatible con Starkli. Siga los pasos anteriores para alinear las versiones. "
"Starkli generalmente admite versiones de compiladores aceptadas por la red principal, incluso si la √∫ltima versi√≥n de Scarb a√∫n no es compatible."

#: src/ch02-05-testnet-deployment.md:343
msgid ""
"After running the command, you‚Äôll receive a contract class hash. This\n"
"unique hash serves as the identifier for your contract class within\n"
"Starknet. For example:"
msgstr "Despu√©s de ejecutar el comando, recibir√° un hash de clase de contrato. Este hash √∫nico sirve como identificador de su clase de contrato (contract class) dentro de Starknet. Por ejemplo:"

#: src/ch02-05-testnet-deployment.md:347
msgid ""
"```bash\n"
"    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"
msgstr ""
"```bash\n"
"    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"

#: src/ch02-05-testnet-deployment.md:351
msgid ""
"You can think of this hash as the contract class‚Äôs _address._ Use a\n"
"block explorer like\n"
"[StarkScan](https://testnet.starkscan.co/class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8)\n"
"to verify this hash on the blockchain."
msgstr ""
"Puede considerar este hash como la direcci√≥n de la clase de contrato. Utilice un explorador de bloques como [StarkScan](https://testnet.starkscan.co/"
"class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) para verificar este hash en la cadena de bloques."

#: src/ch02-05-testnet-deployment.md:356
msgid ""
"If the contract class you‚Äôre attempting to declare already exists, it is\n"
"ok we can continue. You‚Äôll receive a message like:"
msgstr "Si la contract class que intenta declarar ya existe, est√° bien, podemos continuar. Recibir√°s un mensaje como:"

#: src/ch02-05-testnet-deployment.md:359
msgid ""
"```bash\n"
"    Not declaring class as its already declared. Class hash:\n"
"    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"
msgstr ""
"```bash\n"
"    Not declaring class as its already declared. Class hash:\n"
"    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
"```"

#: src/ch02-05-testnet-deployment.md:364
msgid "## Deploying Smart Contracts on Starknet"
msgstr "## Implementaci√≥n de Smart Contracts en Starknet"

#: src/ch02-05-testnet-deployment.md:366
msgid ""
"To deploy a smart contract, you‚Äôll need to instantiate it on Starknet‚Äôs\n"
"testnet. This process involves executing a command that requires two\n"
"main components:"
msgstr ""
"Para implementar un contrato inteligente, deber√° crear una instancia del mismo en la red de prueba de Starknet. Este proceso implica ejecutar un comando que requiere dos componentes principales:"

#: src/ch02-05-testnet-deployment.md:370
msgid ""
"1.  The class hash of your smart contract.\n"
"\n"
"2.  Any constructor arguments that the contract expects."
msgstr ""
"1. El class hash de tu contrato inteligente.\n"
"\n"
"2. Cualquier argumento del constructor que el contrato espera."

#: src/ch02-05-testnet-deployment.md:374
msgid ""
"In our example, the constructor expects an _owner_ address. You can\n"
"learn more about constructors in [Chapter 12 of The Cairo\n"
"Book](https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-constructors)."
msgstr ""
"En nuestro ejemplo, el constructor espera una direcci√≥n de_owner_. Puede\n"
"obtener m√°s informaci√≥n sobre los constructores en el [Cap√≠tulo 12 del Libro de \n"
"Cairo](https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-constructors)."

#: src/ch02-05-testnet-deployment.md:378
msgid "The command would look like this:"
msgstr "El comando se ver√≠a as√≠:"

#: src/ch02-05-testnet-deployment.md:386
msgid ""
"Here‚Äôs a specific example with an actual class hash and constructor\n"
"inputs (as the owner address use the address of your smart wallet so you\n"
"can invoke the transfer_ownership function later):"
msgstr ""
"Aqu√≠ hay un ejemplo espec√≠fico con un class hash real y entradas de constructor (como direcci√≥n del owner, use la direcci√≥n de su billetera inteligente para poder invocar la funci√≥n "
"transfer_ownership m√°s adelante):"

#: src/ch02-05-testnet-deployment.md:390
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \\\n"
"        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \\\n"
"        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510\n"
"```"

#: src/ch02-05-testnet-deployment.md:396
msgid ""
"After executing the command and entering your password, you should see\n"
"output like the following:"
msgstr "Despu√©s de ejecutar el comando e ingresar su contrase√±a, deber√≠a ver un resultado como el siguiente:"

#: src/ch02-05-testnet-deployment.md:399
msgid ""
"```bash\n"
"    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...\n"
"    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14\n"
"    Contract deployed:\n"
"    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"```"
msgstr ""
"```bash\n"
"    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...\n"
"    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14\n"
"    Contract deployed:\n"
"    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
"```"

#: src/ch02-05-testnet-deployment.md:407
msgid ""
"The contract is now live on the Starknet testnet. You can verify its\n"
"status using a block explorer like\n"
"[StarkScan](https://testnet.starkscan.co/contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012).\n"
"On the \"Read/Write Contract\" tab, you‚Äôll see the contract‚Äôs external\n"
"functions."
msgstr ""
"El contrato ya est√° activo en la red de prueba de Starknet. Puede verificar su estado utilizando un explorador de bloques como [StarkScan](https://testnet.starkscan.co/"
"contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012). En la pesta√±a \"Read/Write Contract\", ver√° las funciones externas del contrato."

#: src/ch02-05-testnet-deployment.md:413
msgid "## Interacting with the Starknet Contract"
msgstr "## Interactuando con el Contrato Starknet"

#: src/ch02-05-testnet-deployment.md:415
msgid ""
"Starkli enables interaction with smart contracts via two primary\n"
"methods: `call` for read-only functions and `invoke` for write functions\n"
"that modify the state."
msgstr ""
"Starkli permite la interacci√≥n con contratos inteligentes a trav√©s de dos m√©todos principales:  `call` para funciones de solo lectura e invoke`para funciones de escritura que modifican el estado."

#: src/ch02-05-testnet-deployment.md:419
msgid "### Calling a Read Function"
msgstr "### Llamar a una Funci√≥n de Lectura"

#: src/ch02-05-testnet-deployment.md:421
msgid ""
"The `call` command enables you to query a smart contract function\n"
"without sending a transaction. For instance, to find out who the current\n"
"owner of the contract is, you can use the `get_owner` function, which\n"
"requires no arguments."
msgstr ""
"El comando `call` le permite consultar una funci√≥n de contrato inteligente sin enviar una transacci√≥n. Por ejemplo, para saber qui√©n es el propietario actual del contrato, puede utilizar la funci√≥n "
"`get_owner`, que no requiere argumentos."

#: src/ch02-05-testnet-deployment.md:426 src/ch02-05-testnet-deployment.md:482
msgid ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        owner\n"
"```"
msgstr ""
"```bash\n"
"    starkli call \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        owner\n"
"```"

#: src/ch02-05-testnet-deployment.md:432
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of your recently deployed contract. The command will return the owner‚Äôs address, which was initially set during\n"
"the contract‚Äôs deployment:"
msgstr ""
"Reemplace `<CONTRACT_ADDRESS>` con la direcci√≥n de su contrato implementado recientemente. El comando devolver√° la direcci√≥n del propietario, que se configur√≥ inicialmente durante\n"
"el despliegue del contrato:"

#: src/ch02-05-testnet-deployment.md:435
msgid ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"
msgstr ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"

#: src/ch02-05-testnet-deployment.md:441
msgid "## Invoking a Write Function"
msgstr "## Invocar una Funci√≥n de Escritura"

#: src/ch02-05-testnet-deployment.md:443
msgid ""
"You can modify the contract‚Äôs state using the `invoke` command. For\n"
"example, let‚Äôs transfer the contract‚Äôs ownership with the\n"
"`transfer_ownership` function."
msgstr "Puede modificar el estado del contrato utilizando el comando`invoke`. Por ejemplo, transfiramos la propiedad del contrato con la funci√≥n `transfer_ownership`."

#: src/ch02-05-testnet-deployment.md:447
msgid ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        transfer_ownership \\\n"
"        <NEW_OWNER_ADDRESS>\n"
"```"
msgstr ""
"```bash\n"
"    starkli invoke \\\n"
"        <CONTRACT_ADDRESS> \\\n"
"        transfer_ownership \\\n"
"        <NEW_OWNER_ADDRESS>\n"
"```"

#: src/ch02-05-testnet-deployment.md:454
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of the contract and\n"
"`<NEW_OWNER_ADDRESS>` with the address you want to transfer ownership\n"
"to. If the smart wallet you‚Äôre using isn‚Äôt the contract‚Äôs owner, an\n"
"error will appear. Note that the initial owner was set when deploying\n"
"the contract:"
msgstr ""
"Reemplace `<CONTRACT_ADDRESS>` con la direcci√≥n del contrato y `<NEW_OWNER_ADDRESS>` con la direcci√≥n a la que desea transferir la propiedad. Si la billetera inteligente que est√° utilizando no es "
"la propietaria del contrato, aparecer√° un error. Tenga en cuenta que el propietario inicial se estableci√≥ al implementar el contrato:"

#: src/ch02-05-testnet-deployment.md:460
msgid ""
"```bash\n"
"    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].\n"
"```"
msgstr ""
"```bash\n"
"    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].\n"
"```"

#: src/ch02-05-testnet-deployment.md:464
msgid ""
"The failure reason is encoded as a felt. o decode it, use the starkli‚Äôs\n"
"`parse-cairo-string` command."
msgstr "El motivo del fracaso est√° codificado como un sentimiento. Para decodificarlo, use el comando `parse-cairo-string` de starkli."

#: src/ch02-05-testnet-deployment.md:467
msgid ""
"```bash\n"
"    starkli parse-cairo-string <ENCODED_ERROR>\n"
"```"
msgstr ""
"```bash\n"
"    starkli parse-cairo-string <ENCODED_ERROR>\n"
"```"

#: src/ch02-05-testnet-deployment.md:471
msgid ""
"For example, if you see\n"
"`0x43616c6c6572206973206e6f7420746865206f776e6572`, decoding it will\n"
"yield \"Caller is not the owner.\""
msgstr "Por ejemplo, si ve `0x43616c6c6572206973206e6f7420746865206f776e6572`, al decodificarlo se obtendr√° \"Caller is not the owner.\""

#: src/ch02-05-testnet-deployment.md:475
msgid ""
"After a successful transaction on L2, use a block explorer like\n"
"StarkScan or Voyager to confirm the transaction status using the hash\n"
"provided by the `invoke` command."
msgstr "Despu√©s de una transacci√≥n exitosa en L2, use un explorador de bloques como StarkScan o Voyager para confirmar el estado de la transacci√≥n usando el hash proporcionado por el comando`invoke`."

#: src/ch02-05-testnet-deployment.md:479
msgid ""
"To verify that the ownership has successfully transferred, you can call\n"
"the `get_owner` function again:"
msgstr "Para verificar que la propiedad se haya transferido exitosamente, puedes volver a llamar a la funci√≥n `get_owner`:"

#: src/ch02-05-testnet-deployment.md:488
msgid ""
"If the function returns the new owner‚Äôs address, the transfer was\n"
"successful."
msgstr "Si la funci√≥n devuelve la direcci√≥n del nuevo propietario, la transferencia fue exitosa."

#: src/ch02-05-testnet-deployment.md:491
msgid ""
"Congratulations! You‚Äôve successfully deployed and interacted with a\n"
"Starknet contract."
msgstr "¬°Felicidades! Ha implementado e interactuado con √©xito con un contrato Starknet."

#: src/ch02-05-01-start-with-sepolia.md:1
msgid "# Get started with Sepolia - Get ETH and deploy your wallet"
msgstr "# Comience con Sepolia - Obtenga ETH e implemente su billetera"

#: src/ch02-05-01-start-with-sepolia.md:3
msgid "## Overview"
msgstr "## Descripci√≥n General"

#: src/ch02-05-01-start-with-sepolia.md:5
msgid ""
"Currently, there are no active Sepolia faucets in Starknet. Therefore, the process of acquiring SEPOLIA tokens involves obtaining them on the **Ethereum** Sepolia testnet and then transferring them "
"to the Starknet Sepolia testnet."
msgstr ""
"Actualmente, no hay faucets Sepolia activos en Starknet. Por lo tanto, el proceso de adquisici√≥n de tokens SEPOLIA implica obtenerlos en la red de prueba **Ethereum** Sepolia y luego transferirlos "
"a la red de prueba Starknet Sepolia."

#: src/ch02-05-01-start-with-sepolia.md:7
msgid "## Step 1: Obtain SEPOLIA Tokens on the Ethereum Sepolia Testnet"
msgstr "## Paso 1: Obtenga tokens SEPOLIA en Ethereum Sepolia Testnet"

#: src/ch02-05-01-start-with-sepolia.md:9
msgid "To acquire $ETH on the Ethereum Sepolia testnet, you can use:"
msgstr "Para adquirir $ETH en la red de prueba Ethereum Sepolia, puede utilizar:"

#: src/ch02-05-01-start-with-sepolia.md:11
msgid ""
"1. [Alchemy's Sepolia Faucet](https://sepoliafaucet.com/).\n"
"2. [Infura's Sepolia Faucet](https://www.infura.io/faucet/sepolia).\n"
"3. [LearnWeb3's Sepolia Faucet](https://learnweb3.io/faucets/sepolia)."
msgstr ""
"1. [Alchemy's Sepolia Faucet](https://sepoliafaucet.com/).\n"
"2. [Infura's Sepolia Faucet](https://www.infura.io/faucet/sepolia).\n"
"3. [LearnWeb3's Sepolia Faucet](https://learnweb3.io/faucets/sepolia)."

#: src/ch02-05-01-start-with-sepolia.md:15
msgid "The process is simple: log in, paste your Ethereum Sepolia testnet address, and click the \"Send me $ETH\" button."
msgstr "El proceso es simple: inicie sesi√≥n, pegue su direcci√≥n de prueba de Ethereum Sepolia y haga clic en el bot√≥n \"Enviarme $ETH\"."

#: src/ch02-05-01-start-with-sepolia.md:17
msgid "## Step 2: Transfer Your $ETH to the Starknet Sepolia Testnet"
msgstr "## Paso 2: Transfiera su $ETH a Starknet Sepolia Testnet"

#: src/ch02-05-01-start-with-sepolia.md:19
msgid "This step is slightly more complex. You will need to navigate to the [Bridge Contract](https://sepolia.etherscan.io/address/0x8453FC6Cd1bCfE8D4dFC069C400B433054d47bDc#writeProxyContract)."
msgstr "Este paso es un poco m√°s complejo. Deber√° navegar hasta el [Contrato del Bridge](https://sepolia.etherscan.io/address/0x8453FC6Cd1bCfE8D4dFC069C400B433054d47bDc#writeProxyContract)."

#: src/ch02-05-01-start-with-sepolia.md:21
msgid "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch02-05-01-bridge-sepolia.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch02-05-01-bridge-sepolia.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch02-05-01-start-with-sepolia.md:23
msgid "Connect the wallet containing your $ETH and then open function number 4 `deposit (0xe2bbb158)`."
msgstr "Conecte la billetera que contiene su $ETH y luego abra la funci√≥n n√∫mero 4 `dep√≥sito (0xe2bbb158)`."

#: src/ch02-05-01-start-with-sepolia.md:25
msgid "### Parameter Specification"
msgstr "### Especificaci√≥n de Par√°metros"

#: src/ch02-05-01-start-with-sepolia.md:27
msgid "For the fields, specify:"
msgstr "Para los campos, especifique:"

#: src/ch02-05-01-start-with-sepolia.md:29
msgid ""
"- `deposit`: The amount of ETH to deposit **plus** a small amount for gas. For example, `x + 0.001 ETH`. (Ex: 0.031)\n"
"- `amount`: The amount of $ETH you want to transfer to Starknet in **uint256** format. In this case, `0.03 ETH` would be `30000000000000000` (16 decimals)."
msgstr ""
"- `deposit`: La cantidad de ETH a depositar **m√°s** una peque√±a cantidad para gasolina. Por ejemplo, `x + 0,001 ETH`. (Ejemplo: 0,031)\n"
"- `amount`: La cantidad de $ETH que deseas transferir a Starknet en formato **uint256**. En este caso, `0.03 ETH` ser√≠a `30000000000000000` (16 decimales)."

#: src/ch02-05-01-start-with-sepolia.md:32
msgid ""
"```bash\n"
"1 ETH = 1000000000000000000 (18 decimals)\n"
"```"
msgstr ""
"```bash\n"
"1 ETH = 1000000000000000000 (18 decimals)\n"
"```"

#: src/ch02-05-01-start-with-sepolia.md:36
msgid "- `l2Recipient`: The address of your Starknet Sepolia testnet account."
msgstr "- `l2Recipient`: La direcci√≥n de su cuenta de testnet de Starknet Sepolia."

#: src/ch02-05-01-start-with-sepolia.md:38
msgid "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch02-05-01-deposit-bridge-starknet.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch02-05-01-deposit-bridge-starknet.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch02-05-01-start-with-sepolia.md:40
msgid "Click the \"Write\" button and confirm the transaction in your wallet."
msgstr "Haga clic en el bot√≥n \"Write\" y confirme la transacci√≥n en su billetera."

#: src/ch02-05-01-start-with-sepolia.md:42
msgid "## [Optional] Wallet Deployment"
msgstr "## [Opcional] Implementaci√≥n de billetera"

#: src/ch02-05-01-start-with-sepolia.md:44
msgid ""
"If this is your first time using your wallet on the Starknet Sepolia testnet, go to your ArgentX or Braavos wallet and send some of the ETH you transferred to **another starknet wallet**. This will "
"automatically deploy your wallet."
msgstr ""
"Si es la primera vez que usa su billetera en la red de prueba Starknet Sepolia, vaya a su billetera ArgentX o Braavos y env√≠e parte del ETH que transfiri√≥ a **otra billetera starknet**. Esto "
"implementar√° autom√°ticamente su billetera."

#: src/ch02-06-starkli.md:1
msgid "# Starkli: Querying Starknet"
msgstr "# Starkli: Consultando Starknet"

#: src/ch02-06-starkli.md:3
msgid ""
"[Starkli](https://book.starkli.rs/) is a Command Line Interface (CLI) tool designed for Starknet interaction, utilizing the capabilities of [starknet-rs](https://github.com/xJonathanLEI/starknet-"
"rs). This tool simplifies querying and executing transactions on Starknet."
msgstr ""
"[Starkli](https://book.starkli.rs/) es una herramienta de interfaz de l√≠nea de comandos (CLI) dise√±ada para la interacci√≥n con Starknet, que utiliza las capacidades de [starknet-rs](https://github."
"com/xJonathanLEI/starknet -rs). Esta herramienta simplifica la consulta y ejecuci√≥n de transacciones en Starknet."

#: src/ch02-06-starkli.md:5
msgid "> **NOTE:** Before continuing with this chapter, make sure you have completed the Basic Installation subchapter of Chapter 2. This includes the installation of Starkli."
msgstr "> **NOTA:** Antes de continuar con este cap√≠tulo, aseg√∫rese de haber completado el subcap√≠tulo Instalaci√≥n b√°sica del Cap√≠tulo 2. Esto incluye la instalaci√≥n de Starkli."

#: src/ch02-06-starkli.md:7
msgid ""
"In the next subchapter we will create a short Bash script using Starkli to query Starknet. It's just an example, however, creating your own Bash scripts to interact with Starknet would be very "
"useful in practice."
msgstr ""
"En el siguiente subcap√≠tulo crearemos un breve script Bash usando Starkli para consultar Starknet. Es s√≥lo un ejemplo, sin embargo, crear tus propios scripts Bash para interactuar con Starknet "
"ser√≠a muy √∫til en la pr√°ctica."

#: src/ch02-06-starkli.md:9
msgid "## Basic Setup"
msgstr "## Configuraci√≥n B√°sica"

#: src/ch02-06-starkli.md:11
msgid ""
"To ensure a smooth start with Starkli, execute the following command on your system. If you encounter any issues, refer to the [Basic Installation](ch02-01-basic-installation.md) guide for "
"assistance:"
msgstr ""
"Para garantizar un inicio sin problemas con Starkli, ejecute el siguiente comando en su sistema. Si encuentra alg√∫n problema, consulte la gu√≠a [Instalaci√≥n b√°sica](ch02-01-basic-installation.md) "
"para obtener ayuda:"

#: src/ch02-06-starkli.md:13
msgid ""
"```bash\n"
"starkli --version  # Verifies Starkli installation and interacts with Starknet\n"
"```"
msgstr ""
"```bash\n"
"starkli --version  # Verifies Starkli installation and interacts with Starknet\n"
"```"

#: src/ch02-06-starkli.md:17
msgid "## Connect to Starknet with Providers"
msgstr "## Con√©ctese a Starknet con proveedores"

#: src/ch02-06-starkli.md:19
msgid "Starkli primarily operates with a JSON-RPC provider. To access a JSON-RPC endpoint, you have several options:"
msgstr "Starkli opera principalmente con un proveedor JSON-RPC. Para acceder a un punto final JSON-RPC, tiene varias opciones:"

#: src/ch02-06-starkli.md:21
msgid ""
"- Use services like [Infura](https://docs.infura.io/networks/starknet/how-to) or [Alchemy](https://www.alchemy.com/starknet) for an RPC client.\n"
"- Employ a temporary local node like `katana` for development and testing purposes.\n"
"- Setup your own node."
msgstr ""
"- Utilice servicios como [Infura](https://docs.infura.io/networks/starknet/how-to) o [Alchemy](https://www.alchemy.com/starknet) para un cliente RPC.\n"
"- Emplear un nodo local temporal como `katana` para fines de desarrollo y prueba.\n"
"- Configura tu propio nodo."

#: src/ch02-06-starkli.md:25
msgid "### Interacting with Katana"
msgstr "### Interactuando con Katana"

#: src/ch02-06-starkli.md:27
msgid "To start Katana, open a terminal and execute:"
msgstr "Para iniciar Katana, abra una terminal y ejecute:"

#: src/ch02-06-starkli.md:33
msgid "To retrieve the chain id from the Katana JSON-RPC endpoint, use the following command:"
msgstr "Para recuperar la identificaci√≥n de la cadena del punto final Katana JSON-RPC, use el siguiente comando:"

#: src/ch02-06-starkli.md:35
msgid ""
"```bash\n"
"starkli chain-id --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"starkli chain-id --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch02-06-starkli.md:39
msgid "This command will output:"
msgstr "Este comando generar√°:"

#: src/ch02-06-starkli.md:41
msgid ""
"```bash\n"
"0x4b4154414e41 (KATANA)\n"
"```"
msgstr ""
"```bash\n"
"0x4b4154414e41 (KATANA)\n"
"```"

#: src/ch02-06-starkli.md:45
msgid "To obtain the latest block number on Katana, run:"
msgstr "Para obtener el √∫ltimo n√∫mero de bloque en Katana, ejecute:"

#: src/ch02-06-starkli.md:47
msgid ""
"```bash\n"
"    starkli block-number --rpc http://0.0.0.0:5050\n"
"```"
msgstr ""
"```bash\n"
"    starkli block-number --rpc http://0.0.0.0:5050\n"
"```"

#: src/ch02-06-starkli.md:51
msgid "The output will be:"
msgstr "La salida ser√°:"

#: src/ch02-06-starkli.md:53
msgid ""
"```bash\n"
"    0\n"
"```"
msgstr ""
"```bash\n"
"    0\n"
"```"

#: src/ch02-06-starkli.md:57
msgid ""
"Since katana is a temporary local node and its state is ephemeral, the block number is initially 0. Refer to [Introduction to Starkli, Scarb and Katana](ch02-02-starkli-scarb-katana.md) for further "
"details on changing the state of Katana and observing the block number after commands like starkli declare and starkli deploy."
msgstr ""
"Dado que katana es un nodo local temporal y su estado es ef√≠mero, el n√∫mero de bloque es inicialmente 0. Consulte [Introducci√≥n a Starkli, Scarb y Katana](ch02-02-starkli-scarb-katana.md) para "
"obtener m√°s detalles sobre c√≥mo cambiar el estado de Katana y observar el n√∫mero de bloque despu√©s de comandos como starkli declarar y starkli desplegar."

#: src/ch02-06-starkli.md:59
msgid "To declare a contract, execute:"
msgstr "Para declarar un contrato, ejecute:"

#: src/ch02-06-starkli.md:65
msgid "After declaring, the output will be:"
msgstr "Despu√©s de declarar, el resultado ser√°:"

#: src/ch02-06-starkli.md:71
msgid "Retrieving the latest block number on Katana again:"
msgstr "Recuperando nuevamente el √∫ltimo n√∫mero de bloque en Katana:"

#: src/ch02-06-starkli.md:73
msgid ""
"```bash\n"
"starkli block-number\n"
"```"
msgstr ""
"```bash\n"
"starkli block-number\n"
"```"

#: src/ch02-06-starkli.md:77
msgid "Will result in:"
msgstr "Resultar√° en:"

#: src/ch02-06-starkli.md:79
msgid ""
"```bash\n"
"1\n"
"```"
msgstr ""
"```bash\n"
"1\n"
"```"

#: src/ch02-06-starkli.md:83
msgid "Katana logs also reflect these changes:"
msgstr "Los registros de Katana tambi√©n reflejan estos cambios:"

#: src/ch02-06-starkli.md:85
msgid ""
"```bash\n"
"2023-11-03T04:38:48.712332Z DEBUG server: method=\"starknet_chainId\"\n"
"2023-11-03T04:38:48.725133Z DEBUG server: method=\"starknet_getClass\"\n"
"2023-11-03T04:38:48.726668Z DEBUG server: method=\"starknet_chainId\"\n"
"2023-11-03T04:38:48.741588Z DEBUG server: method=\"starknet_getNonce\"\n"
"2023-11-03T04:38:48.744718Z DEBUG server: method=\"starknet_estimateFee\"\n"
"2023-11-03T04:38:48.766843Z DEBUG server: method=\"starknet_getNonce\"\n"
"2023-11-03T04:38:48.770236Z DEBUG server: method=\"starknet_addDeclareTransaction\"\n"
"2023-11-03T04:38:48.779714Z  INFO txpool: Transaction received | Hash: 0x352f04ad496761c73806f92c64c267746afcbc16406bd0041ac6efa70b01a51\n"
"2023-11-03T04:38:48.782100Z TRACE executor: Transaction resource usage: Steps: 2854 | ECDSA: 1 | L1 Gas: 3672 | Pedersen: 15 | Range Checks: 63\n"
"2023-11-03T04:38:48.782112Z TRACE executor: Event emitted keys=[0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9]\n"
"2023-11-03T04:38:48.782399Z  INFO backend: ‚õèÔ∏è Block 1 mined with 1 transactions\n"
"```"
msgstr ""
"```bash\n"
"2023-11-03T04:38:48.712332Z DEBUG server: method=\"starknet_chainId\"\n"
"2023-11-03T04:38:48.725133Z DEBUG server: method=\"starknet_getClass\"\n"
"2023-11-03T04:38:48.726668Z DEBUG server: method=\"starknet_chainId\"\n"
"2023-11-03T04:38:48.741588Z DEBUG server: method=\"starknet_getNonce\"\n"
"2023-11-03T04:38:48.744718Z DEBUG server: method=\"starknet_estimateFee\"\n"
"2023-11-03T04:38:48.766843Z DEBUG server: method=\"starknet_getNonce\"\n"
"2023-11-03T04:38:48.770236Z DEBUG server: method=\"starknet_addDeclareTransaction\"\n"
"2023-11-03T04:38:48.779714Z  INFO txpool: Transaction received | Hash: 0x352f04ad496761c73806f92c64c267746afcbc16406bd0041ac6efa70b01a51\n"
"2023-11-03T04:38:48.782100Z TRACE executor: Transaction resource usage: Steps: 2854 | ECDSA: 1 | L1 Gas: 3672 | Pedersen: 15 | Range Checks: 63\n"
"2023-11-03T04:38:48.782112Z TRACE executor: Event emitted keys=[0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9]\n"
"2023-11-03T04:38:48.782399Z  INFO backend: ‚õèÔ∏è Block 1 mined with 1 transactions\n"
"```"

#: src/ch02-06-starkli.md:99
msgid "These logs indicate the receipt of a transaction, gas usage, and the mining of a new block, explaining the increment in block number to `1`."
msgstr "Estos registros indican la recepci√≥n de una transacci√≥n, el uso de gas y la extracci√≥n de un nuevo bloque, lo que explica el incremento en el n√∫mero de bloque a `1`."

#: src/ch02-06-starkli.md:101
msgid ""
"Before deploying a contract, note that Starkli supports argument resolution, simplifying the input process. For instance, constructor inputs in felt format can be easily passed as `str:<String-"
"value>`:"
msgstr ""
"Antes de implementar un contrato, tenga en cuenta que Starkli admite la resoluci√≥n de argumentos, lo que simplifica el proceso de entrada. Por ejemplo, las entradas del constructor en formato "
"fieltro se pueden pasar f√°cilmente como `str:<String-value>`:"

#: src/ch02-06-starkli.md:103
msgid ""
"```bash\n"
"    starkli deploy \\\n"
"        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
"        str:starknet-book\n"
"```"
msgstr ""
"```bash\n"
"    starkli deploy \\\n"
"        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
"        str:starknet-book\n"
"```"

#: src/ch02-06-starkli.md:109
msgid "This command deploys the contract without requiring `to-cairo-string`, and a new block is mined as a result."
msgstr "Este comando implementa el contrato sin requerir `to-cairo-string` y, como resultado, se extrae un nuevo bloque."

#: src/ch02-06-starkli.md:111
msgid "### Interacting with Testnet"
msgstr "### Interactuando con Testnet"

#: src/ch02-06-starkli.md:113
msgid "To interact with the Testnet, use a third-party JSON-RPC API provider like Infura or Alchemy. With your provider URL, execute the following command to get the latest block number:"
msgstr ""
"Para interactuar con Testnet, utilice un proveedor de API JSON-RPC de terceros como Infura o Alchemy. Con la URL de su proveedor, ejecute el siguiente comando para obtener el √∫ltimo n√∫mero de "
"bloque:"

#: src/ch02-06-starkli.md:115
msgid ""
"```bash\n"
"starkli block-number --rpc https://starknet-goerli.g.alchemy.com/v2/V0WI...\n"
"```"
msgstr ""
"```bash\n"
"starkli block-number --rpc https://starknet-goerli.g.alchemy.com/v2/V0WI...\n"
"```"

#: src/ch02-06-starkli.md:119
msgid "This command will return a response like:"
msgstr "Este comando devolver√° una respuesta como:"

#: src/ch02-06-starkli.md:121
msgid ""
"```bash\n"
"896360\n"
"```"
msgstr ""
"```bash\n"
"896360\n"
"```"

#: src/ch02-06-starkli.md:125
msgid "You can confirm this result by checking [Starkscan](https://testnet.starkscan.co/), where you'll find matching data."
msgstr "Puede confirmar este resultado consultando [Starkscan](https://testnet.starkscan.co/), donde encontrar√° datos coincidentes."

#: src/ch02-06-starkli.md:127
msgid "Starkli also streamlines the process of invoking commands. For instance, to transfer 1000 Wei of ETH to address 0x1234, first set up your environment variables:"
msgstr "Starkli tambi√©n agiliza el proceso de invocaci√≥n de comandos. Por ejemplo, para transferir 1000 Wei de ETH a la direcci√≥n 0x1234, primero configure sus variables de entorno:"

#: src/ch02-06-starkli.md:129
msgid ""
"```bash\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"
msgstr ""
"```bash\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch02-06-starkli.md:134
msgid "Then, use the following command for the transfer:"
msgstr "Luego, use el siguiente comando para la transferencia:"

#: src/ch02-06-starkli.md:136
msgid ""
"```bash\n"
"starkli invoke eth transfer <YOUR-ACCOUNT-ADDRESS> u256:1000\n"
"```"
msgstr ""
"```bash\n"
"starkli invoke eth transfer <YOUR-ACCOUNT-ADDRESS> u256:1000\n"
"```"

#: src/ch02-06-starkli.md:140
msgid "You can create your own script to connect to Starknet using Starkli. In the next subchapter we will create a short Bash script."
msgstr "Puede crear su propio script para conectarse a Starknet usando Starkli. En el siguiente subcap√≠tulo crearemos un breve script Bash."

#: src/ch02-06-01-connection-script.md:1
msgid "# Example - Starknet Connection Script"
msgstr "# Ejemplo - Script de Conexi√≥n a Starknet"

#: src/ch02-06-01-connection-script.md:3
msgid "This section provides step-by-step instructions to create and run custom bash scripts for Starknet interactions."
msgstr "Esta secci√≥n proporciona instrucciones paso a paso para crear y ejecutar scripts bash personalizados para interacciones con Starknet."

#: src/ch02-06-01-connection-script.md:5
msgid "## Katana Local Node"
msgstr "## Nodo local de Katana"

#: src/ch02-06-01-connection-script.md:7
msgid "**Description:** This script connects to the local StarkNet devnet through Katana, retrieves the current chain ID, the latest block number, and the balance of a specified account."
msgstr "**Descripci√≥n:** Este script se conecta al devnet local de Starknet a trav√©s de Katana, recupera el ID de la cadena actual, el √∫ltimo n√∫mero de bloque y el saldo de una cuenta espec√≠fica."

#: src/ch02-06-01-connection-script.md:9
msgid "First, ensure that Katana is running (in terminal 1):"
msgstr "Primero, aseg√∫rese de que Katana est√© ejecut√°ndose (en la terminal 1):"

#: src/ch02-06-01-connection-script.md:15
msgid "Then, create a file named `script_devnet` (in terminal 2):"
msgstr "Luego, cree un archivo llamado `script_devnet` (en la terminal 2):"

#: src/ch02-06-01-connection-script.md:17
msgid ""
"```bash\n"
"touch script_devnet\n"
"```"
msgstr ""
"```bash\n"
"touch script_devnet\n"
"```"

#: src/ch02-06-01-connection-script.md:21
msgid "Edit this file with your preferred text editor and insert the following script:"
msgstr "Edite este archivo con su editor de texto preferido e inserte el siguiente script:"

#: src/ch02-06-01-connection-script.md:23
msgid ""
"```bash\n"
"#!/bin/bash\n"
"chain=$(starkli chain-id --rpc http://0.0.0.0:5050)\n"
"echo \"Connected to the Starknet local devnet with chain id: $chain\"\n"
"\n"
"block=$(starkli block-number --rpc http://0.0.0.0:5050)\n"
"echo \"The latest block number on Katana is: $block\"\n"
"\n"
"account1=\"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"balance=$(starkli balance $account1 --rpc http://0.0.0.0:5050)\n"
"echo \"The balance of account $account1 is: $balance ETH\"\n"
"```"
msgstr ""
"```bash\n"
"#!/bin/bash\n"
"chain=$(starkli chain-id --rpc http://0.0.0.0:5050)\n"
"echo \"Connected to the Starknet local devnet with chain id: $chain\"\n"
"\n"
"block=$(starkli block-number --rpc http://0.0.0.0:5050)\n"
"echo \"The latest block number on Katana is: $block\"\n"
"\n"
"account1=\"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"balance=$(starkli balance $account1 --rpc http://0.0.0.0:5050)\n"
"echo \"The balance of account $account1 is: $balance ETH\"\n"
"```"

#: src/ch02-06-01-connection-script.md:36
msgid "Execute the script with:"
msgstr "Ejecute el script con:"

#: src/ch02-06-01-connection-script.md:38
msgid ""
"```bash\n"
"bash script_devnet\n"
"```"
msgstr ""
"```bash\n"
"bash script_devnet\n"
"```"

#: src/ch02-06-01-connection-script.md:42
msgid "You will see output details from the devnet."
msgstr "Ver√° los detalles de salida de devnet."

#: src/ch02-06-01-connection-script.md:44
msgid "## Goerli Testnet"
msgstr "## Testnet de Goerli"

#: src/ch02-06-01-connection-script.md:46
msgid "**Description**: This script connects to the Goerli testnet, reads the latest block number, and retrieves the transaction receipt for a specific transaction hash."
msgstr "**Descripci√≥n**: Este script se conecta a la red de prueba de Goerli, lee el √∫ltimo n√∫mero de bloque y recupera el recibo de la transacci√≥n para un hash de transacci√≥n espec√≠fico."

#: src/ch02-06-01-connection-script.md:48
msgid "For Goerli testnet interactions, create a file named `script_testnet`:"
msgstr "Para las interacciones de Goerli testnet, cree un archivo llamado `script_testnet`:"

#: src/ch02-06-01-connection-script.md:50
msgid ""
"```bash\n"
"touch script_testnet\n"
"```"
msgstr ""
"```bash\n"
"touch script_testnet\n"
"```"

#: src/ch02-06-01-connection-script.md:54
msgid "Edit the file and paste in this script:"
msgstr "Edite el archivo y p√©guelo en este script:"

#: src/ch02-06-01-connection-script.md:56
msgid ""
"```bash\n"
"echo \"Input your testnet API URL: \"\n"
"read url\n"
"chain=$(starkli chain-id --rpc $url)\n"
"echo \"Connected to the Starknet testnet with chain id: $chain\"\n"
"\n"
"block=$(starkli block-number --rpc $url)\n"
"echo \"The latest block number on Goerli is: $block\"\n"
"\n"
"echo \"Input your transaction hash: \"\n"
"read hash\n"
"receipt=$(starkli receipt $hash --rpc $url)\n"
"echo \"The receipt of transaction $hash is: $receipt\"\n"
"```"
msgstr ""
"```bash\n"
"echo \"Input your testnet API URL: \"\n"
"read url\n"
"chain=$(starkli chain-id --rpc $url)\n"
"echo \"Connected to the Starknet testnet with chain id: $chain\"\n"
"\n"
"block=$(starkli block-number --rpc $url)\n"
"echo \"The latest block number on Goerli is: $block\"\n"
"\n"
"echo \"Input your transaction hash: \"\n"
"read hash\n"
"receipt=$(starkli receipt $hash --rpc $url)\n"
"echo \"The receipt of transaction $hash is: $receipt\"\n"
"```"

#: src/ch02-06-01-connection-script.md:71
msgid "Run the script:"
msgstr "Ejecute el script:"

#: src/ch02-06-01-connection-script.md:73
msgid ""
"```bash\n"
"bash script_testnet\n"
"```"
msgstr ""
"```bash\n"
"bash script_testnet\n"
"```"

#: src/ch02-06-01-connection-script.md:77
msgid "You will need to input a `testnet API URL` and a `transaction hash`. Example hash: 0x2dd73eb1802aef84e8d73334ce0e5856b18df6626fe1a67bb247fcaaccaac8c."
msgstr "Deber√° ingresar una `URL de API de testnet` y un `hash de transacci√≥n`. Hash de ejemplo: 0x2dd73eb1802aef84e8d73334ce0e5856b18df6626fe1a67bb247fcaaccaac8c."

#: src/ch02-06-01-connection-script.md:79
msgid "These are brief examples but you get the idea. You can create custom Bash scripts to customize your interactions with Starknet."
msgstr "Estos son ejemplos breves pero se entiende la idea. Puede crear scripts Bash personalizados para personalizar sus interacciones con Starknet."

#: src/ch02-07-starknet-devnet.md:1
msgid "# Starknet Devnet"
msgstr "# Starknet Devnet"

#: src/ch02-07-starknet-devnet.md:3
msgid "Starknet Devnet is a development network (devnet) implemented in Rust, similar to the Python-based [`starknet-devnet`](https://0xspaceshard.github.io/starknet-devnet/docs/intro)."
msgstr "Starknet Devnet es una red de desarrollo (devnet) implementada en Rust, similar a la [`starknet-devnet`](https://0xspaceshard.github.io/starknet-devnet/docs/intro) basada en Python."

#: src/ch02-07-starknet-devnet.md:5 src/ch02-15-02-caracal.md:13 src/ch02-15-03-thoth.md:22
msgid "## Installation"
msgstr "## Instalaci√≥n"

#: src/ch02-07-starknet-devnet.md:7
msgid "`starknet devnet rs` can be installed in two ways: using Docker or manually by cloning the repository and running it with Cargo."
msgstr "`starknet devnet rs` se puede instalar de dos maneras: usando Docker o manualmente clonando el repositorio y ejecut√°ndolo con Cargo."

#: src/ch02-07-starknet-devnet.md:9
msgid "### Using Docker"
msgstr "### Usando Docker"

#: src/ch02-07-starknet-devnet.md:11
msgid "To install using Docker, follow the instructions provided [here](https://github.com/0xSpaceShard/starknet-devnet-rs#readme)."
msgstr "Para instalar usando Docker, siga las instrucciones proporcionadas [aqu√≠](https://github.com/0xSpaceShard/starknet-devnet-rs#readme)."

#: src/ch02-07-starknet-devnet.md:13
msgid "### Manual Installation (Cloning the Repo)"
msgstr "### Instalaci√≥n manual (Clonaci√≥n del repositorio)"

#: src/ch02-07-starknet-devnet.md:15
msgid "Prerequisites:"
msgstr "Requisitos Previos:"

#: src/ch02-07-starknet-devnet.md:17
msgid "- Rust installation ([Rust Install Guide](https://www.rust-lang.org/tools/install))"
msgstr "- Instalaci√≥n de Rust ([Gu√≠a de instalaci√≥n de Rust](https://www.rust-lang.org/tools/install))"

#: src/ch02-07-starknet-devnet.md:19
msgid "Procedure:"
msgstr "Procedimiento:"

#: src/ch02-07-starknet-devnet.md:21
msgid ""
"1. Create a new folder for the project.\n"
"2. Clone the repository:"
msgstr ""
"1. Cree una nueva carpeta para el proyecto.\n"
"2. Clona el repositorio:"

#: src/ch02-07-starknet-devnet.md:24
msgid ""
"```shell\n"
"git clone https://github.com/0xSpaceShard/starknet-devnet-rs.git\n"
"```"
msgstr ""
"```shell\n"
"git clone https://github.com/0xSpaceShard/starknet-devnet-rs.git\n"
"```"

#: src/ch02-07-starknet-devnet.md:28
msgid "## Running"
msgstr "## Correr"

#: src/ch02-07-starknet-devnet.md:30
msgid "After installation, run Starknet Devnet with the following command:"
msgstr "Despu√©s de la instalaci√≥n, ejecute Starknet Devnet con el siguiente comando:"

#: src/ch02-07-starknet-devnet.md:32
msgid ""
"```shell\n"
"cargo run\n"
"```"
msgstr ""
"```shell\n"
"cargo run\n"
"```"

#: src/ch02-07-starknet-devnet.md:36
msgid "On successful execution, you'll see outputs like predeployed contract addresses, account information, and seed details."
msgstr "Si la ejecuci√≥n es exitosa, ver√° resultados como direcciones de contrato previamente implementadas, informaci√≥n de cuenta y detalles iniciales."

#: src/ch02-07-starknet-devnet.md:38
msgid ""
"```shell\n"
"Predeployed FeeToken\n"
"Address: 0x49D36570D4E46F48E99674BD3FCC84644DDD6B96F7C741B1562B82F9E004DC7\n"
"Class Hash: 0x6A22BF63C7BC07EFFA39A25DFBD21523D211DB0100A0AFD054D172B81840EAF\n"
"\n"
"Predeployed UDC\n"
"Address: 0x41A78E741E5AF2FEC34B695679BC6891742439F7AFB8484ECD7766661AD02BF\n"
"Class Hash: 0x7B3E05F48F0C69E4A65CE5E076A66271A527AFF2C34CE1083EC6E1526997A69\n"
"\n"
"| Account address |  0x1d11***221c\n"
"| Private key     |  0xb7***8ee25\n"
"| Public key      |  0x5d46***76bf10\n"
"\n"
".\n"
".\n"
".\n"
"\n"
"Predeployed accounts using class with hash: 0x4d07e40e93398ed3c76981e72dd1fd22557a78ce36c0515f679e27f0bb5bc5f\n"
"Initial balance of each account: 1000000000000000000000 WEI\n"
"Seed to replicate this account sequence: 912753742\n"
"```"
msgstr ""
"```shell\n"
"Predeployed FeeToken\n"
"Address: 0x49D36570D4E46F48E99674BD3FCC84644DDD6B96F7C741B1562B82F9E004DC7\n"
"Class Hash: 0x6A22BF63C7BC07EFFA39A25DFBD21523D211DB0100A0AFD054D172B81840EAF\n"
"\n"
"Predeployed UDC\n"
"Address: 0x41A78E741E5AF2FEC34B695679BC6891742439F7AFB8484ECD7766661AD02BF\n"
"Class Hash: 0x7B3E05F48F0C69E4A65CE5E076A66271A527AFF2C34CE1083EC6E1526997A69\n"
"\n"
"| Account address |  0x1d11***221c\n"
"| Private key     |  0xb7***8ee25\n"
"| Public key      |  0x5d46***76bf10\n"
"\n"
".\n"
".\n"
".\n"
"\n"
"Predeployed accounts using class with hash: 0x4d07e40e93398ed3c76981e72dd1fd22557a78ce36c0515f679e27f0bb5bc5f\n"
"Initial balance of each account: 1000000000000000000000 WEI\n"
"Seed to replicate this account sequence: 912753742\n"
"```"

#: src/ch02-07-starknet-devnet.md:60
msgid "## Running Options"
msgstr "## Opciones de Ejecuci√≥n"

#: src/ch02-07-starknet-devnet.md:62
msgid "### Using a Seed"
msgstr "### Usando una Seed"

#: src/ch02-07-starknet-devnet.md:64
msgid ""
"The Starknet devnet provides a `Seed to replicate this account sequence` feature. This allows you to use a specific seed to access previously used accounts. This functionality is particularly "
"useful when employing tools like [`sncast`](https://book.starknet.io/ch02-12-foundry-cast.html) or `starkli` for contract interactions, as it eliminates the need to change account information."
msgstr ""
"Starknet devnet proporciona una funci√≥n `Seed para replicar esta secuencia de cuenta`. Esto le permite utilizar una semilla espec√≠fica para acceder a cuentas utilizadas anteriormente. Esta "
"funcionalidad es particularmente √∫til cuando se emplean herramientas como [`sncast`](https://book.starknet.io/ch02-12-foundry-cast.html) o `starkli` para interacciones contractuales, ya que elimina "
"la necesidad de cambiar Informaci√≥n de la cuenta."

#: src/ch02-07-starknet-devnet.md:66
msgid "To load old accounts using a specific seed, execute the following command:"
msgstr "Para cargar cuentas antiguas usando una seed espec√≠fica, ejecute el siguiente comando:"

#: src/ch02-07-starknet-devnet.md:68
msgid ""
"```shell\n"
"cargo run -- --seed <SEED>\n"
"```"
msgstr ""
"```shell\n"
"cargo run -- --seed <SEED>\n"
"```"

#: src/ch02-07-starknet-devnet.md:72
msgid "Example (add any number you prefer):"
msgstr "Ejemplo (agrega el n√∫mero que prefieras):"

#: src/ch02-07-starknet-devnet.md:74
msgid ""
"```shell\n"
"cargo run -- --seed 912753742\n"
"```"
msgstr ""
"```shell\n"
"cargo run -- --seed 912753742\n"
"```"

#: src/ch02-07-starknet-devnet.md:78
msgid "### Dumping and Loading Data"
msgstr "### Volcado y Carga de Datos"

#: src/ch02-07-starknet-devnet.md:80
msgid "The process of dumping and loading data facilitates resuming work from where you left off."
msgstr "El proceso de volcado y carga de datos facilita reanudar el trabajo desde donde lo dej√≥."

#: src/ch02-07-starknet-devnet.md:82
msgid "- **Dumping Data**:"
msgstr "- **Volcado de Datos**:"

#: src/ch02-07-starknet-devnet.md:84
msgid ""
"* Data can be dumped either on `exit` or after a `transaction`.\n"
"* In this example, dumping is done on exit into a specified directory. Ensure the directory exists, but not the file."
msgstr ""
"* Los datos se pueden volcar al `exit` o despu√©s de una `transaction`.\n"
"* En este ejemplo, el volcado se realiza al salir a un directorio espec√≠fico. Aseg√∫rese de que exista el directorio, pero no el archivo."

#: src/ch02-07-starknet-devnet.md:87
msgid ""
"```shell\n"
"cargo run -- --dump-on exit --dump-path ./dumps/contract_1\n"
"```"
msgstr ""
"```shell\n"
"cargo run -- --dump-on exit --dump-path ./dumps/contract_1\n"
"```"

#: src/ch02-07-starknet-devnet.md:91
msgid ""
"- **Loading Data**:\n"
"- To load data, use the command below. Note that both the directory and the file created by the `dump` command must exist. Also, pass in the seed to avoid issues like 'low account balance'."
msgstr ""
"- **Cargando Datos**:\n"
"- Para cargar datos, utilice el siguiente comando. Tenga en cuenta que tanto el directorio como el archivo creado por el comando `dump` deben existir. Adem√°s, pase la seed para evitar problemas "
"como 'low account balance'."

#: src/ch02-07-starknet-devnet.md:94
msgid ""
"```shell\n"
"cargo run -- --dump-path ./dumps/contract_1 --seed 912753742\n"
"```"
msgstr ""
"```shell\n"
"cargo run -- --dump-path ./dumps/contract_1 --seed 912753742\n"
"```"

#: src/ch02-07-starknet-devnet.md:98
msgid "##### Additional options"
msgstr "##### Opciones Adicionales"

#: src/ch02-07-starknet-devnet.md:100
msgid ""
"```shell\n"
"Options:\n"
"      --accounts <ACCOUNTS>\n"
"          Specify the number of accounts to be predeployed; [default: 10]\n"
"      --account-class <ACCOUNT_CLASS>\n"
"          Specify the class used by predeployed accounts; [default: cairo0] [possible values: cairo0, cairo1]\n"
"      --account-class-custom <PATH>\n"
"          Specify the path to a Cairo Sierra artifact to be used by predeployed accounts;\n"
"  -e, --initial-balance <DECIMAL_VALUE>\n"
"          Specify the initial balance in WEI of accounts to be predeployed; [default: 1000000000000000000000]\n"
"      --seed <SEED>\n"
"          Specify the seed for randomness of accounts to be predeployed; if not provided, it is randomly generated\n"
"      --host <HOST>\n"
"          Specify the address to listen at; [default: 127.0.0.1]\n"
"      --port <PORT>\n"
"          Specify the port to listen at; [default: 5050]\n"
"      --timeout <TIMEOUT>\n"
"          Specify the server timeout in seconds; [default: 120]\n"
"      --gas-price <GAS_PRICE>\n"
"          Specify the gas price in wei per gas unit; [default: 100000000000]\n"
"      --chain-id <CHAIN_ID>\n"
"          Specify the chain ID; [default: TESTNET] [possible values: MAINNET, TESTNET]\n"
"      --dump-on <WHEN>\n"
"          Specify when to dump the state of Devnet; [possible values: exit, transaction]\n"
"      --dump-path <DUMP_PATH>\n"
"          Specify the path to dump to;\n"
"  -h, --help\n"
"          Print help\n"
"  -V, --version\n"
"          Print version\n"
"\n"
"```"
msgstr ""
"```shell\n"
"Options:\n"
"      --accounts <ACCOUNTS>\n"
"          Specify the number of accounts to be predeployed; [default: 10]\n"
"      --account-class <ACCOUNT_CLASS>\n"
"          Specify the class used by predeployed accounts; [default: cairo0] [possible values: cairo0, cairo1]\n"
"      --account-class-custom <PATH>\n"
"          Specify the path to a Cairo Sierra artifact to be used by predeployed accounts;\n"
"  -e, --initial-balance <DECIMAL_VALUE>\n"
"          Specify the initial balance in WEI of accounts to be predeployed; [default: 1000000000000000000000]\n"
"      --seed <SEED>\n"
"          Specify the seed for randomness of accounts to be predeployed; if not provided, it is randomly generated\n"
"      --host <HOST>\n"
"          Specify the address to listen at; [default: 127.0.0.1]\n"
"      --port <PORT>\n"
"          Specify the port to listen at; [default: 5050]\n"
"      --timeout <TIMEOUT>\n"
"          Specify the server timeout in seconds; [default: 120]\n"
"      --gas-price <GAS_PRICE>\n"
"          Specify the gas price in wei per gas unit; [default: 100000000000]\n"
"      --chain-id <CHAIN_ID>\n"
"          Specify the chain ID; [default: TESTNET] [possible values: MAINNET, TESTNET]\n"
"      --dump-on <WHEN>\n"
"          Specify when to dump the state of Devnet; [possible values: exit, transaction]\n"
"      --dump-path <DUMP_PATH>\n"
"          Specify the path to dump to;\n"
"  -h, --help\n"
"          Print help\n"
"  -V, --version\n"
"          Print version\n"
"\n"
"```"

#: src/ch02-07-starknet-devnet.md:133
msgid ""
"> However, the main difference for the Rust version is the syntax for flags. For example, use `cargo run -- --port 5006` or `cargo run -- --dump-on exit ...` for the Rust Devnet. Other flags can be "
"used in the standard format."
msgstr ""
"> Sin embargo, la principal diferencia con la versi√≥n Rust es la sintaxis de las banderas. Por ejemplo, utilice `cargo run -- --port 5006` o `cargo run ---dump-on exit...` para Rust Devnet. Se "
"pueden utilizar otras banderas en el formato est√°ndar."

#: src/ch02-07-starknet-devnet.md:135
msgid "#### Cross-Version Disclaimer"
msgstr "#### Descargo de responsabilidad Cross-Version"

#: src/ch02-07-starknet-devnet.md:137
msgid ""
"Be aware that the dumping and loading functionality might not be compatible across different versions of the Devnet. In other words, data dumped from one version of Devnet may not be loadable with "
"another version."
msgstr ""
"Tenga en cuenta que es posible que la funcionalidad de descarga y carga no sea compatible entre diferentes versiones de Devnet. En otras palabras, es posible que los datos descargados desde una "
"versi√≥n de Devnet no se puedan cargar con otra versi√≥n."

#: src/ch02-07-starknet-devnet.md:139
msgid "### Minting Tokens"
msgstr "### Minting de Tokens"

#: src/ch02-07-starknet-devnet.md:141
msgid "To mint tokens, either to an existing address or a new one, use the following command:"
msgstr "Para mint tokens, ya sea en una direcci√≥n existente o en una nueva, use el siguiente comando:"

#: src/ch02-07-starknet-devnet.md:143
msgid ""
"```shell\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://localhost:5050/mint\n"
"```"
msgstr ""
"```shell\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://localhost:5050/mint\n"
"```"

#: src/ch02-07-starknet-devnet.md:147
msgid "> Commands compatible with the `sncast` and `starkli` subchapters are also applicable in the Rust Devnet."
msgstr "> Los comandos compatibles con los subcap√≠tulos `sncast` y `starkli` tambi√©n son aplicables en Rust Devnet."

#: src/ch02-07-starknet-devnet.md:149
msgid "## Next"
msgstr "## Pr√≥ximo"

#: src/ch02-07-starknet-devnet.md:151
msgid "In the next subchapter we will use the `sncast` tool to interact with the Starknet Devnet in a real world example."
msgstr "En el siguiente subcap√≠tulo usaremos la herramienta `sncast` para interactuar con Starknet Devnet en un ejemplo del mundo real."

#: src/ch02-08-foundry-cast.md:1
msgid "# Foundry Cast: Starknet CLI Interaction"
msgstr "# Foundry Cast: Interacci√≥n CLI de Starknet"

#: src/ch02-08-foundry-cast.md:3
msgid ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) is a tool designed for testing and developing Starknet contracts. It is an adaptation of the Ethereum Foundry for Starknet, aiming "
"to expedite the development process."
msgstr ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) es una herramienta dise√±ada para probar y desarrollar contratos Starknet. Es una adaptaci√≥n de Ethereum Foundry para Starknet, con "
"el objetivo de acelerar el proceso de desarrollo."

#: src/ch02-08-foundry-cast.md:5
msgid "The project consists of two primary components:"
msgstr "El proyecto consta de dos componentes principales:"

#: src/ch02-08-foundry-cast.md:7
msgid ""
"- **Forge**: A testing tool specifically for Cairo contracts. This tool acts as a test runner and boasts features designed to enhance your testing process. Tests are written directly in Cairo, "
"eliminating the need for other programming languages. Additionally, the Forge implementation uses Rust, mirroring Ethereum Foundry's choice of language.\n"
"- **Cast**: This serves as a DevOps tool for Starknet, initially supporting a series of commands to interface with Starknet. In the future, Cast aims to offer deployment scripts for contracts and "
"other DevOps functions."
msgstr ""
"- **Forge**: Una herramienta de prueba espec√≠fica para contratos de Cairo. Esta herramienta act√∫a como un ejecutor de pruebas y cuenta con funciones dise√±adas para mejorar su proceso de prueba. Las "
"pruebas se escriben directamente en Cairo, lo que elimina la necesidad de otros lenguajes de programaci√≥n. Adem√°s, la implementaci√≥n de Forge utiliza Rust, lo que refleja la elecci√≥n de lenguaje de "
"Ethereum Foundry.\n"
"- **Cast**: Sirve como herramienta DevOps para Starknet y admite inicialmente una serie de comandos para interactuar con Starknet. En el futuro, Cast pretende ofrecer scripts de implementaci√≥n para "
"contratos y otras funciones de DevOps."

#: src/ch02-08-foundry-cast.md:10
msgid "## Cast"
msgstr "## Cast"

#: src/ch02-08-foundry-cast.md:12
msgid ""
"Cast provides the Command Line Interface (CLI) for starknet, while Forge addresses testing. Written in Rust, Cast utilizes starknet Rust and integrates with Scarb. This integration allows for "
"argument specification in `Scarb.toml`, streamlining the process."
msgstr ""
"Cast proporciona la interfaz de l√≠nea de comandos (CLI) para Starknet, mientras que Forge se ocupa de las pruebas. Escrito en Rust, Cast utiliza starknet Rust y se integra con Scarb. Esta "
"integraci√≥n permite la especificaci√≥n de argumentos en `Scarb.toml`, agilizando el proceso."

#: src/ch02-08-foundry-cast.md:14
msgid "`sncast` simplifies interaction with smart contracts, reducing the number of necessary commands compared to using `starkli` alone."
msgstr "`sncast` simplifica la interacci√≥n con smart contracts, reduciendo la cantidad de comandos necesarios en comparaci√≥n con el uso de `starkli` solo."

#: src/ch02-08-foundry-cast.md:16
msgid "In this section, we'll delve into `sncast`."
msgstr "En esta secci√≥n, profundizaremos en `sncast`."

#: src/ch02-08-foundry-cast.md:18 src/ch02-08-01-deployment-script.md:9
msgid "## Requirements"
msgstr "## Requisitos"

#: src/ch02-08-foundry-cast.md:20 src/ch02-08-01-deployment-script.md:13
msgid ""
"```bash\n"
"# scarb --version\n"
"scarb 2.4.3\n"
"cairo: 2.4.3\n"
"sierra: 1.4.0\n"
"\n"
"# snforge --version\n"
"snforge 0.14.0\n"
"\n"
"# sncast --version\n"
"sncast 0.14.0\n"
"The Rust Devnet\n"
"```"
msgstr ""
"```bash\n"
"# scarb --version\n"
"scarb 2.4.3\n"
"cairo: 2.4.3\n"
"sierra: 1.4.0\n"
"\n"
"# snforge --version\n"
"snforge 0.14.0\n"
"\n"
"# sncast --version\n"
"sncast 0.14.0\n"
"The Rust Devnet\n"
"```"

#: src/ch02-08-foundry-cast.md:34
msgid "## Step 1: Sample Smart Contract"
msgstr "## Paso 1: Ejemplo de Smart Contract"

#: src/ch02-08-foundry-cast.md:36
msgid ""
"The following code sample is sourced from `starknet foundry`(You can find the source of the example [here](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html)).\n"
"If yo desire to get the files you can do it from [Foundry Example Code](https://github.com/starknet-edu/starknetbook/tree/main/examples/foundry-example)"
msgstr ""
"El siguiente ejemplo de c√≥digo proviene de `starknet foundry` (puede encontrar la fuente del ejemplo [aqu√≠](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html)).\n"
"Si desea obtener los archivos, puede hacerlo desde [C√≥digo de ejemplo de Foundry](https://github.com/starknet-edu/starknetbook/tree/main/examples/foundry-example)"

#: src/ch02-08-foundry-cast.md:39
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        // Increases the balance by the given amount.\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"\n"
"        // Gets the balance.\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        // Increases the balance by the given amount.\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"\n"
"        // Gets the balance.\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-08-foundry-cast.md:68
msgid "Before interacting with this sample smart contract, it's crucial to test its functionality using **`snforge`** to ensure its integrity."
msgstr "Antes de interactuar con este contrato inteligente de muestra, es fundamental probar su funcionalidad utilizando **`snforge`** para garantizar su integridad."

#: src/ch02-08-foundry-cast.md:70
msgid "Here are the associated tests:"
msgstr "Aqu√≠ est√°n las pruebas asociadas:"

#: src/ch02-08-foundry-cast.md:72
msgid "Take a keen look onto the imports ie"
msgstr "Eche un vistazo atento a las importaciones, es decir"

#: src/ch02-08-foundry-cast.md:74
msgid ""
"```rust\n"
"use casttest::{IHelloStarknetDispatcherTrait, IHelloStarknetDispatcher}\n"
"```"
msgstr ""
"```rust\n"
"use casttest::{IHelloStarknetDispatcherTrait, IHelloStarknetDispatcher}\n"
"```"

#: src/ch02-08-foundry-cast.md:78
msgid "`casttest` from the above line is the name of the project as given in the `scarb.toml` file"
msgstr "`casttest` de la l√≠nea anterior es el nombre del proyecto tal como figura en el archivo `scarb.toml`"

#: src/ch02-08-foundry-cast.md:80
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use casttest::{IHelloStarknetDispatcherTrait, IHelloStarknetDispatcher};\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"    #[test]\n"
"    fn call_and_invoke() {\n"
"        // Declare and deploy a contract\n"
"        let contract = declare('HelloStarknet');\n"
"        let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"        // Create a Dispatcher object for interaction with the deployed contract\n"
"        let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"        // Query a contract view function\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 0, 'balance == 0');\n"
"\n"
"        // Invoke a contract function to mutate state\n"
"        dispatcher.increase_balance(100);\n"
"\n"
"        // Verify the transaction's effect\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 100, 'balance == 100');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use casttest::{IHelloStarknetDispatcherTrait, IHelloStarknetDispatcher};\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"    #[test]\n"
"    fn call_and_invoke() {\n"
"        // Declare and deploy a contract\n"
"        let contract = declare('HelloStarknet');\n"
"        let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"        // Create a Dispatcher object for interaction with the deployed contract\n"
"        let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"        // Query a contract view function\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 0, 'balance == 0');\n"
"\n"
"        // Invoke a contract function to mutate state\n"
"        dispatcher.increase_balance(100);\n"
"\n"
"        // Verify the transaction's effect\n"
"        let balance = dispatcher.get_balance();\n"
"        assert(balance == 100, 'balance == 100');\n"
"    }\n"
"}\n"
"```"

#: src/ch02-08-foundry-cast.md:109
msgid "If needed, copy the provided code snippets into the `lib.cairo` file of your new scarb project."
msgstr "Si es necesario, copie los fragmentos de c√≥digo proporcionados en el archivo `lib.cairo` de su nuevo proyecto scarb."

#: src/ch02-08-foundry-cast.md:111
msgid "To execute tests, follow the steps below:"
msgstr "Para ejecutar tests, siga los pasos a continuaci√≥n:"

#: src/ch02-08-foundry-cast.md:113
msgid ""
"1. Ensure `snforge` is listed as a dependency in your `Scarb.toml` file, positioned beneath the `starknet` dependency. Your dependencies section should appear as (make sure to use the latest "
"version of `snforge` and `starknet`):"
msgstr ""
"1. Aseg√∫rese de que `snforge` aparezca como una dependencia en su archivo `Scarb.toml`, ubicado debajo de la dependencia `starknet`. Su secci√≥n de dependencias deber√≠a aparecer como (aseg√∫rese de "
"utilizar la √∫ltima versi√≥n de `snforge` y `starknet`):"

#: src/ch02-08-foundry-cast.md:115
msgid ""
"```txt\n"
"starknet = \"2.4.1\"\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.14.0\" }\n"
"```"
msgstr ""
"```txt\n"
"starknet = \"2.4.1\"\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.14.0\" }\n"
"```"

#: src/ch02-08-foundry-cast.md:120
msgid "2. Run the command:"
msgstr "2. Ejecute el comando:"

#: src/ch02-08-foundry-cast.md:122
msgid ""
"```sh\n"
"snforge test\n"
"```"
msgstr ""
"```sh\n"
"snforge test\n"
"```"

#: src/ch02-08-foundry-cast.md:126
msgid "> **Note:** Use `snforge` for testing instead of the `scarb test` command. The tests are set up to utilize functions from `snforge_std`. Running `scarb test` would cause errors."
msgstr ""
"> **Nota:** Utilice `snforge` para realizar pruebas en lugar del comando `scarb test`. Las pruebas est√°n configuradas para utilizar funciones de `snforge_std`. La ejecuci√≥n de la `scarb test` "
"provocar√≠a errores."

#: src/ch02-08-foundry-cast.md:128
msgid "## Step 2: Setting Up Starknet Devnet"
msgstr "## Paso 2: Configurar Starknet Devnet"

#: src/ch02-08-foundry-cast.md:130
msgid ""
"For this guide, the focus is on using `Rust starknet devnet`. If you've been using `katana` or `pythonic devnet`, please be cautious as there might be inconsistencies. If you haven't configured "
"`devnet`, consider following the [guide](ch02-07-starknet-devnet.md) from Starknet devnet for a quick setup."
msgstr ""
"Para esta gu√≠a, la atenci√≥n se centra en el uso de `Rust starknet devnet`. Si ha estado utilizando `katana` o `pythonic devnet`, tenga cuidado ya que puede haber inconsistencias. Si no ha "
"configurado `devnet`, considere seguir la [gu√≠a](ch02-07-starknet-devnet.md) de Starknet devnet para una configuraci√≥n r√°pida."

#: src/ch02-08-foundry-cast.md:132
msgid "To launch `starknet devnet`, use the command:"
msgstr "Para iniciar `starknet devnet`, use el comando:"

#: src/ch02-08-foundry-cast.md:134
msgid ""
"```sh\n"
"cargo run\n"
"```"
msgstr ""
"```sh\n"
"cargo run\n"
"```"

#: src/ch02-08-foundry-cast.md:138
msgid "Upon successful startup, you should receive a response similar to:"
msgstr "Al iniciarse correctamente, deber√≠a recibir una respuesta similar a:"

#: src/ch02-08-foundry-cast.md:140
msgid ""
"```sh\n"
"Finished dev [unoptimized + debuginfo] target(s) in 0.21s\n"
"     Running `target/debug/starknet-devnet`\n"
"Predeployed FeeToken\n"
"Address: 0x49D36570D4E46F48E99674BD3FCC84644DDD6B96F7C741B1562B82F9E004DC7\n"
"Class Hash: 0x6A22BF63C7BC07EFFA39A25DFBD21523D211DB0100A0AFD054D172B81840EAF\n"
"\n"
"Predeployed UDC\n"
"Address: 0x41A78E741E5AF2FEC34B695679BC6891742439F7AFB8484ECD7766661AD02BF\n"
"Class Hash: 0x7B3E05F48F0C69E4A65CE5E076A66271A527AFF2C34CE1083EC6E1526997A69\n"
"\n"
"| Account address |  0x243a10223fa0a8276cb9bb48cbb2da26dd945d0d09162610d32365b1f8580e1\n"
"| Private key     |  0x41f7d13cf9a928319d39c06b328f76af\n"
"| Public key      |  0x21952db4ec4ca2f0ce5ea3bfe545ad853043b80c06ef44335908e883e5a8988\n"
"\n"
"...\n"
"...\n"
"...\n"
"2023-11-23T17:06:48.221449Z  INFO starknet_devnet: Starknet Devnet listening on 127.0.0.1:5050\n"
"```"
msgstr ""
"```sh\n"
"Finished dev [unoptimized + debuginfo] target(s) in 0.21s\n"
"     Running `target/debug/starknet-devnet`\n"
"Predeployed FeeToken\n"
"Address: 0x49D36570D4E46F48E99674BD3FCC84644DDD6B96F7C741B1562B82F9E004DC7\n"
"Class Hash: 0x6A22BF63C7BC07EFFA39A25DFBD21523D211DB0100A0AFD054D172B81840EAF\n"
"\n"
"Predeployed UDC\n"
"Address: 0x41A78E741E5AF2FEC34B695679BC6891742439F7AFB8484ECD7766661AD02BF\n"
"Class Hash: 0x7B3E05F48F0C69E4A65CE5E076A66271A527AFF2C34CE1083EC6E1526997A69\n"
"\n"
"| Account address |  0x243a10223fa0a8276cb9bb48cbb2da26dd945d0d09162610d32365b1f8580e1\n"
"| Private key     |  0x41f7d13cf9a928319d39c06b328f76af\n"
"| Public key      |  0x21952db4ec4ca2f0ce5ea3bfe545ad853043b80c06ef44335908e883e5a8988\n"
"\n"
"...\n"
"...\n"
"...\n"
"2023-11-23T17:06:48.221449Z  INFO starknet_devnet: Starknet Devnet listening on 127.0.0.1:5050\n"
"```"

#: src/ch02-08-foundry-cast.md:161
msgid "(Note: The abbreviated ... is just a placeholder for the detailed response. In your actual output, you'll see the full details.)"
msgstr "(Nota: La abreviatura... es solo un marcador de posici√≥n para la respuesta detallada. En el resultado real, ver√° los detalles completos.)"

#: src/ch02-08-foundry-cast.md:163
msgid "Now, you have written a smart contract, tested it, and successfully initiated starknet devnet."
msgstr "Ahora, ha escrito un smart contract, lo ha probado e iniciado con √©xito starknet devnet."

#: src/ch02-08-foundry-cast.md:165
msgid "## Dive into `sncast`"
msgstr "## Sum√©rgete en `sncast`"

#: src/ch02-08-foundry-cast.md:167
msgid "Let's unpack **`sncast`**."
msgstr "Analicemos **`sncast`**."

#: src/ch02-08-foundry-cast.md:169
msgid "As a multifunctional tool, the quickest way to discover its capabilities is via the command:"
msgstr "Como herramienta multifuncional, la forma m√°s r√°pida de descubrir sus capacidades es mediante el comando:"

#: src/ch02-08-foundry-cast.md:171
msgid ""
"```sh\n"
"sncast --help\n"
"```"
msgstr ""
"```sh\n"
"sncast --help\n"
"```"

#: src/ch02-08-foundry-cast.md:175
msgid "In the output, you'll notice distinct categories: `commands` and `options`. Each option offers both a concise (`short`) and a descriptive (`long`) variant."
msgstr "En el resultado, notar√°s categor√≠as distintas: `commands` y `options`. Cada opci√≥n ofrece una variante concisa (`short`) y otra descriptiva (`long`)."

#: src/ch02-08-foundry-cast.md:177
msgid "> **Tip:** While both option variants are useful, we'll prioritize the long form in this guide. This choice aids clarity, especially when constructing intricate commands."
msgstr "> **Consejo:** Si bien ambas variantes de opciones son √∫tiles, daremos prioridad al formato largo en esta gu√≠a. Esta elecci√≥n ayuda a la claridad, especialmente al crear comandos complejos."

#: src/ch02-08-foundry-cast.md:179
msgid "Delving deeper, to understand specific commands such as **`account`**, you can run:"
msgstr "Profundizando m√°s, para comprender comandos espec√≠ficos como **`account`**, puedes ejecutar:"

#: src/ch02-08-foundry-cast.md:181
msgid ""
"```sh\n"
"sncast account help\n"
"```"
msgstr ""
"```sh\n"
"sncast account help\n"
"```"

#: src/ch02-08-foundry-cast.md:185
msgid "Each account subcommand like `add`, `create`, and `deploy` can be further explored. For instance:"
msgstr "Cada subcomando de cuenta, como `add`, `create`, y `deploy`, se puede explorar m√°s a fondo. Por ejemplo:"

#: src/ch02-08-foundry-cast.md:187
msgid ""
"```sh\n"
"sncast account add --help\n"
"```"
msgstr ""
"```sh\n"
"sncast account add --help\n"
"```"

#: src/ch02-08-foundry-cast.md:191
msgid ""
"The layered structure of `sncast` provides a wealth of information right at your fingertips. It's like having dynamic documentation. Make it a habit to explore, and you'll always stay informed."
msgstr ""
"La estructura en capas de `sncast` proporciona una gran cantidad de informaci√≥n al alcance de su mano. Es como tener documentaci√≥n din√°mica. Adquiera el h√°bito de explorar y siempre estar√° "
"informado."

#: src/ch02-08-foundry-cast.md:193
msgid "## Step 3: Using `sncast` for Account Management"
msgstr "## Paso 3: Uso de `sncast` para la Gesti√≥n de Cuentas"

#: src/ch02-08-foundry-cast.md:195
msgid "Let's delve into how to use `sncast` for interacting with the contract."
msgstr "Profundicemos en c√≥mo usar `sncast` para interactuar con el contrato."

#: src/ch02-08-foundry-cast.md:197
msgid ""
"By default, `starknet devnet` offers several `predeployed accounts`. These are accounts already registered with the node, loaded with test tokens (for gas fees and various transactions). Developers "
"can use them directly with any `contract` on the `local node` (i.e., starknet devnet)."
msgstr ""
"De forma predeterminada, `starknet devnet` ofrece varias `predeployed accounts`. Se trata de cuentas ya registradas en el nodo, cargadas con tokens de prueba (para tarifas de gas y diversas "
"transacciones). Los desarrolladores pueden usarlos directamente con cualquier `contract` en el `local node` (es decir, starknet devnet)."

#: src/ch02-08-foundry-cast.md:199
msgid "### How to Utilize Predeployed Accounts"
msgstr "### C√≥mo utilizar Cuentas Previamente Implementadas"

#: src/ch02-08-foundry-cast.md:201
msgid "To employ a predeployed account with the smart contract, execute the `account add` command as shown below:"
msgstr "Para emplear una cuenta previamente implementada con el contrato inteligente, ejecute el comando `account add` como se muestra a continuaci√≥n:"

#: src/ch02-08-foundry-cast.md:203
msgid ""
"```sh\n"
"sncast [SNCAST_MAIN_OPTIONS] account add [SUBCOMMAND_OPTIONS] --name <NAME> --address <ADDRESS> --private-key <PRIVATE_KEY>\n"
"```"
msgstr ""
"```sh\n"
"sncast [SNCAST_MAIN_OPTIONS] account add [SUBCOMMAND_OPTIONS] --name <NAME> --address <ADDRESS> --private-key <PRIVATE_KEY>\n"
"```"

#: src/ch02-08-foundry-cast.md:207
msgid ""
"Although several options can accompany the `add` command (e.g., `--name, --address, --class-hash, --deployed, --private-key, --public-key, --salt, --add-profile`), we'll focus on a select few for "
"this illustration."
msgstr ""
"Aunque el comando `add` puede ir acompa√±ado de varias opciones (por ejemplo, `--name, --address, --class-hash, --deployed, --private-key, --public-key, --salt, --add-profile`), nos centraremos en "
"unas pocas para esta ilustraci√≥n."

#: src/ch02-08-foundry-cast.md:209
msgid "Choose an account from the **`starknet-devnet`**, for demonstration, we'll select account **`#0`**, and execute:"
msgstr "Elige una cuenta de la **`starknet-devnet`**, para demostraci√≥n, seleccionaremos la cuenta **`#0`**, y ejecuta:"

#: src/ch02-08-foundry-cast.md:211
msgid ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account add  --name account1 --address 0x5f...60ba --private-key 0xc...0acc --add-profile\n"
"```"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account add  --name account1 --address 0x5f...60ba --private-key 0xc...0acc --add-profile\n"
"```"

#: src/ch02-08-foundry-cast.md:215
msgid "Points to remember:"
msgstr "Puntos a recordar:"

#: src/ch02-08-foundry-cast.md:217
msgid ""
"1. **`-name`** - Mandatory field.\n"
"2. **`-address`** - Necessary account address.\n"
"3. **`-private-key`** - Private key of the account.\n"
"4. **`-add-profile`** - Though optional, it's pivotal. By enabling **`sncast`** to include the account in your **`Scarb.toml`** file, you can manage multiple accounts, facilitating transactions "
"among them when working with your smart contract using sncast."
msgstr ""
"1. **`-name`** - Campo obligatorio.\n"
"2. **`-address`** - Direcci√≥n de cuenta necesaria.\n"
"3. **`-private-key`** - Clave privada de la cuenta.\n"
"4. **`-add-profile`** - Aunque opcional, es fundamental. Activando **`sncast`** para incluir la cuenta en tu archivo **`Scarb.toml`**, puedes gestionar m√∫ltiples cuentas, facilitando las "
"transacciones entre ellas cuando trabajes con tu contrato inteligente usando sncast."

#: src/ch02-08-foundry-cast.md:222
msgid "Now that we have familiarized ourselves with using a predeployed account, let's proceed to add a new account."
msgstr "Ahora que ya nos hemos familiarizado con el uso de una cuenta predesplegada, procedamos a a√±adir una nueva cuenta."

#: src/ch02-08-foundry-cast.md:224
msgid "### Creating and Deploying a New Account to Starknet Devnet"
msgstr "### Creaci√≥n y Despliegue de una Nueva Cuenta en Starknet Devnet"

#: src/ch02-08-foundry-cast.md:226
msgid "Creating a new account involves a few more steps than using an existing one, but it's straightforward when broken down. Here are the steps:"
msgstr "La creaci√≥n de una nueva cuenta implica algunos pasos m√°s que el uso de una ya existente, pero es sencillo cuando se desglosa. Estos son los pasos:"

#: src/ch02-08-foundry-cast.md:228
msgid "1. Account Creation"
msgstr "1. Creaci√≥n de Cuenta"

#: src/ch02-08-foundry-cast.md:230
msgid "To create a new account, use (you can use `sncast account create --help` to see the available options):"
msgstr "Para crear una cuenta nueva, utilice (puede utilizar `sncast account create --help` para ver las opciones disponibles):"

#: src/ch02-08-foundry-cast.md:232
msgid ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account create --name new_account --class-hash  0x19...8dd6 --add-profile\n"
"```"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account create --name new_account --class-hash  0x19...8dd6 --add-profile\n"
"```"

#: src/ch02-08-foundry-cast.md:236
msgid "Wondering where the `--class-hash` comes from? It's visible in the output from the `starknet-devnet` command under the Predeclared Starknet CLI account section. For example:"
msgstr "¬øTe preguntas de d√≥nde viene el `--class-hash`? Es visible en la salida del comando `starknet-devnet` en la secci√≥n Predeclared Starknet CLI account. Por ejemplo:"

#: src/ch02-08-foundry-cast.md:238
msgid ""
"```sh\n"
"Predeclared Starknet CLI account:\n"
"Class hash: 0x195c984a44ae2b8ad5d49f48c0aaa0132c42521dcfc66513530203feca48dd6\n"
"```"
msgstr ""
"```sh\n"
"Predeclared Starknet CLI account:\n"
"Class hash: 0x195c984a44ae2b8ad5d49f48c0aaa0132c42521dcfc66513530203feca48dd6\n"
"```"

#: src/ch02-08-foundry-cast.md:243
msgid "<img src=\"img/ch02-08-foundry-devnet-hash.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img src=\"img/ch02-08-foundry-devnet-hash.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch02-08-foundry-cast.md:245
msgid "2. Funding the Account"
msgstr "2. Financiaci√≥n de la Cuenta"

#: src/ch02-08-foundry-cast.md:247
msgid "To fund the new account, replace the address in the following command with your new one:"
msgstr "Para financiar la nueva cuenta, sustituya la direcci√≥n del comando siguiente por la nueva:"

#: src/ch02-08-foundry-cast.md:249
msgid ""
"```sh\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5050/mint\n"
"```"
msgstr ""
"```sh\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5050/mint\n"
"```"

#: src/ch02-08-foundry-cast.md:253
msgid "Note: The **amount** is specified in the previous command's output."
msgstr "Nota: El **amount** se especifica en la salida del comando anterior."

#: src/ch02-08-foundry-cast.md:255
msgid "A successful fund addition will return:"
msgstr "Volver√° una adici√≥n de fondos exitosa:"

#: src/ch02-08-foundry-cast.md:257
msgid ""
"```sh\n"
"{\"new_balance\":8646000000000,\"tx_hash\":\"0x48...1919\",\"unit\":\"wei\"}\n"
"```"
msgstr ""
"```sh\n"
"{\"new_balance\":8646000000000,\"tx_hash\":\"0x48...1919\",\"unit\":\"wei\"}\n"
"```"

#: src/ch02-08-foundry-cast.md:261
msgid "3. Account Deployment"
msgstr "3. Despliegue de Cuentas"

#: src/ch02-08-foundry-cast.md:263
msgid "Deploy the account to the **`starknet devnet`** local node to register it with the chain:"
msgstr "Despliega la cuenta en el nodo local **`starknet devnet`** para registrarla en la cadena:"

#: src/ch02-08-foundry-cast.md:265
msgid ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account deploy --name new_account --max-fee 0x64a7168300\n"
"```"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account deploy --name new_account --max-fee 0x64a7168300\n"
"```"

#: src/ch02-08-foundry-cast.md:269
msgid "A successful deployment provides a transaction hash. If it doesn't work, revisit your previous steps."
msgstr "Un despliegue con √©xito proporciona un hash de transacci√≥n. Si no funciona, revise los pasos anteriores."

#: src/ch02-08-foundry-cast.md:271
msgid "4. Setting a Default Profile"
msgstr "4. Establecer un Perfil Predeterminado"

#: src/ch02-08-foundry-cast.md:273
msgid ""
"You can define a default profile for your **`sncast`** actions. To set one, edit the **`Scarb.toml`** file. To make the **`new_account`** the default profile, find the section **`[tool.sncast."
"new_account]`** and change it to **`[tool.sncast]`**. This means **`sncast`** will default to using this profile unless instructed otherwise."
msgstr ""
"Puedes definir un perfil por defecto para tus acciones **`sncast`**. Para establecer uno, edita el archivo **`Scarb.toml`**. Para que **`new_account`** sea el perfil por defecto, busca la secci√≥n "
"**`[tool.sncast.new_account]`** y c√°mbiala por **`[tool.sncast]`**. Esto significa que **`sncast`** utilizar√° por defecto este perfil a menos que se le indique lo contrario."

#: src/ch02-08-foundry-cast.md:275
msgid "## Step 4: Declaring and Deploying our Contract"
msgstr "## Paso 4: Declarar y Desplegar nuestro Contrato"

#: src/ch02-08-foundry-cast.md:277
msgid "By now, we've arrived at the crucial step of using `sncast` to declare and deploy our smart contracts."
msgstr "A estas alturas, hemos llegado al paso crucial de utilizar `sncast` para declarar y desplegar nuestros smart contracts."

#: src/ch02-08-foundry-cast.md:279
msgid "### Declaring the Contract"
msgstr "### Declarar el Contrato"

#: src/ch02-08-foundry-cast.md:281
msgid "Recall that we drafted and tested the contract in **Step 1**. Here, we'll focus on two actions: building and declaring."
msgstr "Recordemos que redactamos y probamos el contrato en el **Paso 1**. Aqu√≠, nos centraremos en dos acciones: construir y declarar."

#: src/ch02-08-foundry-cast.md:283
msgid "1. **Building the Contract**"
msgstr "1. **Construir el Contrato**"

#: src/ch02-08-foundry-cast.md:285
msgid "Execute the following to build the contract:"
msgstr "Ejecute lo siguiente para construir el contrato:"

#: src/ch02-08-foundry-cast.md:287
msgid ""
"```sh\n"
"scarb build\n"
"```"
msgstr ""
"```sh\n"
"scarb build\n"
"```"

#: src/ch02-08-foundry-cast.md:291
msgid ""
"If you've successfully run tests using **`snforge`**, the **`scarb build`** should operate without issues. After the build completes, a new **`target`** folder will appear at the root of your "
"project."
msgstr ""
"Si has realizado con √©xito las pruebas utilizando **`snforge`**, la compilaci√≥n **`scarb`** deber√≠a funcionar sin problemas. Una vez finalizada la compilaci√≥n, aparecer√° una nueva carpeta "
"**`target`** en la ra√≠z del proyecto."

#: src/ch02-08-foundry-cast.md:293
msgid "Within the **`target`** folder, you'll find a **`dev`** sub-folder containing three files: **`*.casm.json`**, **`*.sierra.json`**, and **`*.starknet_artifacts.json`**."
msgstr "Dentro de la carpeta **`target`**, encontrar√°s una subcarpeta **`dev`** que contiene tres archivos: **`*.casm.json`**, **`*.sierra.json`**, y **`*.starknet_artifacts.json`**."

#: src/ch02-08-foundry-cast.md:295
msgid "If these files aren't present, it's likely due to missing configurations in your **`Scarb.toml`** file. To address this, append the following lines after **`dependencies`**:"
msgstr ""
"Si estos archivos no est√°n presentes, es probable que se deba a que faltan configuraciones en su archivo **`Scarb.toml`**. Para solucionarlo, a√±ade las siguientes l√≠neas despu√©s de "
"**`dependencies`**:"

#: src/ch02-08-foundry-cast.md:297
msgid ""
"```toml\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"
msgstr ""
"```toml\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"

#: src/ch02-08-foundry-cast.md:303
msgid "These lines instruct the compiler to produce both `sierra` and `casm` outputs."
msgstr "Estas l√≠neas ordenan al compilador que produzca tanto `sierra` como `casm`."

#: src/ch02-08-foundry-cast.md:305
msgid "2. **Declaring the Contract**"
msgstr "2. **Declaraci√≥n del Contrato**"

#: src/ch02-08-foundry-cast.md:307
msgid "We will use the `sncast declare` command to declare the contract. Here's the format:"
msgstr "Utilizaremos el comando `sncast declare` para declarar el contrato. Este es el formato:"

#: src/ch02-08-foundry-cast.md:309
msgid ""
"```shell\n"
"sncast declare [OPTIONS] --contract-name <CONTRACT>\n"
"```"
msgstr ""
"```shell\n"
"sncast declare [OPTIONS] --contract-name <CONTRACT>\n"
"```"

#: src/ch02-08-foundry-cast.md:313
msgid "Given this, the correct command would be:"
msgstr "Dado esto, el comando correcto ser√≠a:"

#: src/ch02-08-foundry-cast.md:315
msgid ""
"```\n"
"sncast --profile account1 declare --contract-name HelloStarknet\n"
"```"
msgstr ""
"```\n"
"sncast --profile account1 declare --contract-name HelloStarknet\n"
"```"

#: src/ch02-08-foundry-cast.md:319
msgid ""
"> **Note:-** that we've omitted the **`--url`** option. Why? When using **`--profile`**, as seen here with **`account1`**, it's not necessary. Remember, earlier in this guide, we discussed adding "
"and creating new accounts. You can use either **`account1`** or **`new_account`** and achieve the desired result."
msgstr ""
"> **Nota:-** hemos omitido la opci√≥n **`--url`**. ¬øPor qu√©? Cuando se utiliza **`--profile`**, como se ve aqu√≠ con **`account1`**, no es necesario. Recuerda que, anteriormente en esta gu√≠a, "
"hablamos de a√±adir y crear nuevas cuentas. Puedes usar tanto **`account1`** como **`new_account`** y conseguir el resultado deseado."

#: src/ch02-08-foundry-cast.md:321
msgid ""
"> **Hint:** You can define a default profile for sncast actions. Modify the `Scarb.toml` file to set a default. For example, to make `new_account` the default, find `[tool.sncast.new_account]` and "
"change it to `[tool.sncast]`. Then, there's no need to specify the profile for each call, simplifying your command to:"
msgstr ""
"> **Consejo:** Puede definir un perfil por defecto para las acciones sncast. Modifique el archivo `Scarb.toml` para establecer un valor predeterminado. Por ejemplo, para que `new_account` sea el "
"predeterminado, busque `[herramienta.sncast.nueva_cuenta]` y c√°mbielo por `[herramienta.sncast]`. Entonces, no hay necesidad de especificar el perfil para cada llamada, simplificando su comando a:"

#: src/ch02-08-foundry-cast.md:323
msgid ""
"```sh\n"
"sncast declare --contract-name HelloStarknet\n"
"```"
msgstr ""
"```sh\n"
"sncast declare --contract-name HelloStarknet\n"
"```"

#: src/ch02-08-foundry-cast.md:327
msgid "The output will resemble:"
msgstr "La salida se parecer√°:"

#: src/ch02-08-foundry-cast.md:329
msgid ""
"```sh\n"
"command: declare\n"
"class_hash: 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"transaction_hash: 0x7fbdcca80e7c666f1b5c4522fdad986ad3b731107001f7d8df5f3cb1ce8fd11\n"
"```"
msgstr ""
"```sh\n"
"command: declare\n"
"class_hash: 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"transaction_hash: 0x7fbdcca80e7c666f1b5c4522fdad986ad3b731107001f7d8df5f3cb1ce8fd11\n"
"```"

#: src/ch02-08-foundry-cast.md:335
msgid "Make sure to note the \\*\\*`class hash` as it will be essential in the subsequent step."
msgstr "Aseg√∫rese de anotar el \\*\\*`class hash` , ya que ser√° esencial en el paso siguiente."

#: src/ch02-08-foundry-cast.md:337
msgid ""
"> **Note:** If you encounter an error stating Class hash already declared, simply move to the next step. Redeclaring an already-declared contract isn't permissible. Use the mentioned class hash for "
"deployment."
msgstr ""
"**Nota:** Si se encuentra con un error que indica que la Class hash ya ha sido declarada, simplemente pase al siguiente paso. Volver a declarar un contrato ya declarado no est√° permitido. Utilice "
"el class hash mencionado para el despliegue."

#: src/ch02-08-foundry-cast.md:339
msgid "### Deploying the Contract"
msgstr "### Despliegue del Contrato"

#: src/ch02-08-foundry-cast.md:341
msgid ""
"With the contract successfully declared and a `class hash` obtained, we're ready to proceed to contract deployment. This step is straightforward. Replace `<class-hash>` in the command below with "
"your obtained class hash:"
msgstr ""
"Con el contrato declarado con √©xito y un `class hash` obtenido, estamos listos para proceder al despliegue del contrato. Este paso es sencillo. Sustituye `<class-hash>` en el siguiente comando por "
"el class hash obtenido:"

#: src/ch02-08-foundry-cast.md:343
msgid ""
"```sh\n"
"sncast deploy --class-hash 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"```"
msgstr ""
"```sh\n"
"sncast deploy --class-hash 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
"```"

#: src/ch02-08-foundry-cast.md:347
msgid "Executing this will likely yield:"
msgstr "Ejecutar esto probablemente dar√° como resultado:"

#: src/ch02-08-foundry-cast.md:349
msgid ""
"```sh\n"
"command: deploy\n"
"contract_address: 0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\n"
"transaction_hash: 0x6bdf6cfc8080336d9315f9b4df7bca5fb90135817aba4412ade6f942e9dbe60\n"
"```"
msgstr ""
"```sh\n"
"command: deploy\n"
"contract_address: 0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\n"
"transaction_hash: 0x6bdf6cfc8080336d9315f9b4df7bca5fb90135817aba4412ade6f942e9dbe60\n"
"```"

#: src/ch02-08-foundry-cast.md:355
msgid "However, you may encounter some issues, such as:"
msgstr "Sin embargo, puedes encontrarte con algunos problemas, como:"

#: src/ch02-08-foundry-cast.md:357
msgid "**Error: RPC url not passed nor found in Scarb.toml**. This indicates the absence of a default profile in the **`Scarb.toml`** file. To remedy this:"
msgstr "**Error: RPC url not passed nor found in Scarb.toml**. Esto indica la ausencia de un perfil por defecto en el archivo **`Scarb.toml`**. Para remediarlo:"

#: src/ch02-08-foundry-cast.md:359
msgid ""
"- Add the **`--profile`** option, followed by the desired profile name, as per the ones you've established.\n"
"- Alternatively, set a default profile as previously discussed in the \"Declaring the Contract\" section under \"Hint\" or as detailed in the \"Adding, Creating, and Deploying Account\" subsection."
msgstr ""
"- A√±ada la opci√≥n **`--profile`**, seguida del nombre del perfil deseado, seg√∫n los que haya establecido.\n"
"- Alternativamente, establezca un perfil por defecto como se ha comentado anteriormente en la secci√≥n \"Declarar el contrato\" en \"Hint\" o como se detalla en la subsecci√≥n \"A√±adir, Crear y "
"Desplegar Cuenta\"."

#: src/ch02-08-foundry-cast.md:362
msgid "You've successfully deployed your contract with `sncast`! Now, let's explore how to interact with it."
msgstr "¬°Has desplegado con √©xito tu contrato con `sncast`! Ahora, vamos a explorar c√≥mo interactuar con √©l."

#: src/ch02-08-foundry-cast.md:364
msgid "## Interacting with the Contract"
msgstr "## Interacci√≥n con el Contrato"

#: src/ch02-08-foundry-cast.md:366
msgid "This section explains how to read and write information to the contract."
msgstr "Esta secci√≥n explica c√≥mo leer y escribir informaci√≥n en el contrato."

#: src/ch02-08-foundry-cast.md:368
msgid "### Invoking Contract Functions"
msgstr "### Invocaci√≥n de Funciones del Contrato"

#: src/ch02-08-foundry-cast.md:370
msgid "To write to the contract, invoke its functions. Here's a basic overview of the command:"
msgstr "Para escribir en el contrato, invoque sus funciones. He aqu√≠ un resumen b√°sico del comando:"

#: src/ch02-08-foundry-cast.md:372
msgid ""
"```sh\n"
"Usage: sncast invoke [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Options:\n"
"  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract\n"
"  -f, --function <FUNCTION>                  Name of the function\n"
"  -c, --calldata <CALLDATA>                  Data for the function\n"
"  -m, --max-fee <MAX_FEE>                    Maximum transaction fee (auto-estimated if absent)\n"
"  -h, --help                                 Show help\n"
"```"
msgstr ""
"```sh\n"
"Uso: sncast invoke [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Opciones:\n"
"  -a, --contract-address <CONTRACT_ADDRESS> Direcci√≥n del contrato.\n"
"  -f, --function <FUNCTION> Nombre de la funci√≥n\n"
"  -c, --calldata <CALLDATA> Datos de la funci√≥n\n"
"  -m, --max-fee <MAX_FEE> Tasa m√°xima de transacci√≥n (autoestimada si no existe)\n"
"  -h, --help Mostrar ayuda\n"
"```"

#: src/ch02-08-foundry-cast.md:383
msgid ""
"To demonstrate, let's invoke the `increase_balance` method of our smart contract with a preset default profile. Not every option is always necessary; for instance, sometimes, including the `--max-"
"fee` might be essential."
msgstr ""
"Para demostrarlo, invoquemos el m√©todo `increase_balance` de nuestro contrato inteligente con un perfil predeterminado. No todas las opciones son siempre necesarias; por ejemplo, a veces, incluir "
"el `--max-fee` puede ser esencial."

#: src/ch02-08-foundry-cast.md:385
msgid ""
"```sh\n"
"sncast invoke --contract-address 0x7e...b3f9 --function increase_balance --calldata 4\n"
"```"
msgstr ""
"```sh\n"
"sncast invoke --contract-address 0x7e...b3f9 --function increase_balance --calldata 4\n"
"```"

#: src/ch02-08-foundry-cast.md:389
msgid "If successful, you'll receive a transaction hash like this:"
msgstr "Si tiene √©xito, recibir√° un hash de transacci√≥n como este:"

#: src/ch02-08-foundry-cast.md:391
msgid ""
"```sh\n"
"command: invoke\n"
"transaction_hash: 0x33248e393d985a28826e9fbb143d2cf0bb3342f1da85483cf253b450973b638\n"
"```"
msgstr ""
"```sh\n"
"command: invoke\n"
"transaction_hash: 0x33248e393d985a28826e9fbb143d2cf0bb3342f1da85483cf253b450973b638\n"
"```"

#: src/ch02-08-foundry-cast.md:396
msgid "### Reading from the Contract"
msgstr "### Lectura del Contrato"

#: src/ch02-08-foundry-cast.md:398
msgid "To retrieve data from the contract, use the `sncast call` command. Here's how it works:"
msgstr "Para recuperar datos del contrato, utilice el comando `sncast call`. As√≠ es como funciona:"

#: src/ch02-08-foundry-cast.md:400
msgid ""
"```sh\n"
"sncast call --help\n"
"```"
msgstr ""
"```sh\n"
"sncast call --help\n"
"```"

#: src/ch02-08-foundry-cast.md:404
msgid "Executing the command displays:"
msgstr "Al ejecutar el comando se muestra:"

#: src/ch02-08-foundry-cast.md:406
msgid ""
"```sh\n"
"Usage: sncast call [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Options:\n"
"  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract (hex format)\n"
"  -f, --function <FUNCTION>                  Name of the function to call\n"
"  -c, --calldata <CALLDATA>                  Function arguments (list of hex values)\n"
"  -b, --block-id <BLOCK_ID>                  Block identifier for the call. Accepts: pending, latest, block hash (with a 0x prefix), or block number (u64). Default is 'pending'.\n"
"  -h, --help                                 Show help\n"
"```"
msgstr ""
"```sh\n"
"Uso: sncast call [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
"\n"
"Opciones:\n"
"  -a, --contract-address <CONTRACT_ADDRESS> Direcci√≥n del contrato (formato hexadecimal)\n"
"  -f, --function <FUNCTION> Nombre de la funci√≥n a llamar\n"
"  -c, --calldata <CALLDATA> Argumentos de la funci√≥n (lista de valores hexadecimales)\n"
"  -b, --block-id <BLOCK_ID> Identificador de bloque para la llamada. Acepta: pendiente, √∫ltimo, hash de bloque (con un prefijo 0x) o n√∫mero de bloque (u64). Por defecto es 'pending'.\n"
"  -h, --help Mostrar ayuda\n"
"```"

#: src/ch02-08-foundry-cast.md:417 src/ch03-01-02-fee-mechanism.md:58
msgid "For instance:"
msgstr "Por ejemplo:"

#: src/ch02-08-foundry-cast.md:419 src/ch02-08-foundry-cast.md:531
msgid ""
"```sh\n"
"sncast call --contract-address 0x7e...b3f9 --function get_balance\n"
"```"
msgstr ""
"```sh\n"
"sncast call --contract-address 0x7e...b3f9 --function get_balance\n"
"```"

#: src/ch02-08-foundry-cast.md:423
msgid "While not all options are used in the example, you might need to include options like `--calldata`, specifying it as a list or array."
msgstr "Aunque no todas las opciones se utilizan en el ejemplo, es posible que necesite incluir opciones como `--calldata`, especific√°ndola como una lista o array."

#: src/ch02-08-foundry-cast.md:425
msgid "A successful call returns:"
msgstr "Una llamada exitosa devuelve:"

#: src/ch02-08-foundry-cast.md:427
msgid ""
"```sh\n"
"command: call\n"
"response: [0x4]\n"
"```"
msgstr ""
"```sh\n"
"command: call\n"
"response: [0x4]\n"
"```"

#: src/ch02-08-foundry-cast.md:432
msgid "This indicates successful read and write operations on the contract."
msgstr "Indica el √©xito de las operaciones de lectura y escritura en el contrato."

#: src/ch02-08-foundry-cast.md:434
msgid "### sncast Multicall Guide"
msgstr "### Gu√≠a de Multicall sncast"

#: src/ch02-08-foundry-cast.md:436
msgid "Use `sncast multicall` to simultaneously read and write to the contract. Let's explore how to effectively use this feature."
msgstr "Utiliza `sncast multicall` para leer y escribir simult√°neamente en el contrato. Veamos c√≥mo utilizar esta funci√≥n de forma eficaz."

#: src/ch02-08-foundry-cast.md:438
msgid "First, understand its basic usage:"
msgstr "En primer lugar, hay que entender su uso b√°sico:"

#: src/ch02-08-foundry-cast.md:440
msgid ""
"```sh\n"
"sncast multicall --help\n"
"```"
msgstr ""
"```sh\n"
"sncast multicall --help\n"
"```"

#: src/ch02-08-foundry-cast.md:444
msgid "This command displays:"
msgstr "Este comando muestra:"

#: src/ch02-08-foundry-cast.md:446
msgid ""
"```sh\n"
"Execute multiple calls\n"
"\n"
"Usage: sncast multicall <COMMAND>\n"
"\n"
"Commands:\n"
"  run   Execute multicall using a .toml file\n"
"  new   Create a template for the multicall .toml file\n"
"  help  Display help for subcommand(s)\n"
"\n"
"Options:\n"
"  -h, --help  Show help\n"
"```"
msgstr ""
"``sh\n"
"Ejecutar m√∫ltiples calls\n"
"\n"
"Uso: sncast multicall <COMANDO>\n"
"\n"
"Comandos:\n"
"  run Ejecutar multicall utilizando un archivo .toml\n"
"  new Crear una plantilla para el archivo .toml de multicall\n"
"  help Mostrar ayuda para subcomandos\n"
"\n"
"Opciones:\n"
"  -h, --help Mostrar ayuda\n"
"```"

#: src/ch02-08-foundry-cast.md:460
msgid "To delve deeper, initiate the `new` subcommand:"
msgstr "Para profundizar, inicie el subcomando `new`:"

#: src/ch02-08-foundry-cast.md:462
msgid ""
"```sh\n"
"Generate a template for the multicall .toml file\n"
"\n"
"Usage: sncast multicall new [OPTIONS]\n"
"\n"
"Options:\n"
"  -p, --output-path <OUTPUT_PATH>  File path for saving the template\n"
"  -o, --overwrite                  Overwrite file if it already exists at specified path\n"
"  -h, --help                       Display help\n"
"```"
msgstr ""
"``sh\n"
"Generar una plantilla para el fichero .toml de multicall\n"
"\n"
"Uso: sncast multicall new [OPCIONES]\n"
"\n"
"Opciones:\n"
"  -p, --output-path <OUTPUT_PATH> Ruta del archivo para guardar la plantilla\n"
"  -o, --overwrite Sobrescribir el archivo si ya existe en la ruta especificada\n"
"  -h, --help Mostrar ayuda\n"
"```"

#: src/ch02-08-foundry-cast.md:473
msgid "Generate a template called `call1.toml`:"
msgstr "Generar una plantilla llamada `call1.toml`:"

#: src/ch02-08-foundry-cast.md:475
msgid ""
"```sh\n"
"sncast multicall new --output-path ./call1.toml --overwrite\n"
"```"
msgstr ""
"```sh\n"
"sncast multicall new --output-path ./call1.toml --overwrite\n"
"```"

#: src/ch02-08-foundry-cast.md:479
msgid "This provides a basic template:"
msgstr "Esto proporciona un template:"

#: src/ch02-08-foundry-cast.md:481
msgid ""
"```toml\n"
"[[call]]\n"
"call_type = \"deploy\"\n"
"class_hash = \"\"\n"
"inputs = []\n"
"id = \"\"\n"
"unique = false\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"\"\n"
"function = \"\"\n"
"inputs = []\n"
"```"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"deploy\"\n"
"class_hash = \"\"\n"
"inputs = []\n"
"id = \"\"\n"
"unique = false\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"\"\n"
"function = \"\"\n"
"inputs = []\n"
"```"

#: src/ch02-08-foundry-cast.md:496
msgid "Modify `call1.toml` to:"
msgstr "Modifica `call1.toml` a:"

#: src/ch02-08-foundry-cast.md:498
msgid ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"

#: src/ch02-08-foundry-cast.md:512
msgid "In multicalls, only `deploy` and `invoke` actions are allowed. For a detailed guide on these, refer to the earlier section."
msgstr "En multicalls, s√≥lo se permiten las acciones `deploy` e `invoke`. Para una gu√≠a detallada sobre ellas, consulte la secci√≥n anterior."

#: src/ch02-08-foundry-cast.md:514
msgid "> **Note:** Ensure inputs are in hexadecimal format. Strings work normally, but numbers require this format for accurate results."
msgstr "> **Nota:** Aseg√∫rese de que las entradas est√°n en formato hexadecimal. Las cadenas funcionan normalmente, pero los n√∫meros requieren este formato para obtener resultados precisos."

#: src/ch02-08-foundry-cast.md:516
msgid "To execute the multicall, use:"
msgstr "Para ejecutar la multicall, utilice:"

#: src/ch02-08-foundry-cast.md:518
msgid ""
"```sh\n"
"sncast multicall run --path call1.toml\n"
"```"
msgstr ""
"```sh\n"
"sncast multicall run --path call1.toml\n"
"```"

#: src/ch02-08-foundry-cast.md:522
msgid "Upon success:"
msgstr "Si tiene √©xito:"

#: src/ch02-08-foundry-cast.md:524
msgid ""
"```sh\n"
"command: multicall run\n"
"transaction_hash: 0x1ae4122266f99a5ede495ff50fdbd927c31db27ec601eb9f3eaa938273d4d61\n"
"```"
msgstr ""
"```sh\n"
"command: multicall run\n"
"transaction_hash: 0x1ae4122266f99a5ede495ff50fdbd927c31db27ec601eb9f3eaa938273d4d61\n"
"```"

#: src/ch02-08-foundry-cast.md:529
msgid "Check the balance:"
msgstr "Consulta el balance:"

#: src/ch02-08-foundry-cast.md:535
msgid "The response:"
msgstr "La respuesta:"

#: src/ch02-08-foundry-cast.md:537
msgid ""
"```shell\n"
"command: call\n"
"response: [0x9]\n"
"```"
msgstr ""
"```shell\n"
"command: call\n"
"response: [0x9]\n"
"```"

#: src/ch02-08-foundry-cast.md:542
msgid "The expected balance, `0x9`, is confirmed."
msgstr "Se confirma el saldo esperado, `0x9`."

#: src/ch02-08-foundry-cast.md:544 src/ch02-09-starknet-js.md:570 src/ch02-10-starknet-react.md:319 src/ch03-00-architecture.md:249 src/ch03-01-transactions.md:63
#: src/ch03-01-01-transactions-lifecycle.md:175 src/ch03-02-sequencers.md:216 src/ch03-03-provers.md:233 src/ch03-06-solidity-verifier.md:139 src/ch04-00-account-abstraction.md:117
#: src/ch04-05-01-multicaller.md:589 src/ch04-05-02-multisig.md:881
msgid "## Conclusion"
msgstr "## Conclusi√≥n"

#: src/ch02-08-foundry-cast.md:546
msgid ""
"This guide detailed the use of `sncast`, a robust command-line tool tailored for starknet smart contracts. Its purpose is to make interactions with starknet's smart contracts effortless. Key "
"functionalities include contract deployment, function invocation, and function calling."
msgstr ""
"Esta gu√≠a detalla el uso de `sncast`, una robusta herramienta de l√≠nea de comandos adaptada a los smart contracts de Starknet. Su prop√≥sito es hacer que las interacciones con los smart contracts de "
"Starknet se realicen sin esfuerzo. Las funcionalidades clave incluyen el despliegue de contratos, la invocaci√≥n de funciones y la llamada a funciones."

#: src/ch02-08-01-deployment-script.md:1
msgid "# Deployment Script Example"
msgstr "# Ejemplo de Script de Despliegue"

#: src/ch02-08-01-deployment-script.md:3
msgid "> **IMPORTANT:** Ensure you have completed the Starknet Devnet subchapter before proceeding with this guide."
msgstr "> **IMPORTANTE:** Aseg√∫rese de haber completado el subcap√≠tulo Starknet Devnet antes de continuar con esta gu√≠a."

#: src/ch02-08-01-deployment-script.md:5
msgid ""
"This guide provides a step-by-step process to set up a testing and deployment environment for Starknet smart contracts. The script provided here will initialize accounts, execute tests, and perform "
"multicalls."
msgstr ""
"Esta gu√≠a proporciona un proceso paso a paso para configurar un entorno de pruebas y despliegue para los smart contracts en Starknet. El script proporcionado aqu√≠ inicializar√° cuentas, ejecutar√° "
"pruebas y realizar√° multicalls."

#: src/ch02-08-01-deployment-script.md:7
msgid "Please note that this is a basic example. You should adapt it to suit your specific needs and requirements."
msgstr "Tenga en cuenta que se trata de un ejemplo b√°sico. Deber√° adaptarlo a sus necesidades y requisitos espec√≠ficos."

#: src/ch02-08-01-deployment-script.md:11
msgid "#### The script is compatible with the following versions or higher"
msgstr "#### El script es compatible con las siguientes versiones o superiores"

#: src/ch02-08-01-deployment-script.md:27
msgid "#### Additional Tools"
msgstr "#### Herramientas Adicionales"

#: src/ch02-08-01-deployment-script.md:29
msgid ""
"The script requires `jq` to run. You can install it with `sudo apt install jq` on Ubuntu or `brew install jq` on macOS. For more information, refer to the [JQ Docs](https://jqlang.github.io/jq/)."
msgstr ""
"El script requiere `jq` para ejecutarse. Puedes instalarlo con `sudo apt install jq` en Ubuntu o `brew install jq` en macOS. Para m√°s informaci√≥n, consulta [JQ Docs](https://jqlang.github.io/jq/)."

#: src/ch02-08-01-deployment-script.md:31
msgid "## Script Preparation"
msgstr "## Preparaci√≥n del Script"

#: src/ch02-08-01-deployment-script.md:33
msgid "### 1. Create the Script File"
msgstr "### 1. Crear el Archivo de Script"

#: src/ch02-08-01-deployment-script.md:35
msgid ""
"- In the root directory of your project, create a file named **`script.sh`**. This file will contain the deployment script.\n"
"- Modify the file permissions to make it executable:"
msgstr ""
"- En el directorio ra√≠z de tu proyecto, crea un archivo llamado **`script.sh`**. Este archivo contendr√° el script de despliegue.\n"
"- Modifica los permisos del archivo para hacerlo ejecutable:"

#: src/ch02-08-01-deployment-script.md:38
msgid ""
"```sh\n"
"chmod +x script.sh\n"
"```"
msgstr ""
"```sh\n"
"chmod +x script.sh\n"
"```"

#: src/ch02-08-01-deployment-script.md:42
msgid "> ‚ö†Ô∏è **NOTE:** The script file must be executable to run. The `chmod +x` command changes the file permissions to allow execution."
msgstr "> ‚ö†Ô∏è **NOTA:** El archivo de script debe ser ejecutable para poder ejecutarse. El comando `chmod +x` cambia los permisos del archivo para permitir su ejecuci√≥n."

#: src/ch02-08-01-deployment-script.md:44
msgid "### 2. Insert the Script"
msgstr "### 2. Inserte el Script"

#: src/ch02-08-01-deployment-script.md:46
msgid "Below is the content for `script.sh`. It adheres to best practices for clarity, error management, and long-term support."
msgstr "A continuaci√≥n se muestra el contenido de `script.sh`. Se adhiere a las mejores pr√°cticas de claridad, gesti√≥n de errores y soporte a largo plazo."

#: src/ch02-08-01-deployment-script.md:48
msgid ""
"**Security Note**: Using environment variables is safer than hardcoding private keys in your scripts, but they're still accessible to any process on your machine and could potentially be leaked in "
"logs or error messages."
msgstr ""
"**Nota de seguridad**: El uso de variables de entorno es m√°s seguro que la codificaci√≥n de claves privadas en sus scripts, pero siguen siendo accesibles a cualquier proceso en su m√°quina y "
"potencialmente podr√≠a ser filtrada en los registros o mensajes de error."

#: src/ch02-08-01-deployment-script.md:50
msgid "On step 5 _declaring_, Uncomment according to local devnet you are using either the rust node or python node for declaration to work as expected."
msgstr "En el paso 5 _declaring_, Uncomment seg√∫n devnet local que est√° utilizando ya sea el nodo de √≥xido o python nodo para la declaraci√≥n de trabajar como se esperaba."

#: src/ch02-08-01-deployment-script.md:52
msgid ""
"```sh\n"
"#!/usr/bin/env bash\n"
"\n"
"# Ensure the script stops on first error\n"
"set -e\n"
"\n"
"# Global variables\n"
"file_path=\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\"\n"
"CONTRACT_NAME=\"HelloStarknet\"\n"
"PROFILE_NAME=\"account1\"\n"
"MULTICALL_FILE=\"multicall.toml\"\n"
"FAILED_TESTS=false\n"
"\n"
"# Addresses and Private keys as environment variables\n"
"ACCOUNT1_ADDRESS=${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}\n"
"ACCOUNT2_ADDRESS=${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}\n"
"ACCOUNT1_PRIVATE_KEY=${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"ACCOUNT2_PRIVATE_KEY=${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"\n"
"# Utility function to log messages\n"
"function log_message() {\n"
"    echo -e \"\\n$1\"\n"
"}\n"
"\n"
"# Step 1: Clean previous environment\n"
"if [ -e \"$file_path\" ]; then\n"
"    log_message \"Removing existing accounts file...\"\n"
"    rm -rf \"$file_path\"\n"
"fi\n"
"\n"
"# Step 2: Define accounts for the smart contract\n"
"accounts_json=$(cat <<EOF\n"
"[\n"
"    {\n"
"        \"name\": \"account1\",\n"
"        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
"    },\n"
"    {\n"
"        \"name\": \"account2\",\n"
"        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
"    }\n"
"]\n"
"EOF\n"
")\n"
"\n"
"# Step 3: Run contract tests\n"
"echo -e \"\\nTesting the contract...\"\n"
"testing_result=$(snforge test 2>&1)\n"
"if echo \"$testing_result\" | grep -q \"Failure\"; then\n"
"    echo -e \"Tests failed!\\n\"\n"
"    snforge\n"
"    echo -e \"\\nEnsure that your tests are passing before proceeding.\\n\"\n"
"    FAILED_TESTS=true\n"
"fi\n"
"\n"
"if [ \"$FAILED_TESTS\" != \"true\" ]; then\n"
"    echo \"Tests passed successfully.\"\n"
"\n"
"    # Step 4: Create new account(s)\n"
"    echo -e \"\\nCreating account(s)...\"\n"
"    for row in $(echo \"${accounts_json}\" | jq -c '.[]'); do\n"
"        name=$(echo \"${row}\" | jq -r '.name')\n"
"        address=$(echo \"${row}\" | jq -r '.address')\n"
"        private_key=$(echo \"${row}\" | jq -r '.private_key')\n"
"\n"
"        account_creation_result=$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)\n"
"        if echo \"$account_creation_result\" | grep -q \"error:\"; then\n"
"            echo \"Account $name already exists.\"\n"
"        else\n"
"            echo \"Account $name created successfully.\"\n"
"        fi\n"
"    done\n"
"\n"
"    # Step 5: Build, declare, and deploy the contract\n"
"    echo -e \"\\nBuilding the contract...\"\n"
"    scarb build\n"
"\n"
"    echo -e \"\\nDeclaring the contract...\"\n"
"    declaration_output=$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)\n"
"\n"
"    if echo \"$declaration_output\" | grep -q \"error: Class with hash\"; then\n"
"        echo \"Class hash already declared.\"\n"
"        # CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p') ## Uncomment this for pythonic devnet\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*\\(0x[0-9a-fA-F]*\\).*/\\1/p') ## Uncomment this for rust devnet\n"
"    else\n"
"        echo \"New class hash declaration.\"\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')\n"
"    fi\n"
"\n"
"    echo \"Class Hash: $CLASS_HASH\"\n"
"\n"
"    echo -e \"\\nDeploying the contract...\"\n"
"    deployment_result=$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")\n"
"    CONTRACT_ADDRESS=$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')\n"
"    echo \"Contract address: $CONTRACT_ADDRESS\"\n"
"\n"
"    # Step 6: Create and execute multicalls\n"
"    echo -e \"\\nSetting up multicall...\"\n"
"    cat >\"$MULTICALL_FILE\" <<-EOM\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x1']\n"
"\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x2']\n"
"EOM\n"
"\n"
"    echo \"Executing multicall...\"\n"
"    sncast --profile \"$PROFILE_NAME\" multicall run --path \"$MULTICALL_FILE\"\n"
"\n"
"    # Step 7: Query the contract state\n"
"    echo -e \"\\nChecking balance...\"\n"
"    sncast --profile \"$PROFILE_NAME\" call --contract-address \"$CONTRACT_ADDRESS\" --function get_balance\n"
"\n"
"    # Step 8: Clean up temporary files\n"
"    echo -e \"\\nCleaning up...\"\n"
"    [ -e \"$MULTICALL_FILE\" ] && rm \"$MULTICALL_FILE\"\n"
"\n"
"    echo -e \"\\nScript completed successfully.\\n\"\n"
"fi\n"
"```"
msgstr ""
"```sh\n"
"#!/usr/bin/env bash\n"
"\n"
"# Ensure the script stops on first error\n"
"set -e\n"
"\n"
"# Global variables\n"
"file_path=\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\"\n"
"CONTRACT_NAME=\"HelloStarknet\"\n"
"PROFILE_NAME=\"account1\"\n"
"MULTICALL_FILE=\"multicall.toml\"\n"
"FAILED_TESTS=false\n"
"\n"
"# Addresses and Private keys as environment variables\n"
"ACCOUNT1_ADDRESS=${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}\n"
"ACCOUNT2_ADDRESS=${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}\n"
"ACCOUNT1_PRIVATE_KEY=${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"ACCOUNT2_PRIVATE_KEY=${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
"\n"
"# Utility function to log messages\n"
"function log_message() {\n"
"    echo -e \"\\n$1\"\n"
"}\n"
"\n"
"# Step 1: Clean previous environment\n"
"if [ -e \"$file_path\" ]; then\n"
"    log_message \"Removing existing accounts file...\"\n"
"    rm -rf \"$file_path\"\n"
"fi\n"
"\n"
"# Step 2: Define accounts for the smart contract\n"
"accounts_json=$(cat <<EOF\n"
"[\n"
"    {\n"
"        \"name\": \"account1\",\n"
"        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
"    },\n"
"    {\n"
"        \"name\": \"account2\",\n"
"        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
"    }\n"
"]\n"
"EOF\n"
")\n"
"\n"
"# Step 3: Run contract tests\n"
"echo -e \"\\nTesting the contract...\"\n"
"testing_result=$(snforge test 2>&1)\n"
"if echo \"$testing_result\" | grep -q \"Failure\"; then\n"
"    echo -e \"Tests failed!\\n\"\n"
"    snforge\n"
"    echo -e \"\\nEnsure that your tests are passing before proceeding.\\n\"\n"
"    FAILED_TESTS=true\n"
"fi\n"
"\n"
"if [ \"$FAILED_TESTS\" != \"true\" ]; then\n"
"    echo \"Tests passed successfully.\"\n"
"\n"
"    # Step 4: Create new account(s)\n"
"    echo -e \"\\nCreating account(s)...\"\n"
"    for row in $(echo \"${accounts_json}\" | jq -c '.[]'); do\n"
"        name=$(echo \"${row}\" | jq -r '.name')\n"
"        address=$(echo \"${row}\" | jq -r '.address')\n"
"        private_key=$(echo \"${row}\" | jq -r '.private_key')\n"
"\n"
"        account_creation_result=$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)\n"
"        if echo \"$account_creation_result\" | grep -q \"error:\"; then\n"
"            echo \"Account $name already exists.\"\n"
"        else\n"
"            echo \"Account $name created successfully.\"\n"
"        fi\n"
"    done\n"
"\n"
"    # Step 5: Build, declare, and deploy the contract\n"
"    echo -e \"\\nBuilding the contract...\"\n"
"    scarb build\n"
"\n"
"    echo -e \"\\nDeclaring the contract...\"\n"
"    declaration_output=$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)\n"
"\n"
"    if echo \"$declaration_output\" | grep -q \"error: Class with hash\"; then\n"
"        echo \"Class hash already declared.\"\n"
"        # CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p') ## Uncomment this for pythonic devnet\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*\\(0x[0-9a-fA-F]*\\).*/\\1/p') ## Uncomment this for rust devnet\n"
"    else\n"
"        echo \"New class hash declaration.\"\n"
"        CLASS_HASH=$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')\n"
"    fi\n"
"\n"
"    echo \"Class Hash: $CLASS_HASH\"\n"
"\n"
"    echo -e \"\\nDeploying the contract...\"\n"
"    deployment_result=$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")\n"
"    CONTRACT_ADDRESS=$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')\n"
"    echo \"Contract address: $CONTRACT_ADDRESS\"\n"
"\n"
"    # Step 6: Create and execute multicalls\n"
"    echo -e \"\\nSetting up multicall...\"\n"
"    cat >\"$MULTICALL_FILE\" <<-EOM\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x1']\n"
"\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x2']\n"
"EOM\n"
"\n"
"    echo \"Executing multicall...\"\n"
"    sncast --profile \"$PROFILE_NAME\" multicall run --path \"$MULTICALL_FILE\"\n"
"\n"
"    # Step 7: Query the contract state\n"
"    echo -e \"\\nChecking balance...\"\n"
"    sncast --profile \"$PROFILE_NAME\" call --contract-address \"$CONTRACT_ADDRESS\" --function get_balance\n"
"\n"
"    # Step 8: Clean up temporary files\n"
"    echo -e \"\\nCleaning up...\"\n"
"    [ -e \"$MULTICALL_FILE\" ] && rm \"$MULTICALL_FILE\"\n"
"\n"
"    echo -e \"\\nScript completed successfully.\\n\"\n"
"fi\n"
"```"

#: src/ch02-08-01-deployment-script.md:181
msgid "### 3. [Optional]Adjust the Bash Path"
msgstr "### 3. [Opcional]Ajuste la ruta de Bash"

#: src/ch02-08-01-deployment-script.md:183
msgid "The line `#!/usr/bin/env bash` indicates the path to the bash interpreter. If you require a different version or location of bash, determine its path using:"
msgstr "La l√≠nea `#!/usr/bin/env bash` indica la ruta al int√©rprete bash. Si necesita una versi√≥n o ubicaci√≥n diferente de bash, determine su ruta utilizando:"

#: src/ch02-08-01-deployment-script.md:185
msgid ""
"```sh\n"
"which bash\n"
"```"
msgstr ""
"```sh\n"
"which bash\n"
"```"

#: src/ch02-08-01-deployment-script.md:189
msgid "Then replace `#!/usr/bin/env` bash in the script with the resulting path, such as `#!/path/to/your/bash`."
msgstr "A continuaci√≥n, sustituye `#!/usr/bin/env` bash en el script por la ruta resultante, como `#!/ruta/a/tu/bash`."

#: src/ch02-08-01-deployment-script.md:191
msgid "## Execution"
msgstr "## Ejecuci√≥n"

#: src/ch02-08-01-deployment-script.md:193
msgid "When running the script, you'll need to provide the environment variables `ACCOUNT1_PRIVATE_KEY` and `ACCOUNT2_PRIVATE_KEY`."
msgstr "Cuando ejecutes el script, tendr√°s que proporcionar las variables de entorno `ACCOUNT1_PRIVATE_KEY` y `ACCOUNT2_PRIVATE_KEY`."

#: src/ch02-08-01-deployment-script.md:195 src/ch03-05-layer-3.md:9
msgid "Example:"
msgstr "Ejemplo:"

#: src/ch02-08-01-deployment-script.md:197
msgid ""
"```sh\n"
"ACCOUNT1_PRIVATE_KEY=\"0x259f4329e6f4590b\" ACCOUNT2_PRIVATE_KEY=\"0xb4862b21fb97d\" ./script.sh\n"
"```"
msgstr ""
"```sh\n"
"ACCOUNT1_PRIVATE_KEY=\"0x259f4329e6f4590b\" ACCOUNT2_PRIVATE_KEY=\"0xb4862b21fb97d\" ./script.sh\n"
"```"

#: src/ch02-08-01-deployment-script.md:201 src/ch04-05-01-multicaller.md:597
msgid "## Considerations"
msgstr "## Consideraciones"

#: src/ch02-08-01-deployment-script.md:203
msgid ""
"- The **`set -e`** directive in the script ensures it exits if any command fails, enhancing the reliability of the deployment and testing process.\n"
"- Always secure private keys and sensitive information. Keep them away from logs and visible outputs.\n"
"- For greater flexibility, consider moving hardcoded values like accounts or contract names to a configuration file. This approach simplifies updates and overall management."
msgstr ""
"- La directiva **`set -e`** del script garantiza que √©ste se cierre si falla alg√∫n comando, lo que aumenta la fiabilidad del proceso de despliegue y prueba.\n"
"- Asegura siempre las claves privadas y la informaci√≥n sensible. Mant√©ngalas alejadas de los registros y las salidas visibles.\n"
"- Para una mayor flexibilidad, considere la posibilidad de trasladar valores codificados como cuentas o nombres de contratos a un archivo de configuraci√≥n. Este enfoque simplifica las "
"actualizaciones y la gesti√≥n general."

#: src/ch02-09-starknet-js.md:1
msgid "# Starknet-js: Javascript SDK"
msgstr "# Starknet-js: Javascript SDK"

#: src/ch02-09-starknet-js.md:3
msgid ""
"Starknet.js is a JavaScript/TypeScript library designed to connect your\n"
"website or decentralized application (D-App) to Starknet. It aims to\n"
"mimic the architecture of [ethers.js](https://docs.ethers.org/v5/), so\n"
"if you are familiar with ethers, you should find Starknet.js easy to\n"
"work with."
msgstr ""
"Starknet.js es una biblioteca JavaScript/TypeScript dise√±ada para conectar su sitio web o aplicaci√≥n descentralizada (D-App) a Starknet. Su objetivo es imitar la arquitectura de [ethers.js](https://"
"docs.ethers.org/v5/), por lo que si est√° familiarizado con ethers, le resultar√° f√°cil trabajar con Starknet.js."

#: src/ch02-09-starknet-js.md:9
msgid "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch02-09-starknet-js.md:11
msgid "<span class=\"caption\">Starknet-js in your dapp</span>"
msgstr "<span class=\"caption\">Starknet-js en tu dapp</span>"

#: src/ch02-09-starknet-js.md:15
msgid "To install Starknet.js, follow these steps:"
msgstr "Para instalar Starknet.js, siga estos pasos:"

#: src/ch02-09-starknet-js.md:17
msgid "- For the latest official release (main branch):"
msgstr "- Para la √∫ltima versi√≥n oficial (main branch):"

#: src/ch02-09-starknet-js.md:19 src/ch02-09-starknet-js.md:25
msgid "<!-- -->"
msgstr "<!-- -->"

#: src/ch02-09-starknet-js.md:21
msgid "npm install starknet"
msgstr "npm install starknet"

#: src/ch02-09-starknet-js.md:23
msgid "- To use the latest features (merges in develop branch):"
msgstr "- Para utilizar las √∫ltimas funciones (se fusiona en la rama de desarrollo):"

#: src/ch02-09-starknet-js.md:27
msgid "npm install starknet@next"
msgstr "npm install starknet@next"

#: src/ch02-09-starknet-js.md:29
msgid "## Getting Started"
msgstr "## Primeros Pasos"

#: src/ch02-09-starknet-js.md:31
msgid ""
"To build an app that users are able to connect to and interact with\n"
"Starknet, we recommend adding the\n"
"[get-starknet](https://github.com/starknet-io/get-starknet) library,\n"
"which allows you to manage wallet connections."
msgstr ""
"Para crear una aplicaci√≥n a la que los usuarios puedan conectarse e interactuar con Starknet, recomendamos agregar la biblioteca [get-starknet](https://github.com/starknet-io/get-starknet), que le "
"permite administrar conexiones de billetera."

#: src/ch02-09-starknet-js.md:36
msgid ""
"With these tools ready, there are basically 3 main concepts to know on\n"
"the frontend: Account, Provider, and Contracts."
msgstr "Con estas herramientas listas, hay b√°sicamente 3 conceptos principales que debes conocer en el frontend: Account, Provider y Contracts."

#: src/ch02-09-starknet-js.md:39
msgid "### Account"
msgstr "### Account"

#: src/ch02-09-starknet-js.md:41
msgid ""
"We can generally think of the account as the \"end user\" of a\n"
"dapp, and some user interaction will be involved to gain access to it."
msgstr "Generalmente podemos pensar en la cuenta como el \"usuario final\" de una dapp, y ser√° necesaria alguna interacci√≥n del usuario para obtener acceso a ella."

#: src/ch02-09-starknet-js.md:44
msgid ""
"Think of a dapp where the user connects their browser extension wallet\n"
"(such as ArgentX or Braavos) - if the user accepts the connection, that\n"
"gives us access to the account and signer, which can sign transactions\n"
"and messages."
msgstr ""
"Piense en una dapp donde el usuario conecta la billetera de la extensi√≥n de su navegador (como ArgentX o Braavos); si el usuario acepta la conexi√≥n, eso nos da acceso a la cuenta y al firmante, que "
"puede firmar transacciones y mensajes."

#: src/ch02-09-starknet-js.md:49
msgid ""
"Unlike Ethereum, where user accounts are Externally Owned Accounts,\n"
"Starknet **accounts are contracts**. This might not necessarily impact\n"
"your dapp‚Äôs frontend, but you should definitely be aware of this\n"
"difference."
msgstr ""
"A diferencia de Ethereum, donde las cuentas de usuario son cuentas de propiedad externa, las **cuentas de Starknet son contratos**. Es posible que esto no afecte necesariamente la interfaz de su "
"dapp, pero definitivamente debe tener en cuenta esta diferencia."

#: src/ch02-09-starknet-js.md:54
msgid ""
"```ts\n"
"async function connectWallet() {\n"
"    const starknet = await connect();\n"
"    console.log(starknet.account);\n"
"\n"
"    const nonce = await starknet.account.getNonce();\n"
"    const message = await starknet.account.signMessage(...)\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"async function connectWallet() {\n"
"    const starknet = await connect();\n"
"    console.log(starknet.account);\n"
"\n"
"    const nonce = await starknet.account.getNonce();\n"
"    const message = await starknet.account.signMessage(...)\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:64
msgid ""
"The snippet above uses the `connect` function provided by `get-starknet` to establish a connection to the user wallet. Once connected, we are able to access account methods, such as `signMessage` "
"or `execute`."
msgstr ""
"El fragmento anterior utiliza la funci√≥n `connect` proporcionada por `get-starknet` para establecer una conexi√≥n con la billetera del usuario. Una vez conectados, podremos acceder a los m√©todos de "
"la cuenta, como `signMessage` o `execute`."

#: src/ch02-09-starknet-js.md:66 src/ch02-09-01-counter-ui.md:145
msgid "### Provider"
msgstr "### Provider"

#: src/ch02-09-starknet-js.md:68
msgid ""
"The provider allows you to interact with the Starknet\n"
"network. You can think of it as a \"read\" connection to the blockchain,\n"
"as it doesn‚Äôt allow signing transactions or messages. Just like in\n"
"Ethereum, you can use a default provider, or use services such as Infura\n"
"or Alchemy, both of which support Starknet, to create an RPC provider."
msgstr ""
"El proveedor le permite interactuar con la red Starknet. Puedes considerarlo como una conexi√≥n de \"lectura\" a la cadena de bloques, ya que no permite firmar transacciones o mensajes. Al igual que "
"en Ethereum, puede utilizar un proveedor predeterminado o utilizar servicios como Infura o Alchemy, los cuales son compatibles con Starknet, para crear un proveedor de RPC."

#: src/ch02-09-starknet-js.md:74
msgid "By default, the Provider is a sequencer provider."
msgstr "De forma predeterminada, el proveedor es un proveedor de secuenciador."

#: src/ch02-09-starknet-js.md:76
msgid ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"
msgstr ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"

#: src/ch02-09-starknet-js.md:90
msgid "## Contracts"
msgstr "## Contracts"

#: src/ch02-09-starknet-js.md:92
msgid ""
"Your frontend will likely be interacting with deployed\n"
"contracts. For each contract, there should be a counterpart on the\n"
"frontend. To create these instances, you will need the contract‚Äôs\n"
"address and ABI, and either a provider or signer."
msgstr ""
"Es probable que su interfaz interact√∫e con los contratos implementados. Para cada contrato, debe haber una contraparte en la interfaz. Para crear estas instancias, necesitar√° la direcci√≥n del "
"contrato y el ABI, y un proveedor o firmante."

#: src/ch02-09-starknet-js.md:97
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"
msgstr ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"

#: src/ch02-09-starknet-js.md:107
msgid ""
"If you create a contract instance with a provider, you‚Äôll be limited to\n"
"calling read functions on the contract - only with a signer can you\n"
"change the state of the blockchain. However, you are able to connect a\n"
"previously created `Contract` instance with a new account:"
msgstr ""
"Si crea una instancia de contrato con un proveedor, estar√° limitado a llamar a funciones de lectura en el contrato; solo con un firmante puede cambiar el estado de la cadena de bloques. Sin "
"embargo, puede conectar una instancia de `Contract` creada previamente con una cuenta nueva:"

#: src/ch02-09-starknet-js.md:112
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, provider);\n"
"\n"
"contract.connect(starknet.account);\n"
"```"
msgstr ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, provider);\n"
"\n"
"contract.connect(starknet.account);\n"
"```"

#: src/ch02-09-starknet-js.md:118
msgid ""
"In the snippet above, after\n"
"calling the `connect` method, it would be possible to call read\n"
"functions on the contract, but not before."
msgstr "En el fragmento anterior, despu√©s de llamar al m√©todo `connect`, ser√≠a posible llamar a funciones de lectura en el contrato, pero no antes."

#: src/ch02-09-starknet-js.md:122
msgid "### Units"
msgstr "### Units"

#: src/ch02-09-starknet-js.md:124
msgid ""
"If you have previous experience with web3, you know dealing\n"
"with units requires care, and Starknet is no exception. Once again, the\n"
"docs are very useful here, in particular [this section on data\n"
"transformation](https://www.starknetjs.com/docs/guides/define_call_message/)."
msgstr ""
"Si tiene experiencia previa con web3, sabr√° que manejar unidades requiere cuidado y Starknet no es una excepci√≥n. Una vez m√°s, los documentos son muy √∫tiles aqu√≠, en particular [esta secci√≥n sobre "
"transformaci√≥n de datos](https://www.starknetjs.com/docs/guides/define_call_message/)."

#: src/ch02-09-starknet-js.md:129
msgid ""
"Very often you will need to convert Cairo structs (such as Uint256) that\n"
"are returned from contracts into numbers:"
msgstr "Muy a menudo necesitar√°s convertir las estructuras Cairo (como Uint256) que se devuelven de los contratos en n√∫meros:"

#: src/ch02-09-starknet-js.md:132
msgid ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"
msgstr ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"

#: src/ch02-09-starknet-js.md:145
msgid "And vice versa:"
msgstr "Y vice versa:"

#: src/ch02-09-starknet-js.md:147
msgid ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"
msgstr ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"

#: src/ch02-09-starknet-js.md:156
msgid ""
"There are other helpful utils, besides `bnToUint256` and `uint256ToBN`,\n"
"provided by Starknet.js."
msgstr ""
"Hay otras utilidades √∫tiles, adem√°s de `bnToUint256` y `uint256ToBN`,\n"
"proporcionado por Starknet.js."

#: src/ch02-09-starknet-js.md:159
msgid ""
"We now have a solid foundation to build a Starknet dapp. However, there\n"
"are framework specific tools that help us build Starknet dapps, which\n"
"are covered in chapter 5."
msgstr ""
"Ahora tenemos una base s√≥lida para construir una dapp Starknet. Sin embargo, existen herramientas espec√≠ficas del marco que nos ayudan a construir dapps Starknet, que se tratan en el cap√≠tulo 5."

#: src/ch02-09-starknet-js.md:163
msgid "With Starknet.js, you can also automate the process of deploying a smart contract to Starknet testnet / mainnet."
msgstr "Con Starknet.js, tambi√©n puedes automatizar el proceso de despliegue de un smart contract en Starknet testnet / mainnet."

#: src/ch02-09-starknet-js.md:165
msgid "# Deployment of Smart Contracts using Starknet.js"
msgstr "# Despliegue de Smart Contracts usando Starknet.js"

#: src/ch02-09-starknet-js.md:167
msgid ""
"Starknet.js offers capabilities for deploying smart contracts. In this tutorial, we demonstrate this by deploying an account contract, which we previously developed in [Chapter 4](https://book."
"starknet.io/ch04-03-standard-account.html), through a scripted approach."
msgstr ""
"Starknet.js ofrece capacidades para desplegar smart contracts. En este tutorial, demostramos esto desplegando un contrato de cuenta, que desarrollamos previamente en [Cap√≠tulo 4](https://book."
"starknet.io/ch04-03-standard-account.html), a trav√©s de un enfoque de secuencias de comandos."

#: src/ch02-09-starknet-js.md:169
msgid "## STEP 1: Initial Setup and Dependency Installation"
msgstr "## PASO 1: Configuraci√≥n Inicial e Instalaci√≥n de Dependencias"

#: src/ch02-09-starknet-js.md:171
msgid "To begin, set up your project environment for the account contract deployment. Within your project'sroot directory, start by initializing a Node.js environment:"
msgstr "Para empezar, configura el entorno de tu proyecto para el despliegue del contrato de cuenta. Dentro del directorio ra√≠z del proyecto, empieza por inicializar un entorno Node.js:"

#: src/ch02-09-starknet-js.md:173
msgid ""
"```sh\n"
"npm init -y\n"
"```"
msgstr ""
"```sh\n"
"npm init -y\n"
"```"

#: src/ch02-09-starknet-js.md:177
msgid "This command generates a package.json file. Next, update this file to include the latest versions of the necessary dependencies:"
msgstr "Este comando genera un archivo package.json. A continuaci√≥n, actualice este archivo para incluir las √∫ltimas versiones de las dependencias necesarias:"

#: src/ch02-09-starknet-js.md:179
msgid ""
"```json\n"
"\"@tsconfig/node20\": \"^20.1.2\",\n"
"\"axios\": \"^1.6.0\",\n"
"\"chalk\": \"^5.3.0\",\n"
"\"dotenv\": \"^16.3.1\",\n"
"\"starknet\": \"^5.19.5\",\n"
"\"ts-node\": \"^10.9.1\",\n"
"\"typescript\": \"^5.2.2\"\n"
"```"
msgstr ""
"```json\n"
"\"@tsconfig/node20\": \"^20.1.2\",\n"
"\"axios\": \"^1.6.0\",\n"
"\"chalk\": \"^5.3.0\",\n"
"\"dotenv\": \"^16.3.1\",\n"
"\"starknet\": \"^5.19.5\",\n"
"\"ts-node\": \"^10.9.1\",\n"
"\"typescript\": \"^5.2.2\"\n"
"```"

#: src/ch02-09-starknet-js.md:189
msgid "With the dependencies specified, install them using:"
msgstr "Con las dependencias especificadas, inst√°lalas utilizando:"

#: src/ch02-09-starknet-js.md:191
msgid ""
"```sh\n"
"npm install\n"
"```"
msgstr ""
"```sh\n"
"npm install\n"
"```"

#: src/ch02-09-starknet-js.md:195
msgid "## Configuration of TypeScript Environment"
msgstr "## Configuraci√≥n del entorno TypeScript"

#: src/ch02-09-starknet-js.md:197
msgid "Create a `tsconfig.json` file in your project directory:"
msgstr "Cree un archivo `tsconfig.json` en el directorio de su proyecto:"

#: src/ch02-09-starknet-js.md:199
msgid ""
"```json\n"
"{\n"
"  \"extends\": \"./node_modules/@tsconfig/node20/tsconfig.json\",\n"
"  \"include\": [\"scripts/**/*\"]\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"extends\": \"./node_modules/@tsconfig/node20/tsconfig.json\",\n"
"  \"include\": [\"scripts/**/*\"]\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:206
msgid "Ensure your Node.js version aligns with v20 to match this configuration."
msgstr "Aseg√∫rate de que tu versi√≥n de Node.js coincide con la v20 para que coincida con esta configuraci√≥n."

#: src/ch02-09-starknet-js.md:208
msgid "Furthermore, establish a `.env` file at the root of your project. This file should contain your RPC endpoint and the private key of your deployer account:"
msgstr "Adem√°s, cree un archivo `.env` en la ra√≠z de su proyecto. Este archivo debe contener su punto final RPC y la clave privada de su cuenta deployer:"

#: src/ch02-09-starknet-js.md:210
msgid ""
"```sh\n"
"DEPLOYER_PRIVATE_KEY=<YOUR_WALLET_ADDRESS_PRIVATE_KEY>\n"
"RPC_ENDPOINT=\"<INFURA_STARKNET_GOERLI_API_KEY>\"\n"
"```"
msgstr ""
"```sh\n"
"DEPLOYER_PRIVATE_KEY=<YOUR_WALLET_ADDRESS_PRIVATE_KEY>\n"
"RPC_ENDPOINT=\"<INFURA_STARKNET_GOERLI_API_KEY>\"\n"
"```"

#: src/ch02-09-starknet-js.md:215
msgid "Your environment is successfully set up."
msgstr "Su entorno se ha configurado correctamente."

#: src/ch02-09-starknet-js.md:217
msgid "## Preparation of Deployment Scripts"
msgstr "## Preparaci√≥n de los Deployment Scripts"

#: src/ch02-09-starknet-js.md:219
msgid "To facilitate the deployment of the account contract, three key files are necessary:"
msgstr "Para facilitar el despliegue del contrato de cuenta, son necesarios tres ficheros clave:"

#: src/ch02-09-starknet-js.md:221
msgid ""
"- `utils.ts`: This file will contain the functions and logic for deployment.\n"
"- `deploy.ts`: This is the main deployment script.\n"
"- `l2-eth-abi.json`: his file will hold the ABI (Application Binary Interface) for the account contract."
msgstr ""
"- `utils.ts`: Este archivo contendr√° las funciones y la l√≥gica para el despliegue.\n"
"- `deploy.ts`: Este es el script principal de despliegue.\n"
"- `l2-eth-abi.json`: Este archivo contendr√° el ABI (Application Binary Interface) para el contrato de cuenta."

#: src/ch02-09-starknet-js.md:225
msgid "## STEP 2: Import Required Modules and Functions"
msgstr "## PASO 2: Importe los M√≥dulos y Funciones Necesarios"

#: src/ch02-09-starknet-js.md:227
msgid ""
"In the `utils.ts` file, import the necessary modules and functions from various packages. This includes functionality from Starknet, filesystem operations, path handling, and environment variable "
"configuration:"
msgstr ""
"En el archivo `utils.ts`, importa los m√≥dulos y funciones necesarios de varios paquetes. Esto incluye la funcionalidad de Starknet, las operaciones del sistema de archivos, el manejo de rutas y la "
"configuraci√≥n de variables de entorno:"

#: src/ch02-09-starknet-js.md:229
msgid ""
"```ts\n"
"import {\n"
"  Account,\n"
"  stark,\n"
"  ec,\n"
"  hash,\n"
"  CallData,\n"
"  RpcProvider,\n"
"  Contract,\n"
"  cairo,\n"
"} from \"starknet\";\n"
"import { promises as fs } from \"fs\";\n"
"import path from \"path\";\n"
"import readline from \"readline\";\n"
"import \"dotenv/config\";\n"
"```"
msgstr ""
"```ts\n"
"import {\n"
"  Account,\n"
"  stark,\n"
"  ec,\n"
"  hash,\n"
"  CallData,\n"
"  RpcProvider,\n"
"  Contract,\n"
"  cairo,\n"
"} from \"starknet\";\n"
"import { promises as fs } from \"fs\";\n"
"import path from \"path\";\n"
"import readline from \"readline\";\n"
"import \"dotenv/config\";\n"
"```"

#: src/ch02-09-starknet-js.md:246
msgid "## STEP 3: Implementing the `waitForEnter` Function"
msgstr "## PASO 3: Implementaci√≥n de la Funci√≥n `waitForEnter`"

#: src/ch02-09-starknet-js.md:248
msgid "To enhance user interaction during the deployment process, implement the `waitForEnter` function. This function prompts the user to press 'Enter' to proceed, ensuring an interactive session:"
msgstr ""
"Para mejorar la interacci√≥n del usuario durante el proceso de despliegue, implemente la funci√≥n `waitForEnter`. Esta funci√≥n pide al usuario que pulse 'Enter' para continuar, lo que garantiza una "
"sesi√≥n interactiva:"

#: src/ch02-09-starknet-js.md:250
msgid ""
"```ts\n"
"export async function waitForEnter(message: string): Promise<void> {\n"
"  return new Promise((resolve) => {\n"
"    const rl = readline.createInterface({\n"
"      input: process.stdin,\n"
"      output: process.stdout,\n"
"    });\n"
"\n"
"    rl.question(message, (_) => {\n"
"      rl.close();\n"
"      resolve();\n"
"    });\n"
"  });\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"export async function waitForEnter(message: string): Promise<void> {\n"
"  return new Promise((resolve) => {\n"
"    const rl = readline.createInterface({\n"
"      input: process.stdin,\n"
"      output: process.stdout,\n"
"    });\n"
"\n"
"    rl.question(message, (_) => {\n"
"      rl.close();\n"
"      resolve();\n"
"    });\n"
"  });\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:266
msgid "## STEP 4: Styling Terminal Output Messages"
msgstr "## PASO 4: Estilizar los mensajes de salida del terminal"

#: src/ch02-09-starknet-js.md:268
msgid "Integrate the `chalk` module for styling terminal output messages. This enhances the readability and user experience in the command line interface:"
msgstr "Integra el m√≥dulo `chalk` para dar estilo a los mensajes de salida del terminal. Esto mejora la legibilidad y la experiencia del usuario en la interfaz de l√≠nea de comandos:"

#: src/ch02-09-starknet-js.md:270
msgid ""
"```ts\n"
"export async function importChalk() {\n"
"  return import(\"chalk\").then((m) => m.default);\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"export async function importChalk() {\n"
"  return import(\"chalk\").then((m) => m.default);\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:276
msgid "## STEP 5: Establishing Connection to the Starknet Network"
msgstr "## PASO 5: Establecer la Conexi√≥n a la Red Starknet"

#: src/ch02-09-starknet-js.md:278
msgid "Configure the `RpcProvider` object to connect to the Starknet network. This connection uses the RPC endpoint specified in the `.env` file, facilitating communication through the Infura client:"
msgstr ""
"Configure el objeto `RpcProvider` para conectarse a la red Starknet. Esta conexi√≥n utiliza el punto final RPC especificado en el archivo `.env`, facilitando la comunicaci√≥n a trav√©s del cliente "
"Infura:"

#: src/ch02-09-starknet-js.md:280
msgid ""
"```ts\n"
"export function connectToStarknet() {\n"
"  return new RpcProvider({\n"
"    nodeUrl: process.env.RPC_ENDPOINT as string,\n"
"  });\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"export function connectToStarknet() {\n"
"  return new RpcProvider({\n"
"    nodeUrl: process.env.RPC_ENDPOINT as string,\n"
"  });\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:288
msgid "## STEP 6: Preparing the Deployer Account"
msgstr "## PASO 6: Preparaci√≥n de la Cuenta del Deployer"

#: src/ch02-09-starknet-js.md:290
msgid ""
"Set up the deployer account for contract deployment.\n"
"Utilize the private key from the `.env` file and its respective pre-deployed address to create a new `Account` object:"
msgstr ""
"Configure la cuenta del deployer para el despliegue de contratos.\n"
"Utilice la clave privada del archivo `.env` y su respectiva direcci√≥n predesplegada para crear un nuevo objeto `Account`:"

#: src/ch02-09-starknet-js.md:293
msgid ""
"```ts\n"
"export function getDeployerWallet(provider: RpcProvider) {\n"
"  const privateKey = process.env.DEPLOYER_PRIVATE_KEY as string;\n"
"  const address =\n"
"    \"0x070a0122733c00716cb9f4ab5a77b8bcfc04b707756bbc27dc90973844a752d1\";\n"
"  return new Account(provider, address, privateKey);\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"export function getDeployerWallet(provider: RpcProvider) {\n"
"  const privateKey = process.env.DEPLOYER_PRIVATE_KEY as string;\n"
"  const address =\n"
"    \"0x070a0122733c00716cb9f4ab5a77b8bcfc04b707756bbc27dc90973844a752d1\";\n"
"  return new Account(provider, address, privateKey);\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:302
msgid "## STEP 7: Generating a Key Pair for the Account Contract"
msgstr "## PASO 7: Generaci√≥n de un Key Pair para el Contrato de Cuenta"

#: src/ch02-09-starknet-js.md:304
msgid "The next step involves generating a key pair for the account contract using the `stark` object from Starknet.js. The key pair consists of a private key and a corresponding public key:"
msgstr ""
"El siguiente paso consiste en generar un par de claves para el contrato de cuenta utilizando el objeto `stark` de Starknet.js. El par de claves consta de una clave privada y su correspondiente "
"clave p√∫blica:"

#: src/ch02-09-starknet-js.md:306
msgid ""
"```ts\n"
"export function createKeyPair() {\n"
"  const privateKey = stark.randomAddress();\n"
"  const publicKey = ec.starkCurve.getStarkKey(privateKey);\n"
"  return {\n"
"    privateKey,\n"
"    publicKey,\n"
"  };\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"export function createKeyPair() {\n"
"  const privateKey = stark.randomAddress();\n"
"  const publicKey = ec.starkCurve.getStarkKey(privateKey);\n"
"  return {\n"
"    privateKey,\n"
"    publicKey,\n"
"  };\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:317
msgid "Note: If a specific private key is required, replace `stark.randomAddress()` with the desired private key."
msgstr "Nota: Si se requiere una clave privada espec√≠fica, sustituya `stark.randomAddress()` por la clave privada deseada."

#: src/ch02-09-starknet-js.md:319
msgid "## STEP 8: Importing Compiled Account Contract Files"
msgstr "## PASO 8: Importaci√≥n de Ficheros de Contratos de Cuentas Compilados"

#: src/ch02-09-starknet-js.md:321
msgid "After compiling the account contract with `scarb build`, Sierra and Casm files are generated in the `target/dev/`directory:"
msgstr "Despu√©s de compilar el contrato de cuenta con `scarb build`, se generan archivos Sierra y Casm en el directorio `target/dev/`:"

#: src/ch02-09-starknet-js.md:323
msgid ""
"- Sierra File: `<Project_File_Name>.contract_class.json`\n"
"- Casm File: `<Project_File_Name>.compiled_contract_class.json`"
msgstr ""
"- Sierra File: `<Project_File_Name>.contract_class.json`\n"
"- Casm File: `<Project_File_Name>.compiled_contract_class.json`"

#: src/ch02-09-starknet-js.md:326
msgid "To import these files into the deployment script, specify their absolute paths:"
msgstr "Para importar estos archivos en el script de despliegue, especifique sus rutas absolutas:"

#: src/ch02-09-starknet-js.md:328
msgid ""
"```ts\n"
"export async function getCompiledCode(filename: string) {\n"
"  const sierraFilePath = path.join(\n"
"    __dirname,\n"
"    `../target/dev/${filename}.contract_class.json`,\n"
"  );\n"
"  const casmFilePath = path.join(\n"
"    __dirname,\n"
"    `../target/dev/${filename}.compiled_contract_class.json`,\n"
"  );\n"
"\n"
"  const code = [sierraFilePath, casmFilePath].map(async (filePath) => {\n"
"    const file = await fs.readFile(filePath);\n"
"    return JSON.parse(file.toString(\"ascii\"));\n"
"  });\n"
"\n"
"  const [sierraCode, casmCode] = await Promise.all(code);\n"
"\n"
"  return {\n"
"    sierraCode,\n"
"    casmCode,\n"
"  };\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"export async function getCompiledCode(filename: string) {\n"
"  const sierraFilePath = path.join(\n"
"    __dirname,\n"
"    `../target/dev/${filename}.contract_class.json`,\n"
"  );\n"
"  const casmFilePath = path.join(\n"
"    __dirname,\n"
"    `../target/dev/${filename}.compiled_contract_class.json`,\n"
"  );\n"
"\n"
"  const code = [sierraFilePath, casmFilePath].map(async (filePath) => {\n"
"    const file = await fs.readFile(filePath);\n"
"    return JSON.parse(file.toString(\"ascii\"));\n"
"  });\n"
"\n"
"  const [sierraCode, casmCode] = await Promise.all(code);\n"
"\n"
"  return {\n"
"    sierraCode,\n"
"    casmCode,\n"
"  };\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:353
msgid "We use `fs` method to read the file contents."
msgstr "Utilizamos el m√©todo `fs` para leer el contenido del archivo."

#: src/ch02-09-starknet-js.md:355
msgid "## STEP 9: Declaration of the Account Contract"
msgstr "## PASO 9: Declaraci√≥n del Contrato de Cuenta"

#: src/ch02-09-starknet-js.md:357
msgid "To declare the account contract's class, define an `interface` containing all necessary fields for the declaration, then use the `declare()` method:"
msgstr "Para declarar la clase del contrato de cuenta, defina una `interface` que contenga todos los campos necesarios para la declaraci√≥n y, a continuaci√≥n, utilice el m√©todo `declare()`:"

#: src/ch02-09-starknet-js.md:359
msgid ""
"```ts\n"
"interface DeclareAccountConfig {\n"
"  provider: RpcProvider;\n"
"  deployer: Account;\n"
"  sierraCode: any;\n"
"  casmCode: any;\n"
"}\n"
"\n"
"export async function declareContract({\n"
"  provider,\n"
"  deployer,\n"
"  sierraCode,\n"
"  casmCode,\n"
"}: DeclareAccountConfig) {\n"
"  const declare = await deployer.declare({\n"
"    contract: sierraCode,\n"
"    casm: casmCode,\n"
"  });\n"
"  await provider.waitForTransaction(declare.transaction_hash);\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"interface DeclareAccountConfig {\n"
"  provider: RpcProvider;\n"
"  deployer: Account;\n"
"  sierraCode: any;\n"
"  casmCode: any;\n"
"}\n"
"\n"
"export async function declareContract({\n"
"  provider,\n"
"  deployer,\n"
"  sierraCode,\n"
"  casmCode,\n"
"}: DeclareAccountConfig) {\n"
"  const declare = await deployer.declare({\n"
"    contract: sierraCode,\n"
"    casm: casmCode,\n"
"  });\n"
"  await provider.waitForTransaction(declare.transaction_hash);\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:381
msgid "## STEP 10: Deploying the Account Contract"
msgstr "## PASO 10: Despliegue del Contrato de Cuenta"

#: src/ch02-09-starknet-js.md:383
msgid ""
"To deploy the account contract, calculate its address using the contract's class hash. After determining the address, fund it using the [Starknet Faucet](https://faucet.goerli.starknet.io/) to "
"cover gas fees during deployment:"
msgstr ""
"Para desplegar el contrato de cuenta, calcula su direcci√≥n utilizando el hash de clase del contrato. Una vez determinada la direcci√≥n, f√∫ndala utilizando el [Starknet Faucet](https://faucet.goerli."
"starknet.io/) para cubrir los gastos de gas durante el despliegue:"

#: src/ch02-09-starknet-js.md:385
msgid ""
"```ts\n"
"interface DeployAccountConfig {\n"
"  privateKey: string;\n"
"  publicKey: string;\n"
"  classHash: string;\n"
"  provider: RpcProvider;\n"
"}\n"
"\n"
"export async function deployAccount({\n"
"  privateKey,\n"
"  publicKey,\n"
"  classHash,\n"
"  provider,\n"
"}: DeployAccountConfig) {\n"
"  const chalk = await importChalk();\n"
"\n"
"  const constructorArgs = CallData.compile({\n"
"    public_key: publicKey,\n"
"  });\n"
"\n"
"  const myAccountAddress = hash.calculateContractAddressFromHash(\n"
"    publicKey,\n"
"    classHash,\n"
"    constructorArgs,\n"
"    0,\n"
"  );\n"
"\n"
"  console.log(`Send ETH to contract address ${chalk.bold(myAccountAddress)}`);\n"
"  const message = \"Press [Enter] when ready...\";\n"
"  await waitForEnter(message);\n"
"\n"
"  const account = new Account(provider, myAccountAddress, privateKey, \"1\");\n"
"\n"
"  const deploy = await account.deployAccount({\n"
"    classHash: classHash,\n"
"    constructorCalldata: constructorArgs,\n"
"    addressSalt: publicKey,\n"
"  });\n"
"\n"
"  await provider.waitForTransaction(deploy.transaction_hash);\n"
"  return deploy.contract_address;\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"interface DeployAccountConfig {\n"
"  privateKey: string;\n"
"  publicKey: string;\n"
"  classHash: string;\n"
"  provider: RpcProvider;\n"
"}\n"
"\n"
"export async function deployAccount({\n"
"  privateKey,\n"
"  publicKey,\n"
"  classHash,\n"
"  provider,\n"
"}: DeployAccountConfig) {\n"
"  const chalk = await importChalk();\n"
"\n"
"  const constructorArgs = CallData.compile({\n"
"    public_key: publicKey,\n"
"  });\n"
"\n"
"  const myAccountAddress = hash.calculateContractAddressFromHash(\n"
"    publicKey,\n"
"    classHash,\n"
"    constructorArgs,\n"
"    0,\n"
"  );\n"
"\n"
"  console.log(`Send ETH to contract address ${chalk.bold(myAccountAddress)}`);\n"
"  const message = \"Press [Enter] when ready...\";\n"
"  await waitForEnter(message);\n"
"\n"
"  const account = new Account(provider, myAccountAddress, privateKey, \"1\");\n"
"\n"
"  const deploy = await account.deployAccount({\n"
"    classHash: classHash,\n"
"    constructorCalldata: constructorArgs,\n"
"    addressSalt: publicKey,\n"
"  });\n"
"\n"
"  await provider.waitForTransaction(deploy.transaction_hash);\n"
"  return deploy.contract_address;\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:429
msgid "## STEP 11: Interacting with the Deployed Account Contract"
msgstr "## PASO 11: Interacci√≥n con el Contrato de Cuenta Desplegado"

#: src/ch02-09-starknet-js.md:431
msgid "Once the account contract is successfully deployed, we can test it by sending test Ethereum (ETH) to another address:"
msgstr "Una vez desplegado con √©xito el contrato de cuenta, podemos probarlo enviando Ethereum (ETH) de prueba a otra direcci√≥n:"

#: src/ch02-09-starknet-js.md:433
msgid ""
"```ts\n"
"interface TransferEthConfig {\n"
"  provider: RpcProvider;\n"
"  account: Account;\n"
"}\n"
"\n"
"export async function transferEth({ provider, account }: TransferEthConfig) {\n"
"  const L2EthAddress =\n"
"    \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\";\n"
"\n"
"  const L2EthAbiPath = path.join(__dirname, \"./l2-eth-abi.json\");\n"
"  const L2EthAbiFile = await fs.readFile(L2EthAbiPath);\n"
"  const L2ETHAbi = JSON.parse(L2EthAbiFile.toString(\"ascii\"));\n"
"\n"
"  const contract = new Contract(L2ETHAbi, L2EthAddress, provider);\n"
"\n"
"  contract.connect(account);\n"
"\n"
"  const recipient =\n"
"    \"0x05feeb3a0611b8f1f602db065d36c0f70bb01032fc1f218bf9614f96c8f546a9\";\n"
"  const amountInGwei = cairo.uint256(100);\n"
"\n"
"  await contract.transfer(recipient, amountInGwei);\n"
"}\n"
"\n"
"export async function isContractAlreadyDeclared(\n"
"  classHash: string,\n"
"  provider: RpcProvider,\n"
") {\n"
"  try {\n"
"    await provider.getClassByHash(classHash);\n"
"    return true;\n"
"  } catch (error) {\n"
"    return false;\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```ts\n"
"interface TransferEthConfig {\n"
"  provider: RpcProvider;\n"
"  account: Account;\n"
"}\n"
"\n"
"export async function transferEth({ provider, account }: TransferEthConfig) {\n"
"  const L2EthAddress =\n"
"    \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\";\n"
"\n"
"  const L2EthAbiPath = path.join(__dirname, \"./l2-eth-abi.json\");\n"
"  const L2EthAbiFile = await fs.readFile(L2EthAbiPath);\n"
"  const L2ETHAbi = JSON.parse(L2EthAbiFile.toString(\"ascii\"));\n"
"\n"
"  const contract = new Contract(L2ETHAbi, L2EthAddress, provider);\n"
"\n"
"  contract.connect(account);\n"
"\n"
"  const recipient =\n"
"    \"0x05feeb3a0611b8f1f602db065d36c0f70bb01032fc1f218bf9614f96c8f546a9\";\n"
"  const amountInGwei = cairo.uint256(100);\n"
"\n"
"  await contract.transfer(recipient, amountInGwei);\n"
"}\n"
"\n"
"export async function isContractAlreadyDeclared(\n"
"  classHash: string,\n"
"  provider: RpcProvider,\n"
") {\n"
"  try {\n"
"    await provider.getClassByHash(classHash);\n"
"    return true;\n"
"  } catch (error) {\n"
"    return false;\n"
"  }\n"
"}\n"
"```"

#: src/ch02-09-starknet-js.md:471
msgid "With the necessary functions in place, we can now write the deployment script in `deploy.ts`, which orchestrates the deployment and verification process:"
msgstr "Con las funciones necesarias en su lugar, ahora podemos escribir el script de despliegue en `deploy.ts`, que orquesta el proceso de despliegue y verificaci√≥n:"

#: src/ch02-09-starknet-js.md:473
msgid ""
"```ts\n"
"import { hash, LibraryError, Account } from \"starknet\";\n"
"\n"
"import {\n"
"  importChalk,\n"
"  connectToStarknet,\n"
"  getDeployerWallet,\n"
"  createKeyPair,\n"
"  getCompiledCode,\n"
"  declareContract,\n"
"  deployAccount,\n"
"  transferEth,\n"
"  isContractAlreadyDeclared,\n"
"} from \"./utils\";\n"
"\n"
"async function main() {\n"
"  const chalk = await importChalk();\n"
"  const provider = connectToStarknet();\n"
"  const deployer = getDeployerWallet(provider);\n"
"  const { privateKey, publicKey } = createKeyPair();\n"
"\n"
"  console.log(chalk.yellow(\"Account Contract:\"));\n"
"  console.log(`Private Key = ${privateKey}`);\n"
"  console.log(`Public Key = ${publicKey}`);\n"
"\n"
"  let sierraCode, casmCode;\n"
"  try {\n"
"    ({ sierraCode, casmCode } = await getCompiledCode(\"aa_Account\"));\n"
"  } catch (error: any) {\n"
"    console.log(chalk.red(\"Failed to read contract files\"));\n"
"    process.exit(1);\n"
"  }\n"
"\n"
"  const classHash = hash.computeContractClassHash(sierraCode);\n"
"  const isAlreadyDeclared = await isContractAlreadyDeclared(\n"
"    classHash,\n"
"    provider,\n"
"  );\n"
"\n"
"  if (isAlreadyDeclared) {\n"
"    console.log(chalk.yellow(\"Contract class already declared\"));\n"
"  } else {\n"
"    try {\n"
"      console.log(\"Declaring account contract...\");\n"
"      await declareContract({ provider, deployer, sierraCode, casmCode });\n"
"      console.log(chalk.green(\"Account contract successfully declared\"));\n"
"    } catch (error: any) {\n"
"      console.log(chalk.red(\"Declare transaction failed\"));\n"
"      console.log(error);\n"
"      process.exit(1);\n"
"    }\n"
"  }\n"
"\n"
"  console.log(`Class Hash = ${classHash}`);\n"
"\n"
"  let address: string;\n"
"  try {\n"
"    console.log(\"Deploying account contract...\");\n"
"    address = await deployAccount({\n"
"      privateKey,\n"
"      publicKey,\n"
"      classHash,\n"
"      provider,\n"
"    });\n"
"    console.log(\n"
"      chalk.green(`Account contract successfully deployed to Starknet testnet`),\n"
"    );\n"
"  } catch (error: any) {\n"
"    if (\n"
"      error instanceof LibraryError &&\n"
"      error.message.includes(\"balance is smaller\")\n"
"    ) {\n"
"      console.log(chalk.red(\"Insufficient account balance for deployment\"));\n"
"      process.exit(1);\n"
"    } else {\n"
"      console.log(chalk.red(\"Deploy account transaction failed\"));\n"
"      process.exit(1);\n"
"    }\n"
"  }\n"
"\n"
"  const account = new Account(provider, address, privateKey, \"1\");\n"
"\n"
"  try {\n"
"    console.log(\"Testing account by transferring ETH...\");\n"
"    await transferEth({ provider, account });\n"
"    console.log(chalk.green(`Account works!`));\n"
"  } catch (error) {\n"
"    console.log(chalk.red(\"Failed to transfer ETH\"));\n"
"    process.exit(1);\n"
"  }\n"
"}\n"
"\n"
"main();\n"
"```"
msgstr ""
"```ts\n"
"import { hash, LibraryError, Account } from \"starknet\";\n"
"\n"
"import {\n"
"  importChalk,\n"
"  connectToStarknet,\n"
"  getDeployerWallet,\n"
"  createKeyPair,\n"
"  getCompiledCode,\n"
"  declareContract,\n"
"  deployAccount,\n"
"  transferEth,\n"
"  isContractAlreadyDeclared,\n"
"} from \"./utils\";\n"
"\n"
"async function main() {\n"
"  const chalk = await importChalk();\n"
"  const provider = connectToStarknet();\n"
"  const deployer = getDeployerWallet(provider);\n"
"  const { privateKey, publicKey } = createKeyPair();\n"
"\n"
"  console.log(chalk.yellow(\"Account Contract:\"));\n"
"  console.log(`Private Key = ${privateKey}`);\n"
"  console.log(`Public Key = ${publicKey}`);\n"
"\n"
"  let sierraCode, casmCode;\n"
"  try {\n"
"    ({ sierraCode, casmCode } = await getCompiledCode(\"aa_Account\"));\n"
"  } catch (error: any) {\n"
"    console.log(chalk.red(\"Failed to read contract files\"));\n"
"    process.exit(1);\n"
"  }\n"
"\n"
"  const classHash = hash.computeContractClassHash(sierraCode);\n"
"  const isAlreadyDeclared = await isContractAlreadyDeclared(\n"
"    classHash,\n"
"    provider,\n"
"  );\n"
"\n"
"  if (isAlreadyDeclared) {\n"
"    console.log(chalk.yellow(\"Contract class already declared\"));\n"
"  } else {\n"
"    try {\n"
"      console.log(\"Declaring account contract...\");\n"
"      await declareContract({ provider, deployer, sierraCode, casmCode });\n"
"      console.log(chalk.green(\"Account contract successfully declared\"));\n"
"    } catch (error: any) {\n"
"      console.log(chalk.red(\"Declare transaction failed\"));\n"
"      console.log(error);\n"
"      process.exit(1);\n"
"    }\n"
"  }\n"
"\n"
"  console.log(`Class Hash = ${classHash}`);\n"
"\n"
"  let address: string;\n"
"  try {\n"
"    console.log(\"Deploying account contract...\");\n"
"    address = await deployAccount({\n"
"      privateKey,\n"
"      publicKey,\n"
"      classHash,\n"
"      provider,\n"
"    });\n"
"    console.log(\n"
"      chalk.green(`Account contract successfully deployed to Starknet testnet`),\n"
"    );\n"
"  } catch (error: any) {\n"
"    if (\n"
"      error instanceof LibraryError &&\n"
"      error.message.includes(\"balance is smaller\")\n"
"    ) {\n"
"      console.log(chalk.red(\"Insufficient account balance for deployment\"));\n"
"      process.exit(1);\n"
"    } else {\n"
"      console.log(chalk.red(\"Deploy account transaction failed\"));\n"
"      process.exit(1);\n"
"    }\n"
"  }\n"
"\n"
"  const account = new Account(provider, address, privateKey, \"1\");\n"
"\n"
"  try {\n"
"    console.log(\"Testing account by transferring ETH...\");\n"
"    await transferEth({ provider, account });\n"
"    console.log(chalk.green(`Account works!`));\n"
"  } catch (error) {\n"
"    console.log(chalk.red(\"Failed to transfer ETH\"));\n"
"    process.exit(1);\n"
"  }\n"
"}\n"
"\n"
"main();\n"
"```"

#: src/ch02-09-starknet-js.md:568
msgid ""
"The `main` function orchestrates the entire deployment process, from creating a key pair to declaring and deploying the account contract, and finally testing its functionality by executing a "
"transfer transaction."
msgstr ""
"La funci√≥n `main` orquesta todo el proceso de despliegue, desde la creaci√≥n de un par de claves hasta la declaraci√≥n y despliegue del contrato de cuenta, y finalmente prueba su funcionalidad "
"ejecutando una transacci√≥n de transferencia."

#: src/ch02-09-starknet-js.md:572
msgid ""
"We have walked through the process of deploying an account contract using Starknet.js. Starting from setting up the environment, compiling the contract, and preparing the deployment scripts, to the "
"final steps of declaring, deploying, and interacting with the contract, each phase has been covered in detail. This approach ensures that developers can easily deploy their account contracts on the "
"Starknet network."
msgstr ""
"Hemos recorrido el proceso de implementaci√≥n de un contrato de cuenta utilizando Starknet.js. Desde la configuraci√≥n del entorno, la compilaci√≥n del contrato y la preparaci√≥n de los scripts de "
"implementaci√≥n, hasta los pasos finales de declarar, implementar e interactuar con el contrato, cada fase se ha cubierto en detalle. Este enfoque garantiza que los desarrolladores puedan "
"implementar f√°cilmente sus contratos de cuenta en la red Starknet."

#: src/ch02-09-01-counter-ui.md:1
msgid "# Counter Smart Contract UI Integration"
msgstr "# Integraci√≥n de UI del Contrato Counter"

#: src/ch02-09-01-counter-ui.md:3
msgid "This guide walks readers through integrating a simple counter smart contract with a frontend. By the end of this guide, readers will understand how to:"
msgstr "Esta gu√≠a orienta a los lectores a trav√©s de la integraci√≥n de un smart contract de un contador simple con una interfaz. Al final de esta gu√≠a, los lectores entender√°n c√≥mo:"

#: src/ch02-09-01-counter-ui.md:5
msgid ""
"- Connect the frontend to a smart contract.\n"
"- Initiate transactions, such as incrementing or decrementing the counter.\n"
"- Read and display data, such as showing the counter value on the frontend."
msgstr ""
"- Conectar el frontend a un smart contract.\n"
"- Iniciar transacciones, como incrementar o disminuir el contador.\n"
"- Leer y mostrar datos, como mostrar el valor del contador en la interfaz."

#: src/ch02-09-01-counter-ui.md:9 src/ch02-09-01-counter-ui.md:237
msgid ""
"For a visual walkthrough, do check out the [Basecamp frontend session](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view). This comprehensive session delves deeper into the "
"nuances of the concepts we've touched upon, presenting a mix of theoretical explanations and hands-on demonstrations."
msgstr ""
"Para obtener un recorrido visual, consulte la [sesi√≥n de frontend de Basecamp](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view). Esta sesi√≥n integral profundiza en los "
"matices de los conceptos que hemos tocado, presentando una combinaci√≥n de explicaciones te√≥ricas y demostraciones pr√°cticas."

#: src/ch02-09-01-counter-ui.md:11
msgid "## Tools Used"
msgstr "## Tools Utilizadas"

#: src/ch02-09-01-counter-ui.md:13
msgid ""
"- [Reactjs](https://react.dev/learn/start-a-new-react-project): A frontend building framework.\n"
"- [@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet): A wrapper for **[starknet.js](https://github.com/0xs34n/starknet.js)**, aiding interaction with wallet extensions.\n"
"- [starknet](https://www.npmjs.com/package/starknet): A JavaScript library for Starknet."
msgstr ""
"- [Reactjs](https://react.dev/learn/start-a-new-react-project): Un framework de construcci√≥n de frontend.\n"
"- [@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet): Un wrapper para **[starknet.js](https://github.com/0xs34n /starknet.js)**, lo que ayuda a la interacci√≥n con las "
"extensiones de billetera.\n"
"- [starknet](https://www.npmjs.com/package/starknet): Una biblioteca de JavaScript para Starknet."

#: src/ch02-09-01-counter-ui.md:17
msgid "## Setting Up the Environment"
msgstr "# Configuraci√≥n de Variables de Entorno"

#: src/ch02-09-01-counter-ui.md:19
msgid "To begin, clone the project repository:"
msgstr "Para comenzar, clona el repositorio del proyecto:"

#: src/ch02-09-01-counter-ui.md:21
msgid ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"
msgstr ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"

#: src/ch02-09-01-counter-ui.md:25
msgid "Then, navigate to the project directory and install necessary packages:"
msgstr "Luego, navegue hasta el directorio del proyecto e instale los paquetes necesarios:"

#: src/ch02-09-01-counter-ui.md:27
msgid ""
"```bash\n"
"cd basecamp-frontend-boilerplate\n"
"npm install\n"
"```"
msgstr ""
"```bash\n"
"cd basecamp-frontend-boilerplate\n"
"npm install\n"
"```"

#: src/ch02-09-01-counter-ui.md:32
msgid "To launch the project, run:"
msgstr "Para iniciar el proyecto, ejecute:"

#: src/ch02-09-01-counter-ui.md:34
msgid ""
"```bash\n"
"yarn start\n"
"```"
msgstr ""
"```bash\n"
"yarn start\n"
"```"

#: src/ch02-09-01-counter-ui.md:38
msgid "In `index.js`, several key functions are provided:"
msgstr "En `index.js`, se proporcionan varias funciones clave:"

#: src/ch02-09-01-counter-ui.md:40
msgid ""
"```javascript\n"
"// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
"const connectWallet = async () => {};\n"
"\n"
"// Terminate the connection\n"
"const disconnectWallet = async () => {};\n"
"\n"
"// Trigger increment\n"
"const increaseCounter = async () => {};\n"
"\n"
"// Trigger decrement\n"
"const decreaseCounter = async () => {};\n"
"\n"
"// Retrieve current count\n"
"const getCounter = async () => {};\n"
"```"
msgstr ""
"```javascript\n"
"// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
"const connectWallet = async () => {};\n"
"\n"
"// Terminate the connection\n"
"const disconnectWallet = async () => {};\n"
"\n"
"// Trigger increment\n"
"const increaseCounter = async () => {};\n"
"\n"
"// Trigger decrement\n"
"const decreaseCounter = async () => {};\n"
"\n"
"// Retrieve current count\n"
"const getCounter = async () => {};\n"
"```"

#: src/ch02-09-01-counter-ui.md:57
msgid "## Managing Connection"
msgstr "## Administrar la conexi√≥n"

#: src/ch02-09-01-counter-ui.md:59
msgid "### `connectWallet`"
msgstr "### `connectWallet`"

#: src/ch02-09-01-counter-ui.md:61
msgid ""
"The `connectWallet` function serves as the mechanism to establish a connection to the blockchain through specific wallet providers such as ArgentX or Braavos. It is asynchronous, allowing the use "
"of `await` for handling asynchronous tasks."
msgstr ""
"La funci√≥n `connectWallet` sirve como mecanismo para establecer una conexi√≥n a la cadena de bloques a trav√©s de proveedores de billetera espec√≠ficos como ArgentX o Braavos. Es asincr√≥nico, lo que "
"permite el uso de `await` para manejar tareas asincr√≥nicas."

#: src/ch02-09-01-counter-ui.md:63
msgid ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-09-01-counter-ui.md:74
msgid ""
"- Initiates the connection using the **`connect`** method from the **`@argent/get-starknet`** library, targeting Starknet.\n"
"- Upon a successful connection, updates the React component's state with details of the **`connection`**, **`account`**, and **`selectedAddress`**."
msgstr ""
"- Inicia la conexi√≥n utilizando el m√©todo **`connect`** de la biblioteca **`@argent/get-starknet`**, apuntando a Starknet.\n"
"- Tras una conexi√≥n exitosa, actualiza el estado del componente React con detalles de **`connection`**, **`account`** y **`selectedAddress`**."

#: src/ch02-09-01-counter-ui.md:77
msgid "### `disconnectWallet`"
msgstr "### `disconnectWallet`"

#: src/ch02-09-01-counter-ui.md:79
msgid "The `disconnectWallet` function is designed to sever the connection with the web wallet asynchronously. After disconnection, it updates the component's state, resetting connection details."
msgstr ""
"La funci√≥n `disconnectWallet` est√° dise√±ada para cortar la conexi√≥n con la billetera web de forma asincr√≥nica. Despu√©s de la desconexi√≥n, actualiza el estado del componente y restablece los "
"detalles de la conexi√≥n."

#: src/ch02-09-01-counter-ui.md:81
msgid ""
"```bash\n"
"const disconnectWallet = async() => {\n"
"    await disconnect();\n"
"    setConnection(undefined);\n"
"    setAccount(undefined);\n"
"    setAddress('');\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"const disconnectWallet = async() => {\n"
"    await disconnect();\n"
"    setConnection(undefined);\n"
"    setAccount(undefined);\n"
"    setAddress('');\n"
"}\n"
"```"

#: src/ch02-09-01-counter-ui.md:90
msgid ""
"- It utilizes the **`disconnect`** function, possibly from an external library, and handles the operation asynchronously with **`await`**.\n"
"- Post-disconnection, the state of the React component is updated:\n"
"  - **`setConnection`** is set to **`undefined`**.\n"
"  - **`setAccount`** is set to **`undefined`**.\n"
"  - **`setAddress`** is cleared with an empty string."
msgstr ""
"- Utiliza la funci√≥n **`disconnect`**, posiblemente de una biblioteca externa, y maneja la operaci√≥n de forma asincr√≥nica con **`await`**.\n"
"- Despu√©s de la desconexi√≥n, se actualiza el estado del componente React:\n"
"   - **`setConnection`** est√° establecido en **`undefined`**.\n"
"   - **`setAccount`** est√° establecido en **`undefined`**.\n"
"   - **`setAddress`** se borra con una string vac√≠a."

#: src/ch02-09-01-counter-ui.md:96
msgid "### `EagerlyConnect`"
msgstr "### `EagerlyConnect`"

#: src/ch02-09-01-counter-ui.md:98
msgid "The `EagerlyConnect` mechanism leverages React's `useEffect` hook to initiate a connection to Starknet upon the component's mounting or initial rendering."
msgstr "El mecanismo `EagerlyConnect` aprovecha el hook `useEffect` de React para iniciar una conexi√≥n a Starknet durante el montaje o renderizado inicial del componente."

#: src/ch02-09-01-counter-ui.md:100
msgid ""
"```javascript\n"
"useEffect(() => {\n"
"  const connectToStarknet = async () => {\n"
"    const connection = await connect({\n"
"      modalMode: \"neverAsk\",\n"
"      webWalletUrl: \"https://web.argent.xyz\",\n"
"    });\n"
"\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"  };\n"
"  connectToStarknet();\n"
"}, []);\n"
"```"
msgstr ""
"```javascript\n"
"useEffect(() => {\n"
"  const connectToStarknet = async () => {\n"
"    const connection = await connect({\n"
"      modalMode: \"neverAsk\",\n"
"      webWalletUrl: \"https://web.argent.xyz\",\n"
"    });\n"
"\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"  };\n"
"  connectToStarknet();\n"
"}, []);\n"
"```"

#: src/ch02-09-01-counter-ui.md:118
msgid ""
"- Inside the **`useEffect`**, the **`connectToStarknet`** function is defined, aiming to establish an asynchronous connection using the **`connect`** function. Parameters like **`modalMode`** and "
"**`webWalletUrl`** are passed to guide the connection process.\n"
"- If successful in connecting (**`connection && connection.isConnected`**), the state updates with details of the connection, the account, and the selected address using **`setConnection`**, "
"**`setAccount`**, and **`setAddress`**.\n"
"- The **`connectToStarknet`** function is executed immediately after its definition."
msgstr ""
"- Dentro del **`useEffect`**, se define la funci√≥n **`connectToStarknet`**, cuyo objetivo es establecer una conexi√≥n asincr√≥nica usando la funci√≥n **`connect`**. Par√°metros como **`modalMode`** y "
"**`webWalletUrl`** se pasan para guiar el proceso de conexi√≥n.\n"
"- Si se logra conectar (**`connection && connection.isConnected`**), el estado se actualiza con detalles de la conexi√≥n, la cuenta y la direcci√≥n seleccionada usando **`setConnection`**, "
"**`setAccount`* * y **`setAddress`**.\n"
"- La funci√≥n **`connectToStarknet`** se ejecuta inmediatamente despu√©s de su definici√≥n."

#: src/ch02-09-01-counter-ui.md:122
msgid "## Important Refresher on Smart Contract Interactions"
msgstr "## Actualizaci√≥n Importante Sobre Interacciones de Smart Contract"

#: src/ch02-09-01-counter-ui.md:124
msgid ""
"For effective interaction with a smart contract on the network, it's crucial to understand key components after establishing a connection. Among these are the `contract address`, `ABI`, `Signer`, "
"and `Provider`."
msgstr ""
"Para una interacci√≥n efectiva con un smart contract en la red, es crucial comprender los componentes clave despu√©s de establecer una conexi√≥n. Entre ellos se encuentran la `contract address`, "
"`ABI`, `Signer`, y `Provider`."

#: src/ch02-09-01-counter-ui.md:126
msgid "### ABI (Application Binary Interface)"
msgstr "### ABI (Interfaz Binaria de Aplicaciones)"

#: src/ch02-09-01-counter-ui.md:128
msgid "ABI is a standardized bridge between two binary program modules. It is essential for:"
msgstr "ABI es un puente estandarizado entre dos m√≥dulos de programa binario. Es esencial para:"

#: src/ch02-09-01-counter-ui.md:130
msgid ""
"- Interacting with smart contracts on the blockchain.\n"
"- Specifying the structure of functions, events, and variables for software applications.\n"
"- Enabling smooth communication with the smart contract, detailing function signatures, input/output types, event formats, and variable types.\n"
"- Facilitating invocation of functions and data retrieval from the contract."
msgstr ""
"- Interactuar con smart contracts en blockchain.\n"
"- Especificar la estructura de funciones, eventos y variables para aplicaciones de software.\n"
"- Permitir una comunicaci√≥n fluida con el contrato inteligente, detallando firmas de funciones, tipos de input/output, formatos de eventos y tipos de variables.\n"
"- Facilitar la invocaci√≥n de funciones y la recuperaci√≥n de datos del contrato."

#: src/ch02-09-01-counter-ui.md:135
msgid "### Signer"
msgstr "### Signer"

#: src/ch02-09-01-counter-ui.md:137
msgid "The Signer plays a pivotal role in:"
msgstr "EL Signer juega un papel fundamental en:"

#: src/ch02-09-01-counter-ui.md:139
msgid ""
"- Signing transactions.\n"
"- Authorizing actions on the blockchain.\n"
"- Bearing the fees associated with blockchain operations."
msgstr ""
"- Firma de transacciones.\n"
"- Autorizar acciones sobre la blockchain.\n"
"- Correr con las tarifas asociadas a las operaciones blockchain."

#: src/ch02-09-01-counter-ui.md:143
msgid "Signers are especially linked to write operations that change the state of the blockchain. These operations need cryptographic signing for security and validity."
msgstr ""
"Los signers est√°n especialmente vinculados a operaciones de escritura que cambian el estado de la cadena de bloques. Estas operaciones necesitan firma criptogr√°fica por motivos de seguridad y "
"validez."

#: src/ch02-09-01-counter-ui.md:147
msgid "The Provider acts as the medium for:"
msgstr "El Proveedor act√∫a como medio para:"

#: src/ch02-09-01-counter-ui.md:149
msgid ""
"- Communication with the blockchain.\n"
"- Creating transactions.\n"
"- Fetching data from the blockchain."
msgstr ""
"- Comunicaci√≥n con la blockchain.\n"
"- Creaci√≥n de transacciones.\n"
"- Obtenci√≥n de datos de la blockchain."

#: src/ch02-09-01-counter-ui.md:153
msgid "To initiate a write transaction, the connected account (signer) must be provided. This signer then signs the transaction, bearing the necessary fee for execution."
msgstr "Para iniciar una transacci√≥n de escritura, debe facilitarse la cuenta conectada (signer). A continuaci√≥n, este signer firma la transacci√≥n, soportando la tasa necesaria para su ejecuci√≥n."

#: src/ch02-09-01-counter-ui.md:155
msgid "## Invoking the `increment` Function"
msgstr "## Invocando la funci√≥n `increment`"

#: src/ch02-09-01-counter-ui.md:157
msgid ""
"```javascript\n"
"const increaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.increment();\n"
"    alert(\"You successfully incremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```javascript\n"
"const increaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.increment();\n"
"    alert(\"You successfully incremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-09-01-counter-ui.md:169
msgid "The **`increaseCounter`** function is crafted to interact with a smart contract and increment a specific counter. Here's a step-by-step breakdown:"
msgstr "La funci√≥n **`increaseCounter`** est√° dise√±ada para interactuar con un smart contract e incrementar un contador espec√≠fico. He aqu√≠ un desglose paso a paso:"

#: src/ch02-09-01-counter-ui.md:171
msgid ""
"1. Establishes a new contract instance using the provided contract's ABI, its address, and the connected account. The account is essential since this write transaction alters the contract's state.\n"
"2. Executes the contract's **`increment`** method. The **`await`** keyword ensures the program pauses until this action completes.\n"
"3. On successful execution, the user receives a confirmation alert indicating the counter's increment.\n"
"4. In case of any errors during the process, an alert displays the corresponding error message to the user."
msgstr ""
"1. Establece una nueva instancia de contrato utilizando el ABI del contrato proporcionado, su direcci√≥n y la cuenta conectada. La cuenta es esencial ya que esta transacci√≥n de escritura altera el "
"estado del contrato.\n"
"2. 2. Ejecuta el m√©todo **`increment`** del contrato. La palabra clave **`await`** asegura que el programa haga una pausa hasta que esta acci√≥n se complete.\n"
"3. En caso de ejecuci√≥n exitosa, el usuario recibe una alerta de confirmaci√≥n indicando el incremento del contador.\n"
"4. En caso de que se produzca alg√∫n error durante el proceso, una alerta muestra al usuario el mensaje de error correspondiente."

#: src/ch02-09-01-counter-ui.md:176
msgid "## Invoking the `decrement` Function"
msgstr "## Invocando la Funci√≥n `decrement`"

#: src/ch02-09-01-counter-ui.md:178
msgid ""
"```javascript\n"
"const decreaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.decrement();\n"
"    alert(\"You successfully decremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```javascript\n"
"const decreaseCounter = async () => {\n"
"  try {\n"
"    const contract = new Contract(contractAbi, contractAddress, account);\n"
"    await contract.decrement();\n"
"    alert(\"You successfully decremented the counter!\");\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-09-01-counter-ui.md:190
msgid "The **`decreaseCounter`** function is designed to interact with a smart contract and decrement a specific counter. Here's a succinct breakdown of its operation:"
msgstr "La funci√≥n **`decreaseCounter`** est√° dise√±ada para interactuar con un smart contract y disminuir un contador espec√≠fico. He aqu√≠ un desglose sucinto de su funcionamiento:"

#: src/ch02-09-01-counter-ui.md:192
msgid ""
"1. Creates a new contract instance by utilizing the provided contract's ABI, its address, and the connected account. The account is vital as this write transaction modifies the contract's state.\n"
"2. Initiates the contract's **`decrement`** method. With the use of the **`await`** keyword, the program ensures it waits for the decrement action to finalize.\n"
"3. Upon successful execution, the user is notified with an alert indicating the counter's decrement.\n"
"4. Should any errors arise during the interaction, the user is promptly alerted with the pertinent error message."
msgstr ""
"1. Crea una nueva instancia de contrato utilizando el ABI del contrato proporcionado, su direcci√≥n y la cuenta conectada. La cuenta es vital ya que esta transacci√≥n de escritura modifica el estado "
"del contrato.\n"
"2. Inicia el m√©todo **`decrement`** del contrato. Con el uso de la palabra clave **`await`**, el programa se asegura de esperar a que la acci√≥n de decremento finalice.\n"
"3. Al ejecutarse con √©xito, se notifica al usuario con una alerta que indica la disminuci√≥n del contador.\n"
"4. Si se produce alg√∫n error durante la interacci√≥n, se avisa al usuario con el mensaje de error correspondiente."

#: src/ch02-09-01-counter-ui.md:197
msgid "## Fetching the Current Count with `get_current_count` Function"
msgstr "## Obtenci√≥n del Recuento Actual con la Funci√≥n `get_current_count`"

#: src/ch02-09-01-counter-ui.md:199
msgid ""
"```javascript\n"
"const getCounter = async () => {\n"
"  const provider = new Provider({\n"
"    sequencer: { network: constants.NetworkName.SN_MAIN },\n"
"  });\n"
"  try {\n"
"    const mycontract = new Contract(contractAbi, contractAddress, provider);\n"
"    const num = await mycontract.get_current_count();\n"
"    setRetrievedValue(num.toString());\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```javascript\n"
"const getCounter = async () => {\n"
"  const provider = new Provider({\n"
"    sequencer: { network: constants.NetworkName.SN_MAIN },\n"
"  });\n"
"  try {\n"
"    const mycontract = new Contract(contractAbi, contractAddress, provider);\n"
"    const num = await mycontract.get_current_count();\n"
"    setRetrievedValue(num.toString());\n"
"  } catch (err) {\n"
"    alert(err.message);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-09-01-counter-ui.md:214
msgid "The **`getCounter`** function is designed to retrieve the current count from a smart contract. Here's a breakdown of its operation:"
msgstr "La funci√≥n **`getCounter`** est√° dise√±ada para recuperar el recuento actual de un smart contract. Aqu√≠ tienes un desglose de su funcionamiento:"

#: src/ch02-09-01-counter-ui.md:216
msgid ""
"1. Establishes a provider instance, specifying the sequencer network ‚Äì in this instance, it's set to the **`mainnet`** through **`constants.NetworkName.SN_MAIN`**.\n"
"2. With this provider, it then initiates a contract instance using the provided contract's ABI, its address, and the aforementioned provider.\n"
"3. The function then invokes the **`get_current_count`** method of the contract to fetch the current count. This is an asynchronous action, and the program waits for its completion with the "
"**`await`** keyword.\n"
"4. Once successfully retrieved, the count, which is presumably a number, is converted to a string and stored using the **`setRetrievedValue`** function.\n"
"5. In the event of any errors during the process, an alert provides the user with the relevant error message."
msgstr ""
"1. Establece una instancia de proveedor, especificando la red del secuenciador - en este caso, se establece en **`mainnet`** a trav√©s de **`constants.NetworkName.SN_MAIN`**.\n"
"2. Con este proveedor, a continuaci√≥n, inicia una instancia de contrato utilizando el ABI del contrato proporcionado, su direcci√≥n, y el proveedor antes mencionado.\n"
"3. A continuaci√≥n, la funci√≥n invoca el m√©todo **`get_current_count`** del contrato para obtener el recuento actual. Esta es una acci√≥n as√≠ncrona, y el programa espera a que se complete con la "
"palabra clave **`await`**.\n"
"4. Una vez recuperado con √©xito, el recuento, que presumiblemente es un n√∫mero, se convierte en una cadena y se almacena utilizando la funci√≥n **`setRetrievedValue`**.\n"
"5. En caso de que se produzca alg√∫n error durante el proceso, una alerta proporciona al usuario el mensaje de error correspondiente."

#: src/ch02-09-01-counter-ui.md:222
msgid ""
"It's essential to emphasize that while performing read operations, like fetching data from a blockchain network, the function uses the provider. Unlike write operations, which typically require a "
"signer (or an account) for transaction signing, read operations don't mandate such authentication. Thus, in this function, only the provider is specified, and not the signer."
msgstr ""
"Es esencial destacar que al realizar operaciones de lectura, como la obtenci√≥n de datos de una red blockchain, la funci√≥n utiliza el proveedor. A diferencia de las operaciones de escritura, que "
"normalmente requieren un firmante (o una cuenta) para la firma de la transacci√≥n, las operaciones de lectura no requieren dicha autenticaci√≥n. Por lo tanto, en esta funci√≥n, s√≥lo se especifica el "
"proveedor, y no el firmante."

#: src/ch02-09-01-counter-ui.md:224
msgid "## Wrapping It Up: Integrating a Frontend with a Counter Smart Contract"
msgstr "## Conclusi√≥n: Integraci√≥n de un Frontend con un Smart Contract de Contador"

#: src/ch02-09-01-counter-ui.md:226
msgid "In this tutorial, we review the process of integrating a basic counter smart contract with a frontend application."
msgstr "En este tutorial, revisamos el proceso de integraci√≥n de un contrato inteligente de smart contract con una aplicaci√≥n frontend."

#: src/ch02-09-01-counter-ui.md:228
msgid "Here's a quick recap:"
msgstr "He aqu√≠ un breve resumen:"

#: src/ch02-09-01-counter-ui.md:230
msgid ""
"1. **Establishing Connection**: With the **`connectWallet`** function, we made seamless connections to the blockchain, paving the way for interactions with our smart contract.\n"
"2. **Terminating Connection**: The **`disconnectWallet`** function ensures that users can safely terminate their active connections to the blockchain, maintaining security and control.\n"
"3. **Interacting with the Smart Contract**: Using the **`increaseCounter`**, **`decreaseCounter`**, and **`getCounter`** functions, we explored how to:\n"
"   - Initiate transactions\n"
"   - Adjust the counter value (increment or decrement)\n"
"   - Fetch data from the blockchain"
msgstr ""
"1. **Establecimiento de la Conexi√≥n**: Con la funci√≥n **`connectWallet`**, establecimos conexiones fluidas con la blockchain, allanando el camino para las interacciones con nuestro smart contract.\n"
"2. **Terminar la Conexi√≥n**: La funci√≥n **`disconnectWallet`** garantiza que los usuarios puedan finalizar de forma segura sus conexiones activas a la blockchain, manteniendo la seguridad y el "
"control.\n"
"3. **Interactuar con el Smart Contract**: Usando las funciones **`increaseCounter`**, **`decreaseCounter`**, y **`getCounter`**, exploramos c√≥mo:\n"
"   - Iniciar transacciones\n"
"   - Ajustar el valor del contador (incrementarlo o disminuirlo)\n"
"   - Obtener datos de la blockchain"

#: src/ch02-09-02-erc20-ui.md:1 src/ch02-10-01-erc20-ui.md:1
msgid "# ERC-20 UI"
msgstr "# ERC-20 UI"

#: src/ch02-09-02-erc20-ui.md:3
msgid "This guide offers steps to build an ERC20 smart contract using Cairo and to incorporate it within a React web application with StarknetJS. Readers will:"
msgstr "Esta gu√≠a ofrece pasos para construir un contrato inteligente ERC20 usando Cairo e incorporarlo dentro de una aplicaci√≥n web React con StarknetJS. Los lectores podr√°n:"

#: src/ch02-09-02-erc20-ui.md:5 src/ch02-10-01-erc20-ui.md:5
msgid ""
"- Understand how to implement the ERC20 interface\n"
"- Learn how to deploy contracts on the Starknet network\n"
"- Discover ways to engage with contracts within a React application\n"
"- Design their own ERC20 token and initiate it on Starknet"
msgstr ""
"- Comprender c√≥mo implementar la interfaz ERC20.\n"
"- Aprenda a implementar contratos en la red Starknet\n"
"- Descubra formas de interactuar con contratos dentro de una aplicaci√≥n React\n"
"- Dise√±ar su propio token ERC20 e iniciarlo en Starknet"

#: src/ch02-09-02-erc20-ui.md:10
msgid "A prerequisite for this guide is a foundational understanding of both the Cairo programming language and StarknetJS. Additionally, ensure Node.js and NPM are installed on the system."
msgstr ""
"Un requisito previo para esta gu√≠a es una comprensi√≥n b√°sica tanto del lenguaje de programaci√≥n Cairo como de StarknetJS. Adem√°s, aseg√∫rese de que Node.js y NPM est√°n instalados en el sistema."

#: src/ch02-09-02-erc20-ui.md:12 src/ch02-10-01-erc20-ui.md:12
msgid "The example will walk through creating an ERC20 token named MKT and crafting a web3 interface for functionalities such as balance verification and token transfer."
msgstr "El ejemplo explicar√° la creaci√≥n de un token ERC20 llamado MKT y la creaci√≥n de una interfaz web3 para funcionalidades como la verificaci√≥n de saldo y la transferencia de tokens."

#: src/ch02-09-02-erc20-ui.md:14
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:16 src/ch02-10-01-erc20-ui.md:16
msgid "Throughout this guide, the following tools and libraries will be utilized:"
msgstr "A lo largo de esta gu√≠a, se utilizar√°n las siguientes herramientas y bibliotecas:"

#: src/ch02-09-02-erc20-ui.md:18
msgid ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- StarknetJS v5.19.5\n"
"- get-starknet v3.0.1\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.5.5\n"
"- Visual Studio Code\n"
"- Vercel"
msgstr ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- StarknetJS v5.19.5\n"
"- get-starknet v3.0.1\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.5.5\n"
"- Visual Studio Code\n"
"- Vercel"

#: src/ch02-09-02-erc20-ui.md:28 src/ch02-10-01-erc20-ui.md:27
msgid "## Initiating a New Starknet Project"
msgstr "## Iniciando un Nuevo Proyecto en Starknet"

#: src/ch02-09-02-erc20-ui.md:30 src/ch02-10-01-erc20-ui.md:29
msgid "Begin by establishing a new Starknet project named \"erc20\" using Scarb:"
msgstr "Comience estableciendo un nuevo proyecto Starknet llamado \"erc20\" usando Scarb:"

#: src/ch02-09-02-erc20-ui.md:32 src/ch02-10-01-erc20-ui.md:31
msgid ""
"```bash\n"
"mkdir erc20\n"
"cd erc20\n"
"scarb init --name erc20\n"
"```"
msgstr ""
"```bash\n"
"mkdir erc20\n"
"cd erc20\n"
"scarb init --name erc20\n"
"```"

#: src/ch02-09-02-erc20-ui.md:38 src/ch02-10-01-erc20-ui.md:37
msgid "Subsequently, update the Scarb.toml to include the essential OpenZeppelin libraries. Post edits, the Scarb.toml should appear as:"
msgstr "Posteriormente, actualice Scarb.toml para incluir las bibliotecas esenciales de OpenZeppelin. Despu√©s de las ediciones, Scarb.toml deber√≠a aparecer como:"

#: src/ch02-09-02-erc20-ui.md:40
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-09-02-erc20-ui.md:54 src/ch02-10-01-erc20-ui.md:53
msgid "## Implementing the ERC20 Token"
msgstr "## Implementaci√≥n del Token ERC20"

#: src/ch02-09-02-erc20-ui.md:56 src/ch02-10-01-erc20-ui.md:55
msgid "Begin by creating a new file named `src/erc20.cairo`. In this file, the ERC20 token named MKT, along with its associated functions, will be defined:"
msgstr "Comience creando un nuevo archivo llamado `src/erc20.cairo`. En este archivo se definir√° el token ERC20 denominado MKT, junto con sus funciones asociadas:"

#: src/ch02-09-02-erc20-ui.md:58 src/ch02-10-01-erc20-ui.md:57
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    #[generate_trait]\n"
"    impl Ierc20Impl of Ierc20 {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    #[generate_trait]\n"
"    impl Ierc20Impl of Ierc20 {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-09-02-erc20-ui.md:97
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:99 src/ch02-10-01-erc20-ui.md:98
msgid "Now edit `src/lib.cairo` and replace the content with:"
msgstr "Ahora edita `src/lib.cairo` y sustituye el contenido por:"

#: src/ch02-09-02-erc20-ui.md:101 src/ch02-10-01-erc20-ui.md:100
msgid ""
"```rust\n"
"mod erc20;\n"
"```"
msgstr ""
"```rust\n"
"mod erc20;\n"
"```"

#: src/ch02-09-02-erc20-ui.md:105 src/ch02-10-01-erc20-ui.md:104
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_lib_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_lib_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:107 src/ch02-10-01-erc20-ui.md:106
msgid "Upon completing your contract, proceed to compile it using Scarb:"
msgstr "Al completar tu contrato, procede a compilarlo usando Scarb:"

#: src/ch02-09-02-erc20-ui.md:113
msgid "Subsequent to the compilation, declare the smart contract on the Starknet testnet (using your own account and keystore):"
msgstr "Tras la compilaci√≥n, declara el smart contract en la red de pruebas de Starknet (utilizando tu propia cuenta y keystore):"

#: src/ch02-09-02-erc20-ui.md:115 src/ch02-10-01-erc20-ui.md:114
msgid ""
"```bash\n"
"starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 --watch\n"
"```"
msgstr ""
"```bash\n"
"starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 --watch\n"
"```"

#: src/ch02-09-02-erc20-ui.md:119 src/ch02-09-02-erc20-ui.md:146 src/ch02-10-01-erc20-ui.md:118 src/ch02-10-01-erc20-ui.md:145
msgid "The output should appear similar to:"
msgstr "El resultado deber√≠a ser similar a:"

#: src/ch02-09-02-erc20-ui.md:121 src/ch02-10-01-erc20-ui.md:120
msgid ""
"```bash\n"
"Enter keystore password:\n"
"Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"... [shortened for brevity]\n"
"Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"... [shortened for brevity]\n"
"Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"

#: src/ch02-09-02-erc20-ui.md:128 src/ch02-10-01-erc20-ui.md:127
msgid "In cases where no modifications have been made to the provided contract, a notification will indicate that the contract has previously been declared on Starknet:"
msgstr "En los casos en que no se hayan realizado modificaciones al contrato proporcionado, una notificaci√≥n indicar√° que el contrato ha sido declarado previamente en Starknet:"

#: src/ch02-09-02-erc20-ui.md:130 src/ch02-10-01-erc20-ui.md:129
msgid ""
"```bash\n"
"Enter keystore password:\n"
"Not declaring class as it's already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"Not declaring class as it's already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"

#: src/ch02-09-02-erc20-ui.md:135 src/ch02-10-01-erc20-ui.md:134
msgid "## Deploying the ERC20 Contract"
msgstr "## Implementaci√≥n del Contrato ERC20"

#: src/ch02-09-02-erc20-ui.md:137 src/ch02-10-01-erc20-ui.md:136
msgid "Proceed to deploy the MKT Token using Starkli. Provide these arguments for successful deployment:"
msgstr "Proceda a implementar el token MKT usando Starkli. Proporcione estos argumentos para una implementaci√≥n exitosa:"

#: src/ch02-09-02-erc20-ui.md:139
msgid ""
"- `Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 \\* 10^18 or 0xd3c21bcecceda1000000. Due to the "
"contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively.\n"
"- `Receiver address`: Use a preferred address who wiil be the initial recipient of 1,000,000 MKT. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""
"- `Initial mint`: Acu√±a 1.000.000 de tokens. Dado que el token MKT consta de 18 decimales (un est√°ndar de OpenZeppelin), la entrada requerida es 1.000.000 * 10^18 o 0xd3c21bcecceda1000000. Debido a "
"la expectativa del contrato de un valor perfecto de u256, proporcione valores bajos y altos: 0xd3c21bcecceda1000000 y 0 respectivamente.\n"
"- `Receiver address`: Utilice una direcci√≥n preferida. En este ejemplo: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#: src/ch02-09-02-erc20-ui.md:142 src/ch02-10-01-erc20-ui.md:141
msgid ""
"```bash\n"
"starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 "
"0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc\n"
"```"
msgstr ""
"```bash\n"
"starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 "
"0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc\n"
"```"

#: src/ch02-09-02-erc20-ui.md:148 src/ch02-10-01-erc20-ui.md:147
msgid ""
"```bash\n"
"Enter keystore password:\n"
"... [shortened for brevity]\n"
"Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\n"
"```"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"... [shortened for brevity]\n"
"Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\n"
"```"

#: src/ch02-09-02-erc20-ui.md:154 src/ch02-10-01-erc20-ui.md:153
msgid "NOTE: The deployed address received will differ for every user. Retain this address, as it will replace instances in subsequent TypeScript files to match the specific contract address."
msgstr ""
"NOTA: La direcci√≥n implementada recibida ser√° diferente para cada usuario. Conserve esta direcci√≥n, ya que reemplazar√° las instancias en archivos TypeScript posteriores para que coincidan con la "
"direcci√≥n del contrato espec√≠fica."

#: src/ch02-09-02-erc20-ui.md:156 src/ch02-10-01-erc20-ui.md:155
msgid "Well done! The Cairo ERC20 smart contract has been deployed successfully on Starknet."
msgstr "¬°Bien hecho! El smart contract en Cairo de ERC20 se implement√≥ con √©xito en Starknet."

#: src/ch02-09-02-erc20-ui.md:158
msgid "## Setting Up a New React Project"
msgstr "## Configurando un Nuevo Proyecto de React"

#: src/ch02-09-02-erc20-ui.md:160
msgid ""
"With the contract in place, initiate the development of the web application. Begin by\n"
"setting up our react project. To do this, Nextjs framework provides the `create-next-app` script that streamlines the setup of a Nextjs application:"
msgstr ""
"Con el contrato en vigor, inicie el desarrollo de la aplicaci√≥n web. Empezaremos\n"
"nuestro proyecto react. Para ello, el framework Nextjs proporciona el script `create-next-app` que agiliza la configuraci√≥n de una aplicaci√≥n Nextjs:"

#: src/ch02-09-02-erc20-ui.md:163
msgid ""
"```bash\n"
"npx create-next-app@latest erc20_web --use-npm\n"
"‚úî Would you like to use TypeScript? ‚Ä¶ Yes\n"
"‚úî Would you like to use ESLint? ‚Ä¶ Yes\n"
"‚úî Would you like to use Tailwind CSS? ‚Ä¶ Yes\n"
"‚úî Would you like to use `src/` directory? ‚Ä¶ Yes\n"
"‚úî Would you like to use App Router? (recommended) ‚Ä¶ Yes\n"
"‚úî Would you like to customize the default import alias (@/*)? ‚Ä¶ No\n"
"```"
msgstr ""
"```bash\n"
"npx create-next-app@latest erc20_web --use-npm\n"
"‚úî Would you like to use TypeScript? ‚Ä¶ Yes\n"
"‚úî Would you like to use ESLint? ‚Ä¶ Yes\n"
"‚úî Would you like to use Tailwind CSS? ‚Ä¶ Yes\n"
"‚úî Would you like to use `src/` directory? ‚Ä¶ Yes\n"
"‚úî Would you like to use App Router? (recommended) ‚Ä¶ Yes\n"
"‚úî Would you like to customize the default import alias (@/*)? ‚Ä¶ No\n"
"```"

#: src/ch02-09-02-erc20-ui.md:173
msgid "Then, you should see something like this:"
msgstr "Entonces, deber√≠as ver algo como esto:"

#: src/ch02-09-02-erc20-ui.md:175
msgid ""
"```bash\n"
"Creating a new Next.js app in /home/kali/cairo/erc20_web.\n"
"Using npm.\n"
"Initializing project with template: app-tw\n"
"Installing dependencies:\n"
"- react\n"
"- react-dom\n"
"- next\n"
"\n"
"... [shortened for brevity]\n"
"\n"
"Initialized a git repository.\n"
"Success! Created erc20_web at /home/kali/cairo/erc20_web\n"
"```"
msgstr ""
"```bash\n"
"Creating a new Next.js app in /home/kali/cairo/erc20_web.\n"
"Using npm.\n"
"Initializing project with template: app-tw\n"
"Installing dependencies:\n"
"- react\n"
"- react-dom\n"
"- next\n"
"\n"
"... [shortened for brevity]\n"
"\n"
"Initialized a git repository.\n"
"Success! Created erc20_web at /home/kali/cairo/erc20_web\n"
"```"

#: src/ch02-09-02-erc20-ui.md:190
msgid "## Installing the Starknet.js Library"
msgstr "## Instalaci√≥n de la Librer√≠a Starknet.js"

#: src/ch02-09-02-erc20-ui.md:192
msgid "Now, let's install the starknet.js and recommended get-starknet (manage wallet connections) libraries:"
msgstr "Ahora, vamos a instalar las bibliotecas starknet.js y get-starknet recomendada (gestionar conexiones de wallet):"

#: src/ch02-09-02-erc20-ui.md:194
msgid ""
"```bash\n"
"cd erc20_web\n"
"npm install get-starknet\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web\n"
"npm install get-starknet\n"
"```"

#: src/ch02-09-02-erc20-ui.md:199 src/ch02-09-02-erc20-ui.md:213
msgid "You should see something like this:"
msgstr "Deber√≠as ver algo como esto:"

#: src/ch02-09-02-erc20-ui.md:201
msgid ""
"```bash\n"
"added 3 packages, changed 1 package, and audited 1549 packages in 7s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"
msgstr ""
"```bash\n"
"added 3 packages, changed 1 package, and audited 1549 packages in 7s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"

#: src/ch02-09-02-erc20-ui.md:207
msgid "Install starknetJS:"
msgstr "Instala starknetJS:"

#: src/ch02-09-02-erc20-ui.md:209
msgid ""
"```bash\n"
"npm install starknet\n"
"```"
msgstr ""
"```bash\n"
"npm install starknet\n"
"```"

#: src/ch02-09-02-erc20-ui.md:215
msgid ""
"```bash\n"
"added 18 packages, and audited 1546 packages in 6s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"
msgstr ""
"```bash\n"
"added 18 packages, and audited 1546 packages in 6s\n"
"... [shortened for brevity]\n"
"Run `npm audit` for details.\n"
"```"

#: src/ch02-09-02-erc20-ui.md:221
msgid "Post-installation, confirm the version of the Starknet.js library:"
msgstr "Tras la instalaci√≥n, confirma la versi√≥n de la biblioteca Starknet.js:"

#: src/ch02-09-02-erc20-ui.md:223
msgid ""
"```bash\n"
"npm list starknet\n"
"\n"
"npm list get-starknet\n"
"```"
msgstr ""
"```bash\n"
"npm list starknet\n"
"\n"
"npm list get-starknet\n"
"```"

#: src/ch02-09-02-erc20-ui.md:229
msgid "The output should display the installed version, such as `starknet@5.19.5` and `get-starknet@3.0.1`."
msgstr "La salida deber√≠a mostrar la versi√≥n instalada, como `starknet@5.19.5` y `get-starknet@3.0.1`."

#: src/ch02-09-02-erc20-ui.md:231
msgid "## Building our Project"
msgstr "## Construir nuestro Proyecto"

#: src/ch02-09-02-erc20-ui.md:233
msgid "Once set up, make modifications to `erc20_web/src/app/layout.tsx` by replacing its content with the following code:"
msgstr "Una vez configurado, realice modificaciones en `erc20_web/src/app/layout.tsx` sustituyendo su contenido por el siguiente c√≥digo:"

#: src/ch02-09-02-erc20-ui.md:235
msgid ""
"```typescript\n"
"import type { Metadata } from 'next'\n"
"\n"
"export const metadata: Metadata = {\n"
"  title: 'Create Next App',\n"
"  description: 'Generated by create next app',\n"
"}\n"
"\n"
"export default function RootLayout({\n"
"  children,\n"
"}: {\n"
"  children: React.ReactNode\n"
"}) {\n"
"  return (\n"
"    <html lang=\"en\">\n"
"      <body>{children}</body>\n"
"    </html>\n"
"  )\n"
"}\n"
"\n"
"```"
msgstr ""
"```typescript\n"
"import type { Metadata } from 'next'\n"
"\n"
"export const metadata: Metadata = {\n"
"  title: 'Create Next App',\n"
"  description: 'Generated by create next app',\n"
"}\n"
"\n"
"export default function RootLayout({\n"
"  children,\n"
"}: {\n"
"  children: React.ReactNode\n"
"}) {\n"
"  return (\n"
"    <html lang=\"en\">\n"
"      <body>{children}</body>\n"
"    </html>\n"
"  )\n"
"}\n"
"\n"
"```"

#: src/ch02-09-02-erc20-ui.md:257
msgid "Now, edit `erc20_web/src/app/page.tsx` and replace its content with the following code:"
msgstr "Ahora, edita `erc20_web/src/app/page.tsx` y sustituye su contenido por el siguiente c√≥digo:"

#: src/ch02-09-02-erc20-ui.md:259
msgid ""
"```typescript\n"
"import Head from \"next/head\";\n"
"import App from \"../components/App\";\n"
"\n"
"export default function Home() {\n"
"\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Homepage</title>\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"      <p>A basic web3 example with StarknetJS</p>\n"
"          <App />\n"
"      </main>\n"
"    </>\n"
"  );\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import Head from \"next/head\";\n"
"import App from \"../components/App\";\n"
"\n"
"export default function Home() {\n"
"\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Homepage</title>\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"      <p>A basic web3 example with StarknetJS</p>\n"
"          <App />\n"
"      </main>\n"
"    </>\n"
"  );\n"
"}\n"
"```"

#: src/ch02-09-02-erc20-ui.md:280 src/ch02-10-01-erc20-ui.md:234
msgid "## Enhancing Your React Application with Additional Features"
msgstr "## Mejora de su Aplicaci√≥n React con Funciones Adicionales"

#: src/ch02-09-02-erc20-ui.md:282
msgid "To enhance the app's functionality, create one component (`erc20_web/src/components/App.tsx`) for balance and transfer with the following code."
msgstr "Para mejorar la funcionalidad de la aplicaci√≥n, cree un componente (`erc20_web/src/components/App.tsx`) para el saldo y la transferencia con el siguiente c√≥digo."

#: src/ch02-09-02-erc20-ui.md:284
msgid ""
"```typescript\n"
"'use client';\n"
"import { useState, useMemo } from \"react\"\n"
"import { connect, disconnect } from \"get-starknet\"\n"
"import { Contract, Provider, SequencerProvider, constants } from \"starknet\"\n"
"\n"
"const contractAddress = \"0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\"\n"
"\n"
"function App() {\n"
"  const [provider, setProvider] = useState({} as Provider)\n"
"  const [address, setAddress] = useState('')\n"
"  const [currentBlockHash, setCurrentBlockHash] = useState('')\n"
"  const [balance, setBalance] = useState('')\n"
"  const [isConnected, setIsConnected] = useState(false)\n"
"  const [recipient, setRecipient] = useState('0x');\n"
"  const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"  const disconnectWallet = async () => {\n"
"    try {\n"
"      await disconnect({ clearLastWallet: true })\n"
"      setProvider({} as Provider)\n"
"      setAddress('')\n"
"      setIsConnected(false)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const connectWallet = async () => {\n"
"    try {\n"
"      const starknet = await connect()\n"
"      if (!starknet) throw new Error(\"Failed to connect to wallet.\")\n"
"      await starknet.enable({ starknetVersion: \"v5\" })\n"
"      setProvider(starknet.account)\n"
"      setAddress(starknet.selectedAddress || '')\n"
"      setIsConnected(true)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const checkBalance = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      const data = await contract.balance_of(address)\n"
"      setBalance(data.toString())\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const transfer = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      await contract.transfer(recipient, amount)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const current_block_hash = async () => {\n"
"    try {\n"
"      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });\n"
"\n"
"      const block = await provider1.getBlock(\"latest\"); // <- Get latest block\n"
"      setCurrentBlockHash(block.block_hash);\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  current_block_hash()\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!isConnected) return ''\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`\n"
"  }, [isConnected, address])\n"
"\n"
"  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"    setRecipient(event.target.value);\n"
"  };\n"
"\n"
"  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"      setAmount(event.target.value);\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Latest block hash: {currentBlockHash}</p>\n"
"      {isConnected ?\n"
"        <div>\n"
"          <span>Connected: {shortenedAddress}</span>\n"
"          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>\n"
"          <hr />\n"
"          <p>Balance.</p>\n"
"          <p>{balance}</p>\n"
"          <p><button onClick={() => checkBalance()}>Check Balance</button></p>\n"
"          <hr />\n"
"          <p>Transfer.</p>\n"
"          <p>Recipient:\n"
"              <input\n"
"              type=\"text\"\n"
"              value={recipient}\n"
"              onChange={handleRecipientChange}\n"
"              />\n"
"          </p>\n"
"          <p>Amount (default 1 MKT with 18 decimals):\n"
"            <input\n"
"            type=\"number\"\n"
"            value={amount}\n"
"            onChange={handleAmountChange}\n"
"            />\n"
"          </p>\n"
"          <p>\n"
"            <button onClick={() => transfer()}>Transfer</button>\n"
"          </p>\n"
"          <hr/>\n"
"        </div> :\n"
"        <div>\n"
"          <span>Choose a wallet:</span>\n"
"          <p>\n"
"            <button onClick={() => connectWallet()}>Connect a Wallet</button>\n"
"          </p>\n"
"        </div>\n"
"      }\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default App;\n"
"```"
msgstr ""
"```typescript\n"
"'use client';\n"
"import { useState, useMemo } from \"react\"\n"
"import { connect, disconnect } from \"get-starknet\"\n"
"import { Contract, Provider, SequencerProvider, constants } from \"starknet\"\n"
"\n"
"const contractAddress = \"0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\"\n"
"\n"
"function App() {\n"
"  const [provider, setProvider] = useState({} as Provider)\n"
"  const [address, setAddress] = useState('')\n"
"  const [currentBlockHash, setCurrentBlockHash] = useState('')\n"
"  const [balance, setBalance] = useState('')\n"
"  const [isConnected, setIsConnected] = useState(false)\n"
"  const [recipient, setRecipient] = useState('0x');\n"
"  const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"  const disconnectWallet = async () => {\n"
"    try {\n"
"      await disconnect({ clearLastWallet: true })\n"
"      setProvider({} as Provider)\n"
"      setAddress('')\n"
"      setIsConnected(false)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const connectWallet = async () => {\n"
"    try {\n"
"      const starknet = await connect()\n"
"      if (!starknet) throw new Error(\"Failed to connect to wallet.\")\n"
"      await starknet.enable({ starknetVersion: \"v5\" })\n"
"      setProvider(starknet.account)\n"
"      setAddress(starknet.selectedAddress || '')\n"
"      setIsConnected(true)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const checkBalance = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      const data = await contract.balance_of(address)\n"
"      setBalance(data.toString())\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const transfer = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      await contract.transfer(recipient, amount)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const current_block_hash = async () => {\n"
"    try {\n"
"      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });\n"
"\n"
"      const block = await provider1.getBlock(\"latest\"); // <- Get latest block\n"
"      setCurrentBlockHash(block.block_hash);\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  current_block_hash()\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!isConnected) return ''\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`\n"
"  }, [isConnected, address])\n"
"\n"
"  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"    setRecipient(event.target.value);\n"
"  };\n"
"\n"
"  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"      setAmount(event.target.value);\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Latest block hash: {currentBlockHash}</p>\n"
"      {isConnected ?\n"
"        <div>\n"
"          <span>Connected: {shortenedAddress}</span>\n"
"          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>\n"
"          <hr />\n"
"          <p>Balance.</p>\n"
"          <p>{balance}</p>\n"
"          <p><button onClick={() => checkBalance()}>Check Balance</button></p>\n"
"          <hr />\n"
"          <p>Transfer.</p>\n"
"          <p>Recipient:\n"
"              <input\n"
"              type=\"text\"\n"
"              value={recipient}\n"
"              onChange={handleRecipientChange}\n"
"              />\n"
"          </p>\n"
"          <p>Amount (default 1 MKT with 18 decimals):\n"
"            <input\n"
"            type=\"number\"\n"
"            value={amount}\n"
"            onChange={handleAmountChange}\n"
"            />\n"
"          </p>\n"
"          <p>\n"
"            <button onClick={() => transfer()}>Transfer</button>\n"
"          </p>\n"
"          <hr/>\n"
"        </div> :\n"
"        <div>\n"
"          <span>Choose a wallet:</span>\n"
"          <p>\n"
"            <button onClick={() => connectWallet()}>Connect a Wallet</button>\n"
"          </p>\n"
"        </div>\n"
"      }\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default App;\n"
"```"

#: src/ch02-09-02-erc20-ui.md:429
msgid "Finally, launch the web3 application:"
msgstr "Por √∫ltimo, inicie la aplicaci√≥n web3:"

#: src/ch02-09-02-erc20-ui.md:431 src/ch02-10-01-erc20-ui.md:227
msgid ""
"```bash\n"
"cd erc20_web/\n"
"npm run dev\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web/\n"
"npm run dev\n"
"```"

#: src/ch02-09-02-erc20-ui.md:436
msgid "Congratulations, you have your starknetjs web3 application. Now connect your wallet in goerli testnet, check your balance and transfer MKT tokens to your friends:"
msgstr "Enhorabuena, ya tienes tu aplicaci√≥n starknetjs web3. Ahora conecta tu wallet en goerli testnet, comprueba tu balance y transfiere tokens MKT a tus amigos:"

#: src/ch02-09-02-erc20-ui.md:438
msgid "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:440 src/ch02-10-01-erc20-ui.md:410
msgid "## Deploying Your Project Online"
msgstr "## Implementaci√≥n de su Proyecto Online"

#: src/ch02-09-02-erc20-ui.md:442 src/ch02-10-01-erc20-ui.md:412
msgid "To share your application with friends and allow them to check their balances and transfer tokens, publish your app online. Vercel offers a straightforward way to do this:"
msgstr "Para compartir su aplicaci√≥n con amigos y permitirles consultar sus saldos y transferir tokens, publique su aplicaci√≥n en l√≠nea. Vercel ofrece una forma sencilla de hacer esto:"

#: src/ch02-09-02-erc20-ui.md:444 src/ch02-10-01-erc20-ui.md:414
msgid "### Set Up Vercel"
msgstr "### Configurar Vercel"

#: src/ch02-09-02-erc20-ui.md:446 src/ch02-10-01-erc20-ui.md:416
msgid ""
"1. Register for an account at [Vercel Signup](https://vercel.com/signup).\n"
"2. Install Vercel in your web application folder (`erc20_web`):"
msgstr ""
"1. Reg√≠strese para obtener una cuenta en [Vercel Signup](https://vercel.com/signup).\n"
"2. Instale Vercel en la carpeta de su aplicaci√≥n web (`erc20_web`):"

#: src/ch02-09-02-erc20-ui.md:449
msgid ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"```"

#: src/ch02-09-02-erc20-ui.md:454 src/ch02-10-01-erc20-ui.md:425
msgid "3. Authenticate your Vercel account:"
msgstr "3. Autentique su cuenta Vercel:"

#: src/ch02-09-02-erc20-ui.md:456
msgid ""
"```bash\n"
"vercel login\n"
"Continue with Email (or select your preferred login method)\n"
"```"
msgstr ""
"```bash\n"
"vercel login\n"
"Continue with Email (or select your preferred login method)\n"
"```"

#: src/ch02-09-02-erc20-ui.md:461 src/ch02-10-01-erc20-ui.md:431
msgid "After entering your email, check your inbox and click on the \"Verify\" button."
msgstr "Despu√©s de ingresar su correo electr√≥nico, revise su bandeja de entrada y haga clic en el bot√≥n \"Verify\"."

#: src/ch02-09-02-erc20-ui.md:463
msgid ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login_js.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login_js.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:467 src/ch02-10-01-erc20-ui.md:437
msgid "On successful verification, you'll receive a confirmation in the console."
msgstr "Si la verificaci√≥n es exitosa, recibir√°s una confirmaci√≥n en la consola."

#: src/ch02-09-02-erc20-ui.md:469 src/ch02-10-01-erc20-ui.md:439
msgid "4. Link your project to Vercel:"
msgstr "4. Vincula tu proyecto a Vercel:"

#: src/ch02-09-02-erc20-ui.md:471
msgid ""
"```bash\n"
"vercel link\n"
"? Set up ‚Äú~/cairo/erc20_web‚Äù? [Y/n] y\n"
"? Which scope should contain your project? (just press enter)\n"
"? Link to existing project? [y/N] n\n"
"? What‚Äôs your project‚Äôs name? erc20-web\n"
"? In which directory is your code located? ./\n"
"? Want to modify these settings? [y/N] n\n"
"‚úÖ  Linked erc20-web (created .vercel)\n"
"```"
msgstr ""
"```bash\n"
"vercel link\n"
"? Set up ‚Äú~/cairo/erc20_web‚Äù? [Y/n] y\n"
"? Which scope should contain your project? (just press enter)\n"
"? Link to existing project? [y/N] n\n"
"? What‚Äôs your project‚Äôs name? erc20-web\n"
"? In which directory is your code located? ./\n"
"? Want to modify these settings? [y/N] n\n"
"‚úÖ  Linked erc20-web (created .vercel)\n"
"```"

#: src/ch02-09-02-erc20-ui.md:482 src/ch02-10-01-erc20-ui.md:445
msgid "5. Upload it:"
msgstr "5. C√°rgalo:"

#: src/ch02-09-02-erc20-ui.md:484 src/ch02-10-01-erc20-ui.md:447
msgid ""
"```bash\n"
"vercel\n"
"```"
msgstr ""
"```bash\n"
"vercel\n"
"```"

#: src/ch02-09-02-erc20-ui.md:488 src/ch02-10-01-erc20-ui.md:451
msgid "6. Publish your project:"
msgstr "6. Publica tu proyecto:"

#: src/ch02-09-02-erc20-ui.md:490
msgid ""
"```bash\n"
"vercel --prod\n"
"‚úÖ  Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]\n"
"```"
msgstr ""
"```bash\n"
"vercel --prod\n"
"‚úÖ  Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]\n"
"```"

#: src/ch02-09-02-erc20-ui.md:495
msgid "Check your production URL and congratulations! Your MKT token web3 application is now accessible to everyone."
msgstr "Compruebe su URL de producci√≥n y ¬°enhorabuena! Tu aplicaci√≥n MKT token web3 ya es accesible para todo el mundo."

#: src/ch02-09-02-erc20-ui.md:497
msgid "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:499 src/ch02-10-01-erc20-ui.md:461
msgid "Engage with your app by:"
msgstr "Interact√∫e con su aplicaci√≥n de la siguiente manera:"

#: src/ch02-09-02-erc20-ui.md:501 src/ch02-10-01-erc20-ui.md:463
msgid "- Connecting your wallet:"
msgstr "- Conectando tu wallet:"

#: src/ch02-09-02-erc20-ui.md:503
msgid "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:505 src/ch02-10-01-erc20-ui.md:467
msgid "- Checking your balance:"
msgstr "- Consulta de tu balance:"

#: src/ch02-09-02-erc20-ui.md:507
msgid "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:509 src/ch02-10-01-erc20-ui.md:471
msgid "- Transferring tokens:"
msgstr "- Transferencia de tokens:"

#: src/ch02-09-02-erc20-ui.md:511
msgid "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4_js.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4_js.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-09-02-erc20-ui.md:513 src/ch02-10-01-erc20-ui.md:475
msgid "## Wrapping Up"
msgstr "## Conclusi√≥n"

#: src/ch02-09-02-erc20-ui.md:515
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 application using React, StarknetJS and Cairo. This application, complete with an ERC20 smart contract, offers a modern web "
"interface for user interaction. Here's a snapshot of your achievements:"
msgstr ""
"A lo largo de este tutorial, has recorrido los pasos para crear una aplicaci√≥n web3 usando React, StarknetJS y Cairo. Esta aplicaci√≥n, completa con un contrato inteligente ERC20, ofrece una "
"interfaz web moderna para la interacci√≥n del usuario. Aqu√≠ tienes una instant√°nea de tus logros:"

#: src/ch02-09-02-erc20-ui.md:517
msgid ""
"- **Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries.\n"
"\n"
"- **Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
"network.\n"
"\n"
"- **React Application**: Built a React application powered by StarknetJS, featuring components dedicated to balance inquiries and token transactions.\n"
"\n"
"- **Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token "
"transactions."
msgstr ""
"- **Inicializaci√≥n del Proyecto**: Configurar un proyecto Starknet con Scarb y las librer√≠as OpenZeppelin incorporadas.\n"
"\n"
"- Elaboraci√≥n del contrato ERC20**: Desarrollamos un token ERC20 usando Cairo, enriquecido con funcionalidades como comprobaciones de saldo y transferencias de tokens. A continuaci√≥n, se compil√≥ y "
"se lanz√≥ en la red Starknet.\n"
"\n"
"- Aplicaci√≥n React**: Construimos una aplicaci√≥n React impulsada por StarknetJS, con componentes dedicados a consultas de saldo y transacciones de tokens.\n"
"\n"
"- Despliegue Online**: Llev√≥ su aplicaci√≥n a un p√∫blico m√°s amplio despleg√°ndola en Vercel. Esto permiti√≥ a los usuarios conectar sus carteras, examinar sus saldos y ejecutar transacciones de "
"tokens."

#: src/ch02-09-02-erc20-ui.md:525 src/ch02-10-01-erc20-ui.md:488
msgid ""
"The insights you've gathered from this tutorial lay a solid groundwork for creating intricate web3 applications. You're now equipped with the prowess to craft more intricate decentralized "
"applications and smart contracts. The vast expanse of decentralized finance and blockchain is ripe for your innovative inputs. Dive in and happy coding!"
msgstr ""
"Los conocimientos que ha recopilado en este tutorial sientan una base s√≥lida para crear aplicaciones web3 complejas. Ahora est√° equipado con la destreza para crear aplicaciones descentralizadas y "
"contratos inteligentes m√°s complejos. La vasta extensi√≥n de las finanzas descentralizadas y blockchain est√° lista para sus aportes innovadores. ¬°Sum√©rgete y feliz codificaci√≥n!"

#: src/ch02-10-starknet-react.md:1
msgid "# Starknet-React: React Integration"
msgstr "# Starknet-React: Integraci√≥n de React"

#: src/ch02-10-starknet-react.md:3
msgid "In the starknet ecosystem, several tools are available for front-end development. The most notable are:"
msgstr "En el ecosistema de starknet hay varias herramientas disponibles para el desarrollo front-end. Las m√°s destacadas son:"

#: src/ch02-10-starknet-react.md:5
msgid ""
"- [starknet-react](https://github.com/apibara/starknet-react) ([documentation](https://starknet-react.com/docs/getting-started)): A collection of React hooks tailored for Starknet, inspired by "
"[wagmi](https://github.com/tmm/wagmi) and powered by [starknet.js](https://github.com/0xs34n/starknet.js).\n"
"\n"
"- [starknet.js](https://github.com/0xs34n/starknet.js): This JavaScript library facilitates interactions with Starknet contracts, akin to [web3.js](https://web3js.org/) for Ethereum."
msgstr ""
"- [starknet-react](https://github.com/apibara/starknet-react) ([documentaci√≥n](https://starknet-react.com/docs/getting-started)): Una colecci√≥n de hooks React adaptados para Starknet, inspirados en "
"[wagmi](https://github.com/tmm/wagmi) y potenciados por [starknet.js](https://github.com/0xs34n/starknet.js).\n"
"\n"
"- [starknet.js](https://github.com/0xs34n/starknet.js): Esta biblioteca JavaScript facilita las interacciones con los contratos de Starknet, similar a [web3.js](https://web3js.org/) para Ethereum."

#: src/ch02-10-starknet-react.md:9
msgid ""
"Developed by the [Apibara](https://github.com/apibara/) team, [Starknet React](https://github.com/apibara/starknet-react/) is an open-source suite of React providers and hooks specifically for "
"Starknet."
msgstr ""
"Desarrollado por el equipo [Apibara](https://github.com/apibara/), [Starknet React](https://github.com/apibara/starknet-react/) es un conjunto de c√≥digo abierto de proveedores y hooks React "
"espec√≠ficos para Starknet."

#: src/ch02-10-starknet-react.md:11
msgid "## Integrating Starknet React"
msgstr "## Integrando Starknet React"

#: src/ch02-10-starknet-react.md:13
msgid "The fastest way to get started using Starknet React is by using the `create-starknet` Command Line Interface (CLI). The tool will guide you through setting up your Starknet application:"
msgstr ""
"La forma m√°s r√°pida de empezar a utilizar Starknet React es utilizando la interfaz de l√≠nea de comandos (CLI) `create-starknet`. La herramienta le guiar√° a trav√©s de la configuraci√≥n de su "
"aplicaci√≥n Starknet:"

#: src/ch02-10-starknet-react.md:15
msgid ""
"```bash\n"
"npm init starknet\n"
"```"
msgstr ""
"```bash\n"
"npm init starknet\n"
"```"

#: src/ch02-10-starknet-react.md:19
msgid "Or, if you want to do it manually you will need to add the following dependencies to your project:"
msgstr "O, si quieres hacerlo manualmente, tendr√°s que a√±adir las siguientes dependencias a tu proyecto:"

#: src/ch02-10-starknet-react.md:21
msgid ""
"```bash\n"
"npm install @starknet-react/chains @starknet-react/core starknet get-starknet-core\n"
"```"
msgstr ""
"```bash\n"
"npm install @starknet-react/chains @starknet-react/core starknet get-starknet-core\n"
"```"

#: src/ch02-10-starknet-react.md:25
msgid ""
"[Starknet.js](https://www.starknetjs.com/) is an SDK designed to simplify interactions with Starknet. Conversely, [get-starknet](https://github.com/starknet-io/get-starknet/) specializes in wallet "
"connection management."
msgstr ""
"[Starknet.js](https://www.starknetjs.com/) es un SDK dise√±ado para simplificar las interacciones con Starknet. Por el contrario, [get-starknet](https://github.com/starknet-io/get-starknet/) se "
"especializa en la gesti√≥n de conexiones de wallets."

#: src/ch02-10-starknet-react.md:27
msgid "Wrap your app in the `StarknetConfig` component to configure and provide a React Context. This component lets you specify wallet connection options for users through its connectors prop."
msgstr ""
"Envuelve tu aplicaci√≥n en el componente `StarknetConfig` para configurar y proporcionar un Contexto React. Este componente te permite especificar opciones de conexi√≥n de wallet para los usuarios a "
"trav√©s de sus conectores prop."

#: src/ch02-10-starknet-react.md:29
msgid ""
"```javascript\n"
"export default function App({ children }) {\n"
"  const chains = [goerli, mainnet];\n"
"  const provider = publicProvider();\n"
"  const { connectors } = useInjectedConnectors({\n"
"    // Show these connectors if the user has no connector installed.\n"
"    recommended: [argent(), braavos()],\n"
"    // Hide recommended connectors if the user has any connector installed.\n"
"    includeRecommended: \"onlyIfNoConnectors\",\n"
"    // Randomize the order of the connectors.\n"
"    order: \"random\",\n"
"  });\n"
"\n"
"  return (\n"
"    <StarknetConfig chains={chains} provider={provider} connectors={connectors}>\n"
"      {children}\n"
"    </StarknetConfig>\n"
"  );\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"export default function App({ children }) {\n"
"  const chains = [goerli, mainnet];\n"
"  const provider = publicProvider();\n"
"  const { connectors } = useInjectedConnectors({\n"
"    // Show these connectors if the user has no connector installed.\n"
"    recommended: [argent(), braavos()],\n"
"    // Hide recommended connectors if the user has any connector installed.\n"
"    includeRecommended: \"onlyIfNoConnectors\",\n"
"    // Randomize the order of the connectors.\n"
"    order: \"random\",\n"
"  });\n"
"\n"
"  return (\n"
"    <StarknetConfig chains={chains} provider={provider} connectors={connectors}>\n"
"      {children}\n"
"    </StarknetConfig>\n"
"  );\n"
"}\n"
"```"

#: src/ch02-10-starknet-react.md:50
msgid "## Establishing Connection and Managing Account"
msgstr "## Establecer Conexi√≥n y Administrar Cuenta"

#: src/ch02-10-starknet-react.md:52
msgid "After defining the connectors in the `config`, you can use a hook to access them. This enables users to connect their wallets."
msgstr "Tras definir los conectores en `config`, puede utilizar un gancho para acceder a ellos. Esto permite a los usuarios conectar sus wallets."

#: src/ch02-10-starknet-react.md:54
msgid ""
"```javascript\n"
"export default function Component() {\n"
"  const { connect, connectors } = useConnect();\n"
"  return (\n"
"    <ul>\n"
"      {connectors.map((connector) => (\n"
"        <li key={connector.id}>\n"
"          <button onClick={() => connect({ connector })}>\n"
"            {connector.name}\n"
"          </button>\n"
"        </li>\n"
"      ))}\n"
"    </ul>\n"
"  );\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"export default function Component() {\n"
"  const { connect, connectors } = useConnect();\n"
"  return (\n"
"    <ul>\n"
"      {connectors.map((connector) => (\n"
"        <li key={connector.id}>\n"
"          <button onClick={() => connect({ connector })}>\n"
"            {connector.name}\n"
"          </button>\n"
"        </li>\n"
"      ))}\n"
"    </ul>\n"
"  );\n"
"}\n"
"```"

#: src/ch02-10-starknet-react.md:71
msgid ""
"Now, observe the `disconnect` function that terminates the connection when\n"
"invoked:"
msgstr ""
"Ahora, observe la funci√≥n `disconnect` que termina la conexi√≥n cuando es\n"
"invocada:"

#: src/ch02-10-starknet-react.md:74
msgid ""
"```javascript\n"
"const { disconnect } = useDisconnect();\n"
"return <button onClick={() => disconnect()}>Disconnect</button>;\n"
"```"
msgstr ""
"```javascript\n"
"const { disconnect } = useDisconnect();\n"
"return <button onClick={() => disconnect()}>Disconnect</button>;\n"
"```"

#: src/ch02-10-starknet-react.md:79
msgid "Once connected, the `useAccount` hook provides access to the connected account, giving insights into the connection's current state."
msgstr "Una vez conectado, el hook `useAccount` proporciona acceso a la cuenta conectada, dando informaci√≥n sobre el estado actual de la conexi√≥n."

#: src/ch02-10-starknet-react.md:81
msgid ""
"```javascript\n"
"const { address, isConnected, isReconnecting, account } = useAccount();\n"
"\n"
"return <div>{isConnected ? <p>Hello, {address}</p> : <Connect />}</div>;\n"
"```"
msgstr ""
"```javascript\n"
"const { address, isConnected, isReconnecting, account } = useAccount();\n"
"\n"
"return <div>{isConnected ? <p>Hello, {address}</p> : <Connect />}</div>;\n"
"```"

#: src/ch02-10-starknet-react.md:87
msgid ""
"State values like `isConnected` and `isReconnecting` update automatically, easing UI updates. This is particularly useful for asynchronous processes, removing the need for manual state management "
"in your components."
msgstr ""
"Los valores de estado como `isConnected` y `isReconnecting` se actualizan autom√°ticamente, facilitando las actualizaciones de la interfaz de usuario. Esto resulta especialmente √∫til para los "
"procesos as√≠ncronos, ya que elimina la necesidad de gestionar manualmente el estado de los componentes."

#: src/ch02-10-starknet-react.md:89
msgid "Once connected, signing messages is easy with the account value from the `useAccount` hook. For a smoother experience, you can also use the `useSignTypedData` hook."
msgstr "Una vez conectado, firmar mensajes es f√°cil con el valor de la cuenta del hook `useAccount`. Para una experiencia m√°s fluida, tambi√©n puedes utilizar el hook `useSignTypedData`."

#: src/ch02-10-starknet-react.md:91
msgid ""
"```Javascript\n"
"    const { data, isPending, signTypedData } = useSignTypedData(exampleData);\n"
"\n"
"    return (\n"
"      <button\n"
"        onClick={() => signTypedData(exampleData)}\n"
"        disabled={!account}\n"
"      >\n"
"        {isPending ? <p>Waiting for wallet...</p> : <p>Sign Message</p>}\n"
"      </button>\n"
"    );\n"
"```"
msgstr ""
"```Javascript\n"
"    const { data, isPending, signTypedData } = useSignTypedData(exampleData);\n"
"\n"
"    return (\n"
"      <button\n"
"        onClick={() => signTypedData(exampleData)}\n"
"        disabled={!account}\n"
"      >\n"
"        {isPending ? <p>Waiting for wallet...</p> : <p>Sign Message</p>}\n"
"      </button>\n"
"    );\n"
"```"

#: src/ch02-10-starknet-react.md:104
msgid ""
"Starknet React supports signing an array of `BigNumberish` values or an object. When signing an object, ensure the data adheres to the EIP712 type. For detailed guidance on signing, see the "
"Starknet.js documentation: [here](https://www.starknetjs.com/docs/guides/signature/)."
msgstr ""
"Starknet React admite la firma de una array de valores `BigNumberish` o de un objeto. Al firmar un objeto, aseg√∫rese de que los datos se adhieren al tipo EIP712. Para obtener informaci√≥n detallada "
"sobre la firma, consulta la documentaci√≥n de Starknet.js: [aqu√≠](https://www.starknetjs.com/docs/guides/signature/)."

#: src/ch02-10-starknet-react.md:106
msgid "## Displaying StarkName"
msgstr "## Mostrando StarkName"

#: src/ch02-10-starknet-react.md:108
msgid ""
"Once an account is connected, the `useStarkName` hook retrieves the `StarkName` of the account. Linked to [Starknet.id](https://www.starknet.id/), it allows for displaying the user address in a "
"user-friendly manner."
msgstr ""
"Una vez conectada una cuenta, el hook `useStarkName` recupera el `StarkName` de la cuenta. Vinculado a [Starknet.id](https://www.starknet.id/), permite mostrar la direcci√≥n del usuario de forma "
"sencilla."

#: src/ch02-10-starknet-react.md:110
msgid ""
"```Javascript\n"
"    const { data, isLoading, isError } = useStarkName({ address });\n"
"\n"
"    if (isLoading)\n"
"        return <span>Loading...</span>;\n"
"    if (isError)\n"
"        return <span>Error fetching name...</span>;\n"
"\n"
"    return <span>StarkName: {data}</span>;\n"
"```"
msgstr ""
"```Javascript\n"
"    const { data, isLoading, isError } = useStarkName({ address });\n"
"\n"
"    if (isLoading)\n"
"        return <span>Loading...</span>;\n"
"    if (isError)\n"
"        return <span>Error fetching name...</span>;\n"
"\n"
"    return <span>StarkName: {data}</span>;\n"
"```"

#: src/ch02-10-starknet-react.md:121
msgid ""
"This hook provides additional information: **error**, **status**, **fetchStatus**, **isSuccess**, **isError**, **isPending**, **isFetching**, **isLoading**. These details offer precise insights "
"into the current process."
msgstr ""
"Este hook proporciona informaci√≥n adicional: **error**, **status**, **fetchStatus**, **isSuccess**, **isError**, **isPending**, **isFetching**, **isLoading**. Estos detalles ofrecen informaci√≥n "
"precisa sobre el proceso actual."

#: src/ch02-10-starknet-react.md:123
msgid "## Fetching Address from `StarkName`"
msgstr "## Obtenci√≥n de la direcci√≥n de `StarkName`"

#: src/ch02-10-starknet-react.md:125
msgid "To retrieve an `address` from a `StarkName`, use the `useAddressFromStarkName` hook."
msgstr "Para recuperar una `direcci√≥n` a partir de un `StarkName`, utiliza el hook `useAddressFromStarkName`."

#: src/ch02-10-starknet-react.md:127
msgid ""
"```Javascript\n"
"    const { data, isLoading, isError } = useAddressFromStarkName({\n"
"      name: \"vitalik.stark\",\n"
"    });\n"
"\n"
"    if (isLoading)\n"
"        return <span>Loading...</span>;\n"
"    if (isError)\n"
"        return <span>Error fetching address...</span>;\n"
"\n"
"    return <span>address: {data}</span>;\n"
"```"
msgstr ""
"```Javascript\n"
"    const { data, isLoading, isError } = useAddressFromStarkName({\n"
"      name: \"vitalik.stark\",\n"
"    });\n"
"\n"
"    if (isLoading)\n"
"        return <span>Loading...</span>;\n"
"    if (isError)\n"
"        return <span>Error fetching address...</span>;\n"
"\n"
"    return <span>address: {data}</span>;\n"
"```"

#: src/ch02-10-starknet-react.md:140
msgid ""
"If the provided name does not have an associated address, it will return\n"
"`0x0`"
msgstr ""
"Si el nombre proporcionado no tiene una direcci√≥n asociada, devolver√°\n"
"`0x0`"

#: src/ch02-10-starknet-react.md:143
msgid "## Navigating the Network"
msgstr "## Navegando por la Red"

#: src/ch02-10-starknet-react.md:145
msgid "Starknet React provides developers with tools for network interactions, including hooks like useBlock for retrieving the latest block:"
msgstr "Starknet React proporciona a los desarrolladores herramientas para las interacciones de red, incluidos ganchos como useBlock para recuperar el √∫ltimo bloque:"

#: src/ch02-10-starknet-react.md:147
msgid ""
"```Javascript\n"
"        const { data, isLoading, isError } = useBlock({\n"
"        refetchInterval: 10_000,\n"
"        blockIdentifier: \"latest\" as BlockNumber,\n"
"        });\n"
"\n"
"        if (isLoading)\n"
"            return <span>Loading...</span>;\n"
"        if (isError || !data)\n"
"            return <span>Error...</span>;\n"
"\n"
"        return <span>Hash: {data.block_hash}</span>;\n"
"```"
msgstr ""
"```Javascript\n"
"        const { data, isLoading, isError } = useBlock({\n"
"        refetchInterval: 10_000,\n"
"        blockIdentifier: \"latest\" as BlockNumber,\n"
"        });\n"
"\n"
"        if (isLoading)\n"
"            return <span>Loading...</span>;\n"
"        if (isError || !data)\n"
"            return <span>Error...</span>;\n"
"\n"
"        return <span>Hash: {data.block_hash}</span>;\n"
"```"

#: src/ch02-10-starknet-react.md:161
msgid ""
"Here, `refetchInterval` sets the data refresh rate. Starknet React uses [react-query](https://github.com/TanStack/query/) for state and query management. Other hooks like `useContractRead` and "
"`useWaitForTransaction` are also available for interval-based updates."
msgstr ""
"Aqu√≠, `refetchInterval` establece la frecuencia de actualizaci√≥n de datos. Starknet React utiliza [react-query](https://github.com/TanStack/query/) para la gesti√≥n de estados y consultas. Otros "
"hooks como `useContractRead` y `useWaitForTransaction` tambi√©n est√°n disponibles para actualizaciones basadas en intervalos."

#: src/ch02-10-starknet-react.md:163
msgid "The useStarknet hook gives direct access to the ProviderInterface:"
msgstr "El hook useStarknet da acceso directo a la ProviderInterface:"

#: src/ch02-10-starknet-react.md:165
msgid ""
"```Javascript\n"
"    const { provider } = useProvider()\n"
"\n"
"    // library.getClassByHash(...)\n"
"    // library.getTransaction(...)\n"
"```"
msgstr ""
"```Javascript\n"
"    const { provider } = useProvider()\n"
"\n"
"    // library.getClassByHash(...)\n"
"    // library.getTransaction(...)\n"
"```"

#: src/ch02-10-starknet-react.md:172
msgid "## Tracking Wallet changes"
msgstr "## Seguimiento de Cambios en la Wallet"

#: src/ch02-10-starknet-react.md:174
msgid ""
"For a better dApp user experience, tracking wallet changes is crucial. This includes account changes, connections, disconnections, and network switches. Reload balances on account changes, or reset "
"your dApp's state on network changes. Use `useAccount` and `useNetwork` for this."
msgstr ""
"Para mejorar la experiencia del usuario de una dApp, es crucial realizar un seguimiento de los cambios en el monedero. Esto incluye cambios de cuenta, conexiones, desconexiones y cambios de red. "
"Recarga los saldos en los cambios de cuenta, o restablece el estado de tu dApp en los cambios de red. Usa `useAccount` y `useNetwork` para esto."

#: src/ch02-10-starknet-react.md:176
msgid "`useNetwork` provides the current network chain:"
msgstr "`useNetwork` proporciona la cadena de red actual:"

#: src/ch02-10-starknet-react.md:178
msgid ""
"```Javascript\n"
"    const { chain: { id, name } } = useNetwork();\n"
"\n"
"    return (\n"
"        <>\n"
"            <p>Connected chain: {name}</p>\n"
"            <p>Connected chain id: {id}</p>\n"
"        </>\n"
"    )\n"
"```"
msgstr ""
"```Javascript\n"
"    const { chain: { id, name } } = useNetwork();\n"
"\n"
"    return (\n"
"        <>\n"
"            <p>Connected chain: {name}</p>\n"
"            <p>Connected chain id: {id}</p>\n"
"        </>\n"
"    )\n"
"```"

#: src/ch02-10-starknet-react.md:189
msgid "This hook also offers **blockExplorer**, **testnet** for detailed network information."
msgstr "Este gancho tambi√©n ofrece **blockExplorer**, **testnet** para obtener informaci√≥n detallada de la red."

#: src/ch02-10-starknet-react.md:191
msgid "Monitor user interactions with account and network using the `useEffect` hook:"
msgstr "Monitoriza las interacciones del usuario con la cuenta y la red utilizando el hook `useEffect`:"

#: src/ch02-10-starknet-react.md:193
msgid ""
"```Javascript\n"
"    const { chain } = useNetwork();\n"
"    const { address } = useAccount();\n"
"\n"
"    useEffect(() => {\n"
"        if(address) {\n"
"            // Do some work when the user changes the account on the wallet\n"
"            // Like reloading the balances\n"
"        }else{\n"
"            // Do some work when the user disconnects the wallet\n"
"            // Like reseting the state of your dApp\n"
"        }\n"
"    }, [address]);\n"
"\n"
"    useEffect(() => {\n"
"        // Do some work when the user changes the network on the wallet\n"
"        // Like reseting the state of your dApp\n"
"    }, [chain]);\n"
"```"
msgstr ""
"```Javascript\n"
"    const { chain } = useNetwork();\n"
"    const { address } = useAccount();\n"
"\n"
"    useEffect(() => {\n"
"        if(address) {\n"
"            // Do some work when the user changes the account on the wallet\n"
"            // Like reloading the balances\n"
"        }else{\n"
"            // Do some work when the user disconnects the wallet\n"
"            // Like reseting the state of your dApp\n"
"        }\n"
"    }, [address]);\n"
"\n"
"    useEffect(() => {\n"
"        // Do some work when the user changes the network on the wallet\n"
"        // Like reseting the state of your dApp\n"
"    }, [chain]);\n"
"```"

#: src/ch02-10-starknet-react.md:213
msgid "## Contract Interactions"
msgstr "## Interacciones del Contrato"

#: src/ch02-10-starknet-react.md:215
msgid "### Read Functions"
msgstr "### Leer Funciones"

#: src/ch02-10-starknet-react.md:217
msgid "Starknet React introduces `useContractRead`, similar to wagmi, for read operations on contracts. These operations are independent of the user's connection status and don't require a signer."
msgstr ""
"Starknet React introduce `useContractRead`, similar a wagmi, para operaciones de lectura de contratos. Estas operaciones son independientes del estado de conexi√≥n del usuario y no requieren un "
"firmante."

#: src/ch02-10-starknet-react.md:219
msgid ""
"```javascript\n"
"    const { data, isError, isLoading, error } = useContractRead({\n"
"        functionName: \"balanceOf\",\n"
"        args: [address as string],\n"
"        abi,\n"
"        address: testAddress,\n"
"        watch: true,\n"
"    });\n"
"\n"
"    if (isLoading)\n"
"        return <div>Loading ...</div>;\n"
"    if (isError || !data)\n"
"        return <div>{error?.message}</div>;\n"
"\n"
"    return <div>{parseFloat(data.balance.low)}n</div>;\n"
"```"
msgstr ""
"```javascript\n"
"    const { data, isError, isLoading, error } = useContractRead({\n"
"        functionName: \"balanceOf\",\n"
"        args: [address as string],\n"
"        abi,\n"
"        address: testAddress,\n"
"        watch: true,\n"
"    });\n"
"\n"
"    if (isLoading)\n"
"        return <div>Loading ...</div>;\n"
"    if (isError || !data)\n"
"        return <div>{error?.message}</div>;\n"
"\n"
"    return <div>{parseFloat(data.balance.low)}n</div>;\n"
"```"

#: src/ch02-10-starknet-react.md:236
msgid "For ERC20 operations, the `useBalance` hook simplifies retrieving balances without needing an ABI."
msgstr "Para las operaciones ERC20, el hook `useBalance` simplifica la recuperaci√≥n de saldos sin necesidad de una ABI."

#: src/ch02-10-starknet-react.md:238
msgid ""
"```javascript\n"
"const { isLoading, isError, error, data } = useBalance({\n"
"  address,\n"
"  watch: true,\n"
"});\n"
"\n"
"if (isLoading) return <div>Loading ...</div>;\n"
"if (isError || !data) return <div>{error?.message}</div>;\n"
"\n"
"return (\n"
"  <div>\n"
"    {data.value.toString()}\n"
"    {data.symbol}\n"
"  </div>\n"
");\n"
"```"
msgstr ""
"```javascript\n"
"const { isLoading, isError, error, data } = useBalance({\n"
"  address,\n"
"  watch: true,\n"
"});\n"
"\n"
"if (isLoading) return <div>Loading ...</div>;\n"
"if (isError || !data) return <div>{error?.message}</div>;\n"
"\n"
"return (\n"
"  <div>\n"
"    {data.value.toString()}\n"
"    {data.symbol}\n"
"  </div>\n"
");\n"
"```"

#: src/ch02-10-starknet-react.md:255
msgid "### Write Functions"
msgstr "### Funciones de Escritura"

#: src/ch02-10-starknet-react.md:257
msgid ""
"The `useContractWrite` hook, unlike wagmi, benefits from Starknet's native support for multicall transactions. This improves user experience by facilitating multiple transactions without individual "
"approvals."
msgstr ""
"El hook `useContractWrite`, a diferencia de wagmi, se beneficia del soporte nativo de Starknet para transacciones multicall. Esto mejora la experiencia del usuario facilitando m√∫ltiples "
"transacciones sin aprobaciones individuales."

#: src/ch02-10-starknet-react.md:259
msgid ""
"```javascript\n"
"    const calls = useMemo(() => {\n"
"      if (!address || !contract) return [];\n"
"      // return a single object for single transaction,\n"
"      // or an array of objects for multicall**\n"
"      return contract.populateTransaction[\"transfer\"]!(address, { low: 1, high: 0 });\n"
"    }, [contract, address]);\n"
"\n"
"    const {\n"
"      writeAsync,\n"
"      data,\n"
"      isPending,\n"
"    } = useContractWrite({\n"
"      calls,\n"
"    });\n"
"\n"
"    return (\n"
"      <>\n"
"        <button onClick={() => writeAsync()}>Transfer</button>\n"
"        <p>status: {isPending && <div>Submitting...</div>}</p>\n"
"        <p>hash: {data?.transaction_hash}</p>\n"
"      </>\n"
"    );\n"
"```"
msgstr ""
"```javascript\n"
"    const calls = useMemo(() => {\n"
"      if (!address || !contract) return [];\n"
"      // return a single object for single transaction,\n"
"      // or an array of objects for multicall**\n"
"      return contract.populateTransaction[\"transfer\"]!(address, { low: 1, high: 0 });\n"
"    }, [contract, address]);\n"
"\n"
"    const {\n"
"      writeAsync,\n"
"      data,\n"
"      isPending,\n"
"    } = useContractWrite({\n"
"      calls,\n"
"    });\n"
"\n"
"    return (\n"
"      <>\n"
"        <button onClick={() => writeAsync()}>Transfer</button>\n"
"        <p>status: {isPending && <div>Submitting...</div>}</p>\n"
"        <p>hash: {data?.transaction_hash}</p>\n"
"      </>\n"
"    );\n"
"```"

#: src/ch02-10-starknet-react.md:284
msgid "This setup starts with the `populateTransaction` utility, followed by executing the transaction through `writeAsync`. The hook also provides transaction status and hash."
msgstr ""
"Esta configuraci√≥n comienza con la utilidad `populateTransaction`, seguida de la ejecuci√≥n de la transacci√≥n a trav√©s de `writeAsync`. El gancho tambi√©n proporciona el estado de la transacci√≥n y el "
"hash."

#: src/ch02-10-starknet-react.md:286
msgid "### A Single Contract Instance"
msgstr "### Una Unica Instancia de Contrato"

#: src/ch02-10-starknet-react.md:288
msgid "For cases where a single contract instance is more than apecifying the contract address and ABI in each hook., use the `useContract` hook:"
msgstr "Para los casos en que una sola instancia de contrato es m√°s que apecifying la direcci√≥n del contrato y ABI en cada hook., utilice el `useContract` hook:"

#: src/ch02-10-starknet-react.md:290
msgid ""
"```javascript\n"
"const { contract } = useContract({\n"
"  address: CONTRACT_ADDRESS,\n"
"  abi: abi_erc20,\n"
"});\n"
"\n"
"// Call functions directly on contract\n"
"// contract.transfer(...);\n"
"// contract.balanceOf(...);\n"
"```"
msgstr ""
"```javascript\n"
"const { contract } = useContract({\n"
"  address: CONTRACT_ADDRESS,\n"
"  abi: abi_erc20,\n"
"});\n"
"\n"
"// Call functions directly on contract\n"
"// contract.transfer(...);\n"
"// contract.balanceOf(...);\n"
"```"

#: src/ch02-10-starknet-react.md:301
msgid "## Tracking Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch02-10-starknet-react.md:303
msgid "`UseWaitForTransaction` tracks transaction states with a transaction hash, reducing network requests through caching."
msgstr "`UseWaitForTransaction` realiza un seguimiento de los estados de transacci√≥n con un hash de transacci√≥n, reduciendo las peticiones de red mediante el almacenamiento en cach√©."

#: src/ch02-10-starknet-react.md:305
msgid ""
"```javascript\n"
"const { isLoading, isError, error, data } = useWaitForTransaction({\n"
"  hash: transaction,\n"
"  watch: true,\n"
"});\n"
"\n"
"if (isLoading) return <div>Loading ...</div>;\n"
"if (isError || !data) return <div>{error?.message}</div>;\n"
"\n"
"return <div>{data.status?.length}</div>;\n"
"```"
msgstr ""
"```javascript\n"
"const { isLoading, isError, error, data } = useWaitForTransaction({\n"
"  hash: transaction,\n"
"  watch: true,\n"
"});\n"
"\n"
"if (isLoading) return <div>Loading ...</div>;\n"
"if (isError || !data) return <div>{error?.message}</div>;\n"
"\n"
"return <div>{data.status?.length}</div>;\n"
"```"

#: src/ch02-10-starknet-react.md:317
msgid "Explore all available hooks in Starknet React's documentation: <https://starknet-react.com/hooks/>."
msgstr "Explora todos los hooks disponibles en la documentaci√≥n de Starknet React: <https://starknet-react.com/hooks/>."

#: src/ch02-10-starknet-react.md:321
msgid ""
"The Starknet React library provides a range of React hooks and providers specifically designed for Starknet and the Starknet.js SDK. These tools enable developers to create applications on the "
"Starknet network."
msgstr ""
"La biblioteca React de Starknet proporciona una serie de hooks y proveedores React dise√±ados espec√≠ficamente para Starknet y el SDK Starknet.js. Estas herramientas permiten a los desarrolladores "
"crear aplicaciones en la red Starknet."

#: src/ch02-10-01-erc20-ui.md:3
msgid "This guide offers steps to build an ERC20 smart contract using Cairo and to incorporate it within a React web application with Starknet React. Readers will:"
msgstr "Esta gu√≠a ofrece pasos para crear un contrato inteligente ERC20 usando Cairo e incorporarlo dentro de una aplicaci√≥n web React con Starknet React. Los lectores:"

#: src/ch02-10-01-erc20-ui.md:10
msgid "A prerequisite for this guide is a foundational understanding of both the Cairo programming language and ReactJS. Additionally, ensure Node.js and NPM are installed on the system."
msgstr "Un requisito previo para esta gu√≠a es una comprensi√≥n b√°sica tanto del lenguaje de programaci√≥n Cairo como de ReactJS. Adem√°s, aseg√∫rese de que Node.js y NPM est√©n instalados en el sistema."

#: src/ch02-10-01-erc20-ui.md:14
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:18
msgid ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- Starknet React v2.1.1\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.1.6\n"
"- Visual Studio Code\n"
"- Vercel"
msgstr ""
"- Scarb 0.7.0 with Cairo 2.2.0\n"
"- Starkli 0.1.9\n"
"- Oppenzeppelin libraries v0.7.0\n"
"- Starknet React v2.1.1\n"
"- NodeJS v19.6.1\n"
"- Next.js 13.1.6\n"
"- Visual Studio Code\n"
"- Vercel"

#: src/ch02-10-01-erc20-ui.md:39
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.0-beta.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.0-beta.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-10-01-erc20-ui.md:96
msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:112
msgid "Subsequent to the compilation, declare the smart contract on the Starknet testnet:"
msgstr "Despu√©s de la compilaci√≥n, declare el contrato inteligente en la red de prueba de Starknet:"

#: src/ch02-10-01-erc20-ui.md:138
msgid ""
"- `Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 \\* 10^18 or 0xd3c21bcecceda1000000. Due to the "
"contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively.\n"
"- `Receiver address`: Use a preferred address. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""
"- `Initial mint`: Acu√±a 1.000.000 de tokens. Dado que el token MKT consta de 18 decimales (un est√°ndar de OpenZeppelin), la entrada requerida es 1.000.000 * 10^18 o 0xd3c21bcecceda1000000. Debido a "
"la expectativa del contrato de un valor perfecto de u256, proporcione valores bajos y altos: 0xd3c21bcecceda1000000 y 0 respectivamente.\n"
"- `Receiver address`: Utilice una direcci√≥n preferida. En este ejemplo: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#: src/ch02-10-01-erc20-ui.md:157
msgid "## Installing the Starknet React Library"
msgstr "## Instalaci√≥n de la Biblioteca Starknet React"

#: src/ch02-10-01-erc20-ui.md:159
msgid "With the contract in place, initiate the development of the web application. Begin by incorporating the Starknet React library and setting up a new React Project called 'erc20':"
msgstr "Con el contrato en su lugar, iniciar el desarrollo de la aplicaci√≥n web. Comienza incorporando la librer√≠a React de Starknet y configurando un nuevo proyecto React llamado 'erc20':"

#: src/ch02-10-01-erc20-ui.md:161
msgid ""
"```bash\n"
"$ npm init starknet\n"
"Need to install the following packages:\n"
"  create-starknet@2.0.1\n"
"Ok to proceed? (y) y\n"
"‚úî What is your project named? ‚Ä¶ erc20_web\n"
"‚úî What framework would you like to use? ‚Ä∫ Next.js\n"
"Installing dependencies...\n"
"Success! Created erc20_web at ~/erc20_web\n"
"\n"
"We suggest that you begin by typing:\n"
"\n"
"    cd erc20\n"
"    npm run dev\n"
"```"
msgstr ""
"```bash\n"
"$ npm init starknet\n"
"Need to install the following packages:\n"
"  create-starknet@2.0.1\n"
"Ok to proceed? (y) y\n"
"‚úî What is your project named? ‚Ä¶ erc20_web\n"
"‚úî What framework would you like to use? ‚Ä∫ Next.js\n"
"Installing dependencies...\n"
"Success! Created erc20_web at ~/erc20_web\n"
"\n"
"We suggest that you begin by typing:\n"
"\n"
"    cd erc20\n"
"    npm run dev\n"
"```"

#: src/ch02-10-01-erc20-ui.md:177
msgid "Post-installation, confirm the version of the Starknet React library:"
msgstr "Despu√©s de la instalaci√≥n, confirme la versi√≥n de la biblioteca Starknet React:"

#: src/ch02-10-01-erc20-ui.md:179
msgid ""
"```bash\n"
"npm list @starknet-react/core\n"
"```"
msgstr ""
"```bash\n"
"npm list @starknet-react/core\n"
"```"

#: src/ch02-10-01-erc20-ui.md:183
msgid "The output should display the installed version, such as `@starknet-react/core@2.1.1`."
msgstr "La salida deber√≠a mostrar la versi√≥n instalada, como `@starknet-react/core@2.1.1`."

#: src/ch02-10-01-erc20-ui.md:185
msgid "Once set up, make modifications to `erc20_web/page.tsx` by replacing its content with the following code:"
msgstr "Una vez configurado, realice modificaciones en `erc20_web/page.tsx` sustituyendo su contenido por el siguiente c√≥digo:"

#: src/ch02-10-01-erc20-ui.md:187
msgid ""
"```typescript\n"
"'use client';\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from \"@/components/WalletBar\";\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" />\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"'use client';\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from \"@/components/WalletBar\";\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" />\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"

#: src/ch02-10-01-erc20-ui.md:225
msgid "To launch the web3 application:"
msgstr "Para iniciar la aplicaci√≥n web3:"

#: src/ch02-10-01-erc20-ui.md:232
msgid "NOTE: Observe the server port that appears during launch. This will be useful for subsequent testing."
msgstr "NOTA: Observe el puerto del servidor que aparece durante el inicio. Esto ser√° √∫til para pruebas posteriores."

#: src/ch02-10-01-erc20-ui.md:236
msgid "To enhance the app's functionality, create two components for balance and transfer. Subsequently, update the `Wallet.tsx` file to incorporate the new features:"
msgstr "Para mejorar la funcionalidad de la aplicaci√≥n, cree dos componentes para saldo y transferencia. Posteriormente, actualice el archivo `Wallet.tsx` para incorporar las nuevas funcionalidades:"

#: src/ch02-10-01-erc20-ui.md:238
msgid "<img alt=\"Basic Dapp ERC20 React Files\" src=\"img/ch02-basic-dapp-react-files.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Basic Dapp ERC20 React Files\" src=\"img/ch02-basic-dapp-react-files.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:240
msgid "### Balance Component"
msgstr "### Componente de Balance"

#: src/ch02-10-01-erc20-ui.md:242
msgid "Design a balance component inside `components/Balance.tsx` and integrate the following code:"
msgstr "Dise√±e un componente de equilibrio dentro de `components/Balance.tsx` e integre el siguiente c√≥digo:"

#: src/ch02-10-01-erc20-ui.md:244
msgid ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../../assets/erc20.json';\n"
"import { MouseEventHandler } from \"react\";\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address || ''], // Provide a default value if address is undefined\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  const handleClick: MouseEventHandler<HTMLButtonElement> = async (event) => {\n"
"    event.preventDefault();\n"
"    await refetch();\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={handleClick}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default Balance;\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../../assets/erc20.json';\n"
"import { MouseEventHandler } from \"react\";\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address || ''], // Provide a default value if address is undefined\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  const handleClick: MouseEventHandler<HTMLButtonElement> = async (event) => {\n"
"    event.preventDefault();\n"
"    await refetch();\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={handleClick}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default Balance;\n"
"```"

#: src/ch02-10-01-erc20-ui.md:280
msgid "NOTE: Replace the address with the address of your deployed contract."
msgstr "NOTA: Reemplace la direcci√≥n con la direcci√≥n de su contrato implementado."

#: src/ch02-10-01-erc20-ui.md:282
msgid "### Transfer Component"
msgstr "### Componente de Transfer"

#: src/ch02-10-01-erc20-ui.md:284
msgid "Craft a transfer component in `components/Transfer.tsx` and embed the subsequent code:"
msgstr "Cree un componente de transferencia en `components/Transfer.tsx` e incruste el c√≥digo siguiente:"

#: src/ch02-10-01-erc20-ui.md:286
msgid ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"  \n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"  \n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"

#: src/ch02-10-01-erc20-ui.md:327
msgid "NOTE: Replace contractAddress with the address of your deployed contract."
msgstr "NOTA: Reemplace contractAddress con la direcci√≥n de su contrato implementado."

#: src/ch02-10-01-erc20-ui.md:329
msgid "### Updating the Wallet Component"
msgstr "### Actualizaci√≥n del Componente Wallet"

#: src/ch02-10-01-erc20-ui.md:331
msgid "Proceed to modify the `components/Wallet.tsx` file. Replace any existing content with the following enhanced code:"
msgstr "Proceda a modificar el archivo `components/Wallet.tsx`. Reemplace cualquier contenido existente con el siguiente c√≥digo mejorado:"

#: src/ch02-10-01-erc20-ui.md:333
msgid ""
"```typescript\n"
"\"use client\";\n"
"import { useAccount, useConnect, useDisconnect } from \"@starknet-react/core\";\n"
"import { useMemo } from \"react\";\n"
"import { Button } from \"./ui/Button\";\n"
"import Balance from './Balance'\n"
"import Transfer from './Transfer'\n"
"\n"
"function WalletConnected() {\n"
"  const { address } = useAccount();\n"
"  const { disconnect } = useDisconnect();\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Connected: {shortenedAddress}</span>\n"
"      <p><button onClick={() => disconnect()}>Disconnect</button></p>\n"
"      <hr/>\n"
"      <Balance />\n"
"      <Transfer />\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnect();\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Choose a wallet: </span>\n"
"      <p>\n"
"      {connectors.map((connector) => {\n"
"        return (\n"
"          <Button\n"
"            key={connector.id}\n"
"            onClick={() => connect({ connector })}\n"
"          >\n"
"            {connector.id}\n"
"          </Button>\n"
"        );\n"
"      })}\n"
"      </p>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar() {\n"
"  const { address } = useAccount();\n"
"\n"
"  return address ? <WalletConnected /> : <ConnectWallet />;\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"

#: src/ch02-10-01-erc20-ui.md:390
msgid "This updated code refines the Wallet component to offer a more interactive experience for users intending to connect or manage their wallets."
msgstr "Este c√≥digo actualizado perfecciona el componente Wallet para ofrecer una experiencia m√°s interactiva a los usuarios que deseen conectarse o administrar sus billeteras."

#: src/ch02-10-01-erc20-ui.md:392
msgid "## Finalizing the MKT Token Application"
msgstr "## Finalizando la solicitud del token MKT"

#: src/ch02-10-01-erc20-ui.md:394
msgid "To finalize the application setup, we need the ABI file for the MKT token. Follow the steps below to generate and integrate it:"
msgstr "Para finalizar la configuraci√≥n de la aplicaci√≥n, necesitamos el archivo ABI para el token MKT. Siga los pasos a continuaci√≥n para generarlo e integrarlo:"

#: src/ch02-10-01-erc20-ui.md:396
msgid ""
"1. At the root of your project, create a new directory named `assets/`.\n"
"2. Inside the `assets/` directory, create an empty JSON file named `erc20.json`.\n"
"3. Go back to your ERC20 Cairo project folder and locate the `erc20/target/erc20_erc20_sierra.json` file."
msgstr ""
"1. En la ra√≠z de su proyecto, cree un nuevo directorio llamado `assets/`.\n"
"2. Dentro del directorio `assets/`, cree un archivo JSON vac√≠o llamado `erc20.json`.\n"
"3. Regrese a la carpeta de su proyecto ERC20 Cairo y busque el archivo `erc20/target/erc20_erc20_sierra.json`."

#: src/ch02-10-01-erc20-ui.md:400
msgid "<img alt=\"ABI Original\" src=\"img/ch02-basic-dapp-abi.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"ABI Original\" src=\"img/ch02-basic-dapp-abi.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:402
msgid "4. Extract the ABI definition (ensuring you include the square brackets) and integrate it into the previously created `assets/erc20.json` file."
msgstr "4. Extraiga la definici√≥n de ABI (asegur√°ndose de incluir los corchetes) e int√©grela en el archivo `assets/erc20.json` creado previamente."

#: src/ch02-10-01-erc20-ui.md:404
msgid "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:406
msgid ""
"Well done! The basic MKT token application is now operational locally. Access it via `http://localhost:3000` or the port noted from earlier server setup. The app allows users to connect their "
"wallets, review their balances, and perform token transfers."
msgstr ""
"¬°Bien hecho! La aplicaci√≥n b√°sica del token MKT ahora est√° operativa localmente. Acceda a √©l a trav√©s de `http://localhost:3000` o el puerto indicado en la configuraci√≥n anterior del servidor. La "
"aplicaci√≥n permite a los usuarios conectar sus billeteras, revisar sus saldos y realizar transferencias de tokens."

#: src/ch02-10-01-erc20-ui.md:408
msgid "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:419
msgid ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"vercel init\n"
"```"
msgstr ""
"```bash\n"
"cd erc20_web/\n"
"npm i -g vercel\n"
"vercel init\n"
"```"

#: src/ch02-10-01-erc20-ui.md:427
msgid ""
"```bash\n"
"vercel login\n"
"```"
msgstr ""
"```bash\n"
"vercel login\n"
"```"

#: src/ch02-10-01-erc20-ui.md:433
msgid ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""
"<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login.png\" class=\"center\" style=\"width: 75%;\" />\n"
"\n"
"<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:441
msgid ""
"```bash\n"
"vercel link\n"
"```"
msgstr ""
"```bash\n"
"vercel link\n"
"```"

#: src/ch02-10-01-erc20-ui.md:453
msgid ""
"```bash\n"
"vercel --prod\n"
"```"
msgstr ""
"```bash\n"
"vercel --prod\n"
"```"

#: src/ch02-10-01-erc20-ui.md:457
msgid "Congratulations! Your MKT token web3 application is now accessible to everyone."
msgstr "¬°Felicidades! Su aplicaci√≥n web3 de token MKT ahora es accesible para todos."

#: src/ch02-10-01-erc20-ui.md:459
msgid "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:465
msgid "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:469
msgid "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:473
msgid "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-01-erc20-ui.md:477
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 application using React and Starknet Cairo. This application, complete with an ERC20 smart contract, offers a modern web "
"interface for user interaction. Here's a snapshot of your achievements:"
msgstr ""
"A lo largo de este tutorial, ha seguido los pasos para crear una aplicaci√≥n web3 utilizando React y Starknet Cairo. Esta aplicaci√≥n, completa con un contrato inteligente ERC20, ofrece una interfaz "
"web moderna para la interacci√≥n del usuario. Aqu√≠ tienes una instant√°nea de tus logros:"

#: src/ch02-10-01-erc20-ui.md:479
msgid ""
"- **Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries.\n"
"- **Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
"network.\n"
"\n"
"- **React Application**: Built a React application powered by Starknet React, featuring components dedicated to balance inquiries and token transactions.\n"
"\n"
"- **ABI Creation**: Produced the ABI for the MKT token, a critical component to liaise with the contract.\n"
"\n"
"- **Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token "
"transactions."
msgstr ""
"- **Inicializaci√≥n del proyecto**: Configur√≥ un proyecto Starknet con Scarb y bibliotecas OpenZeppelin incorporadas.\n"
"  \n"
"- **Elaboraci√≥n del contrato ERC20**: Desarroll√© un token ERC20 usando Cairo, enriquecido con funcionalidades como verificaci√≥n de saldo y transferencias de tokens. Luego se compil√≥ y se lanz√≥ en "
"la red Starknet.\n"
"\n"
"- **Aplicaci√≥n React**: Cre√≥ una aplicaci√≥n React impulsada por Starknet React, que presenta componentes dedicados a consultas de saldo y transacciones de tokens.\n"
"\n"
"- **Creaci√≥n de ABI**: Produjo el ABI para el token MKT, un componente cr√≠tico para vincularse con el contrato.\n"
"\n"
"- **Implementaci√≥n Online**: LLev√≥ su aplicaci√≥n a una audiencia m√°s amplia al implementarla en Vercel. Esto permiti√≥ a los usuarios conectar sus billeteras, examinar sus saldos y ejecutar "
"transacciones simb√≥licas."

#: src/ch02-10-02-million-dollar-homepage.md:1
msgid "# Million Dollar Homepage"
msgstr "# Million Dollar Homepage"

#: src/ch02-10-02-million-dollar-homepage.md:3
msgid ""
"[Starknet Homepage](https://github.com/dbejarano820/starknet_homepage) is a decentralized application on the Starknet blockchain. It provides a virtual space where users can claim and personalize "
"sections of a 100x100 grid, known as \"Starknet Homepage\". Each section is a 10x10 pixel area. Users can acquire these sections by minting non-fungible tokens (NFTs) and then personalizing them "
"with images and other content."
msgstr ""
"[Starknet Homepage](https://github.com/dbejarano820/starknet_homepage) es una aplicaci√≥n descentralizada en la cadena de bloques Starknet. Proporciona un espacio virtual donde los usuarios pueden "
"reclamar y personalizar secciones de una cuadr√≠cula de 100x100, conocida como \"Starknet Homepage\". Cada secci√≥n es un √°rea de 10x10 p√≠xeles. Los usuarios pueden adquirir estas secciones acu√±ando "
"tokens no fungibles (NFT) y luego personaliz√°ndolos con im√°genes y otro contenido."

#: src/ch02-10-02-million-dollar-homepage.md:5
msgid "View the live app on testnet [here](https://starknet-homepage-kappa.vercel.app/)."
msgstr "Vea la aplicaci√≥n en vivo en testnet [aqu√≠](https://starknet-homepage-kappa.vercel.app/)."

#: src/ch02-10-02-million-dollar-homepage.md:7
msgid "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-02-million-dollar-homepage.md:9
msgid ""
"This initiative is an adaptation of the renowned Million Dollar Homepage and was conceived at the Starknet Summit 2023 Hacker House in Palo Alto, California. The following is a guide to "
"understanding how this project was developed using the available tools in the ecosystem."
msgstr ""
"Esta iniciativa es una adaptaci√≥n de la reconocida Million Dollar Homepage y fue concebida en la Hacker House Starknet Summit 2023 en Palo Alto, California. La siguiente es una gu√≠a para comprender "
"c√≥mo se desarroll√≥ este proyecto utilizando las herramientas disponibles en el ecosistema."

#: src/ch02-10-02-million-dollar-homepage.md:11
msgid "### Tools Utilized:"
msgstr "### Tools Utilizadas:"

#: src/ch02-10-02-million-dollar-homepage.md:13
msgid ""
"- [Starknet-react](https://github.com/apibara/starknet-react)\n"
"- [Starknet.js](https://github.com/0xs34n/starknet.js)\n"
"- [OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)\n"
"- [MaterialUI](https://mui.com/material-ui/)"
msgstr ""
"- [Starknet-react](https://github.com/apibara/starknet-react)\n"
"- [Starknet.js](https://github.com/0xs34n/starknet.js)\n"
"- [OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)\n"
"- [MaterialUI](https://mui.com/material-ui/)"

#: src/ch02-10-02-million-dollar-homepage.md:18
msgid "## Initial Setup"
msgstr "## Configuraci√≥n Inicial"

#: src/ch02-10-02-million-dollar-homepage.md:20
msgid "The `Starknet-react` app offers a command to initialize a Starknet app. This command sets up the foundational structure needed for a NextJS application."
msgstr "La aplicaci√≥n `Starknet-react` ofrece un comando para inicializar una aplicaci√≥n Starknet. Este comando configura la estructura fundamental necesaria para una aplicaci√≥n NextJS."

#: src/ch02-10-02-million-dollar-homepage.md:22
msgid ""
"```shell\n"
"npx create-starknet\n"
"```"
msgstr ""
"```shell\n"
"npx create-starknet\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:26
msgid ""
"The `StarknetConfig` component accepts a `connectors` prop, which defines wallet connection options for the user. Additionally, it can take a `defaultProvider` to set the network the application "
"should connect to by default."
msgstr ""
"El componente `StarknetConfig` acepta un accesorio `connectors`, que define las opciones de conexi√≥n de billetera para el usuario. Adem√°s, puede ser necesario un `defaultProvider` para configurar "
"la red a la que la aplicaci√≥n debe conectarse de forma predeterminada."

#: src/ch02-10-02-million-dollar-homepage.md:28
msgid ""
"```javascript\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
"});\n"
"return (\n"
"  <StarknetConfig\n"
"    autoConnect\n"
"    defaultProvider={provider}\n"
"    connectors={connectors}\n"
"  >\n"
"    <CacheProvider value={emotionCache}>\n"
"      <ThemeProvider theme={theme}>\n"
"        <Component {...pageProps} />\n"
"      </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"
msgstr ""
"```javascript\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
"});\n"
"return (\n"
"  <StarknetConfig\n"
"    autoConnect\n"
"    defaultProvider={provider}\n"
"    connectors={connectors}\n"
"  >\n"
"    <CacheProvider value={emotionCache}>\n"
"      <ThemeProvider theme={theme}>\n"
"        <Component {...pageProps} />\n"
"      </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:51
msgid ""
"Both `CacheProvider` and `ThemeProvider` are components that facilitate the seamless integration of MaterialUI with NextJS. For a comprehensive setup guide on these components, please refer to "
"[this link](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)."
msgstr ""
"Tanto `CacheProvider` como `ThemeProvider` son componentes que facilitan la perfecta integraci√≥n de MaterialUI con NextJS. Para obtener una gu√≠a de configuraci√≥n completa sobre estos componentes, "
"consulte [este enlace](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)."

#: src/ch02-10-02-million-dollar-homepage.md:53
msgid "## Main Functionality"
msgstr "## Funcionalidad Principal"

#: src/ch02-10-02-million-dollar-homepage.md:55
msgid ""
"The core functionality of the Starknet Homepage centers around selecting a 4-sided region on a matrix, representing the desired 10x10 cells, and minting a token based on those cells. The "
"responsibility of the smart contract is to validate whether the selected cells are available for minting. If a user owns Starknet Homepage tokens, they can access a dropdown to modify the token's "
"content, including the associated image and link on the grid."
msgstr ""
"La funcionalidad principal de Starknet Homepage se centra en seleccionar una regi√≥n de 4 lados en una matriz, que representa las celdas de 10x10 deseadas y acu√±ar un token basado en esas celdas. La "
"responsabilidad del contrato inteligente es validar si las celdas seleccionadas est√°n disponibles para acu√±ar. Si un usuario posee tokens de la p√°gina de inicio de Starknet, puede acceder a un men√∫ "
"desplegable para modificar el contenido del token, incluida la imagen asociada y el enlace en la cuadr√≠cula."

#: src/ch02-10-02-million-dollar-homepage.md:57
msgid "The app's primary requirements are:"
msgstr "Los requisitos principales de la aplicaci√≥n son:"

#: src/ch02-10-02-million-dollar-homepage.md:59
msgid ""
"- Wallet connectivity\n"
"- Grid for displaying existing tokens\n"
"- Cell selection capability\n"
"- Multicall function for token approval and minting\n"
"- Dropdown to view owned tokens\n"
"- On-chain representation of the entire 1 million pixel grid"
msgstr ""
"- Conectividad de billetera\n"
"- Cuadr√≠cula para mostrar tokens existentes\n"
"- Capacidad de selecci√≥n de celdas\n"
"- Funci√≥n multillamada para aprobaci√≥n y acu√±aci√≥n de tokens\n"
"- Men√∫ desplegable para ver los tokens propios\n"
"- Representaci√≥n en cadena de toda la cuadr√≠cula de 1 mill√≥n de p√≠xeles"

#: src/ch02-10-02-million-dollar-homepage.md:66
msgid ""
"A significant aspect to consider is the string limitation in Cairo contracts. To store links of varying sizes, they are stored as arrays of `felt252`s. The contract uses the following logic for "
"this purpose:"
msgstr ""
"Un aspecto importante a considerar es la limitaci√≥n de cadenas en los contratos de El Cairo. Para almacenar enlaces de diferentes tama√±os, se almacenan como matrices de `felt252`s. El contrato "
"utiliza la siguiente l√≥gica para este prop√≥sito:"

#: src/ch02-10-02-million-dollar-homepage.md:68
msgid ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"        // Read the stored array's length. If the length is superior to 255, the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)\n"
"            .expect('Storage Span too large');\n"
"\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot. 255 of elements is max\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None => {\n"
"                    break Result::Ok(());\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -> u8 {\n"
"        255 / Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"        // Read the stored array's length. If the length is superior to 255, the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)\n"
"            .expect('Storage Span too large');\n"
"\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot. 255 of elements is max\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None => {\n"
"                    break Result::Ok(());\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -> u8 {\n"
"        255 / Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:126
msgid "The storage method for links in the contract state is structured as:"
msgstr "El m√©todo de storage de links en el estado de contrato se estructura de la siguiente manera:"

#: src/ch02-10-02-million-dollar-homepage.md:128
msgid ""
"```rust\n"
"struct Cell {\n"
"    token_id: u256,\n"
"    xpos: u8,\n"
"    ypos: u8,\n"
"    width: u8,\n"
"    height: u8,\n"
"    img: Array<felt252>,\n"
"    link: Array<felt252>,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"struct Cell {\n"
"    token_id: u256,\n"
"    xpos: u8,\n"
"    ypos: u8,\n"
"    width: u8,\n"
"    height: u8,\n"
"    img: Array<felt252>,\n"
"    link: Array<felt252>,\n"
"}\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:140
msgid ""
"The OpenZeppelin Cairo Contracts library played a crucial role in speeding up the development of the ERC721 contract for Starknet Homepage. You can find the contract for review [here](https://"
"github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo). Once you have installed the library, you can refer to the following example for typical usage:"
msgstr ""
"La biblioteca OpenZeppelin Cairo Contracts jug√≥ un papel crucial a la hora de acelerar el desarrollo del contrato ERC721 para Starknet Homepage. Puede encontrar el contrato para revisi√≥n [aqu√≠]"
"(https://github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo). Una vez que haya instalado la biblioteca, puede consultar el siguiente ejemplo para conocer el uso "
"t√≠pico:"

#: src/ch02-10-02-million-dollar-homepage.md:142
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod MyToken {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"    #[storage]\n"
"    struct Storage {}\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"    #[external(v0)]\n"
"    fn name(self: @ContractState) -> felt252 {\n"
"        let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::ERC20Impl::name(@unsafe_state)\n"
"    }\n"
"    ...\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod MyToken {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"    #[storage]\n"
"    struct Storage {}\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: u256,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
"    }\n"
"    #[external(v0)]\n"
"    fn name(self: @ContractState) -> felt252 {\n"
"        let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::ERC20Impl::name(@unsafe_state)\n"
"    }\n"
"    ...\n"
"}\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:170
msgid "### Component Logic"
msgstr "### L√≥gica de Componentes"

#: src/ch02-10-02-million-dollar-homepage.md:172
msgid "#### Grid"
msgstr "#### Grid"

#: src/ch02-10-02-million-dollar-homepage.md:174
msgid ""
"The Grid component represents a 100x100 matrix, with each cell being 100 pixels. This layout corresponds to the data structure found in the smart contract. To showcase the tokens already minted on "
"the Homepage, the app employs a React Hook from `starknet-react` to invoke the `getAllTokens` function from the contract."
msgstr ""
"El componente Grid representa una matriz de 100x100, donde cada celda tiene 100 p√≠xeles. Este dise√±o corresponde a la estructura de datos que se encuentra en el contrato inteligente. Para mostrar "
"los tokens ya acu√±ados en la p√°gina de inicio, la aplicaci√≥n emplea un React Hook de `starknet-react` para invocar la funci√≥n `getAllTokens` del contrato."

#: src/ch02-10-02-million-dollar-homepage.md:176
msgid ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"
msgstr ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:194
msgid "Deserialization ensures the data from the Starknet contract is aptly transformed for frontend use. This process involves decoding the array of `felt252`s into extensive strings."
msgstr ""
"La deserializaci√≥n garantiza que los datos del contrato Starknet se transformen adecuadamente para su uso frontend. Este proceso implica decodificar la matriz de `felt252`s en cadenas extensas."

#: src/ch02-10-02-million-dollar-homepage.md:196
msgid ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"
msgstr ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:211
msgid ""
"Furthermore, the Grid component manages the cell selection process, leading to the minting of a corresponding token. Once an area is chosen, a modal appears displaying the mint details and other "
"necessary inputs for the call data. The intricacies of the multicall will be addressed subsequently."
msgstr ""
"Adem√°s, el componente Grid gestiona el proceso de selecci√≥n de celdas, lo que lleva a la acu√±aci√≥n del token correspondiente. Una vez que se elige un √°rea, aparece un modal que muestra los detalles "
"de la menta y otras entradas necesarias para los datos de la llamada. Las complejidades de la multillamada se abordar√°n m√°s adelante."

#: src/ch02-10-02-million-dollar-homepage.md:213
msgid "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-02-million-dollar-homepage.md:215
msgid "#### Modals"
msgstr "#### Modals"

#: src/ch02-10-02-million-dollar-homepage.md:217
msgid "Modals offer a convenient means to present varied functionalities within the app, such as wallet connection, token minting, and token editing."
msgstr "Los modales ofrecen un medio conveniente para presentar diversas funcionalidades dentro de la aplicaci√≥n, como conexi√≥n de billetera, acu√±aci√≥n de tokens y edici√≥n de tokens."

#: src/ch02-10-02-million-dollar-homepage.md:219
msgid "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-wallets.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-wallets.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-02-million-dollar-homepage.md:221
msgid "A recognized best practice is to invoke the React hook for shared information at a top-level, ensuring components like the `WalletBar` remain streamlined and focused."
msgstr "Una mejor pr√°ctica reconocida es invocar el hook de React para informaci√≥n compartida en un nivel superior, asegurando que componentes como `WalletBar` permanezcan optimizados y enfocados."

#: src/ch02-10-02-million-dollar-homepage.md:223
msgid ""
"```typescript\n"
"const { address } = useAccount();\n"
"\n"
"return (\n"
"    ...\n"
"    <WalletBar account={address} />\n"
"    ...\n"
")\n"
"```"
msgstr ""
"```typescript\n"
"const { address } = useAccount();\n"
"\n"
"return (\n"
"    ...\n"
"    <WalletBar account={address} />\n"
"    ...\n"
")\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:233
msgid ""
"Below, the `WalletConnected` function displays the connected wallet's address, while the `ConnectWallet` function allows users to select and connect their wallet. The `WalletBar` function renders "
"the appropriate modal based on the connection status."
msgstr ""
"A continuaci√≥n, la funci√≥n`WalletConnected`  muestra la direcci√≥n de la billetera conectada, mientras que la funci√≥n `ConnectWallet` permite a los usuarios seleccionar y conectar su billetera. La "
"funci√≥n `WalletBar` muestra el modal apropiado seg√∫n el estado de la conexi√≥n."

#: src/ch02-10-02-million-dollar-homepage.md:235
msgid ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet />;\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet />;\n"
"}\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:317
msgid "#### Token Dropdown"
msgstr "#### Token Dropdown"

#: src/ch02-10-02-million-dollar-homepage.md:319
msgid ""
"The dropdown component is dedicated to showcasing the tokens associated with the currently connected wallet. To retrieve these tokens, a transaction like the one shown below can be executed. The "
"sole argument for this function is the contract address of the intended owner."
msgstr ""
"El componente desplegable (dropdown) est√° dedicado a mostrar los tokens asociados con la billetera actualmente conectada. Para recuperar estos tokens, se puede ejecutar una transacci√≥n como la que "
"se muestra a continuaci√≥n. El √∫nico argumento para esta funci√≥n es la direcci√≥n contractual del propietario previsto."

#: src/ch02-10-02-million-dollar-homepage.md:321
msgid ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"
msgstr ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:335
msgid "### Multicall Contract Interaction"
msgstr "### Interacci√≥n de Contrato con Multicall"

#: src/ch02-10-02-million-dollar-homepage.md:337
msgid ""
"The provided code offers an illustration of a multicall, specifically to approve a transaction for the mint price transfer followed by the actual minting action. Notably, the `shortString` module "
"from `starknet.js` plays a pivotal role; it encodes and segments a lengthy string into an array of `felt252`s, the expected argument type for the contract on Starknet."
msgstr ""
"El c√≥digo proporcionado ofrece una ilustraci√≥n de una llamada m√∫ltiple, espec√≠ficamente para aprobar una transacci√≥n para la transferencia del precio de acu√±aci√≥n seguida de la acci√≥n de acu√±aci√≥n "
"real. En particular, el m√≥dulo `shortString` de `starknet.js` juega un papel fundamental; codifica y segmenta una cadena larga en una matriz de `felt252`s, el tipo de argumento esperado para el "
"contrato en Starknet."

#: src/ch02-10-02-million-dollar-homepage.md:339
msgid "The `useContractWrite` is a Hook dedicated to executing a Starknet multicall, which can be employed for a singular transaction or multiple ones."
msgstr "El `useContractWrite` es un Hook dedicado a ejecutar una multillamada de Starknet, que puede emplearse para una transacci√≥n singular o varias."

#: src/ch02-10-02-million-dollar-homepage.md:341
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"
msgstr ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:372
msgid ""
"Another crucial aspect to point out is the `calldata` of the approve function for the ether transfer: calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`. The amount argument is "
"split into two parts because it's a `u256`, which is composed of two separate `felt252` values."
msgstr ""
"Otro aspecto crucial a destacar es el `calldata` de la funci√≥n de aprobaci√≥n para la transferencia de ether: calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`. El argumento de la "
"cantidad se divide en dos partes porque es un \"u256\", que se compone de dos valores \"felt252\" separados."

#: src/ch02-10-02-million-dollar-homepage.md:374
msgid "Once the multicall is prepared, the next step is to initiate the function and sign the transaction using the connected wallet."
msgstr "Una vez preparada la multillamada, el siguiente paso es iniciar la funci√≥n y firmar la transacci√≥n utilizando la billetera conectada."

#: src/ch02-10-02-million-dollar-homepage.md:376
msgid ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:394
msgid "### Conditional Multicall for Token Editing"
msgstr "### Multicall Condicional para Edici√≥n de Tokens"

#: src/ch02-10-02-million-dollar-homepage.md:396
msgid "Another instructive illustration of a conditional multicall setup is the modal used to modify the data associated with a token."
msgstr "Otro ejemplo instructivo de una configuraci√≥n de multicall condicional es el modal utilizado para modificar los datos asociados con un token."

#: src/ch02-10-02-million-dollar-homepage.md:398
msgid "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage-edit.jpg\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage-edit.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-10-02-million-dollar-homepage.md:400
msgid ""
"There are scenarios where the user may wish to alter just one attribute of the token, rather than both. Consequently, a conditional multicall configuration becomes necessary. It's essential to "
"recall that the token id in the Cairo contract is defined as a `u256`, implying it comprises two `felt252` values."
msgstr ""
"Hay escenarios en los que el usuario puede desear modificar solo un atributo del token, en lugar de ambos. En consecuencia, se hace necesaria una configuraci√≥n de multillamada condicional. Es "
"esencial recordar que la identificaci√≥n del token en el contrato de El Cairo se define como \"u256\", lo que implica que comprende dos valores \"felt252\"."

#: src/ch02-10-02-million-dollar-homepage.md:402
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"
msgstr ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:430
msgid "## Starknet Homepage Overview"
msgstr "## Starknet Homepage Overview"

#: src/ch02-10-02-million-dollar-homepage.md:432
msgid ""
"- **Grid Component**: Represents a 100x100 matrix, allowing users to select cells and mint corresponding tokens. It fetches existing tokens using the `getAllTokens` function from the contract and "
"displays them.\n"
"- **Modals**: Serve as the user interface for actions like wallet connection, token minting, and token editing.\n"
"- **Token Dropdown**: Displays tokens associated with a connected wallet. It retrieves these tokens using the `getTokensByOwner` function.\n"
"- **Multicall Contract Interaction**: Enables token minting and editing. This process utilizes conditional multicalls based on user preferences, especially for editing token attributes."
msgstr ""
"- **Grid Component**: Representa una matriz de 100x100, que permite a los usuarios seleccionar celdas y acu√±ar los tokens correspondientes. Obtiene tokens existentes utilizando la funci√≥n "
"`getAllTokens` del contrato y los muestra.\n"
"- **Modales**: Sirve como interfaz de usuario para acciones como conexi√≥n de billetera, acu√±aci√≥n de tokens y edici√≥n de tokens.\n"
"- **Desplegable de tokens**: Muestra los tokens asociados con una billetera conectada. Recupera estos tokens utilizando la funci√≥n `getTokensByOwner`.\n"
"- **Interacci√≥n de contrato de Multicall**: Permite la acu√±aci√≥n y edici√≥n de tokens. Este proceso utiliza multicall condicionales basadas en las preferencias del usuario, especialmente para editar "
"atributos de token."

#: src/ch02-10-02-million-dollar-homepage.md:437
msgid ""
"Throughout the platform, string limitations in Cairo contracts require encoding lengthy strings into arrays of `felt252`s. The OpenZeppelin Cairo Contracts library significantly expedites the "
"development of the ERC721 contract for the Starknet Homepage."
msgstr ""
"En toda la plataforma, las limitaciones de cadenas en los contratos de Cairo requieren codificar cadenas largas en matrices de `felt252`s. La biblioteca OpenZeppelin Cairo Contracts acelera "
"significativamente el desarrollo del contrato ERC721 para la p√°gina de inicio de Starknet."

#: src/ch02-11-starknet-py.md:1
msgid "# Starknet-py: Python SDK üöß"
msgstr "# Starknet-py: Python SDK üöß"

#: src/ch02-11-starknet-py.md:3
msgid ""
"Starknet.py is a Python SDK designed for integrating websites, decentralized applications, backends, and more, with Starknet. It serves as a bridge, enabling smooth interaction between your "
"application and the Starknet blockchain."
msgstr ""
"Starknet.py es un SDK de Python dise√±ado para integrar sitios web, aplicaciones descentralizadas, backends, y m√°s, con Starknet. Sirve de puente, permitiendo una interacci√≥n fluida entre tu "
"aplicaci√≥n y la blockchain de Starknet."

#: src/ch02-11-starknet-py.md:5
msgid ""
"- For detailed information, documentation, and getting started guides, visit the [Starknet.py documentation](https://starknetpy.readthedocs.io/en/latest/).\n"
"- To access the source code, contribute, or view the latest updates, check out the [Starknet.py GitHub repository](https://github.com/software-mansion/starknet.py).\n"
"- For community support, discussions, and staying connected with other developers, join the Starknet Discord community. Look for the `üêçstarknet-py` channel in [Starknet Discord](https://discord.gg/"
"qypnmzkhbc)."
msgstr ""
"- Para obtener informaci√≥n detallada, documentaci√≥n y gu√≠as de inicio, visita [Starknet.py documentation](https://starknetpy.readthedocs.io/en/latest/).\n"
"- Para acceder al c√≥digo fuente, contribuir o ver las √∫ltimas actualizaciones, visita el repositorio [Starknet.py GitHub repository](https://github.com/software-mansion/starknet.py).\n"
"- Para soporte comunitario, discusiones y estar conectado con otros desarrolladores, √∫nete a la comunidad Discord de Starknet. Busca el canal `üêçstarknet-py` en [Starknet Discord](https://discord.gg/"
"qypnmzkhbc)."

#: src/ch02-12-starknet-rs.md:1
msgid "# Starknet-rs: Rust SDK üöß"
msgstr "# Starknet-rs: Rust SDK üöß"

#: src/ch02-13-foundry-forge.md:1
msgid "# Foundry Forge: Testing"
msgstr "# Foundry Forge: Testing"

#: src/ch02-13-foundry-forge.md:3
msgid ""
"Merely deploying contracts is not the end game. Many tools have offered this capability in the past. Forge sets itself apart by hosting a Cairo VM instance, enabling the sequential execution of "
"tests. It employs Scarb for contract compilation."
msgstr ""
"Simplemente desplegar contratos no es el objetivo final. Muchas herramientas han ofrecido esta capacidad en el pasado. Forge se distingue por alojar una instancia de Cairo VM, lo que permite la "
"ejecuci√≥n secuencial de pruebas. Emplea Scarb para la compilaci√≥n de contratos."

#: src/ch02-13-foundry-forge.md:5
msgid ""
"To utilize Forge, define test functions and label them with test attributes. Users can either test standalone Cairo functions or integrate contracts, dispatchers, and test contract interactions on-"
"chain."
msgstr ""
"Para utilizar Forge, defina funciones de prueba y etiqu√©telas con atributos de prueba. Los usuarios pueden probar funciones independientes de Cairo o integrar contratos, despachadores y probar "
"interacciones de contratos en cadena."

#: src/ch02-13-foundry-forge.md:7
msgid "## `snForge` Command-Line Usage"
msgstr "## `snForge` Uso de la L√≠nea de Comandos"

#: src/ch02-13-foundry-forge.md:9
msgid "This section guides you through the Starknet Foundry `snforge` command-line tool. Learn how to set up a new project, compile the code, and execute tests."
msgstr "Esta secci√≥n le guiar√° a trav√©s de la herramienta de l√≠nea de comandos `snforge` de Starknet Foundry. Aprende a configurar un nuevo proyecto, compilar el c√≥digo y ejecutar pruebas."

#: src/ch02-13-foundry-forge.md:11
msgid "To start a new project with Starknet Foundry, use the `--init` command and replace `project_name` with your project's name."
msgstr "Para iniciar un nuevo proyecto con Starknet Foundry, utilice el comando `--init` y sustituya `project_name` por el nombre de su proyecto."

#: src/ch02-13-foundry-forge.md:13
msgid ""
"```shell\n"
"snforge --init project_name\n"
"```"
msgstr ""
"```shell\n"
"snforge --init project_name\n"
"```"

#: src/ch02-13-foundry-forge.md:17
msgid "Once you've set up the project, inspect its layout:"
msgstr "Una vez que hayas configurado el proyecto, inspecciona su dise√±o:"

#: src/ch02-13-foundry-forge.md:19
msgid ""
"```shell\n"
"cd project_name\n"
"tree . -L 1\n"
"```"
msgstr ""
"```shell\n"
"cd project_name\n"
"tree . -L 1\n"
"```"

#: src/ch02-13-foundry-forge.md:24
msgid "The project structure is as follows:"
msgstr "La estructura del proyecto es la siguiente:"

#: src/ch02-13-foundry-forge.md:26
msgid ""
"```shell\n"
".\n"
"‚îú‚îÄ‚îÄ README.md\n"
"‚îú‚îÄ‚îÄ Scarb.toml\n"
"‚îú‚îÄ‚îÄ src\n"
"‚îî‚îÄ‚îÄ tests\n"
"```"
msgstr ""
"```shell\n"
".\n"
"‚îú‚îÄ‚îÄ README.md\n"
"‚îú‚îÄ‚îÄ Scarb.toml\n"
"‚îú‚îÄ‚îÄ src\n"
"‚îî‚îÄ‚îÄ tests\n"
"```"

#: src/ch02-13-foundry-forge.md:34
msgid ""
"- `src/` holds your contract source code.\n"
"- `tests/` is the location of your test files.\n"
"- `Scarb.toml` is for project and **`snforge`** configurations."
msgstr ""
"- `src/` contiene el c√≥digo fuente del contrato.\n"
"- `tests/` es la ubicaci√≥n de tus archivos de prueba.\n"
"- `Scarb.toml` es para las configuraciones del proyecto y **`snforge`**."

#: src/ch02-13-foundry-forge.md:38
msgid "Ensure the CASM code generation is active in the `Scarb.toml` file:"
msgstr "Aseg√∫rese de que la generaci√≥n de c√≥digo CASM est√° activa en el archivo `Scarb.toml`:"

#: src/ch02-13-foundry-forge.md:40
msgid ""
"```shell\n"
"# ...\n"
"[[target.starknet-contract]]\n"
"casm = true\n"
"# ...\n"
"```"
msgstr ""
"```shell\n"
"# ...\n"
"[[target.starknet-contract]]\n"
"casm = true\n"
"# ...\n"
"```"

#: src/ch02-13-foundry-forge.md:47
msgid "To run tests using `snforge`:"
msgstr "Para realizar pruebas con `snforge`:"

#: src/ch02-13-foundry-forge.md:49
msgid ""
"```shell\n"
"snforge\n"
"\n"
"Collected 2 test(s) from the `test_name` package\n"
"Running 0 test(s) from `src/`\n"
"Running 2 test(s) from `tests/`\n"
"[PASS] tests::test_contract::test_increase_balance\n"
"[PASS] tests::test_contract::test_cannot_increase_balance_with_zero_value\n"
"Tests: 2 passed, 0 failed, 0 skipped\n"
"```"
msgstr ""
"```shell\n"
"snforge\n"
"\n"
"Collected 2 test(s) from the `test_name` package\n"
"Running 0 test(s) from `src/`\n"
"Running 2 test(s) from `tests/`\n"
"[PASS] tests::test_contract::test_increase_balance\n"
"[PASS] tests::test_contract::test_cannot_increase_balance_with_zero_value\n"
"Tests: 2 passed, 0 failed, 0 skipped\n"
"```"

#: src/ch02-13-foundry-forge.md:60
msgid "## Integrating `snforge` with Existing Scarb Projects"
msgstr "## Integraci√≥n de `snforge` con proyectos Scarb existentes"

#: src/ch02-13-foundry-forge.md:62
msgid ""
"For those with an established Scarb project who wish to incorporate `snforge`, ensure the `snforge_std package` is declared as a dependency. Insert the line below in the [dependencies] section of "
"your `Scarb.toml`:"
msgstr ""
"Para aquellos con un proyecto Scarb establecido que deseen incorporar `snforge`, aseg√∫rese de que el paquete `snforge_std` se declara como una dependencia. Inserte la siguiente l√≠nea en la secci√≥n "
"[dependencies] de su `Scarb.toml`:"

#: src/ch02-13-foundry-forge.md:64
msgid ""
"```shell\n"
"# ...\n"
"[dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"[VERSION]\" }\n"
"```"
msgstr ""
"```shell\n"
"# ...\n"
"[dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"[VERSION]\" }\n"
"```"

#: src/ch02-13-foundry-forge.md:70
msgid "Ensure the tag version corresponds with your `snforge` version. To verify your `snforge` version:"
msgstr "Aseg√∫rese de que la versi√≥n de la etiqueta se corresponde con su versi√≥n de `snforge`. Para verificar la versi√≥n de `snforge`:"

#: src/ch02-13-foundry-forge.md:72
msgid ""
"```sh\n"
"snforge --version\n"
"```"
msgstr ""
"```sh\n"
"snforge --version\n"
"```"

#: src/ch02-13-foundry-forge.md:76
msgid "Or, add this dependency using the `scarb` command:"
msgstr "O a√±ada esta dependencia mediante el comando `scarb`:"

#: src/ch02-13-foundry-forge.md:78
msgid ""
"```shell\n"
"scarb add snforge_std --git https://github.com/foundry-rs/starknet-foundry.git --tag VERSION\n"
"```"
msgstr ""
"```shell\n"
"scarb add snforge_std --git https://github.com/foundry-rs/starknet-foundry.git --tag VERSION\n"
"```"

#: src/ch02-13-foundry-forge.md:82
msgid "With these steps, your existing Scarb project is now **`snforge`**-ready."
msgstr "Con estos pasos, su proyecto Scarb ya est√° listo para **`snforge`**."

#: src/ch02-13-foundry-forge.md:84
msgid "## Testing with `snforge`"
msgstr "## Testing con `snforge`"

#: src/ch02-13-foundry-forge.md:86
msgid "Utilize Starknet Foundry's `snforge` command to efficiently run tests."
msgstr "Utilice el comando `snforge` de Starknet Foundry para ejecutar pruebas de forma eficaz."

#: src/ch02-13-foundry-forge.md:88
msgid "### Executing Tests"
msgstr "### Ejecutando Tests"

#: src/ch02-13-foundry-forge.md:90
msgid "Navigate to the package directory and issue this command to run tests:"
msgstr "Navegue hasta el directorio del paquete y ejecute este comando para realizar los tests:"

#: src/ch02-13-foundry-forge.md:92
msgid ""
"```shell\n"
"snforge\n"
"```"
msgstr ""
"```shell\n"
"snforge\n"
"```"

#: src/ch02-13-foundry-forge.md:96
msgid "Sample output might resemble:"
msgstr "La salida de ejemplo podr√≠a parecerse:"

#: src/ch02-13-foundry-forge.md:98
msgid ""
"```shell\n"
"Collected 3 test(s) from `package_name` package\n"
"Running 3 test(s) from `src/`\n"
"[PASS] package_name::executing\n"
"[PASS] package_name::calling\n"
"[PASS] package_name::calling_another\n"
"Tests: 3 passed, 0 failed, 0 skipped\n"
"```"
msgstr ""
"```shell\n"
"Collected 3 test(s) from `package_name` package\n"
"Running 3 test(s) from `src/`\n"
"[PASS] package_name::executing\n"
"[PASS] package_name::calling\n"
"[PASS] package_name::calling_another\n"
"Tests: 3 passed, 0 failed, 0 skipped\n"
"```"

#: src/ch02-13-foundry-forge.md:107
msgid "## Example: Testing a Simple Contract"
msgstr "## Ejemplo: Testing de un Contrato Simple"

#: src/ch02-13-foundry-forge.md:109
msgid "The example provided below demonstrates how to test a Starknet contract using `snforge`."
msgstr "El siguiente ejemplo muestra c√≥mo probar un contrato Starknet utilizando `snforge`."

#: src/ch02-13-foundry-forge.md:111
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        // Increases the balance by the specified amount.\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"\n"
"        // Returns the balance.\n"
"\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IHelloStarknet<TContractState> {\n"
"    fn increase_balance(ref self: TContractState, amount: felt252);\n"
"    fn get_balance(self: @TContractState) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloStarknet {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: felt252,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
"        // Increases the balance by the specified amount.\n"
"        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
"            self.balance.write(self.balance.read() + amount);\n"
"        }\n"
"\n"
"        // Returns the balance.\n"
"\n"
"        fn get_balance(self: @ContractState) -> felt252 {\n"
"            self.balance.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-13-foundry-forge.md:141
msgid "Remember, the identifier following `mod` signifies the contract name. Here, the contract name is `HelloStarknet`."
msgstr "Recuerde que el identificador que sigue a `mod` significa el nombre del contrato. En este caso, el nombre del contrato es `HelloStarknet`."

#: src/ch02-13-foundry-forge.md:143
msgid "### Craft the Test"
msgstr "### Elaborar el Test"

#: src/ch02-13-foundry-forge.md:145
msgid "Below is a test for the **`HelloStarknet`** contract. This test deploys **`HelloStarknet`** and interacts with its functions:"
msgstr "A continuaci√≥n se muestra una prueba para el contrato **`HelloStarknet`**. Este test despliega **`HelloStarknet`** e interact√∫a con sus funciones:"

#: src/ch02-13-foundry-forge.md:147
msgid ""
"```rust\n"
"use snforge_std::{ declare, ContractClassTrait };\n"
"\n"
"#[test]\n"
"fn call_and_invoke() {\n"
"    // Declare and deploy the contract\n"
"    let contract = declare('HelloStarknet');\n"
"    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"    // Instantiate a Dispatcher object for contract interactions\n"
"    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"    // Invoke a contract's view function\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 0, 'balance == 0');\n"
"\n"
"    // Invoke another function to modify the storage state\n"
"    dispatcher.increase_balance(100);\n"
"\n"
"    // Validate the transaction's effect\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 100, 'balance == 100');\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use snforge_std::{ declare, ContractClassTrait };\n"
"\n"
"#[test]\n"
"fn call_and_invoke() {\n"
"    // Declare and deploy the contract\n"
"    let contract = declare('HelloStarknet');\n"
"    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
"\n"
"    // Instantiate a Dispatcher object for contract interactions\n"
"    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"    // Invoke a contract's view function\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 0, 'balance == 0');\n"
"\n"
"    // Invoke another function to modify the storage state\n"
"    dispatcher.increase_balance(100);\n"
"\n"
"    // Validate the transaction's effect\n"
"    let balance = dispatcher.get_balance();\n"
"    assert(balance == 100, 'balance == 100');\n"
"}\n"
"```"

#: src/ch02-13-foundry-forge.md:172
msgid "To run the test, execute the `snforge` command. The expected output is:"
msgstr "Para realizar la prueba, ejecute el comando `snforge`. La salida esperada es:"

#: src/ch02-13-foundry-forge.md:174
msgid ""
"```shell\n"
"Collected 1 test(s) from using_dispatchers package\n"
"Running 1 test(s) from src/\n"
"[PASS] using_dispatchers::call_and_invoke\n"
"Tests: 1 passed, 0 failed, 0 skipped\n"
"```"
msgstr ""
"```shell\n"
"Collected 1 test(s) from using_dispatchers package\n"
"Running 1 test(s) from src/\n"
"[PASS] using_dispatchers::call_and_invoke\n"
"Tests: 1 passed, 0 failed, 0 skipped\n"
"```"

#: src/ch02-13-foundry-forge.md:181
msgid "## Example: Testing ERC20 Contract"
msgstr "## Ejemplo: Testing del Contrato ERC20"

#: src/ch02-13-foundry-forge.md:183
msgid ""
"There are several methods to test smart contracts, such as unit tests, integration tests, fuzz tests, fork tests, E2E tests, and using foundry cheatcodes. This section discusses testing an ERC20 "
"example contract from the `starknet-js` subchapter examples using unit and integration tests, filtering, foundry cheatcodes, and fuzz tests through the `snforge` CLI."
msgstr ""
"Hay varios m√©todos para probar los smart contracts, tales como test unitarios, test de integraci√≥n, test fuzz, test de bifurcaci√≥n, test E2E, y el uso de chetacode de la fundici√≥n. Esta secci√≥n "
"discute los test de un contrato de ejemplo ERC20 de los ejemplos del subcap√≠tulo `starknet-js` utilizando test unitarios y de integraci√≥n, filtrado, foundry cheatcodes, y pruebas fuzz a trav√©s de "
"la CLI `snforge`."

#: src/ch02-13-foundry-forge.md:185
msgid "## ERC20 Contract Example"
msgstr "## Ejemplo de Contrato ERC20"

#: src/ch02-13-foundry-forge.md:187
msgid ""
"After setting up your foundry project, add the following dependency to your `Scarb.toml` (in this case we are using version 0.7.0 of the OpenZeppelin Cairo contracts, but you can use any version "
"you want):"
msgstr ""
"Despu√©s de configurar tu proyecto foundry, a√±ade la siguiente dependencia a tu `Scarb.toml` (en este caso estamos usando la versi√≥n 0.7.0 de los contratos OpenZeppelin Cairo, pero puedes usar "
"cualquier versi√≥n que desees):"

#: src/ch02-13-foundry-forge.md:189
msgid ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"```"
msgstr ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"```"

#: src/ch02-13-foundry-forge.md:193
msgid "Here's a basic ERC20 contract:"
msgstr "He aqu√≠ un contrato ERC20 b√°sico:"

#: src/ch02-13-foundry-forge.md:195
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait Ierc20<TContractState> {\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: felt252,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply.into());\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl Ierc20Impl of super::Ierc20<ContractState> {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait Ierc20<TContractState> {\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use starknet::ContractAddress;\n"
"    use openzeppelin::token::erc20::ERC20;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        initial_supply: felt252,\n"
"        recipient: ContractAddress\n"
"    ) {\n"
"        let name = 'MyToken';\n"
"        let symbol = 'MTK';\n"
"\n"
"        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
"        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply.into());\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl Ierc20Impl of super::Ierc20<ContractState> {\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
"            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-13-foundry-forge.md:241
msgid "This contract allows minting tokens to a recipient during deployment, checking balances, and transferring tokens, relying on the openzeppelin ERC20 library."
msgstr "Este contrato permite mintear tokens a un destinatario durante el despliegue, comprobar saldos y transferir tokens, bas√°ndose en la biblioteca ERC20 de openzeppelin."

#: src/ch02-13-foundry-forge.md:243
msgid "### Test Preparation"
msgstr "### Preparaci√≥n del Test"

#: src/ch02-13-foundry-forge.md:245
msgid "Organize your test file and include the required imports:"
msgstr "Organice su archivo de test e incluya las importaciones necesarias:"

#: src/ch02-13-foundry-forge.md:247
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use array::ArrayTrait;\n"
"    use result::ResultTrait;\n"
"    use option::OptionTrait;\n"
"    use traits::TryInto;\n"
"    use starknet::ContractAddress;\n"
"    use starknet::Felt252TryIntoContractAddress;\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"    // Additional code here.\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use array::ArrayTrait;\n"
"    use result::ResultTrait;\n"
"    use option::OptionTrait;\n"
"    use traits::TryInto;\n"
"    use starknet::ContractAddress;\n"
"    use starknet::Felt252TryIntoContractAddress;\n"
"    use snforge_std::{declare, ContractClassTrait};\n"
"    // Additional code here.\n"
"}\n"
"```"

#: src/ch02-13-foundry-forge.md:261
msgid "For testing, you'll need a helper function to deploy the contract instance. This function requires a `supply` amount and `recipient` address:"
msgstr "Para los test, necesitar√° una funci√≥n de ayuda para desplegar la instancia del contrato. Esta funci√≥n requiere una cantidad de `supply` y una direcci√≥n de `recipient`:"

#: src/ch02-13-foundry-forge.md:263
msgid ""
"```rust\n"
"use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"fn deploy_contract(name: felt252) -> ContractAddress {\n"
"    let recipient = starknet::contract_address_const::<0x01>();\n"
"    let supply: felt252 = 20000000;\n"
"    let contract = declare(name);\n"
"    let mut calldata = array![supply, recipient.into()];\n"
"    contract.deploy(@calldata).unwrap()\n"
"}\n"
"// Additional code here.\n"
"```"
msgstr ""
"```rust\n"
"use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"fn deploy_contract(name: felt252) -> ContractAddress {\n"
"    let recipient = starknet::contract_address_const::<0x01>();\n"
"    let supply: felt252 = 20000000;\n"
"    let contract = declare(name);\n"
"    let mut calldata = array![supply, recipient.into()];\n"
"    contract.deploy(@calldata).unwrap()\n"
"}\n"
"// Additional code here.\n"
"```"

#: src/ch02-13-foundry-forge.md:276
msgid "Use `declare` and `ContractClassTrait` from `snforge_std`. Then, initialize the `supply` and `recipient`, declare the contract, compute the calldata, and deploy."
msgstr "Utiliza `declare` y `ContractClassTrait` de `snforge_std`. A continuaci√≥n, inicializa el `supply` y el `recipient`, declara el contrato, calcula los calldata y despliega."

#: src/ch02-13-foundry-forge.md:278
msgid "### Writing the Test Cases"
msgstr "### Escribir los Casos de Test"

#: src/ch02-13-foundry-forge.md:280
msgid "#### Verifying the Balance After Deployment"
msgstr "#### Verificaci√≥n del Balance Despu√©s del Deployment"

#: src/ch02-13-foundry-forge.md:282
msgid "To begin, test the deployment helper function to confirm the recipient's balance:"
msgstr "Para empezar, pruebe la funci√≥n de ayuda al despliegue para confirmar el balance del destinatario:"

#: src/ch02-13-foundry-forge.md:284
msgid ""
"```rust\n"
"    // ...\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_balance_of() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"        let recipient = starknet::contract_address_const::<0x01>();\n"
"        let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"        assert(balance == 20000000, 'Invalid Balance');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    // ...\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"    use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_balance_of() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"        let recipient = starknet::contract_address_const::<0x01>();\n"
"        let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"        assert(balance == 20000000, 'Invalid Balance');\n"
"    }\n"
"```"

#: src/ch02-13-foundry-forge.md:300
msgid "Execute `snforge` to verify:"
msgstr "Ejecute `snforge` para verificarlo:"

#: src/ch02-13-foundry-forge.md:302
msgid ""
"```shell\n"
"Collected 1 test from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"```"
msgstr ""
"```shell\n"
"Collected 1 test from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"```"

#: src/ch02-13-foundry-forge.md:307
msgid "#### Utilizing Foundry Cheat Codes"
msgstr ""
"#### Utilizando los Cheat Codes\n"
" de Foundry"

#: src/ch02-13-foundry-forge.md:309
msgid ""
"When testing smart contracts, simulating different conditions is essential. `Foundry Cheat Codes` from the `snforge_std` library offer these simulation capabilities for Starknet smart contracts."
msgstr ""
"Cuando se prueban contratos inteligentes, es esencial simular diferentes condiciones. Los `Foundry Cheat Codes` de la biblioteca `snforge_std` ofrecen estas capacidades de simulaci√≥n para los smart "
"contracts de Starknet."

#: src/ch02-13-foundry-forge.md:311
msgid ""
"These cheat codes consist of helper functions that adjust the smart contract's environment. They allow developers to modify parameters or conditions to examine contract behavior in specific "
"scenarios."
msgstr ""
"Estos cheat codes consisten en funciones de ayuda que ajustan el entorno del smart contract. Permiten a los desarrolladores modificar par√°metros o condiciones para examinar el comportamiento del "
"contrato en escenarios espec√≠ficos."

#: src/ch02-13-foundry-forge.md:313
msgid ""
"Using `snforge_std`'s cheat codes, you can change elements like block numbers, timestamps, or even the caller of a function. This guide focuses on `start_prank` and `stop_prank`. You can find a "
"reference to available cheat codes [here](https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html)"
msgstr ""
"Usando los cheat codes de `snforge_std`, puedes cambiar elementos como n√∫meros de bloque, timestamps, o incluso el invocador de una funci√≥n. Esta gu√≠a se centra en `start_prank` y `stop_prank`. "
"Puedes encontrar una referencia a los c√≥digos de trucos disponibles [aqu√≠](https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html)"

#: src/ch02-13-foundry-forge.md:315
msgid "Below is a transfer test example:"
msgstr "A continuaci√≥n se muestra un ejemplo de test de transferencia:"

#: src/ch02-13-foundry-forge.md:317
msgid ""
"```rust\n"
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_transfer() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"        let sender = starknet::contract_address_const::<0x01>();\n"
"        let receiver = starknet::contract_address_const::<0x02>();\n"
"        let amount : felt252 = 10000000;\n"
"\n"
"        // Set the function's caller\n"
"        start_prank(contract_address, sender);\n"
"        safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"\n"
"        let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"        assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"\n"
"        // End the prank\n"
"        stop_prank(contract_address);\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_transfer() {\n"
"        let contract_address = deploy_contract('erc20');\n"
"        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"        let sender = starknet::contract_address_const::<0x01>();\n"
"        let receiver = starknet::contract_address_const::<0x02>();\n"
"        let amount : felt252 = 10000000;\n"
"\n"
"        // Set the function's caller\n"
"        start_prank(contract_address, sender);\n"
"        safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"\n"
"        let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"        assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"\n"
"        // End the prank\n"
"        stop_prank(contract_address);\n"
"    }\n"
"```"

#: src/ch02-13-foundry-forge.md:342
msgid "Executing `snforge` for the tests displays:"
msgstr "Ejecutando `snforge` para las pruebas muestra:"

#: src/ch02-13-foundry-forge.md:344
msgid ""
"```shell\n"
"Collected 2 tests from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"[PASS] tests::test_erc20::test_transfer\n"
"```"
msgstr ""
"```shell\n"
"Collected 2 tests from erc20_contract package\n"
"[PASS] tests::test_erc20::test_balance_of\n"
"[PASS] tests::test_erc20::test_transfer\n"
"```"

#: src/ch02-13-foundry-forge.md:350
msgid "In this example, `start_prank` determines the transfer function's caller, while `stop_prank` concludes the prank."
msgstr "En este ejemplo, `start_prank` determina el llamador de la funci√≥n de transferencia, mientras que `stop_prank` concluye el prank."

#: src/ch02-13-foundry-forge.md:352
msgid ""
"<details>\n"
"<summary>Full `ERC20 test example` file</summary>\n"
"        #[cfg(test)]\n"
"        mod tests {\n"
"        use array::ArrayTrait;\n"
"        use result::ResultTrait;\n"
"        use option::OptionTrait;\n"
"        use traits::TryInto;\n"
"        use starknet::ContractAddress;\n"
"        use starknet::Felt252TryIntoContractAddress;"
msgstr ""
"<details>\n"
"<summary>Full `ERC20 test example` file</summary>\n"
"        #[cfg(test)]\n"
"        mod tests {\n"
"        use array::ArrayTrait;\n"
"        use result::ResultTrait;\n"
"        use option::OptionTrait;\n"
"        use traits::TryInto;\n"
"        use starknet::ContractAddress;\n"
"        use starknet::Felt252TryIntoContractAddress;"

#: src/ch02-13-foundry-forge.md:363
msgid ""
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"        fn deploy_contract(name: felt252) -> ContractAddress {\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let supply : felt252 = 20000000;\n"
"            let contract = declare(name);\n"
"            let mut calldata = array![supply, recipient.into()];\n"
"            contract.deploy(@calldata).unwrap()\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_balance_of() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"            assert(balance == 20000000, 'Invalid Balance');\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_transfer() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"            let sender = starknet::contract_address_const::<0x01>();\n"
"            let receiver = starknet::contract_address_const::<0x02>();\n"
"            let amount : felt252 = 10000000;\n"
"\n"
"            start_prank(contract_address, sender);\n"
"            safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"            let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"            assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"            stop_prank(contract_address);\n"
"        }\n"
"        }"
msgstr ""
"    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
"        use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
"\n"
"        fn deploy_contract(name: felt252) -> ContractAddress {\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let supply : felt252 = 20000000;\n"
"            let contract = declare(name);\n"
"            let mut calldata = array![supply, recipient.into()];\n"
"            contract.deploy(@calldata).unwrap()\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_balance_of() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"            let recipient = starknet::contract_address_const::<0x01>();\n"
"            let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
"            assert(balance == 20000000, 'Invalid Balance');\n"
"        }\n"
"\n"
"        #[test]\n"
"        #[available_gas(3000000000000000)]\n"
"        fn test_transfer() {\n"
"            let contract_address = deploy_contract('erc20');\n"
"            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
"\n"
"            let sender = starknet::contract_address_const::<0x01>();\n"
"            let receiver = starknet::contract_address_const::<0x02>();\n"
"            let amount : felt252 = 10000000;\n"
"\n"
"            start_prank(contract_address, sender);\n"
"            safe_dispatcher.transfer(receiver.into(), amount.into());\n"
"            let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
"            assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
"            stop_prank(contract_address);\n"
"        }\n"
"        }"

#: src/ch02-13-foundry-forge.md:403
msgid "</details>"
msgstr "</details>"

#: src/ch02-13-foundry-forge.md:405
msgid "## Fuzz Testing"
msgstr "## Fuzz Testing"

#: src/ch02-13-foundry-forge.md:407
msgid ""
"Fuzz testing introduces random inputs to the code to identify vulnerabilities, security issues, and unforeseen behaviors. While you can manually provide these inputs, automation is preferable when "
"testing a broad set of values. See the example below in `test_fuzz.cairo`:"
msgstr ""
"Las testing fuzz introducen entradas aleatorias en el c√≥digo para identificar vulnerabilidades, problemas de seguridad y comportamientos imprevistos. Aunque puede introducir estas entradas "
"manualmente, la automatizaci√≥n es preferible cuando se prueba un amplio conjunto de valores. V√©ase el ejemplo siguiente en `test_fuzz.cairo`:"

#: src/ch02-13-foundry-forge.md:409
msgid ""
"```rust\n"
"    fn mul(a: felt252, b: felt252) -> felt252 {\n"
"        return a * b;\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn mul(a: felt252, b: felt252) -> felt252 {\n"
"        return a * b;\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"

#: src/ch02-13-foundry-forge.md:420
msgid "Running `snforge` produces:"
msgstr "Ejecutando `snforge` produce:"

#: src/ch02-13-foundry-forge.md:422
msgid ""
"```shell\n"
"    Collected 1 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 1 test(s) from tests/\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 1 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 6375310854403272271\n"
"```"
msgstr ""
"```shell\n"
"    Collected 1 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 1 test(s) from tests/\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 1 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 6375310854403272271\n"
"```"

#: src/ch02-13-foundry-forge.md:431
msgid "The fuzzer supports these types by November 2023:"
msgstr "El fuzzer soporta estos tipos para noviembre de 2023:"

#: src/ch02-13-foundry-forge.md:433
msgid ""
"- u8\n"
"- u16\n"
"- u32\n"
"- u64\n"
"- u128\n"
"- u256\n"
"- felt252"
msgstr ""
"- u8\n"
"- u16\n"
"- u32\n"
"- u64\n"
"- u128\n"
"- u256\n"
"- felt252"

#: src/ch02-13-foundry-forge.md:441
msgid "`Fuzzer Configuration`"
msgstr "`Fuzzer Configuration`"

#: src/ch02-13-foundry-forge.md:443
msgid "You can set the number of runs and the seed for a test:"
msgstr "Puede establecer el n√∫mero de ejecuciones y la seed para un test:"

#: src/ch02-13-foundry-forge.md:445
msgid ""
"```rust\n"
"    #[test]\n"
"    #[fuzzer(runs: 100, seed: 38)]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    #[test]\n"
"    #[fuzzer(runs: 100, seed: 38)]\n"
"    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
"        assert(mul(x, y) == x * y, 'incorrect');\n"
"    }\n"
"```"

#: src/ch02-13-foundry-forge.md:453
msgid "Or, use the command line:"
msgstr "O bien, utilice la l√≠nea de comandos:"

#: src/ch02-13-foundry-forge.md:455
msgid ""
"```shell\n"
"    $ snforge --fuzzer-runs 500 --fuzzer-seed 4656\n"
"```"
msgstr ""
"```shell\n"
"    $ snforge --fuzzer-runs 500 --fuzzer-seed 4656\n"
"```"

#: src/ch02-13-foundry-forge.md:459
msgid "Or in `scarb.toml`:"
msgstr "O en `scarb.toml`:"

#: src/ch02-13-foundry-forge.md:461
msgid ""
"```shell\n"
"    # ...\n"
"    [tool.snforge]\n"
"    fuzzer_runs = 500\n"
"    fuzzer_seed = 4656\n"
"    # ...\n"
"```"
msgstr ""
"```shell\n"
"    # ...\n"
"    [tool.snforge]\n"
"    fuzzer_runs = 500\n"
"    fuzzer_seed = 4656\n"
"    # ...\n"
"```"

#: src/ch02-13-foundry-forge.md:469
msgid "For more insight on fuzz tests, you can view it [here](https://foundry-rs.github.io/starknet-foundry/testing/fuzz-testing.html#fuzz-testing)"
msgstr "Para m√°s informaci√≥n sobre los tests fuzz, puede consultar [aqu√≠](https://foundry-rs.github.io/starknet-foundry/testing/fuzz-testing.html#fuzz-testing)"

#: src/ch02-13-foundry-forge.md:471
msgid "## Filter Tests"
msgstr "## Tests de Filtrado"

#: src/ch02-13-foundry-forge.md:473
msgid "To execute specific tests, use a filter string with the `snforge` command. Tests matching the filter based on their absolute module tree path will be executed."
msgstr "Para ejecutar test espec√≠ficos, utilice una string de filtro con el comando `snforge`. Se ejecutar√°n las pruebas que coincidan con el filtro basado en la ruta absoluta del √°rbol de m√≥dulos."

#: src/ch02-13-foundry-forge.md:475
msgid "For instance, to run all tests with the string 'test\\_' in their name:"
msgstr "Por ejemplo, para ejecutar todas las pruebas con la string 'test\\_' en su nombre:"

#: src/ch02-13-foundry-forge.md:477
msgid ""
"```shell\n"
"snforge test_\n"
"```"
msgstr ""
"```shell\n"
"snforge test_\n"
"```"

#: src/ch02-13-foundry-forge.md:481
msgid "Expected output:"
msgstr "Resultado esperado:"

#: src/ch02-13-foundry-forge.md:483
msgid ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [PASS] tests::test_erc20::tests::test_balance_of\n"
"    [PASS] tests::test_erc20::tests::test_transfer\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 3 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 10426315620495146768\n"
"```"
msgstr ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [PASS] tests::test_erc20::tests::test_balance_of\n"
"    [PASS] tests::test_erc20::tests::test_transfer\n"
"    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
"    Tests: 3 passed, 0 failed, 0 skipped\n"
"    Fuzzer seed: 10426315620495146768\n"
"```"

#: src/ch02-13-foundry-forge.md:494
msgid "All the tests with the string 'test\\_' in their test name went through."
msgstr "Todos los tests con la string 'test\\_' en su nombre pasaron."

#: src/ch02-13-foundry-forge.md:496
msgid "Another example: To filter and run `test_fuzz_sum` we can partially match the test name with the string 'fuzz_sum' like this:"
msgstr "Otro ejemplo: Para filtrar y ejecutar `test_fuzz_sum` podemos hacer coincidir parcialmente el nombre de la prueba con la cadena `fuzz_sum` de esta forma:"

#: src/ch02-13-foundry-forge.md:498
msgid ""
"```shell\n"
"snforge test_fuzz_sum\n"
"```"
msgstr ""
"```shell\n"
"snforge test_fuzz_sum\n"
"```"

#: src/ch02-13-foundry-forge.md:502
msgid "To execute an exact test, combine the `--exact` flag with a fully qualified test name:"
msgstr "Para ejecutar un test exacto, combine el indicador `--exact` con un nombre de prueba completo:"

#: src/ch02-13-foundry-forge.md:504
msgid ""
"```shell\n"
"snforge package_name::test_name --exact\n"
"```"
msgstr ""
"```shell\n"
"snforge package_name::test_name --exact\n"
"```"

#: src/ch02-13-foundry-forge.md:508
msgid "To halt the test suite upon the first test failure, use the `--exit-first` flag:"
msgstr "Para detener el conjunto de test tras el primer fallo, utilice el indicador `--exit-first`:"

#: src/ch02-13-foundry-forge.md:510
msgid ""
"```shell\n"
"snforge --exit-first\n"
"```"
msgstr ""
"```shell\n"
"snforge --exit-first\n"
"```"

#: src/ch02-13-foundry-forge.md:514
msgid "If a test fails, the output will resemble:"
msgstr ""
"Si in test\n"
" falla, la salida ser√° similar:"

#: src/ch02-13-foundry-forge.md:516
msgid ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [FAIL] tests::test_erc20::tests::test_balance_of\n"
"\n"
"    Failure data:\n"
"    original value: [381278114803728420489684244530881381], converted to a string: [Invalid Balance]\n"
"\n"
"    [SKIP] tests::test_erc20::tests::test_transfer\n"
"    [SKIP] tests::test_fuzz::test_fuzz_sum\n"
"    Tests: 0 passed, 1 failed, 2 skipped\n"
"\n"
"    Failures:\n"
"        tests::test_erc20::tests::test_balance_of\n"
"```"
msgstr ""
"```shell\n"
"    Collected 3 test(s) from erc20_contract package\n"
"    Running 0 test(s) from src/\n"
"    Running 3 test(s) from tests/\n"
"    [FAIL] tests::test_erc20::tests::test_balance_of\n"
"\n"
"    Failure data:\n"
"    original value: [381278114803728420489684244530881381], converted to a string: [Invalid Balance]\n"
"\n"
"    [SKIP] tests::test_erc20::tests::test_transfer\n"
"    [SKIP] tests::test_fuzz::test_fuzz_sum\n"
"    Tests: 0 passed, 1 failed, 2 skipped\n"
"\n"
"    Failures:\n"
"        tests::test_erc20::tests::test_balance_of\n"
"```"

#: src/ch02-13-foundry-forge.md:533
msgid "### Conclusion"
msgstr "### Conclusi√≥n"

#: src/ch02-13-foundry-forge.md:535
msgid ""
"Starknet Foundry offers a notable step forward in Starknet contract development and testing. This toolset sharpens the process of creating, deploying, and testing Cairo contracts. Its main "
"components, Forge and Cast, provide developers with robust tools for Cairo contract work."
msgstr ""
"Starknet Foundry ofrece un notable paso adelante en el desarrollo y los tests de contratos de Starknet. Este conjunto de herramientas perfecciona el proceso de creaci√≥n, despliegue y comprobaci√≥n "
"de los contratos de Cairo. Sus componentes principales, Forge y Cast, proporcionan a los desarrolladores herramientas robustas para el trabajo con contratos de Cairo."

#: src/ch02-13-foundry-forge.md:537
msgid ""
"Forge shines with its dual functionality: deploying and thoroughly testing Cairo contracts. It directly supports test writing in Cairo, removing the need for other languages and simplifying the "
"task. Moreover, Forge seamlessly integrates with Scarb, emphasizing its adaptability, especially with existing Scarb projects."
msgstr ""
"Forge brilla por su doble funcionalidad: desplegar y probar a fondo los contratos de Cairo. Soporta directamente la escritura de pruebas en Cairo, eliminando la necesidad de otros lenguajes y "
"simplificando la tarea. Adem√°s, Forge se integra perfectamente con Scarb, destacando su adaptabilidad, especialmente con proyectos Scarb existentes."

#: src/ch02-13-foundry-forge.md:539
msgid "The `snforge` command-line tool makes initializing, setting up, and testing Starknet contracts straightforward."
msgstr "La herramienta de l√≠nea de comandos `snforge` facilita la inicializaci√≥n, configuraci√≥n y comprobaci√≥n de los contratos Starknet."

#: src/ch02-14-security-considerations.md:1
msgid "# Security Considerations"
msgstr "# Consideraciones de Seguridad"

#: src/ch02-14-security-considerations.md:3
msgid "In blockchain programming, understanding and mitigating smart contract vulnerabilities is vital to maintain user trust. This is as true for Cairo as any other language."
msgstr ""
"En la programaci√≥n de blockchain, comprender y mitigar las vulnerabilidades de los smart contract es vital para mantener la confianza de los usuarios. Esto es tan cierto para Cairo como para "
"cualquier otro lenguaje."

#: src/ch02-14-security-considerations.md:5
msgid "We'll cover common security issues and Starknet-specific vulnerabilities in Cairo, along with strategies to safeguard your contracts."
msgstr "Trataremos los problemas de seguridad m√°s comunes y las vulnerabilidades espec√≠ficas de Starknet en Cairo, junto con estrategias para salvaguardar sus contratos."

#: src/ch02-14-security-considerations.md:7
msgid "Your insights can enhance this chapter. To contribute, submit a pull request to the [Book repo](https://github.com/starknet-edu/starknetbook)."
msgstr "Sus ideas pueden mejorar este cap√≠tulo. Para contribuir, env√≠e una solicitud de extracci√≥n al [repositorio del Libro de Starknet](https://github.com/starknet-edu/starknetbook)."

#: src/ch02-14-security-considerations.md:9
msgid "> Note: Some code examples here are simplified pseudo-code, meant for concept explanation, not for production use."
msgstr "> Nota: Algunos ejemplos de c√≥digo aqu√≠ son pseudoc√≥digos simplificados, destinados a la explicaci√≥n de conceptos, no al uso en producci√≥n."

#: src/ch02-14-security-considerations.md:11
msgid "## 1. Access Control"
msgstr "## 1. Control de Acceso"

#: src/ch02-14-security-considerations.md:13
msgid ""
"Access control vulnerabilities occur when a smart contract's functions are insufficiently protected, allowing unauthorized actions. This can result in unexpected behavior and data manipulation."
msgstr ""
"Las vulnerabilidades de control de acceso ocurren cuando las funciones de un smart contract no est√°n suficientemente protegidas, lo que permite acciones no autorizadas. Esto puede dar lugar a "
"comportamientos inesperados y manipulaci√≥n de datos."

#: src/ch02-14-security-considerations.md:15
msgid "Take, for instance, a smart contract for token minting without proper access control:"
msgstr "Tomemos, por ejemplo, un smart contract para la acu√±aci√≥n de tokens sin un control de acceso adecuado:"

#: src/ch02-14-security-considerations.md:17
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Token {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        total_supply: u256, // Stores the total supply of tokens.\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl ITokenImpl of IToken {\n"
"        fn mint_tokens(ref self: ContractState, amount: u256) {\n"
"            // The mint_tokens function updates the total supply.\n"
"            // Without access control, any user can call this function, posing a risk.\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Token {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        total_supply: u256, // Stores the total supply of tokens.\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl ITokenImpl of IToken {\n"
"        fn mint_tokens(ref self: ContractState, amount: u256) {\n"
"            // The mint_tokens function updates the total supply.\n"
"            // Without access control, any user can call this function, posing a risk.\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:36
msgid ""
"In this code, the `mint_tokens` function is vulnerable because any user can call it, leading to potential token supply exploitation. Implementing access controls would restrict this function to "
"authorized users only."
msgstr ""
"En este c√≥digo, la funci√≥n `mint_tokens` es vulnerable porque cualquier usuario puede llamarla, lo que lleva a una posible explotaci√≥n del suministro de tokens. La implementaci√≥n de controles de "
"acceso restringir√≠a esta funci√≥n √∫nicamente a usuarios autorizados."

#: src/ch02-14-security-considerations.md:38
msgid "### Recommendation"
msgstr "### Recomendaci√≥n"

#: src/ch02-14-security-considerations.md:40
msgid ""
"To prevent access control vulnerabilities, integrate authorization mechanisms like role-based access control (RBAC) or ownership checks. You can develop a custom solution or use templates from "
"sources like [OpenZeppelin](https://docs.openzeppelin.com/contracts-cairo/access)."
msgstr ""
"Para evitar vulnerabilidades en el control de acceso, integre mecanismos de autorizaci√≥n como control de acceso basado en roles (RBAC) o comprobaciones de propiedad. Puede desarrollar una soluci√≥n "
"personalizada o utilizar plantillas de fuentes como [OpenZeppelin](https://docs.openzeppelin.com/contracts-cairo/access)."

#: src/ch02-14-security-considerations.md:42
msgid ""
"In our earlier example, we can enhance security by adding an owner variable, initializing the owner in the constructor, and including a verification in the `mint_tokens` function to allow only the "
"owner to mint tokens."
msgstr ""
"En nuestro ejemplo anterior, podemos mejorar la seguridad agregando una variable de owner, inicializando el owner en el constructor e incluyendo una verificaci√≥n en la funci√≥n `mint_tokens` para "
"permitir que solo el owner acu√±e tokens."

#: src/ch02-14-security-considerations.md:44
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Token {\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress, // New variable to store the contract owner's address.\n"
"        total_supply: u256,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState,) {\n"
"        let sender = get_caller_address(); // Get the address of the contract creator.\n"
"        self.owner.write(sender); // Set the creator as the owner.\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl ITokenImpl of IToken {\n"
"        fn mint_tokens(ref self: ContractState, amount: u256) {\n"
"            // Check if the caller is the owner before minting tokens.\n"
"            let sender = get_caller_address();\n"
"            assert(sender == self.owner.read()); // Assert ensures only the owner can mint.\n"
"\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Token {\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        owner: ContractAddress, // New variable to store the contract owner's address.\n"
"        total_supply: u256,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState,) {\n"
"        let sender = get_caller_address(); // Get the address of the contract creator.\n"
"        self.owner.write(sender); // Set the creator as the owner.\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl ITokenImpl of IToken {\n"
"        fn mint_tokens(ref self: ContractState, amount: u256) {\n"
"            // Check if the caller is the owner before minting tokens.\n"
"            let sender = get_caller_address();\n"
"            assert(sender == self.owner.read()); // Assert ensures only the owner can mint.\n"
"\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:73
msgid "By establishing robust access control, you ensure that only authorized entities execute your smart contract functions, significantly reducing the risk of unauthorized interference."
msgstr ""
"Al establecer un control de acceso s√≥lido, se asegura de que solo las entidades autorizadas ejecuten las funciones de su smart contract, lo que reduce significativamente el riesgo de interferencia "
"no autorizada."

#: src/ch02-14-security-considerations.md:75
msgid "## 2. Reentrancy"
msgstr "## 2. Reentrada"

#: src/ch02-14-security-considerations.md:77
msgid ""
"Reentrancy vulnerabilities arise when a smart contract calls an external contract before updating its state. This allows the external contract to recursively call the original function, potentially "
"leading to unintended behavior."
msgstr ""
"Las vulnerabilidades de reentrada (reentrancy) surgen cuando un smart contract llama a un contrato externo antes de actualizar su estado. Esto permite que el contrato externo llame de forma "
"recursiva a la funci√≥n original, lo que podr√≠a provocar un comportamiento no deseado."

#: src/ch02-14-security-considerations.md:79
msgid ""
"Consider a game contract where whitelisted addresses can mint an NFT sword and then execute an `on_receive_sword()` function before returning it. This NFT contract is at risk of a reentrancy "
"attack, where an attacker can mint multiple swords."
msgstr ""
"Considere un contrato de juego en el que las direcciones incluidas en la whitelisted pueden acu√±ar una espada NFT y luego ejecutar una funci√≥n `on_receive_sword()` antes de devolverla. Este "
"contrato NFT corre el riesgo de sufrir un ataque de reentrada, donde un atacante puede acu√±ar varias espadas."

#: src/ch02-14-security-considerations.md:81
msgid ""
"```rust\n"
"#[storage]\n"
"struct Storage {\n"
"    available_swords: u256, // Stores available swords.\n"
"    sword: LegacyMap::<ContractAddress, u256>, // Maps swords to addresses.\n"
"    whitelisted: LegacyMap::<ContractAddress, u256>, // Tracks whitelisted addresses.\n"
"    ...\n"
"    ...\n"
"}\n"
"\n"
"#[constructor]\n"
"fn constructor(ref self: ContractState,) {\n"
"    self.available_swords.write(100); // Initializes the sword count.\n"
"}\n"
"\n"
"#[external(v0)]\n"
"impl IGameImpl of IGame {\n"
"    fn mint_one_sword(ref self: ContractState) {\n"
"        let sender = get_caller_address();\n"
"        if self.whitelisted.read(sender) {\n"
"            // Update the sword count before minting.\n"
"            let sword_count = self.available_swords.read();\n"
"            self.available_swords.write(sword_count - 1);\n"
"            // Mint a sword.\n"
"            self.sword.write(sender, 1);\n"
"            // Callback to sender's contract.\n"
"            let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword();\n"
"            // Remove sender from whitelist after callback to prevent reentrancy.\n"
"            self.whitelisted.write(sender, false);\n"
"        }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[storage]\n"
"struct Storage {\n"
"    available_swords: u256, // Stores available swords.\n"
"    sword: LegacyMap::<ContractAddress, u256>, // Maps swords to addresses.\n"
"    whitelisted: LegacyMap::<ContractAddress, u256>, // Tracks whitelisted addresses.\n"
"    ...\n"
"    ...\n"
"}\n"
"\n"
"#[constructor]\n"
"fn constructor(ref self: ContractState,) {\n"
"    self.available_swords.write(100); // Initializes the sword count.\n"
"}\n"
"\n"
"#[external(v0)]\n"
"impl IGameImpl of IGame {\n"
"    fn mint_one_sword(ref self: ContractState) {\n"
"        let sender = get_caller_address();\n"
"        if self.whitelisted.read(sender) {\n"
"            // Update the sword count before minting.\n"
"            let sword_count = self.available_swords.read();\n"
"            self.available_swords.write(sword_count - 1);\n"
"            // Mint a sword.\n"
"            self.sword.write(sender, 1);\n"
"            // Callback to sender's contract.\n"
"            let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword();\n"
"            // Remove sender from whitelist after callback to prevent reentrancy.\n"
"            self.whitelisted.write(sender, false);\n"
"        }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:114
msgid ""
"An attacker's contract can implement the `on_receive_sword` function to exploit the reentry vulnerability and mint multiple swords by calling `mint_one_sword` again before removing the sender from "
"the `whitelist`:"
msgstr ""
"El contrato de un atacante puede implementar la funci√≥n `on_receive_sword` para explotar la vulnerabilidad de reentrada y acu√±ar m√∫ltiples espadas llamando a `mint_one_sword` nuevamente antes de "
"eliminar al remitente de la `whitelist`:"

#: src/ch02-14-security-considerations.md:116
msgid ""
"```rust\n"
"fn on_receive_sword(ref self: ContractState) {\n"
"    let nft_sword_contract = get_caller_address();\n"
"    let call_number: felt252 = self.total_calls.read();\n"
"    self.total_calls.write(call_number + 1);\n"
"    if call_number < 10 {\n"
"        // Attempt to mint a sword again.\n"
"        let call = ISwordDispatcher { contract_address: nft_sword_contract }.mint_one_sword();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn on_receive_sword(ref self: ContractState) {\n"
"    let nft_sword_contract = get_caller_address();\n"
"    let call_number: felt252 = self.total_calls.read();\n"
"    self.total_calls.write(call_number + 1);\n"
"    if call_number < 10 {\n"
"        // Attempt to mint a sword again.\n"
"        let call = ISwordDispatcher { contract_address: nft_sword_contract }.mint_one_sword();\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:128
msgid ""
"Reentrancy protections are critical in many ERC standards with `safeTransfer` functions (like ERC721, ERC777, ERC1155, ERC223) and in flash loans, where borrower contracts need to safely use and "
"return funds."
msgstr ""
"Las protecciones de reentrada son fundamentales en muchos est√°ndares ERC con funciones de `safeTransfer` (como ERC721, ERC777, ERC1155, ERC223) y en pr√©stamos flash, donde los contratos de los "
"prestatarios deben utilizar y devolver los fondos de forma segura."

#: src/ch02-14-security-considerations.md:130 src/ch02-14-security-considerations.md:202 src/ch02-14-security-considerations.md:261 src/ch02-14-security-considerations.md:369
msgid "### Recommendation:"
msgstr "### Recomendaci√≥n:"

#: src/ch02-14-security-considerations.md:132
msgid ""
"To prevent reentrancy attacks, use the check-effects-interactions pattern. This means updating your contract's internal state before interacting with external contracts. In the previous example, "
"remove the sender from the whitelist before making the external call."
msgstr ""
"Para evitar ataques de reentrada, utilice el patr√≥n de verificaci√≥n-efectos-interacciones. Esto significa actualizar el estado interno de su contrato antes de interactuar con contratos externos. En "
"el ejemplo anterior, elimine al remitente de la whitelist antes de realizar la llamada externa."

#: src/ch02-14-security-considerations.md:134
msgid ""
"```rust\n"
"if self.whitelisted.read(sender) {\n"
"    // Update the sword count first.\n"
"    let sword_count = self.available_swords.read();\n"
"    self.available_swords.write(sword_count - 1);\n"
"    // Mint a sword to the caller.\n"
"    self.sword.write(sender, 1);\n"
"    // Crucially, remove the sender from the whitelist before the external call.\n"
"    self.whitelisted.write(sender, false);\n"
"    // Only then, make the callback to the sender.\n"
"    let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword();\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"if self.whitelisted.read(sender) {\n"
"    // Update the sword count first.\n"
"    let sword_count = self.available_swords.read();\n"
"    self.available_swords.write(sword_count - 1);\n"
"    // Mint a sword to the caller.\n"
"    self.sword.write(sender, 1);\n"
"    // Crucially, remove the sender from the whitelist before the external call.\n"
"    self.whitelisted.write(sender, false);\n"
"    // Only then, make the callback to the sender.\n"
"    let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword();\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:148
msgid "Adhering to this pattern enhances the security of your smart contract by minimizing the risk of reentrancy attacks and preserving the integrity of its internal state."
msgstr "Cumplir con este patr√≥n mejora la seguridad de su smart contract al minimizar el riesgo de ataques de reentrada y preservar la integridad de su estado interno."

#: src/ch02-14-security-considerations.md:150
msgid "## 3. Tx.Origin Authentication"
msgstr "## 3. Autenticaci√≥n de Origen de Tx"

#: src/ch02-14-security-considerations.md:152
msgid ""
"In Solidity, `tx.origin` is a global variable that stores the address of the transaction initiator, while `msg.sender` stores the address of the transaction caller. In Cairo, we have the "
"`account_contract_address` global variable and `get_caller_address` function, which serve the same purpose."
msgstr ""
"En Solidity, `tx.origin` es una variable global que almacena la direcci√≥n del iniciador de la transacci√≥n, mientras que `msg.sender` almacena la direcci√≥n de quien llama a la transacci√≥n. En Cairo, "
"tenemos la variable global `account_contract_address` y la funci√≥n `get_caller_address`, que tienen el mismo prop√≥sito."

#: src/ch02-14-security-considerations.md:154
msgid ""
"Using `account_contract_address` (the equivalent of `tx.origin`) for authentication in your smart contract functions can lead to phishing attacks. Attackers can create custom smart contracts and "
"trick users into placing them as intermediaries in a transaction call, effectively impersonating the contract owner."
msgstr ""
"El uso de `account_contract_address` (el equivalente de `tx.origin`) para la autenticaci√≥n en las funciones de su smart contract puede provocar ataques de phishing. Los atacantes pueden crear smart "
"contract personalizados y enga√±ar a los usuarios para que los coloquen como intermediarios en una llamada de transacci√≥n, haci√©ndose pasar por el propietario del contrato."

#: src/ch02-14-security-considerations.md:156
msgid "For example, consider a Cairo smart contract that allows transferring funds to the owner and uses `account_contract_address` for authentication:"
msgstr "Por ejemplo, considere un smart contract de Cairo que permite transferir fondos al propietario y utiliza `account_contract_address` para la autenticaci√≥n:"

#: src/ch02-14-security-considerations.md:158
msgid ""
"```rust\n"
"use starknet::get_caller_address;\n"
"use box::BoxTrait;\n"
"\n"
"struct Storage {\n"
"    owner: ContractAddress, // Stores the owner's address.\n"
"}\n"
"\n"
"#[constructor]\n"
"fn constructor(){\n"
"    // Initialize the owner as the contract deployer.\n"
"    let contract_deployer = get_caller_address();\n"
"    self.owner.write(contract_deployer)\n"
"}\n"
"\n"
"#[external(v0)]\n"
"impl ITokenImpl of IToken {\n"
"    fn transferTo(ref self: ContractState, to: ContractAddress, amount: u256) {\n"
"        let tx_info = starknet::get_tx_info().unbox();\n"
"        let authorizer: ContractAddress = tx_info.account_contract_address;\n"
"        // Verifies the transaction initiator as the owner.\n"
"        assert(authorizer == self.owner.read());\n"
"        // Processes the fund transfer.\n"
"        self.balance.write(to + amount);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::get_caller_address;\n"
"use box::BoxTrait;\n"
"\n"
"struct Storage {\n"
"    owner: ContractAddress, // Stores the owner's address.\n"
"}\n"
"\n"
"#[constructor]\n"
"fn constructor(){\n"
"    // Initialize the owner as the contract deployer.\n"
"    let contract_deployer = get_caller_address();\n"
"    self.owner.write(contract_deployer)\n"
"}\n"
"\n"
"#[external(v0)]\n"
"impl ITokenImpl of IToken {\n"
"    fn transferTo(ref self: ContractState, to: ContractAddress, amount: u256) {\n"
"        let tx_info = starknet::get_tx_info().unbox();\n"
"        let authorizer: ContractAddress = tx_info.account_contract_address;\n"
"        // Verifies the transaction initiator as the owner.\n"
"        assert(authorizer == self.owner.read());\n"
"        // Processes the fund transfer.\n"
"        self.balance.write(to + amount);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:186
msgid "An attacker can trick the owner into using a malicious contract, allowing the attacker to call the `transferTo` function and impersonate the contract owner:"
msgstr "Un atacante puede enga√±ar al owner para que utilice un contrato malicioso, permiti√©ndole llamar a la funci√≥n `transferTo` y hacerse pasar por el propietario del contrato:"

#: src/ch02-14-security-considerations.md:188
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod MaliciousContract {\n"
"...\n"
"...\n"
"#[external(v0)]\n"
"impl IMaliciousContractImpl of IMaliciousContract {\n"
"    fn transferTo(ref self: ContractState, to: ContractAddress, amount: u256) {\n"
"        // Malicious callback to transfer funds.\n"
"        let callback = ICallerDispatcher { contract_address: sender }.transferTo(ATTACKER_ACCOUNT, amount);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod MaliciousContract {\n"
"...\n"
"...\n"
"#[external(v0)]\n"
"impl IMaliciousContractImpl of IMaliciousContract {\n"
"    fn transferTo(ref self: ContractState, to: ContractAddress, amount: u256) {\n"
"        // Malicious callback to transfer funds.\n"
"        let callback = ICallerDispatcher { contract_address: sender }.transferTo(ATTACKER_ACCOUNT, amount);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:204
msgid "To guard against phishing attacks, replace `account_contract_address` (origin) authentication with `get_caller_address` (sender) in the `transferTo` function:"
msgstr "Para protegerse contra ataques de phishing, reemplace la autenticaci√≥n `account_contract_address` (origen) con `get_caller_address` (remitente) en la funci√≥n `transferTo`:"

#: src/ch02-14-security-considerations.md:206
msgid ""
"```rust\n"
"use starknet::get_caller_address;\n"
"\n"
"struct Storage {\n"
"    owner: ContractAddress, // Stores the owner's address.\n"
"}\n"
"\n"
"#[constructor]\n"
"fn constructor(){\n"
"    // Initialize the owner as the contract deployer.\n"
"    let contract_deployer = get_caller_address();\n"
"    self.owner.write(contract_deployer)\n"
"}\n"
"\n"
"#[external(v0)]\n"
"impl ITokenImpl of IToken {\n"
"    fn transferTo(ref self: ContractState, to: ContractAddress, amount: u256) {\n"
"        let authorizer = get_caller_address();\n"
"        // Verify that the caller is the owner.\n"
"        assert(authorizer == self.owner.read());\n"
"        // Execute the fund transfer.\n"
"        self.balance.write(to + amount);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::get_caller_address;\n"
"\n"
"struct Storage {\n"
"    owner: ContractAddress, // Stores the owner's address.\n"
"}\n"
"\n"
"#[constructor]\n"
"fn constructor(){\n"
"    // Initialize the owner as the contract deployer.\n"
"    let contract_deployer = get_caller_address();\n"
"    self.owner.write(contract_deployer)\n"
"}\n"
"\n"
"#[external(v0)]\n"
"impl ITokenImpl of IToken {\n"
"    fn transferTo(ref self: ContractState, to: ContractAddress, amount: u256) {\n"
"        let authorizer = get_caller_address();\n"
"        // Verify that the caller is the owner.\n"
"        assert(authorizer == self.owner.read());\n"
"        // Execute the fund transfer.\n"
"        self.balance.write(to + amount);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:232
msgid "This change ensures secure authentication, preventing unauthorized users from executing critical functions and safeguarding against phishing attempts."
msgstr "Este cambio garantiza una autenticaci√≥n segura, evitando que usuarios no autorizados ejecuten funciones cr√≠ticas y protegiendo contra intentos de phishing."

#: src/ch02-14-security-considerations.md:234
msgid "## 4. Handling Overflow and Underflow in Smart Contracts"
msgstr "## 4. Manejo de Overflow y Underflow en Smart Contracts"

#: src/ch02-14-security-considerations.md:236
msgid "Overflow and underflow vulnerabilities arise from assigning values too large (overflow) or too small (underflow) for a specific data type."
msgstr "Las vulnerabilidades de overflow y underflow surgen al asignar valores demasiado grandes (overflow) o demasiado peque√±os (underflow) para un tipo de datos espec√≠fico."

#: src/ch02-14-security-considerations.md:238
msgid "Consider the `felt252` data type: adding or subtracting values beyond its range can yield incorrect results:"
msgstr "Considere el tipo de datos `felt252`: sumar o restar valores m√°s all√° de su rango puede generar resultados incorrectos:"

#: src/ch02-14-security-considerations.md:240
msgid ""
"```rust\n"
"    fn overflow_felt252() -> felt252 {\n"
"        // Assigns the maximum felt252 value: 2^251 + 17 * 2^192\n"
"        let max: felt252 = 3618502788666131106986593281521497120414687020801267626233049500247285301248 + 17 * 6277101735386680763835789423207666416102355444464034512896;\n"
"        // Attempting to add beyond the maximum value.\n"
"        max + 3\n"
"    }\n"
"\n"
"    fn underflow_felt252() -> felt252 {\n"
"        let min: felt252 = 0;\n"
"        // Same maximum value as in overflow.\n"
"        let subtract = (3618502788666131106986593281521497120414687020801267626233049500247285301248 + 17 * 6277101735386680763835789423207666416102355444464034512896);\n"
"        // Subtracting more than the minimum, leading to underflow.\n"
"        min - subtract\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn overflow_felt252() -> felt252 {\n"
"        // Assigns the maximum felt252 value: 2^251 + 17 * 2^192\n"
"        let max: felt252 = 3618502788666131106986593281521497120414687020801267626233049500247285301248 + 17 * 6277101735386680763835789423207666416102355444464034512896;\n"
"        // Attempting to add beyond the maximum value.\n"
"        max + 3\n"
"    }\n"
"\n"
"    fn underflow_felt252() -> felt252 {\n"
"        let min: felt252 = 0;\n"
"        // Same maximum value as in overflow.\n"
"        let subtract = (3618502788666131106986593281521497120414687020801267626233049500247285301248 + 17 * 6277101735386680763835789423207666416102355444464034512896);\n"
"        // Subtracting more than the minimum, leading to underflow.\n"
"        min - subtract\n"
"    }\n"
"```"

#: src/ch02-14-security-considerations.md:257
msgid "Executing these functions will result in incorrect values due to overflow and underflow, as illustrated in the following image:"
msgstr "La ejecuci√≥n de estas funciones dar√° como resultado valores incorrectos debido a desbordamiento y desbordamiento insuficiente, como se ilustra en la siguiente imagen:"

#: src/ch02-14-security-considerations.md:259
msgid "<img alt=\"felt252\" src=\"img/ch02-sec_over_felt.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"felt252\" src=\"img/ch02-sec_over_felt.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-14-security-considerations.md:263
msgid "To prevent incorrect results, use protected data types like `u128` or `u256`, which are designed to manage overflows and underflows."
msgstr "Para evitar resultados incorrectos, utilice tipos de datos protegidos como `u128` o `u256`, que est√°n dise√±ados para gestionar overflows y underflows."

#: src/ch02-14-security-considerations.md:265
msgid "Here's how you can use the `u256` data type to handle these issues:"
msgstr "A continuaci√≥n se explica c√≥mo puede utilizar el tipo de datos `u256` para solucionar estos problemas:"

#: src/ch02-14-security-considerations.md:267
msgid ""
"```rust\n"
"    fn overflow_u256() -> u256 {\n"
"        let max_u128: u128 = 0xffffffffffffffffffffffffffffffff_u128; // Maximum u128 value.\n"
"        let max: u256 = u256 { low: max_u128, high: max_u128 }; // Maximum u256 value.\n"
"        let three: u256 = u256 { low: 3_u128, high: 0_u128 }; // Value of 3.\n"
"        max + three // Attempting to add beyond max, will trigger overflow protection.\n"
"    }\n"
"\n"
"    fn underflow_u256() -> u256 {\n"
"        let min: u256 = u256 { low: 0_u128, high: 0_u128 }; // Zero value for u256.\n"
"        let three: u256 = u256 { low: 3_u128, high: 0_u128 }; // Value of 3.\n"
"        min - three // Attempting to subtract from zero, will trigger underflow protection.\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn overflow_u256() -> u256 {\n"
"        let max_u128: u128 = 0xffffffffffffffffffffffffffffffff_u128; // Maximum u128 value.\n"
"        let max: u256 = u256 { low: max_u128, high: max_u128 }; // Maximum u256 value.\n"
"        let three: u256 = u256 { low: 3_u128, high: 0_u128 }; // Value of 3.\n"
"        max + three // Attempting to add beyond max, will trigger overflow protection.\n"
"    }\n"
"\n"
"    fn underflow_u256() -> u256 {\n"
"        let min: u256 = u256 { low: 0_u128, high: 0_u128 }; // Zero value for u256.\n"
"        let three: u256 = u256 { low: 3_u128, high: 0_u128 }; // Value of 3.\n"
"        min - three // Attempting to subtract from zero, will trigger underflow protection.\n"
"    }\n"
"```"

#: src/ch02-14-security-considerations.md:282
msgid "When these functions encounter overflows or underflows, the transaction will revert, as shown in these images:"
msgstr "Cuando estas funciones encuentran overflows o underflows, la transacci√≥n se revertir√°, como se muestra en estas im√°genes:"

#: src/ch02-14-security-considerations.md:284
msgid ""
"<img alt=\"u256\" src=\"img/ch02-sec_over_u256.png\" class=\"center\" style=\"width: 75%;\" />\n"
"<img alt=\"u256\" src=\"img/ch02-sec_under_u256.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""
"<img alt=\"u256\" src=\"img/ch02-sec_over_u256.png\" class=\"center\" style=\"width: 75%;\" />\n"
"<img alt=\"u256\" src=\"img/ch02-sec_under_u256.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-14-security-considerations.md:287
msgid "Failure reasons for `u256`:"
msgstr "Razones de falla para `u256`:"

#: src/ch02-14-security-considerations.md:289
msgid ""
"- Overflow: `0x753235365f616464204f766572666c6f77=u256_add Overflow`\n"
"- Underflow: `0x753235365f737562204f766572666c6f77=u256_sub Overflow`"
msgstr ""
"- Overflow: `0x753235365f616464204f766572666c6f77=u256_add Overflow`\n"
"- Underflow: `0x753235365f737562204f766572666c6f77=u256_sub Overflow`"

#: src/ch02-14-security-considerations.md:292
msgid "Similarly, the `u128` data type can be used to handle overflow and underflow:"
msgstr "De manera similar, el tipo de datos `u128` se puede utilizar para manejar el overflow y el underflow:"

#: src/ch02-14-security-considerations.md:294
msgid ""
"```rust\n"
"    fn overflow_u128() -> u128 {\n"
"        let max: u128 = 0xffffffffffffffffffffffffffffffff_u128; // Maximum u128 value.\n"
"        max + 3_u128 // Adding to max, overflow protection triggers if necessary.\n"
"    }\n"
"\n"
"    fn underflow_u128() -> u128 {\n"
"        let min: u128 = 0_u128; // Zero value for u128.\n"
"        min - 3_u128 // Subtracting from zero, underflow protection activates if needed.\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    fn overflow_u128() -> u128 {\n"
"        let max: u128 = 0xffffffffffffffffffffffffffffffff_u128; // Maximum u128 value.\n"
"        max + 3_u128 // Adding to max, overflow protection triggers if necessary.\n"
"    }\n"
"\n"
"    fn underflow_u128() -> u128 {\n"
"        let min: u128 = 0_u128; // Zero value for u128.\n"
"        min - 3_u128 // Subtracting from zero, underflow protection activates if needed.\n"
"    }\n"
"```"

#: src/ch02-14-security-considerations.md:306
msgid "Overflow or underflow in u128 will similarly revert the transaction, with corresponding failure reasons:"
msgstr "El overflow o underflow en u128 revertir√° de manera similar la transacci√≥n, con las correspondientes razones de falla:"

#: src/ch02-14-security-considerations.md:308
msgid ""
"<img alt=\"u128\" src=\"img/ch02-sec_over_u128.png\" class=\"center\" style=\"width: 75%;\" />\n"
"<img alt=\"u128\" src=\"img/ch02-sec_under_u128.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""
"<img alt=\"u128\" src=\"img/ch02-sec_over_u128.png\" class=\"center\" style=\"width: 75%;\" />\n"
"<img alt=\"u128\" src=\"img/ch02-sec_under_u128.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-14-security-considerations.md:311
msgid "Failure reasons for u128:"
msgstr "Razones del fracaso del u128:"

#: src/ch02-14-security-considerations.md:313
msgid ""
"- Overflow: `0x753132385f616464204f766572666c6f77=u128_add Overflow`\n"
"- Underflow: `0x753132385f737562204f766572666c6f77=u128_sub Overflow`"
msgstr ""
"- Overflow: `0x753132385f616464204f766572666c6f77=u128_add Overflow`\n"
"- Underflow: `0x753132385f737562204f766572666c6f77=u128_sub Overflow`"

#: src/ch02-14-security-considerations.md:316
msgid "Using these data types, you can ensure safer arithmetic operations in your smart contracts, avoiding unintended consequences of overflows and underflows."
msgstr "Al utilizar estos tipos de datos, puede garantizar operaciones aritm√©ticas m√°s seguras en sus smart contracts, evitando consecuencias no deseadas de desbordamientos y desbordamientos."

#: src/ch02-14-security-considerations.md:318
msgid "## 5. Private Data On-Chain."
msgstr "## 5. Datos Privados On-Chain."

#: src/ch02-14-security-considerations.md:320
msgid ""
"Storing secret values in smart contracts presents a challenge because all on-chain data is publicly accessible, even if the code isn't published. For example, consider a smart contract storing a "
"password (12345678) using a constructor parameter:"
msgstr ""
"Almacenar valores secretos en smart contracts presenta un desaf√≠o porque todos los datos en on-chain son accesibles p√∫blicamente, incluso si el c√≥digo no est√° publicado. Por ejemplo, considere un "
"contrato inteligente que almacena una contrase√±a (12345678) usando un par√°metro de constructor:"

#: src/ch02-14-security-considerations.md:322
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod StoreSecretPassword {\n"
"    struct Storage {\n"
"        password: felt252, // Field to store the password.\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(_password: felt252) {\n"
"        // Writing the password to the storage.\n"
"        self.password.write(_password);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod StoreSecretPassword {\n"
"    struct Storage {\n"
"        password: felt252, // Field to store the password.\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(_password: felt252) {\n"
"        // Writing the password to the storage.\n"
"        self.password.write(_password);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-14-security-considerations.md:337
msgid "<img alt=\"deploy\" src=\"img/ch02-sec_priv01.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"deploy\" src=\"img/ch02-sec_priv01.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-14-security-considerations.md:339
msgid ""
"However, understanding Cairo's [storage layout](https://book.cairo-lang.org/ch99-01-03-01-contract-storage.html?highlight=kecc#storage-addresses), we can create a script to read the stored variable:"
msgstr ""
"Sin embargo, al comprender el [storage de Cairo](https://book.cairo-lang.org/ch99-01-03-01-contract-storage.html?highlight=kecc#storage-addresses), podemos crear un script para leer la variable "
"almacenada:"

#: src/ch02-14-security-considerations.md:341
msgid ""
"```javascript\n"
"import { Provider, hash } from \"starknet\";\n"
"\n"
"const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"});\n"
"\n"
"var passHash = hash.starknetKeccak(\"password\");\n"
"console.log(\n"
"  \"getStor=\",\n"
"  await provider.getStorageAt(\n"
"    \"0x032d0392eae7440063ea0f3f50a75dbe664aaa1df76b4662223430851a113369\",\n"
"    passHash,\n"
"    812512,\n"
"  ),\n"
");\n"
"```"
msgstr ""
"```javascript\n"
"import { Provider, hash } from \"starknet\";\n"
"\n"
"const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"});\n"
"\n"
"var passHash = hash.starknetKeccak(\"password\");\n"
"console.log(\n"
"  \"getStor=\",\n"
"  await provider.getStorageAt(\n"
"    \"0x032d0392eae7440063ea0f3f50a75dbe664aaa1df76b4662223430851a113369\",\n"
"    passHash,\n"
"    812512,\n"
"  ),\n"
");\n"
"```"

#: src/ch02-14-security-considerations.md:361
msgid "Executing this script reveals the stored password value (hex value of 12345678):"
msgstr "La ejecuci√≥n de este script revela el valor de la contrase√±a almacenada (valor hexadecimal de 12345678):"

#: src/ch02-14-security-considerations.md:363
msgid "<img alt=\"get_storage\" src=\"img/ch02-sec_priv02.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"get_storage\" src=\"img/ch02-sec_priv02.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-14-security-considerations.md:365
msgid "Moreover, using a block explorer, we can view the deployed parameters in the transaction:"
msgstr "Adem√°s, utilizando un explorador de bloques, podemos ver los par√°metros implementados en la transacci√≥n:"

#: src/ch02-14-security-considerations.md:367
msgid "<img alt=\"block explorer\" src=\"img/ch02-sec_priv03.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"block explorer\" src=\"img/ch02-sec_priv03.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-14-security-considerations.md:371
msgid ""
"If your smart contract requires storing private data on-chain, consider off-chain encryption before sending data to the blockchain. Alternatively, explore options like hashes, merkle trees, or "
"commit-reveal patterns to maintain data privacy."
msgstr ""
"Si su smart contract requiere almacenar datos privados en la cadena, considere el cifrado fuera de la cadena antes de enviar datos a la cadena de bloques. Alternativamente, explore opciones como "
"hashes, √°rboles merkle o patrones de confirmaci√≥n y revelaci√≥n para mantener la privacidad de los datos."

#: src/ch02-14-security-considerations.md:373
msgid "## Call for Contributions: Additional Vulnerabilities"
msgstr "## Convocatoria de Contribuciones: Vulnerabilidades Adicionales"

#: src/ch02-14-security-considerations.md:375
msgid ""
"We've discussed several common vulnerabilities in Cairo smart contracts, but many other security risks need attention. We invite community contributions to expand this chapter with more "
"vulnerabilities:"
msgstr ""
"Hemos discutido varias vulnerabilidades comunes en los smart contracts de Cairo, pero muchos otros riesgos de seguridad requieren atenci√≥n. Invitamos a la comunidad a contribuir para ampliar este "
"cap√≠tulo con m√°s vulnerabilidades:"

#: src/ch02-14-security-considerations.md:377
msgid ""
"- Storage Collision\n"
"- Flash Loan Attacks\n"
"- Oracle Manipulation\n"
"- Bad Randomness\n"
"- Denial of Service\n"
"- Untrusted Delegate Calls\n"
"- Public Burn"
msgstr ""
"- Storage Collision\n"
"- Flash Loan Attacks\n"
"- Oracle Manipulation\n"
"- Bad Randomness\n"
"- Denial of Service\n"
"- Untrusted Delegate Calls\n"
"- Public Burn"

#: src/ch02-14-security-considerations.md:385
msgid ""
"If you have expertise in these areas, please consider contributing your knowledge, including explanations and examples of these vulnerabilities. Your input will greatly benefit the Starknet and "
"Cairo developer community, aiding in the development of more secure and resilient smart contracts."
msgstr ""
"Si tiene experiencia en estas √°reas, considere contribuir con sus conocimientos, incluidas explicaciones y ejemplos de estas vulnerabilidades. Su aporte beneficiar√° enormemente a la comunidad de "
"desarrolladores de Starknet y Cairo, ayudando en el desarrollo de smart contracts m√°s seguros y resistentes."

#: src/ch02-14-security-considerations.md:387
msgid "We appreciate your support in enhancing the safety and security of the Starknet ecosystem for developers and users alike."
msgstr "Agradecemos su apoyo para mejorar la seguridad del ecosistema Starknet tanto para desarrolladores como para usuarios."

#: src/ch02-15-security-tools.md:1
#, fuzzy
msgid "# Starknet Security Tools"
msgstr "# Herramientas en Starknet"

#: src/ch02-15-security-tools.md:3
msgid "Starknet offers a range of tools for testing the security of smart contracts. We invite developers to improve existing tools or create new ones."
msgstr ""

#: src/ch02-15-security-tools.md:5
msgid "This section covers:"
msgstr ""

#: src/ch02-15-security-tools.md:7
msgid ""
"- Tools for security testing.\n"
"- Security considerations for smart contracts."
msgstr ""

#: src/ch02-15-security-tools.md:10
msgid "Below is an overview of the tools for Starknet security testing discussed in this chapter:"
msgstr ""

#: src/ch02-15-security-tools.md:12
msgid ""
"1. **Cairo-fuzzer**: A tool for smart contract developers to test security. It functions both as a standalone tool and as a library.\n"
"2. **Caracal**: A static analysis tool for Starknet smart contracts, utilizing the SIERRA representation.\n"
"3. **Thoth**: A comprehensive Cairo/Starknet security toolkit. It includes analyzers, disassemblers, and decompilers."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:1
msgid "# Cairo-fuzzer"
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:3
msgid "[Cairo-fuzzer](https://github.com/FuzzingLabs/cairo-fuzzer) is a tool designed for smart contract developers to assess security. It operates both independently and as a library."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:5 src/ch02-15-02-caracal.md:5 src/ch02-15-03-thoth.md:5
#, fuzzy
msgid "## Features"
msgstr "## Caracter√≠sticas Clave"

#: src/ch02-15-01-cairo-fuzzer.md:7
#, fuzzy
msgid "<img alt=\"cairo-fuzzer\" src=\"img/ch02-cairo-fuzzer.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch02-15-01-cairo-fuzzer.md:9
msgid ""
"- Execute Cairo contracts.\n"
"- Execute Starknet contracts.\n"
"- Replay fuzzing corpus.\n"
"- Minimize fuzzing corpus.\n"
"- Load previous corpus.\n"
"- Manage multiple arguments.\n"
"- Utilize workspace architecture.\n"
"- Import dictionaries.\n"
"- Integrate Cairo-fuzzer as a library."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:19
msgid "## Usage"
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:21
#, fuzzy
msgid "To use Cairo-fuzzer, run the following command:"
msgstr "Para instalar `katana` desde su c√≥digo fuente, ejecute los siguientes comandos:"

#: src/ch02-15-01-cairo-fuzzer.md:23
msgid ""
"```bash\n"
"cargo run --release -- --cores 3 --contract tests/fuzzinglabs.json --function \"Fuzz_symbolic_execution\"\n"
"```"
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:27
msgid "This outputs:"
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:29
msgid ""
"```bash\n"
"For more usage information, follow our tutorial\n"
"CMDLINE (--help):\n"
"\n"
"Usage: cairo-fuzzer [OPTIONS]\n"
"\n"
"Options:\n"
"      --cores <CORES>              Set the number of threads to run [default: 1]\n"
"      --contract <CONTRACT>        Set the path of the JSON artifact to load [default: ]\n"
"      --function <FUNCTION>        Set the function to fuzz [default: ]\n"
"      --workspace <WORKSPACE>      Workspace of the fuzzer [default: fuzzer_workspace]\n"
"      --inputfolder <INPUTFOLDER>  Path to the inputs folder to load [default: ]\n"
"      --crashfolder <CRASHFOLDER>  Path to the crashes folder to load [default: ]\n"
"      --inputfile <INPUTFILE>      Path to the inputs file to load [default: ]\n"
"      --crashfile <CRASHFILE>      Path to the crashes file to load [default: ]\n"
"      --logs                       Enable fuzzer logs in file\n"
"      --seed <SEED>                Set a custom seed (only applicable for 1 core run)\n"
"      --run-time <RUN_TIME>        Number of seconds this fuzzing session will last\n"
"      --config <CONFIG>            Load config file\n"
"      --replay                     Replay the corpus folder\n"
"      --minimizer                  Minimize Corpora\n"
"  -h, --help                       Print help information\n"
"```"
msgstr ""

#: src/ch02-15-02-caracal.md:1
#, fuzzy
msgid "# Caracal"
msgstr "## Paquetes en Cairo"

#: src/ch02-15-02-caracal.md:3
msgid "[Caracal](https://github.com/crytic/caracal) is a static analysis tool for Starknet smart contracts, specifically analyzing their SIERRA representation."
msgstr ""

#: src/ch02-15-02-caracal.md:7
msgid ""
"- Vulnerability detectors for Cairo code.\n"
"- Report printers.\n"
"- Taint analysis.\n"
"- Data flow analysis framework.\n"
"- Compatibility with Scarb projects."
msgstr ""

#: src/ch02-15-02-caracal.md:15
msgid "### Precompiled Binaries"
msgstr ""

#: src/ch02-15-02-caracal.md:17
msgid "Download precompiled binaries from the [releases page](https://github.com/crytic/caracal/releases). Use binary version v0.1.x for Cairo compiler 1.x.x, and v0.2.x for Cairo compiler 2.x.x."
msgstr ""

#: src/ch02-15-02-caracal.md:19
#, fuzzy
msgid "### Building from Source"
msgstr "# Construyendo un Proyecto Scarb"

#: src/ch02-15-02-caracal.md:21
msgid "#### Requirements"
msgstr ""

#: src/ch02-15-02-caracal.md:23
msgid ""
"- Rust compiler\n"
"- Cargo"
msgstr ""

#: src/ch02-15-02-caracal.md:26
#, fuzzy
msgid "#### Installation Steps"
msgstr "# Instalaci√≥n"

#: src/ch02-15-02-caracal.md:28
msgid "Clone and build from the repository:"
msgstr ""

#: src/ch02-15-02-caracal.md:30
msgid ""
"```bash\n"
"cargo install --git https://github.com/crytic/caracal --profile release --force\n"
"```"
msgstr ""

#: src/ch02-15-02-caracal.md:34
msgid "### Building from a Local Copy:"
msgstr ""

#: src/ch02-15-02-caracal.md:36
msgid "If you prefer to build from a local copy:"
msgstr ""

#: src/ch02-15-02-caracal.md:38
#, fuzzy
msgid ""
"```bash\n"
"git clone https://github.com/crytic/caracal\n"
"cd caracal\n"
"cargo install --path . --profile release --force\n"
"```"
msgstr ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"

#: src/ch02-15-03-thoth.md:1
msgid "# Thoth"
msgstr ""

#: src/ch02-15-03-thoth.md:3
msgid ""
"[Thoth](https://github.com/FuzzingLabs/thoth) (pronounced \"taut\" or \"toss\") is a security toolkit for Cairo/Starknet. Written in Python 3, it includes analyzers, disassemblers, and decompilers. "
"Thoth is capable of generating call graphs, control-flow graphs (CFG), and data-flow graphs for Sierra files or Cairo/Starknet compilation artifacts. It also features tools like a symbolic "
"execution engine and a symbolic bounded model checker."
msgstr ""

#: src/ch02-15-03-thoth.md:7
msgid ""
"- **Remote & Local Analysis**: Works with contracts on Mainnet/Goerli and local compilations.\n"
"- **Decompiler**: Transforms assembly into decompiled code using SSA (Static Single Assignment).\n"
"- **Call Flow Analysis**: Generates Call Flow Graphs.\n"
"- **Static Analysis**: Conducts various types of analyses (security/optimization/analytics) on contracts.\n"
"- **Symbolic Execution**: Finds variable values for specific paths in functions and generates test cases.\n"
"- **Data Flow Analysis**: Produces Data Flow Graphs (DFG) for each function.\n"
"- **Disassembler**: Converts bytecode to assembly.\n"
"- **Control Flow Analysis**: Creates Control Flow Graphs (CFG).\n"
"- **Cairo Fuzzer Inputs**: Generates inputs for Cairo fuzzer.\n"
"- **Sierra Files Analysis**: Analyzes Sierra files.\n"
"- **Sierra Files Symbolic Execution**: Performs symbolic execution on Sierra files.\n"
"- **Symbolic Bounded Model Checker**: Functions as a symbolic bounded model checker.\n"
"\n"
"  <img alt=\"thoth\" src=\"img/ch02-thoth.png\" class=\"center\" style=\"width: 75%;\" />"
msgstr ""

#: src/ch02-15-03-thoth.md:24
#, fuzzy
msgid "Install Thoth using the following commands:"
msgstr "Para instalar `katana` desde su c√≥digo fuente, ejecute los siguientes comandos:"

#: src/ch02-15-03-thoth.md:26
msgid ""
"```bash\n"
"sudo apt install graphviz\n"
"git clone https://github.com/FuzzingLabs/thoth && cd thoth\n"
"pip install .\n"
"thoth -h\n"
"```"
msgstr ""

#: src/ch03-00-architecture.md:1
msgid "# Architecture"
msgstr ""

#: src/ch03-00-architecture.md:3
msgid "This is an introduction to Starknet‚Äôs Layer 2 architecture,"
msgstr ""

#: src/ch03-00-architecture.md:5
msgid ""
"Starknet is a coordinated system, with each component‚ÄîSequencers,\n"
"Provers, and nodes‚Äîplaying a specific yet interconnected role. Although\n"
"Starknet hasn‚Äôt fully decentralized yet, it‚Äôs actively moving toward\n"
"that goal. This understanding of the roles and interactions within the\n"
"system will help you better grasp the intricacies of the Starknet\n"
"ecosystem."
msgstr ""

#: src/ch03-00-architecture.md:12
msgid "## High-Level Overview"
msgstr ""

#: src/ch03-00-architecture.md:14
msgid ""
"Starknet‚Äôs operation begins when a transaction is received by a gateway,\n"
"which serves as the Mempool. This stage could also be managed by the\n"
"Sequencer. The transaction is initially marked as \"RECEIVED.\" The\n"
"Sequencer then incorporates the transaction into the network state and\n"
"tags it as \"ACCEPTED_ON_L2.\" The final step involves the Prover, which\n"
"executes the operating system on the new block, calculates its proof,\n"
"and submits it to the Layer 1 (L1) for verification."
msgstr ""

#: src/ch03-00-architecture.md:22
msgid "<img alt=\"Starknet Architecture\" src=\"img/ch03-architecture.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch03-00-architecture.md:24
msgid "<span class=\"caption\">Starknet architecture</span>"
msgstr ""

#: src/ch03-00-architecture.md:26
msgid "In essence, Starknet‚Äôs architecture involves multiple components:"
msgstr ""

#: src/ch03-00-architecture.md:28
msgid ""
"- The Sequencer is responsible for receiving transactions, ordering\n"
"  them, and producing blocks. It operates similarly to validators in\n"
"  Ethereum or Bitcoin.\n"
"\n"
"- The Prover is tasked with generating proofs for the created blocks\n"
"  and transactions. It uses Cairo‚Äôs Virtual Machine to run provable\n"
"  programs, thereby creating execution traces necessary for generating\n"
"  STARK proofs.\n"
"\n"
"- Layer 1 (L1), in this case Ethereum, hosts a smart contract capable\n"
"  of verifying these STARK proofs. If the proofs are valid, Starknet‚Äôs\n"
"  state root on L1 is updated."
msgstr ""

#: src/ch03-00-architecture.md:41
msgid ""
"Starknet‚Äôs state is a comprehensive snapshot maintained through Merkle\n"
"trees, much like in Ethereum. This establishes the architecture of the\n"
"validity roll-up and the roles of each component."
msgstr ""

#: src/ch03-00-architecture.md:45
msgid "For a more in-depth look at each component, read on."
msgstr ""

#: src/ch03-00-architecture.md:47
msgid ""
"After exploring the introductory overview of the different components,\n"
"delve deeper into their specific roles by referring to their dedicated\n"
"subchapters in this Chapter."
msgstr ""

#: src/ch03-00-architecture.md:51
msgid "## Sequencers"
msgstr ""

#: src/ch03-00-architecture.md:53
msgid ""
"Sequencers are the backbone of the Starknet network, akin to Ethereum‚Äôs\n"
"validators. They usher transactions into the system."
msgstr ""

#: src/ch03-00-architecture.md:56
msgid ""
"Validity rollups excel at offloading some network chores, like bundling\n"
"and processing transactions, to specialized players. This setup is\n"
"somewhat like how Ethereum and Bitcoin delegate security to miners.\n"
"Sequencing, like mining, demands hefty resources."
msgstr ""

#: src/ch03-00-architecture.md:61
msgid ""
"For networks like Starknet and other platforms utilizing Validity\n"
"rollups, a similar parallel is drawn. These networks outsource\n"
"transaction processing to specialized entities and then verify their\n"
"work. These specialized entities in the context of Validity rollups are\n"
"known as \"Sequencers.\""
msgstr ""

#: src/ch03-00-architecture.md:67
msgid ""
"Instead of providing security, as miners do, Sequencers provide\n"
"transaction capacity. They order (sequence) multiple transactions into a\n"
"single batch, executes them, and produce a block that will later be\n"
"proved by the Prover and submmited to the Layer 1 network as a single,\n"
"compact proof, known as a \"rollup.\" In other words, just as validators\n"
"in Ethereum and miners in Bitcoin are specialized actors securing the\n"
"network, Sequencers in Validity rollup-based networks are specialized\n"
"actors that provide transaction capacity."
msgstr ""

#: src/ch03-00-architecture.md:76
msgid ""
"This mechanism allows Validity (or ZK) rollups to handle a higher volume\n"
"of transactions while maintaining the security of the underlying\n"
"Ethereum network. It enhances scalability without compromising on\n"
"security."
msgstr ""

#: src/ch03-00-architecture.md:81
msgid "Sequencers follow a systematic method for transaction processing:"
msgstr ""

#: src/ch03-00-architecture.md:83
msgid ""
"1.  Sequencing: They collect transactions from users and order\n"
"    (sequence) them.\n"
"\n"
"2.  Executing: Sequencers then process these transactions.\n"
"\n"
"3.  Batching: Transactions are grouped together in batches or blocks for\n"
"    efficiency.\n"
"\n"
"4.  Block Production: Sequencers produce blocks that contain batches of\n"
"    processed transactions."
msgstr ""

#: src/ch03-00-architecture.md:94
msgid ""
"Sequencers must be reliable and highly available, as their role is\n"
"critical to the network‚Äôs smooth functioning. They need powerful and\n"
"well-connected machines to perform their role effectively, as they must\n"
"process transactions rapidly and continuously."
msgstr ""

#: src/ch03-00-architecture.md:99
msgid ""
"The current roadmap for Starknet includes decentralizing the Sequencer\n"
"role. This shift towards decentralization will allow more participants\n"
"to become Sequencers, contributing to the robustness of the network."
msgstr ""

#: src/ch03-00-architecture.md:103
msgid ""
"For more details in the Sequencer role, refer to the dedicated\n"
"subchapter in this Chapter."
msgstr ""

#: src/ch03-00-architecture.md:106
msgid "## Provers"
msgstr ""

#: src/ch03-00-architecture.md:108
msgid ""
"Provers serve as the second line of verification in the Starknet\n"
"network. Their main task is to validate the work of the Sequencers (when\n"
"they receive the block produced by the Sequencer) and to generate proofs\n"
"that these processes were correctly performed."
msgstr ""

#: src/ch03-00-architecture.md:113
msgid "The duties of a Prover include:"
msgstr ""

#: src/ch03-00-architecture.md:115
msgid ""
"1.  Receiving Blocks: Provers obtain blocks of processed transactions\n"
"    from Sequencers.\n"
"\n"
"2.  Processing: Provers process these blocks a second time, ensuring\n"
"    that all transactions within the block have been correctly handled.\n"
"\n"
"3.  Proof Generation: After processing, Provers generate a proof of\n"
"    correct transaction processing.\n"
"\n"
"4.  Sending Proof to Ethereum: Finally, the proof is sent to the\n"
"    Ethereum network for validation. If the proof is correct, the\n"
"    Ethereum network accepts the block of transactions."
msgstr ""

#: src/ch03-00-architecture.md:128
msgid ""
"Provers need even more computational power than Sequencers because they\n"
"have to calculate and generate proofs, a process that is computationally\n"
"heavy. However, the work of Provers can be split into multiple parts,\n"
"allowing for parallelism and efficient proof generation. The proof\n"
"generation process is asynchronous, meaning it doesn‚Äôt have to occur\n"
"immediately or in real-time. This flexibility allows for the workload to\n"
"be distributed among multiple Provers. Each Prover can work on a\n"
"different block, allowing for parallelism and efficient proof\n"
"generation."
msgstr ""

#: src/ch03-00-architecture.md:138
msgid ""
"The design of Starknet relies on these two types of actors ‚Äî Sequencers\n"
"and Provers ‚Äî working in tandem to ensure efficient processing and\n"
"secure verification of transactions."
msgstr ""

#: src/ch03-00-architecture.md:142
msgid ""
"For more details in the Prover role, refer to the dedicated subchapter\n"
"in this Chapter."
msgstr ""

#: src/ch03-00-architecture.md:145
msgid "## Optimizing Sequencers and Provers: Debunking Common Misconceptions"
msgstr ""

#: src/ch03-00-architecture.md:147
msgid ""
"The relationship between Sequencers and Provers in blockchain technology\n"
"often sparks debate. A common misunderstanding suggests that either the\n"
"Prover or the Sequencer is the main bottleneck. To set the record\n"
"straight, let‚Äôs discuss the optimization of both components."
msgstr ""

#: src/ch03-00-architecture.md:152
msgid ""
"Starknet, utilizing the Cairo programming language, currently supports\n"
"only sequential transactions. Plans are in place to introduce parallel\n"
"transactions in the future. However, as of now, the Sequencer operates\n"
"one transaction at a time, making it the bottleneck in the system."
msgstr ""

#: src/ch03-00-architecture.md:157
msgid ""
"In contrast, Provers operate asynchronously and can execute multiple\n"
"tasks in parallel. The use of proof recursion allows for task\n"
"distribution across multiple machines, making scalability less of an\n"
"issue for Provers."
msgstr ""

#: src/ch03-00-architecture.md:162
msgid ""
"Given the asynchronous and scalable nature of Provers, focus in Starknet\n"
"has shifted to enhancing the Sequencer‚Äôs efficiency. This explains why\n"
"current development efforts are primarily aimed at the sequencing side\n"
"of the equation."
msgstr ""

#: src/ch03-00-architecture.md:167
msgid "## Nodes"
msgstr ""

#: src/ch03-00-architecture.md:169
msgid ""
"When it comes to defining what nodes do in Bitcoin or Ethereum, people\n"
"often misinterpret their role as keeping track of every transaction\n"
"within the network. This, however, is not entirely accurate."
msgstr ""

#: src/ch03-00-architecture.md:173
msgid ""
"Nodes serve as auditors of the network, maintaining the state of the\n"
"network, such as how much Bitcoin each participant owns or the current\n"
"state of a specific smart contract. They accomplish this by processing\n"
"transactions and preserving a record of all transactions, but that‚Äôs a\n"
"means to an end, not the end itself."
msgstr ""

#: src/ch03-00-architecture.md:179
msgid ""
"In Validity rollups and specifically within Starknet, this concept is\n"
"somewhat reversed. Nodes don‚Äôt necessarily have to process transactions\n"
"to get the state. In contrast to Ethereum or Bitcoin, Starknet nodes\n"
"aren‚Äôt required to process all transactions to maintain the state of the\n"
"network."
msgstr ""

#: src/ch03-00-architecture.md:185
msgid ""
"There are two main ways to access network state data: via an API gateway\n"
"or using the RPC protocol to communicate with a node. Operating your own\n"
"node is typically faster than using a shared architecture, like the\n"
"gateway. Over time, Starknet plans to deprecate APIs and replace them\n"
"with a JSON RPC standard, making it even more beneficial to operate your\n"
"own node."
msgstr ""

#: src/ch03-00-architecture.md:192
msgid ""
"It‚Äôs worth noting that encouraging more people to run nodes increases\n"
"the resilience of the network and prevents server flooding, which has\n"
"been an issue in networks in other L2s."
msgstr ""

#: src/ch03-00-architecture.md:196
msgid ""
"Currently, there are primarily three methods for a node to keep track of\n"
"the network‚Äôs state and we can have nodes implement any of these\n"
"methods:"
msgstr ""

#: src/ch03-00-architecture.md:200
msgid ""
"1.  **Replaying Old Transactions**: Like Ethereum or Bitcoin, a node can\n"
"    take all the transactions and re-execute them. Although this\n"
"    approach is accurate, it isn‚Äôt scalable unless you have a powerful\n"
"    machine that‚Äôs capable of handling the load. If you can replay all\n"
"    transactions, you can become a Sequencer.\n"
"\n"
"2.  **Relying on L2 Consensus**: Nodes can trust the Sequencer(s) to\n"
"    execute the network correctly. When the Sequencer updates the state\n"
"    and adds a new block, nodes accept the update as accurate.\n"
"\n"
"3.  **Checking Proof Validation on L1**: Nodes can monitor the state of\n"
"    the network by observing L1 and ensuring that every time a proof is\n"
"    sent, they receive the updated state. This way, they don‚Äôt have to\n"
"    trust anyone and only need to keep track of the latest valid\n"
"    transaction for Starknet."
msgstr ""

#: src/ch03-00-architecture.md:216
msgid ""
"Each type of node setup comes with its own set of hardware requirements\n"
"and trust assumptions."
msgstr ""

#: src/ch03-00-architecture.md:219
msgid "### Nodes That Replay Transactions"
msgstr ""

#: src/ch03-00-architecture.md:221
msgid ""
"Nodes that replay transactions require powerful machines to track and\n"
"execute all transactions. These nodes don‚Äôt have trust assumptions; they\n"
"rely solely on the transactions they execute, guaranteeing that the\n"
"state at any given point is valid."
msgstr ""

#: src/ch03-00-architecture.md:226
msgid "### Nodes That Rely on L2 Consensus"
msgstr ""

#: src/ch03-00-architecture.md:228
msgid ""
"Nodes relying on L2 consensus require less computational power. They\n"
"need sufficient storage to keep the state but don‚Äôt need to process a\n"
"lot of transactions. The trade-off here is a trust assumption.\n"
"Currently, Starknet revolves around one Sequencer, so these nodes are\n"
"trusting Starkware not to disrupt the network. However, once a consensus\n"
"mechanism and leader election amongst Sequencers are in place, these\n"
"nodes will only need to trust that a Sequencer who staked their stake to\n"
"produce a block is not willing to lose it."
msgstr ""

#: src/ch03-00-architecture.md:237
msgid "### Nodes That Check Proof Validation on L1"
msgstr ""

#: src/ch03-00-architecture.md:239
msgid ""
"Nodes that only update their state based on proof validation on L1\n"
"require the least hardware. They have the same requirements as an\n"
"Ethereum node, and once Ethereum light nodes become a reality,\n"
"maintaining such a node could be as simple as using a smartphone. The\n"
"only trade-off is latency. Proofs are not sent to Ethereum every block\n"
"but intermittently, resulting in delayed state updates. Plans are in\n"
"place to produce proofs more frequently, even if they are not sent to\n"
"Ethereum immediately, allowing these nodes to reduce their latency.\n"
"However, this development is still a way off in the Starknet roadmap."
msgstr ""

#: src/ch03-00-architecture.md:251
msgid ""
"Through this chapter, we delve into Starknet‚Äôs structure, uncovering the\n"
"importance of Sequencers, Provers, and nodes. Each plays a unique role,\n"
"but together, they create a highly scalable, efficient, and secure\n"
"network that marks a significant step forward in Layer 2 solutions. As\n"
"Starknet evolves towards decentralization, understanding these roles\n"
"will provide valuable insight into the inner workings of this network."
msgstr ""

#: src/ch03-00-architecture.md:258
msgid ""
"As we venture further into the Starknet universe, our next stop will be\n"
"an exploration of the transaction lifecycle before we dive into the\n"
"heart of coding with Cairo."
msgstr ""

#: src/ch03-01-transactions.md:1
#, fuzzy
msgid "# Transaction Versions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-transactions.md:3
msgid ""
"Understanding Starknet's transaction types is essential to master its architecture and capabilities. Each transaction type serves a unique purpose, and getting a grip on their differences is "
"crucial for proficient Starknet usage."
msgstr ""

#: src/ch03-01-transactions.md:5
#, fuzzy
msgid "## Starknet OS: The Backbone"
msgstr "# Herramientas en Starknet"

#: src/ch03-01-transactions.md:7
msgid "Central to Starknet's functionality is the Starknet Operating System (OS), a Cairo program that fuels the network. This OS orchestrates key activities, including:"
msgstr ""

#: src/ch03-01-transactions.md:9
msgid ""
"- Deploying contracts\n"
"- Executing transactions\n"
"- Facilitating L1<>L2 message exchanges"
msgstr ""

#: src/ch03-01-transactions.md:13
msgid "In Starknet terminology, \"protocol level\" alludes to modifications in the foundational Starknet OS Cairo program, ensuring its steadfastness."
msgstr ""

#: src/ch03-01-transactions.md:15
#, fuzzy
msgid "## Transaction Types"
msgstr "Transacciones"

#: src/ch03-01-transactions.md:17
msgid ""
"- **Declare Transactions**: Unique in their ability to introduce new classes, leading to potential new smart contracts.\n"
"- **Invoke Transactions**: They call upon an action but can't introduce new ones.\n"
"- **Deploy Account Transactions**: Designed for setting up smart wallet contracts."
msgstr ""

#: src/ch03-01-transactions.md:21
#, fuzzy
msgid "## Declare Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-transactions.md:23
msgid "Declare transactions are the sole mechanism for introducing new smart contracts to Starknet."
msgstr ""

#: src/ch03-01-transactions.md:25
msgid ""
"Recall programming in C++. Before employing a variable or function, it's first 'declared', signaling to the compiler its existence and type. Only then can you 'define' or use it. Declare "
"transactions in Starknet operate on similar principles: they announce a new operation, prepping it for future use."
msgstr ""

#: src/ch03-01-transactions.md:27
msgid "Versions:"
msgstr ""

#: src/ch03-01-transactions.md:29
msgid ""
"- V0 - Suited for Cairo 0 contracts before nonces.\n"
"- V1 - Tailored for Cairo 0 with nonces.\n"
"- V2 (current) - Optimized for the modern Cairo contracts."
msgstr ""

#: src/ch03-01-transactions.md:33
msgid "Here's a key distinction to understand between the different Cairo versions:"
msgstr ""

#: src/ch03-01-transactions.md:35
msgid ""
"With Cairo 0, developers sent Cairo Assembly (CASM) code directly to the sequencer. But with the contemporary Cairo version, they send Sierra code to the Sequencer. Breaking it down, Cairo 0 "
"compiled straight to CASM, while the current Cairo version compiles to Sierra, which subsequently compiles to CASM. A crucial difference is that Sierra executions are infallible and always "
"provable, whereas in Cairo 0, transactions could fail. If they did, they became non-provable. The latest Cairo iteration ensures all code compiles to Sierra, making every transaction reliable."
msgstr ""

#: src/ch03-01-transactions.md:37
msgid "When declaring a contract with the latest version, developers are essentially announcing Sierra code, not just raw CASM."
msgstr ""

#: src/ch03-01-transactions.md:39
msgid ""
"Examining the parameters of a V2 transaction reveals measures that ensure the class hash corresponds to the Sierra code being dispatched. The class hash encompasses the hash of the Cairo assembly "
"code, but since developers send Sierra code, it's imperative to ensure that the dispatched code aligns with the indicated class hash."
msgstr ""

#: src/ch03-01-transactions.md:41
msgid "// TODO -> Provide specifics about the parameters included in the transaction."
msgstr ""

#: src/ch03-01-transactions.md:43
msgid "In essence, using the most recent Cairo version implies the utilization of the latest Declare transaction version."
msgstr ""

#: src/ch03-01-transactions.md:45
#, fuzzy
msgid "## Invoke Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-transactions.md:47
msgid ""
"Unlike Declare transactions, Invoke transactions don't add new functions. They ask the network to carry out actions, such as executing or deploying contracts. This method contrasts with Ethereum, "
"where a contract can either be deployed by sending a distinct transaction or by having another smart contract factory to deploy it. Starknet uses only the second method."
msgstr ""

#: src/ch03-01-transactions.md:49
msgid "The Universal Deployer Contract (UDC) in Starknet illustrates this idea. UDC, a public utility, helps deploy contracts. This mirrors how in C++, a declared function is called to perform tasks."
msgstr ""

#: src/ch03-01-transactions.md:51
msgid ""
"In computer science terms, think of how functions operate in C++. After declaring a function or object, you invoke it to take action. Starknet's Invoke transaction works similarly, activating pre-"
"declared contracts or functions."
msgstr ""

#: src/ch03-01-transactions.md:53
msgid ""
"Every Invoke transaction in Starknet undergoes `__validate__` and `__execute__` stages. The `__validate__` step checks the transaction's correctness, similar to a syntax or logic check. After "
"validation, the `__execute__` phase processes the transaction."
msgstr ""

#: src/ch03-01-transactions.md:55
msgid "This two-step process, focusing on utilizing existing functionalities, highlights Starknet's distinct transaction strategy."
msgstr ""

#: src/ch03-01-transactions.md:57
#, fuzzy
msgid "## Deploy Account Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-transactions.md:59
msgid ""
"A challenge arises: How do you set up accounts without having one already? When creating your first smart wallet contract, deployment fees arise. How do you cover these without a smart wallet? The "
"solution is deploy account transactions."
msgstr ""

#: src/ch03-01-transactions.md:61
msgid ""
"Uniquely in Starknet, addresses can accept funds even without an associated smart wallet. This trait is pivotal during deployment. Before an account is formally created, the `__validate__` function "
"checks the proposed deployment address (even if it lacks a smart wallet) for sufficient funds. If present, the constructor proceeds, resulting in account deployment. This method guarantees the new "
"account's legitimacy and financial readiness."
msgstr ""

#: src/ch03-01-transactions.md:65
msgid ""
"It's vital to understand each transaction type. Declare transactions stand out for their role in presenting new functions. By likening the process to C++ declarations, developers can grasp the "
"reasoning behind each transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:1
#, fuzzy
msgid "# Transactions Lifecycle"
msgstr "Transacciones"

#: src/ch03-01-01-transactions-lifecycle.md:3
msgid "This chapter outlines the path of a Starknet transaction from its initiation to its finalization."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:5
msgid "Starknet processes transactions in distinct steps:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:7
msgid ""
"- A transaction starts by being sent to a gateway, a node, which acts as the Mempool.\n"
"- The Sequencer, currently a single service, first validates and then executes the transactions in order.\n"
"  - If validated successfully, the status becomes RECEIVED.\n"
"  - If not, the status is REJECTED.\n"
"  - Successfully executed transactions are applied to the state and marked as ACCEPTED_ON_L2.\n"
"  - Failed transactions during this phase are REVERTED.\n"
"- In the Prover stage, the system operates on the new block, computes its proof, and sends it to L1."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:15
msgid "The following image shows the transaction flow:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:17
#, fuzzy
msgid "<img alt=\"Transaction Overview\" src=\"img/ch03-transaction-overview.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-01-01-transactions-lifecycle.md:19
msgid "Before exploring each step in-depth, let's clarify the different transaction statuses."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:21
msgid "Each transaction has two primary status types:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:23
msgid ""
"- **finality_status**: Reflects the transaction's finality. Possible values are:\n"
"  - RECEIVED: The transaction passed Mempool validation but hasn't been included in a block.\n"
"  - ACCEPTED_ON_L2 and ACCEPTED_ON_L1: The transaction was added to a block on L2 or L1, respectively.\n"
"- **execution_status**: Indicates the transaction's execution outcome. Values include:\n"
"  - REJECTED, REVERTED, or SUCCEEDED."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:29
msgid ""
"To obtain this information, query the transaction receipt returned by the Nodes. Refer to the Tooling chapter in the Starknet Book for methods like the `transaction_receipt` command in starkli or "
"the `fetch_transaction_receipt` method in the starknet-py library. We will use these tools throughout this chapter."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:31
#, fuzzy
msgid "## Nonces in Starknet"
msgstr "## Entendiendo RPC en Starknet"

#: src/ch03-01-01-transactions-lifecycle.md:33
msgid ""
"Initially, Starknet did not incorporate nonces. This omission meant that the same transaction could be sent multiple times with an identical nonce, leading to duplicate hashes‚Äîa problem. In "
"Ethereum, nonces not only sequence transactions but also ensure each has a unique hash. Similarly, Starknet employs nonces to assign a distinct hash to every transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:35
msgid ""
"Starknet's current stance on nonces mandates that they be sequential. In other words, when you transmit a transaction from your account, its nonce must precisely follow the previous transaction's "
"nonce."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:37
msgid "Although nonce abstraction would allow developers to manage this logic at the smart contract level, Starknet is reviewing this feature. However, its implementation is not deemed a priority."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:39
#, fuzzy
msgid "## Transaction Creation"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-01-transactions-lifecycle.md:41
msgid "A transaction starts with its preparation. The sender:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:43
msgid ""
"1. Queries their account nonce, which acts as a unique identifier for the transaction.\n"
"2. Signs the transaction.\n"
"3. Sends it to their Node."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:47
msgid ""
"The Node, analogous to a post office, receives the transaction and broadcasts it on the Starknet network, primarily to the Sequencer. As the network evolves, the transaction will be broadcasted to "
"multiple Sequencers."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:49
msgid ""
"Before broadcasting the transaction to the Sequencer, the gateways perform a validation step, such as checking that the max fee exceeds a minimum fee and the account's balance is greater than the "
"max fee. The transaction will be saved in the storage if the validation function passes."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:51
#, fuzzy
msgid "## The Sequencer's Role"
msgstr "Secuenciadores"

#: src/ch03-01-01-transactions-lifecycle.md:53
msgid "On receiving the transaction, the Sequencer acknowledges its receipt but hasn't processed it yet‚Äîsimilar to Ethereum's mempool state."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:55
#, fuzzy
msgid "Sequencer's Process:"
msgstr "Secuenciadores"

#: src/ch03-01-01-transactions-lifecycle.md:57
msgid ""
"1. Receive the transaction.\n"
"2. Validate it.\n"
"3. Execute it.\n"
"4. Update the state."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:62
msgid ""
"Remember, Starknet processes transactions sequentially. The nonce won't change until the Sequencer processes the transaction. This can complicate backend application development, potentially "
"causing errors if sending multiple transactions consecutively."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:64
msgid "## Acceptance on Layer-2 (L2)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:66
msgid ""
"Once the Sequencer validates and executes a transaction, it updates the state without waiting for block creation. The transaction finality status changes from 'RECEIVED' to 'ACCEPTED ON L2' at this "
"stage and the execution status to 'SUCCEEDED'."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:68
msgid ""
"Following the state update, the transaction is included in a block. However, the block isn't emitted immediately. The Sequencer decides the opportune moment to emit the block, either when there are "
"enough transactions to form a block or after a certain time has passed. When the block is emitted, the block becomes available for other Nodes to query."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:70
msgid "The transaction will have the following status:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:72
msgid ""
"- Finality status: ACCEPTED_ON_L2\n"
"- Execution status: SUCCEEDED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:75
msgid "If a transaction fails during execution, it will be included in the block with the status 'REVERTED'. In other words, REVERTED transactions"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:77
msgid ""
"It's essential to remember that at this stage, no proof has been generated, and the transaction relies on L2 consensus for security against censorship. There remains a slim possibility of "
"transaction reversal if all Sequencers collude. Therefore, these stages should be seen as different layers of transaction finality."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:79
msgid "## Acceptance on Layer-1 (L1)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:81
msgid ""
"The final step in the transaction's lifecycle is its acceptance on Layer-1 (L1). A Prover receives the block containing the transaction, re-executes the block, generates a proof, and sends it to "
"Ethereum. Specifically, the proof is sent to a smart contract on Ethereum called the Verifier smart contract, which checks the proof's validity. If valid, the transaction's status changes to "
"'accepted on L1', signifying the transaction's security by Ethereum consensus."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:83
msgid "Transaction Status Transition:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:85
msgid "1. Accepted on L2 -> Accepted on L1"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:87
msgid "## [Optional] Transaction Finality in Starknet"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:89
msgid ""
"Transaction finality refers to the point at which a transaction is considered irreversible and is no longer susceptible to being reversed or undone. It's the assurance that once a transaction is "
"committed, it can't be altered or rolled back, hence securing the integrity of the transaction and the system as a whole."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:91
msgid "Let's dive into the transaction finality in both Starknet and Ethereum, and how they compare."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:93
msgid "### Ethereum Transaction Finality"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:95
msgid ""
"Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A transaction has the finality status when it is part of a block that can't change without a significant amount of ETH getting "
"burned. The number of blocks required to ensure that a transaction won't be rolled back is called 'blocks to finality', and the time to create those blocks is called 'time to finality'."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:97
msgid "It is considered to be an average of 6 blocks to reach the finality status; given that a new block is validated each 12 seconds, the average time to finality for a transaction is 75 seconds."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:99
msgid "### Starknet Transaction Finality"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:101
msgid ""
"Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction finality process. The first step is when the transaction gets accepted on Layer-2 (Starknet), and the second step is when "
"the transaction gets accepted on Layer-1 (Ethereum)."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:103
msgid ""
"Accepted on L2: When a transaction is processed by the Sequencer and included in a block on Starknet, it reaches L2 finality. However, this finality relies on the L2 consensus and comes with a "
"slight risk of collusion among Sequencers leading to transaction reversal.\n"
"Accepted on L1: The absolute finality comes when the block containing the transaction gets a proof generated, the proof is validated by the Verifier contract on Ethereum, and the state is updated "
"on Ethereum. At this point, the transaction is as secure as the Ethereum's PoW consensus can provide, meaning it becomes computationally infeasible to alter or reverse."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:106
msgid "### Comparison"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:108
msgid "The main difference between Ethereum and Starknet's transaction finality lies in the stages of finality and their reliance on consensus mechanisms."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:110
msgid ""
"Ethereum's transaction finality becomes increasingly unlikely to be reversed as more blocks are added.\n"
"Starknet's finality process is two-fold. The initial finality (L2) is quicker but relies on L2 consensus and carries a small risk of collusion. The ultimate finality (L1) is slower, as it involves "
"generation and validation of proofs and updates on Ethereum. However, once reached, it provides the same level of security as an Ethereum transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:113
#, fuzzy
msgid "## REJECTED Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-01-transactions-lifecycle.md:115
msgid ""
"When a transaction passes validation in the Mempool but fails during the sequencer's **validate** phase, it receives the REJECTED status. Such transactions are not included in any block and "
"maintain the `finality_status` as RECEIVED. This rejection can occur for reasons including:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:117
msgid ""
"- Check max_fee is higher than the minimal tx cost\n"
"- Check Account balance is at least max_fee\n"
"- Check nonce. A mismatched nonce, where the transaction's nonce doesn't align with the account's expected next nonce.\n"
"- Execute **validate** (here a repeated contract declaration will fail and the transaction will be rejected)\n"
"- Limit #txs per account in the Gateway"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:123
msgid "Such transaction will have the following status:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:125
msgid ""
"- Finality status: RECEIVED\n"
"- Execution status: REJECTED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:128
msgid "To demonstrate a transaction with an invalid nonce, consider the Python code below (`get_transaction_receipt.py`). Using the `starknet-py` library, it fetches a rejected transaction:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:130
msgid ""
"```python\n"
"import asyncio\n"
"from starknet_py.net.gateway_client import GatewayClient\n"
"\n"
"async def fetch_transaction_receipt(transaction_id: str, network: str = \"testnet\"):\n"
"    client = GatewayClient(network)\n"
"    call_result = await client.get_transaction_receipt(transaction_id)\n"
"    return call_result\n"
"\n"
"receipt = asyncio.run(fetch_transaction_receipt(\"0x6d6e6575b85913ee8dfb170fe0db418f58f9422a0c6115350a79f9b38a1f5b8\"))\n"
"print(receipt)\n"
"```"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:143
msgid "Execute the code with:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:145
msgid ""
"```bash\n"
"python3 get_transaction_receipt.py\n"
"```"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:149
msgid "The resulting transaction receipt will include:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:151
msgid ""
"```bash\n"
"execution_status=<TransactionExecutionStatus.REJECTED: 'REJECTED'>, finality_status=<TransactionFinalityStatus.RECEIVED: 'RECEIVED'>,\n"
"block_number=None,\n"
"actual_fee=0\n"
"```"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:157
msgid "It's important to note that the user isn't charged a fee because the transaction didn't execute in the Sequencer."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:159
#, fuzzy
msgid "## Handling of Reverted Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-01-transactions-lifecycle.md:161
msgid "A transaction can be reverted due to failed execution, the transaction will still be included in a block, and the account will be charged for the resources consumed."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:163
msgid ""
"This adds a trust assumption for the Sequencer to be honest and non-censoring. In later versions, there will be an OS change that will enable the Sequencer to prove that a transaction failed and "
"charge the correct amount of gas for it, thus making it censorship-resistant with provably failed transactions."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:165
#, fuzzy
msgid "Transaction Status Transition"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-01-transactions-lifecycle.md:167
msgid "1. Received -> Reverted"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:169
msgid "## Transaction Lifecycle Summary"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:171
msgid "The following outlines the various steps in a transaction's lifecycle:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:173
#, fuzzy
msgid "<img alt=\"Transaction flow\" src=\"img/ch03-transaction_flow.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-01-01-transactions-lifecycle.md:177
msgid ""
"The lifecycle of a Starknet transaction is a carefully curated journey, ensuring efficient, secure, and transparent transaction processing. It incorporates everything from transaction creation, "
"Sequencer processing, Layer-2 and Layer-1 validation, to handling rejected and reverted transactions. By comprehending this lifecycle, developers and users can better navigate the Starknet "
"ecosystem and leverage its capabilities to the fullest."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:1
msgid "# Fee Mechanism"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:3
msgid "> **NOTE:** This section is a work in progress. Contributions are welcome."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:5
msgid "Implementing a fee system enhances Starknet's performance. Without fees, the system risks becoming overwhelmed by numerous transactions, even with optimizations."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:7
msgid "## Fee Collection"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:9
msgid "When a transaction occurs on Layer 2 (L2), Starknet collects the corresponding fee using ERC-20 tokens. The transaction submitter pays the fee, and the sequencer receives it."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:11
#, fuzzy
msgid "## Fee Calculation"
msgstr "# Instalaci√≥n"

#: src/ch03-01-02-fee-mechanism.md:13
msgid "### Fee Measurement"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:15
msgid "Currently, fees are denominated in ETH. To determine the expected fee, multiply the transaction's gas estimate by the gas price:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:17
msgid ""
"```\n"
"expected_fee = gas_estimate * gas_price;\n"
"```"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:21
#, fuzzy
msgid "### Fee Computation"
msgstr "### Componente de Balance"

#: src/ch03-01-02-fee-mechanism.md:23
msgid "To grasp fee computation, understand these terms:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:25
msgid ""
"- **Built-In**: These are predefined operations in your code, simplifying common tasks or calculations. The following are built-ins:\n"
"\n"
"  - **Cairo Steps**: These building blocks in Cairo facilitate various program operations. Essential for running smart contracts and apps on blockchain platforms, the steps used influence a "
"program's cost and efficiency.\n"
"  - **Pedersen Hashes**: A method to convert data into a distinct code, similar to a data fingerprint, ensuring data integrity on blockchains.\n"
"  - **Range Checks**: Safety measures in programs, ensuring numbers or values stay within designated limits to avoid errors.\n"
"  - **Signature Verifications**: These confirm that a digital signature matches the anticipated one, verifying the sender's authenticity.\n"
"\n"
"- **Weight**: Indicates the significance or cost of an operation, showing how resource-intensive an action is in the program."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:34
#, fuzzy
msgid "### Computation"
msgstr "## Proceso de Compilaci√≥n"

#: src/ch03-01-02-fee-mechanism.md:36
msgid "In Cairo, each execution trace is divided into distinct slots dedicated to specific built-in components, influencing fee calculation."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:38
msgid "Consider a trace containing the following component limits:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:40
msgid ""
"| Component               | Limit       |\n"
"| ----------------------- | ----------- |\n"
"| Cairo Steps             | 200,000,000 |\n"
"| Pedersen Hashes         | 5,000,000   |\n"
"| Signature Verifications | 1,000,000   |\n"
"| Range Checks            | 2,500,000   |"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:47
msgid "When a component reaches its maximum, the proof is sent to Layer 1. It's imperative to set these component divisions beforehand as they cannot be adjusted dynamically."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:49
msgid ""
"Assuming a transaction utilizes 10,000 Cairo steps and 500 Pedersen hashes, it could accommodate 40,000 such transactions in this trace (given the calculation 20,000,000/500). The gas price becomes "
"1/40,000 of the proof submission cost. In this instance, the number of Cairo steps isn't the constraining factor, so it isn't factored into our performance estimate."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:51
msgid "Typically, the sequencer determines a vector, `CairoResourceUsage`, for every transaction. This vector accounts for:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:53
msgid ""
"1. The count of Cairo steps.\n"
"2. The application count of each Cairo built-in (like range checks and Pedersen hashes)."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:56
msgid "The sequencer then pairs this data with the `CairoResourceFeeWeights` vector, dictating the gas cost of each proof component."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:60
msgid ""
"> If a proof with 20,000,000 Pedersen hashes costs 5 million gas, then the Pedersen built-in has a weight of 0.25 gas per use (calculated as 5,000,000/20,000,000). Sequencers set these weight "
"values based on proof parameters."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:62
msgid "The fee is determined by the most restrictive component and is calculated as:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:64
msgid ""
"```\n"
"maxk[CairoResourceUsagek * CairoResourceFeeWeightsk]\n"
"```"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:68
msgid "Where \"k\" denotes the Cairo resource elements, encompassing step numbers and built-ins. The weightings for these components are:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:70
msgid ""
"| Component   | Gas Cost       | Range           |\n"
"| ----------- | -------------- | --------------- |\n"
"| Cairo Step  | 0.01 gwei/gas  | per step        |\n"
"| Pedersen    | 0.32 gwei/gas  | per application |\n"
"| Poseidon    | 0.32 gwei/gas  | per application |\n"
"| Range Check | 0.16 gwei/gas  | per application |\n"
"| ECDSA       | 20.48 gwei/gas | per application |\n"
"| Keccak      | 20.48 gwei/gas | per application |\n"
"| Bitwise     | 0.64 gwei/gas  | per application |\n"
"| EC_OP       | 10.24 gwei/gas | per application |"
msgstr ""

#: src/ch03-01-03-data-availability.md:1
msgid "# Data Availability"
msgstr ""

#: src/ch03-01-03-data-availability.md:3
msgid "Data availability is key in blockchain networks, especially in Layer 2 solutions like Starknet."
msgstr ""

#: src/ch03-01-03-data-availability.md:5
msgid ""
"Rollups, acting as a bridge between the Ethereum blockchain and off-chain computation, enable transactions off-chain while maintaining Ethereum's security and asset system. The focus often lies on "
"scaling computation and execution, but it's just part of the challenge. Both computation and data aspects are vital for effective blockchain scaling."
msgstr ""

#: src/ch03-01-03-data-availability.md:7
msgid ""
"The growing use of rollups, which facilitate more off-chain execution, intensifies the need for efficient data availability solutions. This demand arises from the necessity to store, access, and "
"verify data from off-chain transactions. Robust data availability solutions are critical for rollup success. Without effective data handling, the scalability and performance advantages of rollups "
"could be significantly undermined."
msgstr ""

#: src/ch03-01-03-data-availability.md:9
msgid ""
"Base layer blockchains such as Ethereum are evolving towards becoming Data Availability (DA) layers (more [here](https://www.youtube.com/watch?v=PNPryqrJg3s)). A prime example of this evolution is "
"Celestia. They have spearheaded this movement by developing a Layer 1 blockchain with a DA-centric approach."
msgstr ""

#: src/ch03-01-03-data-availability.md:11
msgid ""
"In parallel, Ethereum is undergoing a significant transition. Historically an execution-focused blockchain, Ethereum is now incorporating new Ethereum Improvement Proposals (EIPs) to shift its "
"focus towards DA."
msgstr ""

#: src/ch03-01-03-data-availability.md:13
#, fuzzy
msgid "## Data Availability in Starknet"
msgstr "## Mostrando StarkName"

#: src/ch03-01-03-data-availability.md:15
msgid ""
"1. **State Transition Process**: In Starknet, as in most blockchain networks, the system transitions from a state $n$ to state $(n+1)$ by executing a series of transactions within a block. In "
"Starknet's case, this is done through the Cairo language.\n"
"\n"
"2. **Accessing Current State Information**: To know the current state $n$ of the network, there are two primary sources:\n"
"   - **The Sequencer**: It holds comprehensive details about the network's current state.\n"
"   - **Layer 2 Full Nodes**: In Starknet, there are multiple full nodes, such as Juno, Papyrus, and Pathfinder, which users can run on their computers."
msgstr ""

#: src/ch03-01-03-data-availability.md:21
msgid ""
"The liveness problem arises from a concern: what happens if both the sequencer and all the full nodes become unresponsive? This could be due to a variety of reasons, such as technical failures or "
"external attacks."
msgstr ""

#: src/ch03-01-03-data-availability.md:23
msgid ""
"If for some reason, both the sequencer and the Layer 2 full nodes stop responding, there would be no way to ascertain the current state $n$ of the network. In such a scenario, while transactions "
"could still be received, the network would be unable to transition to state $(n+1)$ due to the lack of information about state $n$. Consequently, the network would essentially become stuck."
msgstr ""

#: src/ch03-01-03-data-availability.md:25
msgid ""
"Although this situation is highly unlikely, its potential impact is significant. It would halt the progress of the network, preventing any state transitions and effectively freezing operations."
msgstr ""

#: src/ch03-01-03-data-availability.md:27
msgid "## State Diffs"
msgstr ""

#: src/ch03-01-03-data-availability.md:29
msgid ""
"Starknet addresses the liveness problem through the transmission of validity proofs and state differences to Layer 1. This process is critical for ensuring that the network remains operational and "
"its state can be verified independently of the sequencer and Layer 2 full nodes."
msgstr ""

#: src/ch03-01-03-data-availability.md:31
msgid ""
"1. **Validity Proof to Layer 1**: After computing the validity proof, Starknet sends it to Layer 1, specifically to the Verifier.\n"
"\n"
"2. **State Diff as Cold Data**: Along with the validity proof, Starknet also sends what's known as the 'state diff.' The state diff represents the changes in the Layer 2 state since the last "
"validity proof was sent. This includes updates and modifications made to the network's state."
msgstr ""

#: src/ch03-01-03-data-availability.md:35
#, fuzzy
msgid "<img alt=\"\" src=\"img/ch03-state-diff-validity-proof.png\" class=\"center\" style=\"width: 70%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-01-03-data-availability.md:37
msgid ""
"The state diff involves a substantial amount of data. To manage this, the data is sent as 'cold data' to Layer 1. It implies that the data isn't directly stored but is made available in a way that "
"requires significant transactional capacity to transfer to Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:39
#, fuzzy
msgid "## Data Availability and State Changes in Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch03-01-03-data-availability.md:41
msgid ""
"**Transmitting Changes, Not Balances**: What Starknet sends to Layer 1 for data availability are the changes in state, not the new balances. This involves capturing how each transaction within a "
"validity proof alters the state."
msgstr ""

#: src/ch03-01-03-data-availability.md:43
msgid ""
"1. **Example 1**: Consider a simple scenario with three participants: Jimmy, Rose, and Nick.\n"
"\n"
"   - **Transaction Sequence**: Jimmy sends one ETH to Rose, then Rose sends half an ETH to Nick.\n"
"   - **State Changes Sent to Layer 1**: The data sent to Layer 1 would reflect that Jimmy has one ETH less, Rose has half an ETH more, and Nick also gains half an ETH.\n"
"\n"
"2. **Example 2**: The net changes are what matter. For instance, if Jimmy and Rose send ETH back and forth, but the end result is Jimmy having half an ETH more and Rose half an ETH less, only these "
"net changes are sent to Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:50
#, fuzzy
msgid "<img alt=\"\" src=\"img/ch03-state-diff-transactions.png\" class=\"center\" style=\"width: 70%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-01-03-data-availability.md:52
msgid "This approach means that even with multiple transactions, the actual data sent for availability can be less if the net state changes are minimal."
msgstr ""

#: src/ch03-01-03-data-availability.md:54
msgid ""
"In cases where transactions between parties nullify each other (e.g., Rose sends one ETH to Nick, and then Nick sends it back), no change in the state occurs. Consequently, nothing is sent to Layer "
"1 for data availability, making it the cheapest form of transaction."
msgstr ""

#: src/ch03-01-03-data-availability.md:56
msgid ""
"Since the cost of sending data to Ethereum as cold data constitutes about 90% of a Layer 2 transaction's cost, reducing the amount of data sent can significantly impact overall transaction costs. "
"Projects on Starknet often use strategies to minimize state changes in their transactions, thereby reducing the data sent to Layer 1 and lowering transaction costs."
msgstr ""

#: src/ch03-01-03-data-availability.md:58
#, fuzzy
msgid "## Reducing Data Availability Costs in Starknet"
msgstr "## Declarando Smart Contracts en Starknet"

#: src/ch03-01-03-data-availability.md:60
msgid ""
"Two main mechanisms to reduce data availability costs are currently under consideration: the implementation of EIP 4844 and the concept of Volition. Both aim to optimize how data is stored and "
"reduce the associated costs."
msgstr ""

#: src/ch03-01-03-data-availability.md:62
msgid "### EIP 4844: Blob Data and Cost Reduction"
msgstr ""

#: src/ch03-01-03-data-availability.md:64
msgid ""
"EIP 4844 proposes a change in how data availability information is sent to Layer 1. Instead of using call data, the information would be sent as blobs. This mechanism is expected to be cheaper than "
"the current method used by Starknet for posting data to Ethereum. Consequently, it would make Layer 2 transactions more affordable. A notable downside of this approach is the limited lifespan of "
"blob data. Once posted to Ethereum, this data will only be available for one month before being pruned by Layer 1 nodes."
msgstr ""

#: src/ch03-01-03-data-availability.md:66
msgid "Starknet's adoption of this feature depends on its implementation on the Ethereum mainnet. It's anticipated to be incorporated into Starknet by mid-2024, following its activation on Ethereum."
msgstr ""

#: src/ch03-01-03-data-availability.md:68
msgid "### Volition: Flexible Data Storage Options"
msgstr ""

#: src/ch03-01-03-data-availability.md:70
msgid ""
"Volition introduces the concept of choosing where to store data for transaction liveness. Users can opt to post data either to Ethereum or off-chain alternatives such as a data availability "
"committee, systems like Celestia, or EigenDA. The cost of using Volition varies based on the chosen storage option. Off-chain options are expected to be cheaper than using EIP 4844."
msgstr ""

#: src/ch03-01-03-data-availability.md:72
msgid "The timeline for enabling Volition on Starknet is not yet determined, but it's certain to follow the support of EIP 4844."
msgstr ""

#: src/ch03-01-03-data-availability.md:74
msgid ""
"While EIP 4844's blob data approach will be beneficial for multiple rollups, Volition offers a unique advantage for Starknet by providing more flexibility in data storage and potentially lowering "
"costs further. The implementation of Volition requires having a virtual machine that is not limited by the adherence to emulate the EVM, so a custom virtual machine like Cairo is required."
msgstr ""

#: src/ch03-01-03-data-availability.md:76
#, fuzzy
msgid "## Recreating Starknet's State"
msgstr "## Integrando Starknet React"

#: src/ch03-01-03-data-availability.md:78
msgid "This process is a contingency plan for extreme scenarios where the sequencer and Layer 2 full nodes become unavailable."
msgstr ""

#: src/ch03-01-03-data-availability.md:80
msgid ""
"1. Starknet, like any blockchain network, started with an empty state and a genesis block. Over time, it has processed multiple blocks, leading to changes in its state.\n"
"\n"
"2. Periodically, Starknet sends a validity proof to Layer 1. This proof attests to the computations of all the blocks processed since the last proof was sent.\n"
"\n"
"3. Along with the validity proof, Starknet sends the state difference. This state difference details the changes from the empty state to the current state, as a result of executing transactions in "
"all these blocks. The state difference is transmitted to Layer 1.\n"
"\n"
"4. As Starknet continues to produce more blocks on Layer 2, the process repeats. At some point, a new validity proof, along with a new set of transactions for data availability and the new state "
"difference, is sent to Layer 1.\n"
"\n"
"5. By applying the state differences in order, as they are sent to Layer 1, it's possible to reconstruct the Layer 2 state. This means that the entire history and current state of Starknet can be "
"pieced together from the data available on Layer 1. This is the role of the Layer 1 indexer."
msgstr ""

#: src/ch03-01-03-data-availability.md:90
#, fuzzy
msgid "<img alt=\"\" src=\"img/ch03-recreate-state.png\" class=\"center\" style=\"width: 70%;\" />"
msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-01-03-data-availability.md:92
msgid "This process ensures that the network's state is never lost and can always be recovered from Layer 1 data."
msgstr ""

#: src/ch03-01-03-data-availability.md:94
#, fuzzy
msgid "## The StarknetOS"
msgstr "# El Libro de Starknet"

#: src/ch03-01-03-data-availability.md:96
msgid ""
"The StarknetOS, the last step inside the Sequencer, plays a crucial role in determining why the state diff is the output of the SHARP and how it interacts with the network's state. The StarknetOS "
"is based on Cairo Zero, an older version of the Cairo programming language."
msgstr ""

#: src/ch03-01-03-data-availability.md:98
#, fuzzy
msgid "<img alt=\"\" src=\"img/ch03-starknetos-sequencer.png\" class=\"center\" style=\"width: 20%;\" />"
msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-01-03-data-availability.md:100
msgid "The StarknetOS receives four main inputs:"
msgstr ""

#: src/ch03-01-03-data-availability.md:102
msgid ""
"- The current state of the network.\n"
"- New blocks created since the last validity proof was sent to Layer 1. These include declare_account and invoke transactions.\n"
"- Class hashes resulting from declared transactions.\n"
"- Compiled class hashes resulting from declared transactions."
msgstr ""

#: src/ch03-01-03-data-availability.md:107
msgid ""
"The StarknetOS takes the current state and processes the new transactions and blocks. It evaluates what changes occur in the state as a result of these transactions. The output from this process "
"includes:"
msgstr ""

#: src/ch03-01-03-data-availability.md:109
msgid ""
"- The state diff: Changes in the state.\n"
"- Class hashes of newly declared smart contracts.\n"
"- Compiled class hashes of newly declared smart contracts."
msgstr ""

#: src/ch03-01-03-data-availability.md:113
#, fuzzy
msgid "<img alt=\"\" src=\"img/ch03-starknetos.png\" class=\"center\" style=\"width: 70%;\" />"
msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-01-03-data-availability.md:115
msgid ""
"The sequencer executes numerous transactions and creates blocks. When enough blocks accumulate, they trigger the creation of a validity proof. These blocks are passed to the StarknetOS to calculate "
"the state diff, class hashes, and compiled class hashes. This is the information that the Prover is tasked with proving. The output from the [Blockchain Writer](https://etherscan.io/"
"address/0x16d5783a96ab20c9157d7933ac236646b29589a4), therefore, includes these three elements: state diff, class hashes, and compiled class hashes. This output is what gets sent to the memory pages "
"smart contract on Ethereum."
msgstr ""

#: src/ch03-01-03-data-availability.md:117
msgid "## The Blockchain Writer Module"
msgstr ""

#: src/ch03-01-03-data-availability.md:119
msgid ""
"Contrary to a direct interaction between the Prover and the Ethereum Verifier, there's an intermediary process involving SHARP. The Prover in Starknet (currently [the Stone Prover](https://github."
"com/starkware-libs/stone-prover)) is focused solely on proving the execution of a Cairo program. Its role is confined to generating proofs without concerning itself with Ethereum directly. The "
"primary concern of the Prover is to accurately prove the execution of Cairo programs."
msgstr ""

#: src/ch03-01-03-data-availability.md:121
msgid "Internally, SHARP utilizes an Externally Owned Account (EOA) specifically for interacting with Ethereum. This account is responsible for conducting transactions on the Ethereum network."
msgstr ""

#: src/ch03-01-03-data-availability.md:123
msgid ""
"1. **Handling Validity Proofs and State Diff**: The actual module within SHARP that sends the validity proof and state diff to the memory pages on Ethereum is known as the [Blockchain Writer]"
"(https://etherscan.io/address/0x16d5783a96ab20c9157d7933ac236646b29589a4). This module bridges the gap between the internal workings of Starknet and the Ethereum blockchain.\n"
"\n"
"2. **Direct Interaction with Ethereum**: The output from the Prover is directed to the Blockchain Writer. It is this Blockchain Writer that interacts with Ethereum, sending data to the appropriate "
"location on the Layer 1.\n"
"\n"
"3. **Final Step in Data Transmission**: The Blockchain Writer represents the final step in the process where the proven data from Starknet's internal operations is transmitted to Ethereum for "
"storage and verification."
msgstr ""

#: src/ch03-01-03-data-availability.md:129
#, fuzzy
msgid "<img alt=\"\" src=\"img/ch03-blockchain-writer.png\" class=\"center\" style=\"width: 70%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-01-03-data-availability.md:131
msgid ""
"This is Ethereum address of the Blockchain Writer, which is by itself an EOA holding resources: [0x16d5783a96ab20c9157d7933ac236646b29589a4](https://etherscan.io/"
"address/0x16d5783a96ab20c9157d7933ac236646b29589a4)."
msgstr ""

#: src/ch03-01-03-data-availability.md:133
msgid ""
"The cost for data availability in Starknet, as handled by SHARP, is a direct expense. There isn't any form of subsidy for these costs. SHARP bears the full financial responsibility for the block "
"space required on Ethereum. The lack of subsidy in DA costs directly influences the fees users pay for transactions on Starknet."
msgstr ""

#: src/ch03-01-03-data-availability.md:135
msgid ""
"A closer look at the transactions emanating from the [Blockchain Writer](https://etherscan.io/address/0x16d5783a96ab20c9157d7933ac236646b29589a4), which are responsible for DA, reveals substantial "
"costs. SHARP incurs millions of dollars in expenses for block space on Ethereum each month."
msgstr ""

#: src/ch03-01-03-data-availability.md:137
msgid "## Data Availability Modes"
msgstr ""

#: src/ch03-01-03-data-availability.md:139
msgid "Currently, there are three primary modes, with two already in use and a third on the horizon. These modes are Rollup, Validium, and Volition."
msgstr ""

#: src/ch03-01-03-data-availability.md:141
msgid "### 1. Rollup Mode"
msgstr ""

#: src/ch03-01-03-data-availability.md:143
msgid ""
"- **Definition and Characteristics**: The data for DA is posted directly on Ethereum. This approach is what classifies a Layer 2 solution as a Rollup.\n"
"- **Advantages**: The primary benefit of Rollup mode is enhanced liveness due to the reliability and track record of Ethereum. It provides robust guarantees about data availability.\n"
"- **Cost Implications**: This mode tends to be more expensive due to the cost associated with posting data on Ethereum. However, future implementations like EIP 4844 may reduce these costs.\n"
"- **Example**: Starknet, which sends data to the memory pages smart contract, is an example of a Rollup."
msgstr ""

#: src/ch03-01-03-data-availability.md:148
msgid "### 2. Validium Mode"
msgstr ""

#: src/ch03-01-03-data-availability.md:150
msgid ""
"- **Definition and Characteristics**: Characterized by Layer 2 networks not utilizing Ethereum for DA. Instead, data is stored off-chain.\n"
"- **Advantages**: The primary advantage of Validium is cost efficiency. Transactions in Validiums are typically much cheaper than in Rollups.\n"
"- **Liveness Guarantees**: The trade-off for reduced cost is weaker liveness guarantees compared to Ethereum-based DA.\n"
"- **Example**: StarkEx is an example of Validium, known for its significantly lower transaction costs compared to Rollups."
msgstr ""

#: src/ch03-01-03-data-availability.md:155
msgid "### 3. Volition Mode (Upcoming)"
msgstr ""

#: src/ch03-01-03-data-availability.md:157
msgid ""
"- **Definition and Characteristics**: Volition mode is a hybrid DA mode that combines aspects of both Rollup and Validium. It offers users the choice of where to store data, either on-chain "
"(Ethereum) or off-chain.\n"
"- **User Choice**: The key feature of Volition mode is the flexibility it provides users in deciding their data storage preferences, balancing between cost and liveness guarantees.\n"
"- **Implementation Timeline**: Volition mode is expected to be introduced to networks like Starknet in the near future, potentially within a year or so."
msgstr ""

#: src/ch03-01-03-data-availability.md:161
msgid "The following table summarizes the key characteristics of each mode:"
msgstr ""

#: src/ch03-01-03-data-availability.md:163
msgid ""
"| Mode     | Definition                                    | Advantages                                  | Cost         | Example  |\n"
"| -------- | --------------------------------------------- | ------------------------------------------- | ------------ | -------- |\n"
"| Rollup   | Data posted on Ethereum; a Layer 2 solution.  | Reliable, robust data availability.         | Higher cost. | Starknet |\n"
"| Validium | Data stored off-chain, not on Ethereum.       | Lower transaction costs.                    | Lower cost.  | StarkEx  |\n"
"| Volition | Hybrid mode, choice of on-chain or off-chain. | Balance between cost and data availability. | -            | -        |"
msgstr ""

#: src/ch03-02-sequencers.md:1
msgid "# Sequencers"
msgstr ""

#: src/ch03-02-sequencers.md:3
msgid ""
"Before diving in, make sure to check out the [\"Understanding Starknet:\n"
"Sequencers, Provers, and\n"
"Nodes\"](https://book.starknet.io/chapter_3/topology.html) chapter for a\n"
"quick exploration of Starknet‚Äôs architecture."
msgstr ""

#: src/ch03-02-sequencers.md:8
msgid ""
"Three main layers exist in blockchain: data availability, ordering, and\n"
"execution. Sequencers have evolved within this evolving modular\n"
"landscape of blockchain technology. Most L1 blockchains, like Ethereum,\n"
"handle all these tasks. Initially, blockchains served as distributed\n"
"virtual machines focused on organizing and executing transactions. Even\n"
"roll-ups running on Ethereum today often centralize sequencing\n"
"(ordering) and execution while relying on Ethereum for data\n"
"availability. This is the current state of Starknet, which uses Ethereum\n"
"for data availability and a centralized Sequencer for ordering and\n"
"execution. However, it is possible to decentralize sequencing and\n"
"execution, as Starknet is doing."
msgstr ""

#: src/ch03-02-sequencers.md:20
msgid ""
"Each of these layers plays a crucial role in achieving consensus. First,\n"
"the data must be available. Second, it needs to be put in a specific\n"
"order. That‚Äôs the main job of a Sequencer, whether run by a single\n"
"computer or a decentralized protocol. Lastly, you execute transactions\n"
"in the order they‚Äôve been sequenced. This final step, done by the\n"
"Sequencer too, determines the system‚Äôs current state and keeps all\n"
"connected clients on the same page."
msgstr ""

#: src/ch03-02-sequencers.md:28
msgid "## Introduction to Sequencers"
msgstr ""

#: src/ch03-02-sequencers.md:30
msgid ""
"The advent of Layer Two (L2) solutions like Roll-Ups has altered the\n"
"blockchain landscape, improving scalability and efficiency. But what\n"
"about transaction order? Is it still managed by the base layer (L1), or\n"
"is an external system involved? Enter Sequencers. They ensure\n"
"transactions are in the correct order, regardless of whether they‚Äôre\n"
"managed by L1 or another system."
msgstr ""

#: src/ch03-02-sequencers.md:37
msgid ""
"In essence, sequencing has two core tasks: sequencing (ordering) and\n"
"executing (validation). First, it orders transactions, determining the\n"
"canonical sequence of blocks for a given chain fork. It then appends new\n"
"blocks to this sequence. Second, it executes these transactions,\n"
"updating the system‚Äôs state based on a given function."
msgstr ""

#: src/ch03-02-sequencers.md:43
msgid ""
"To clarify, we see sequencing as the act of taking a group of unordered\n"
"transactions and producing an ordered block. Sequencers also confirm the\n"
"resulting state of the machine. However, the approach explained here\n"
"separates these tasks. While some systems handle both ordering and state\n"
"validation simultaneously, we advocate for treating them as distinct\n"
"steps."
msgstr ""

#: src/ch03-02-sequencers.md:50
msgid "<img alt=\"Sequencer role in the Starknet network\" src=\"img/ch03-sequencer.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch03-02-sequencers.md:52
msgid "<span class=\"caption\">Sequencer role in the Starknet network</span>"
msgstr ""

#: src/ch03-02-sequencers.md:54
msgid "## Sequencers in Starknet"
msgstr ""

#: src/ch03-02-sequencers.md:56
msgid ""
"Let‚Äôs delve into Sequencers by focusing on\n"
"[Madara](https://github.com/keep-starknet-strange/madara) and\n"
"[Kraken](https://github.com/lambdaclass/starknet_stack/tree/main/sequencer),\n"
"two high-performance Starknet Sequencers. A Sequencer must, at least, do\n"
"two things: order and execute transactions."
msgstr ""

#: src/ch03-02-sequencers.md:62
msgid ""
"- **Ordering**: Madara handles the sequencing process, supporting\n"
"  methods from simple FCFS and PGA to complex ones like Narwhall &\n"
"  Bullshark. It also manages the mempool, a critical data structure\n"
"  that holds unconfirmed transactions. Developers can choose the\n"
"  consensus protocol through Madara‚Äôs use of Substrate, which offers\n"
"  multiple built-in options.\n"
"\n"
"- **Execution**: Madara lets you choose between two execution crates:\n"
"  [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)\n"
"  and\n"
"  [Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust).\n"
"  Both use the [Cairo VM](https://github.com/lambdaclass/cairo-vm) for\n"
"  their framework."
msgstr ""

#: src/ch03-02-sequencers.md:76
msgid "We also have the Kraken Sequencer as another option."
msgstr ""

#: src/ch03-02-sequencers.md:78
msgid ""
"- **Ordering**: It employs Narwhall & Bullshark for mempool\n"
"  management. You can choose from multiple consensus methods, like\n"
"  Bullshark, Tendermint, or Hotstuff.\n"
"\n"
"- **Execution**: Runs on Starknet_in_Rust. Execution can be deferred\n"
"  to either [Cairo\n"
"  Native](https://github.com/lambdaclass/cairo_native) or [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm)."
msgstr ""

#: src/ch03-02-sequencers.md:87
msgid ""
"<table style=\"width:100%;\">\n"
"<colgroup>\n"
"<col style=\"width: 42%\" />\n"
"<col style=\"width: 28%\" />\n"
"<col style=\"width: 28%\" />\n"
"</colgroup>\n"
"<thead>\n"
"<tr class=\"header\">\n"
"<th style=\"text-align: left;\">Feature</th>\n"
"<th style=\"text-align: left;\"><a\n"
"href=\"https://github.com/keep-starknet-strange/madara\">Madara</a></th>\n"
"<th style=\"text-align: left;\"><a\n"
"href=\"https://github.com/lambdaclass/starknet_stack/tree/main/sequencer\">Kraken</a></th>\n"
"</tr>\n"
"</thead>\n"
"<tbody>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Ordering\n"
"Method</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>FCFS, PGA, Narwhall &amp;\n"
"Bullshark</p></td>\n"
"<td style=\"text-align: left;\"><p>Narwhall &amp; Bullshark</p></td>\n"
"</tr>\n"
"<tr class=\"even\">\n"
"<td style=\"text-align: left;\"><p><strong>Mempool\n"
"Management</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>Managed by Madara</p></td>\n"
"<td style=\"text-align: left;\"><p>Managed using Narwhall &amp;\n"
"Bullshark</p></td>\n"
"</tr>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Consensus\n"
"Options</strong></p></td>\n"
"<td style=\"text-align: left;\"><p>Developer‚Äôs choice through\n"
"Substrate</p></td>\n"
"<td style=\"text-align: left;\"><p>Bullshark, Tendermint or\n"
"Hotstuff</p></td>\n"
"</tr>\n"
"<tr class=\"even\">\n"
"<td style=\"text-align: left;\"><p><strong>Execution\n"
"Crates</strong></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/starkware-libs/blockifier/tree/main\">Blockifier</a>,\n"
"Starknet_in_rust</p></td>\n"
"<td style=\"text-align: left;\"><p>Starknet_in_rust</p></td>\n"
"</tr>\n"
"<tr class=\"odd\">\n"
"<td style=\"text-align: left;\"><p><strong>Execution\n"
"Framework</strong></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
"<td style=\"text-align: left;\"><p><a\n"
"href=\"https://github.com/lambdaclass/cairo_native\">Cairo Native</a> or\n"
"<a href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
"</tr>\n"
"</tbody>\n"
"</table>"
msgstr ""

#: src/ch03-02-sequencers.md:145
msgid "### Understanding the Execution Layer"
msgstr ""

#: src/ch03-02-sequencers.md:147
msgid ""
"- [Blockifier](https://github.com/starkware-libs/blockifier/tree/main),\n"
"  a Rust component in Starknet Sequencers, generates state diffs and\n"
"  blocks. It uses [Cairo VM](https://github.com/lambdaclass/cairo-vm).\n"
"  Its goal is to become a full Starknet Sequencer.\n"
"\n"
"- Starknet_in_Rust is another Rust component for Starknet that also\n"
"  generates state diffs and blocks. It uses [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm).\n"
"\n"
"- [Cairo Native](https://github.com/lambdaclass/cairo_native) stands\n"
"  out by converting Cairo‚Äôs Sierra code to MLIR. See an example\n"
"  [here](https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)."
msgstr ""

#: src/ch03-02-sequencers.md:160
msgid "## The Need for Decentralized Sequencers"
msgstr ""

#: src/ch03-02-sequencers.md:162
msgid ""
"For more details on the Decentralization of Starknet, refer to the\n"
"dedicated subchapter in this Chapter."
msgstr ""

#: src/ch03-02-sequencers.md:165
msgid ""
"Proving transactions doesn‚Äôt require to be decentralized (although in\n"
"the near future Starknet will operate with decentralized provers). Once\n"
"the order is set, anyone can submit a proof; it‚Äôs either correct or not.\n"
"However, the process that determines this order should be decentralized\n"
"to maintain a blockchain‚Äôs original qualities."
msgstr ""

#: src/ch03-02-sequencers.md:171
msgid ""
"In the context of Ethereum‚Äôs Layer 1 (L1), Sequencers can be likened to\n"
"Ethereum validators. They are responsible for creating and broadcasting\n"
"blocks. This role is divided under the concept of \"Proposer-Builder\n"
"Separation\" (PBS) ([Hasu,\n"
"2023](https://www.youtube.com/watch?v=6xS0xMzh9Tc)). Block builders form\n"
"blocks (order the transactions), while block proposers, unaware of the\n"
"block‚Äôs content, choose the most profitable one. This separation\n"
"prevents transaction censorship at the protocol level. Currently, most\n"
"Layer 2 (L2) Sequencers, including Starknet, perform both roles, which\n"
"can create issues."
msgstr ""

#: src/ch03-02-sequencers.md:182
msgid ""
"The drive toward centralized Sequencers mainly stems from performance\n"
"issues like high costs and poor user experience on Ethereum for both\n"
"data storage and transaction ordering. The challenge is scalability: how\n"
"to expand without sacrificing decentralization. Opting for\n"
"centralization risks turning the blockchain monopolistic, negating its\n"
"unique advantages like network-effect services without monopoly."
msgstr ""

#: src/ch03-02-sequencers.md:189
msgid ""
"With centralization, blockchain loses its core principles: credible\n"
"neutrality and resistance to monopolization. What‚Äôs wrong with a\n"
"centralized system? It raises the risks of censorship (via transaction\n"
"reordering)."
msgstr ""

#: src/ch03-02-sequencers.md:194
msgid "A centralized validity roll-up looks like this:"
msgstr ""

#: src/ch03-02-sequencers.md:196
msgid ""
"- User Interaction & Selection: Users send transactions to a\n"
"  centralized Sequencer, which selects and orders them.\n"
"\n"
"- Block Formation: The Sequencer packages these ordered transactions\n"
"  into a block.\n"
"\n"
"- Proof & Verification: The block is sent to a proving service, which\n"
"  generates a proof and posts it to Layer 1 (L1) for verification.\n"
"\n"
"- Verification: Once verified on L1, the transactions are considered\n"
"  finalized and integrated into the L1 blockchain."
msgstr ""

#: src/ch03-02-sequencers.md:208
msgid "<img alt=\"Centralized rollup\" src=\"img/ch03-centralized-rollup.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch03-02-sequencers.md:210
msgid "<span class=\"caption\">Centralized rollup</span>"
msgstr ""

#: src/ch03-02-sequencers.md:212
msgid ""
"While centralized roll-ups can provide L1 security, they come with a\n"
"significant downside: the risk of censorship. Hence, the push for\n"
"decentralization in roll-ups."
msgstr ""

#: src/ch03-02-sequencers.md:218
msgid ""
"This chapter has dissected the role of Sequencers in the complex\n"
"ecosystem of blockchain technology, focusing on Starknet‚Äôs current state\n"
"and future directions. Sequencers essentially serve two main functions:\n"
"ordering transactions and executing them. While these tasks may seem\n"
"straightforward, they are pivotal in achieving network consensus and\n"
"ensuring security."
msgstr ""

#: src/ch03-02-sequencers.md:225
msgid ""
"Given the evolving modular architecture of blockchain‚Äîwith distinct\n"
"layers for data availability, transaction ordering, and\n"
"execution‚ÄîSequencers provide a crucial link. Their role gains more\n"
"significance in the context of Layer 2 solutions, where achieving\n"
"scalability without sacrificing decentralization is a pressing concern."
msgstr ""

#: src/ch03-02-sequencers.md:231
msgid ""
"In Starknet, Sequencers like Madara and Kraken demonstrate the potential\n"
"of high-performance, customizable solutions. These Sequencers allow for\n"
"a range of ordering methods and execution frameworks, proving that\n"
"there‚Äôs room for innovation even within seemingly rigid structures."
msgstr ""

#: src/ch03-02-sequencers.md:236
msgid ""
"The discussion on \"Proposer-Builder Separation\" (PBS) highlights the\n"
"need for role specialization to maintain a system‚Äôs integrity and thwart\n"
"transaction censorship. This becomes especially crucial when we\n"
"recognize that the current model of many L2 Sequencers, Starknet\n"
"included, performs both proposing and building, potentially exposing the\n"
"network to vulnerabilities."
msgstr ""

#: src/ch03-02-sequencers.md:243
msgid ""
"To reiterate, Sequencers aren‚Äôt just a mechanism for transaction\n"
"ordering and execution; they are a linchpin in blockchain‚Äôs\n"
"decentralized ethos. Whether centralized or decentralized, Sequencers\n"
"must strike a delicate balance between scalability, efficiency, and the\n"
"overarching principle of decentralization."
msgstr ""

#: src/ch03-02-sequencers.md:249
msgid ""
"As blockchain technology continues to mature, it‚Äôs worth keeping an eye\n"
"on how the role of Sequencers evolves. They hold the potential to either\n"
"strengthen or weaken the unique advantages that make blockchain\n"
"technology so revolutionary."
msgstr ""

#: src/ch03-02-01-madara.md:1
msgid "# Madara üöß"
msgstr ""

#: src/ch03-02-01-madara.md:3
msgid "> **TODO:** ADD EXAMPLES OF HOW TO SET UP AND USE MADARA"
msgstr ""

#: src/ch03-02-01-madara.md:5
msgid ""
"Madara is a Starknet sequencer that operates on the Substrate framework, executing Cairo programs and Starknet smart contracts with the Cairo VM. Madara enables the launch and control of Starknet "
"Appchains or L3s."
msgstr ""

#: src/ch03-02-01-madara.md:7
#, fuzzy
msgid "## Get Started with Madara"
msgstr "## Primeros Pasos con Katana"

#: src/ch03-02-01-madara.md:9
msgid "Visit the [GitHub repository](https://github.com/madara) for detailed instructions on installing and configuring Madara, including practical examples."
msgstr ""

#: src/ch03-02-01-madara.md:11
msgid "## TODO: ADD EXAMPLES OF HOW TO SET UP AND USE MADARA"
msgstr ""

#: src/ch03-03-provers.md:1
msgid "# Provers"
msgstr ""

#: src/ch03-03-provers.md:3
msgid ""
"SHARP is like public transportation for proofs on Starknet, aggregating\n"
"multiple Cairo programs to save costs and boost efficiency. It uses\n"
"recursive proofs, allowing parallelization and optimization, making it\n"
"more affordable for all users. Critical services like the gateway,\n"
"validator, and Prover work together with a stateless design for\n"
"flexibility. SHARP‚Äôs adoption by StarkEx, Starknet, and external users\n"
"(through the Cairo Playground) highlights its significance and potential\n"
"for future optimization."
msgstr ""

#: src/ch03-03-provers.md:12
msgid ""
"This chapter will discuss SHARP, how it has evolved to incorporate\n"
"recursive proofs, and its role in reducing costs and improving\n"
"efficiency within the Starknet network."
msgstr ""

#: src/ch03-03-provers.md:16
msgid "## What is SHARP?"
msgstr ""

#: src/ch03-03-provers.md:18
msgid ""
"SHARP, which stands for \"Shared Prover\", is a mechanism used in Starknet\n"
"that aggregates multiple Cairo programs from different users, each\n"
"containing different logic. These Cairo programs are then executed\n"
"together, generating a single proof common to all the programs. Rather\n"
"than sending the proof directly to the Solidity Verifier in Ethereum, it\n"
"is initially sent to a STARK Verifier program written in Cairo. The\n"
"STARK Verifier generates a new proof to confirm that the initial proofs\n"
"were verified, which can be sent back into SHARP and the STARK Verifier.\n"
"This recursive proof process will be discussed in more detail later in\n"
"this chapter. Ultimately, the last proof in the series is sent to the\n"
"Solidity Verifier on Ethereum. In other words, there are many proofs\n"
"generated until we reach Ethereum and the Solidity Verifier."
msgstr ""

#: src/ch03-03-provers.md:31
msgid ""
"The primary benefit of SHARP system lies in its ability to decrease\n"
"costs and enhance efficiency within the Starknet network. It achieves\n"
"this by aggregating multiple Cairo jobs, which are individual sets of\n"
"computations. This aggregation allows the protocol to leverage the\n"
"exponential amortization offered by STARK proofs."
msgstr ""

#: src/ch03-03-provers.md:37
msgid ""
"Exponential amortization means that as the computational load of the\n"
"proofs increases, the cost of verifying those proofs rises at a slower\n"
"logarithmic rate than the computation increase. In other words, the\n"
"computation itself grows slower than the verification cost. As a result,\n"
"the cost of each transaction within the aggregated set is significantly\n"
"reduced, making the overall process more cost-effective and accessible\n"
"for users."
msgstr ""

#: src/ch03-03-provers.md:45
msgid ""
"In SHARP and Cairo context, \"jobs\" refer to the individual Cairo\n"
"programs or tasks submitted by different users. These jobs contain\n"
"specific logic or computations that must be executed on the Starknet\n"
"network."
msgstr ""

#: src/ch03-03-provers.md:50
msgid ""
"Additionally, SHARP allows smaller users with limited computation to\n"
"benefit from joining other jobs and share the cost of generating the\n"
"proofs. This collaborative approach is similar to using public\n"
"transportation instead of a private car, where the cost is distributed\n"
"among all participants, making it more affordable for everyone."
msgstr ""

#: src/ch03-03-provers.md:56
msgid "## Recursive Proofs in SHARP"
msgstr ""

#: src/ch03-03-provers.md:58
msgid ""
"One of the most powerful features of SHARP is its use of recursive\n"
"proofs. Rather than directly sending the generated proofs to the\n"
"Solidity Verifier, they are first sent to a STARK Verifier program\n"
"written in Cairo. This Verifier, which is also a Cairo Program, receives\n"
"the proof and creates a new Cairo job that is sent to the Prover. The\n"
"Prover then generates a new proof to confirm that the initial proofs\n"
"were verified. These new proofs can be sent back into SHARP and the\n"
"STARK Verifier, restarting the process."
msgstr ""

#: src/ch03-03-provers.md:67
msgid ""
"This process continues recursively, with each new proof being sent to\n"
"the Cairo Verifier until a trigger is reached. At this point, the last\n"
"proof in the series is sent to the Solidity Verifier on Ethereum. This\n"
"approach allows for greater parallelization of the computation and\n"
"reduces the time and cost associated with generating and verifying\n"
"proofs."
msgstr ""

#: src/ch03-03-provers.md:74
msgid ""
"     Generated Proofs\n"
"                 |\n"
"                 V\n"
"    STARK Verifier program (in Cairo)\n"
"                 |\n"
"                 V\n"
"            Cairo Job\n"
"                 |\n"
"                 V\n"
"                Prover\n"
"                 |\n"
"                 V\n"
"      New Proof Generated\n"
"                 |\n"
"                 V\n"
"           Repeat Process\n"
"                 |\n"
"                 V\n"
"     Trigger Reached (last proof)\n"
"                 |\n"
"                 V\n"
"        Solidity Verifier"
msgstr ""

#: src/ch03-03-provers.md:97
msgid ""
"At first glance, recursive proofs may seem more complex and\n"
"time-consuming. However, there are several benefits to this approach:"
msgstr ""

#: src/ch03-03-provers.md:100
msgid ""
"1.  **Parallelization**: Recursive proofs allow for work\n"
"    parallelization, reducing user latency and improving SHARP\n"
"    efficiency.\n"
"\n"
"2.  **Cheaper on-chain costs**: Parallelization enables SHARP to create\n"
"    larger proofs, which would have previously been limited by the\n"
"    availability of large cloud machines (which are rare and limited).\n"
"    As a result, on-chain costs are reduced.\n"
"\n"
"3.  **Lower cloud costs**: Since each job is shorter, the required\n"
"    memory for processing is reduced, resulting in lower cloud costs.\n"
"\n"
"4.  **Optimization**: Recursive proofs enable SHARP to optimize for\n"
"    various factors, including latency, on-chain costs, and time to\n"
"    proof.\n"
"\n"
"5.  **Cairo support**: Recursive proofs only require support in Cairo,\n"
"    without the need to add support in the Solidity Verifier."
msgstr ""

#: src/ch03-03-provers.md:119
msgid ""
"Latency in Starknet encompasses the time taken for processing,\n"
"confirming, and including transactions in a block. It is affected by\n"
"factors like network congestion, transaction fees, and system\n"
"efficiency. Minimizing latency ensures faster transaction processing and\n"
"user feedback."
msgstr ""

#: src/ch03-03-provers.md:125
msgid ""
"Time to proof, however, specifically pertains to the duration required\n"
"to generate and verify cryptographic proofs for transactions or\n"
"operations."
msgstr ""

#: src/ch03-03-provers.md:129
msgid "## SHARP Backend Architecture and Data Pipeline"
msgstr ""

#: src/ch03-03-provers.md:131
msgid ""
"SHARP back end architecture consists of several services that work\n"
"together to process Cairo jobs and generate proofs. These services\n"
"include:"
msgstr ""

#: src/ch03-03-provers.md:135
msgid ""
"1.  **Gateway**: Cairo jobs enter SHARP through the gateway.\n"
"\n"
"2.  **Job Creator**: It prevents job duplication and ensures that the\n"
"    system operates consistently, regardless of multiple identical\n"
"    requests.\n"
"\n"
"3.  **Validator**: This is the first important step. The validator\n"
"    service runs validation checks on each job, ensuring they meet the\n"
"    requirements and can fit within the prover machines. Invalid jobs\n"
"    are tagged as such and do not proceed to the Prover.\n"
"\n"
"4.  **Scheduler**: The scheduler service creates \"trains\" that aggregate\n"
"    jobs and send them to the Prover. Recursive jobs are paired and sent\n"
"    to the Prover together.\n"
"\n"
"5.  **Cairo Runner**: This service runs Cairo for the Prover‚Äôs needs.\n"
"    The Cairo Runner service runs Cairo programs, executing the\n"
"    necessary computations and generating the execution trace as an\n"
"    intermediate result. The Prover then uses this execution trace.\n"
"\n"
"6.  **Prover**: The Prover computes the proofs for each train (that\n"
"    contains a few jobs).\n"
"\n"
"7.  **Dispatcher**: The Dispatcher serves two functions in the SHARP\n"
"    system.\n"
"\n"
"    1.  In the case of a recursive proof, the Dispatcher runs the Cairo\n"
"        Verifier program on the proof it has received from the Prover,\n"
"        resulting in a new Cairo job that goes back to the Validator.\n"
"\n"
"    2.  In the case of a proof that needs to go on chain (e.g., to\n"
"        Ethereum), the Dispatcher creates \"packages\" from the proof,\n"
"        which can then be sent to the Blockchain Writer.\n"
"\n"
"8.  **Blockchain Writer**: Once the packages have been created by the\n"
"    Dispatcher, they are sent to the Blockchain Writer. The Blockchain\n"
"    Writer is responsible for sending the packages to the appropriate\n"
"    blockchain (e.g., Ethereum) for verification. This is an important\n"
"    step in the SHARP system, as it ensures that the proofs are properly\n"
"    verified and that the transactions are securely recorded on the\n"
"    blockchain.\n"
"\n"
"9.  **Catcher**: The Catcher monitors blockchain (e.g., Ethereum)\n"
"    transactions to ensure that they have been accepted. While the\n"
"    Catcher is relevant for internal monitoring purposes, it is\n"
"    important to note that if a transaction fails, the fact won‚Äôt be\n"
"    registered on-chain in the fact registry. As a result, the soundness\n"
"    of the system is still preserved even without the catcher."
msgstr ""

#: src/ch03-03-provers.md:184
msgid ""
"SHARP is designed to be stateless (each Cairo job is executed in its own\n"
"context and has no dependency on other jobs), allowing for greater\n"
"flexibility in processing jobs."
msgstr ""

#: src/ch03-03-provers.md:188
msgid "## Current SHARP Users"
msgstr ""

#: src/ch03-03-provers.md:190
msgid "Currently, the primary users of SHARP include:"
msgstr ""

#: src/ch03-03-provers.md:192
msgid ""
"- StarkEx\n"
"\n"
"- Starknet\n"
"\n"
"- External users who use the Cairo Playground"
msgstr ""

#: src/ch03-03-provers.md:198
msgid "## Challenges and Optimization"
msgstr ""

#: src/ch03-03-provers.md:200
msgid ""
"Optimizing the Prover involves numerous challenges and potential\n"
"projects on which the Starkware team and the community are currently\n"
"working:"
msgstr ""

#: src/ch03-03-provers.md:204
msgid ""
"- Exploring more efficient hash functions: SHARP is constantly\n"
"  exploring more efficient hash functions for Cairo, the Prover, and\n"
"  Solidity.\n"
"\n"
"- Investigating smaller fields: Investigating smaller fields for\n"
"  recursive proof steps could lead to more efficient computations.\n"
"\n"
"- Adjusting various parameters: SHARP is continually adjusting various\n"
"  parameters of the STARK protocol, such as FRI parameters and block\n"
"  factors.\n"
"\n"
"- Optimizing the Cairo code: SHARP is optimizing the Cairo code to\n"
"  make it faster, resulting in a faster recursive prover.\n"
"\n"
"- Developing dynamic layouts: This will allow Cairo programs to scale\n"
"  resources depending on their needs.\n"
"\n"
"- Improving scheduling algorithm: This is another optimization path\n"
"  that can be taken. It is not within the Prover itself."
msgstr ""

#: src/ch03-03-provers.md:224
msgid ""
"In particular, dynamic layouts (you can learn more about layouts here\n"
"(TODO)) will allow Cairo programs to scale resources depending on their\n"
"needs. This can lead to more efficient computation and better\n"
"utilization of resources. Dynamic layouts allow SHARP to determine the\n"
"required resources for a specific job and adjust the layout accordingly\n"
"instead of relying on predefined layouts with fixed resources. This\n"
"approach can provide tailored solutions for each job, improving overall\n"
"efficiency."
msgstr ""

#: src/ch03-03-provers.md:235
msgid ""
"In conclusion, SHARP is a critical component of Starknet‚Äôs architecture,\n"
"providing a more efficient and cost-effective solution for processing\n"
"Cairo programs and verifying their proofs. By leveraging the power of\n"
"STARK technology and incorporating recursive proofs, SHARP plays a vital\n"
"role in improving the overall performance and scalability of the\n"
"Starknet network. The stateless nature of SHARP and the reliance on the\n"
"cryptographic soundness of the STARK proving system make it an\n"
"innovative and valuable addition to the blockchain ecosystem."
msgstr ""

#: src/ch03-04-nodes.md:1
msgid "# Nodes"
msgstr ""

#: src/ch03-04-nodes.md:3
msgid "This chapter explores the role and functionality of nodes in the Starknet ecosystem, their interactions with sequencers, and their overall importance."
msgstr ""

#: src/ch03-04-nodes.md:5
#, fuzzy
msgid "## Contributing to the Guide"
msgstr "# Tus Contribuciones Importan"

#: src/ch03-04-nodes.md:7
msgid "Your contributions can help enhance this guide. Specifically, you can add:"
msgstr ""

#: src/ch03-04-nodes.md:9
msgid ""
"- Additional hardware options for running a Starknet node.\n"
"- Alternative methods to set up and operate a Starknet node."
msgstr ""

#: src/ch03-04-nodes.md:12
msgid "To contribute, feel free to [open a PR](https://github.com/starknet-edu/starknetbook) with your suggestions or additions."
msgstr ""

#: src/ch03-04-nodes.md:14
msgid "## Overview of Nodes in the Starknet Ecosystem"
msgstr ""

#: src/ch03-04-nodes.md:16
msgid ""
"A node in the Starknet ecosystem is a computer equipped with Starknet software, contributing significantly to the network's operations. Nodes are vital for the Starknet ecosystem's functionality, "
"security, and overall health. Without nodes, the Starknet network would not be able to function effectively."
msgstr ""

#: src/ch03-04-nodes.md:18
msgid "Nodes in Starknet are categorized into two types:"
msgstr ""

#: src/ch03-04-nodes.md:20
msgid ""
"- **Full Nodes**: Store the entire Starknet state and validate all transactions, crucial for the network's integrity.\n"
"\n"
"- **Light Nodes**: Do not store the entire Starknet state but rely on full nodes for information. They are faster and more efficient but offer less security than full nodes."
msgstr ""

#: src/ch03-04-nodes.md:24
#, fuzzy
msgid "### Core Functions of Nodes"
msgstr "### Funciones de Escritura"

#: src/ch03-04-nodes.md:26
msgid "Nodes are fundamental to the Starknet network, performing a variety of critical functions:"
msgstr ""

#: src/ch03-04-nodes.md:28
msgid ""
"- **Transaction Validation**: Nodes ensure transactions comply with Starknet's rules, helping prevent fraud and malicious activities.\n"
"\n"
"- **Block Creation and Propagation**: They create and circulate blocks to maintain a consistent blockchain view across the network.\n"
"\n"
"- **State Maintenance**: Nodes track the Starknet network's current state, including user balances and smart contract code, essential for transaction processing and smart contract execution.\n"
"\n"
"- **API Endpoint Provision**: Nodes provide API endpoints, aiding developers in creating applications, wallets, and tools for network interaction.\n"
"\n"
"- **Transaction Relay**: They relay user transactions to other nodes, improving network performance and reducing congestion."
msgstr ""

#: src/ch03-04-nodes.md:38
msgid "## Interplay of Nodes, Sequencers, Clients, and Mempool in the Starknet Network"
msgstr ""

#: src/ch03-04-nodes.md:40
#, fuzzy
msgid "### Nodes and Sequencers"
msgstr "Secuenciadores"

#: src/ch03-04-nodes.md:42
msgid "Nodes and sequencers are interdependent:"
msgstr ""

#: src/ch03-04-nodes.md:44
msgid ""
"- **Nodes and Block Production**: Nodes depend on sequencers to create blocks and update the network state. Sequencers integrate the transactions validated by nodes into blocks, maintaining a "
"consistent and current Starknet state.\n"
"\n"
"- **Sequencers and Transaction Validation**: Sequencers rely on nodes for transaction validation and network consensus. Prior to executing transactions, sequencers work with nodes to confirm "
"transaction legitimacy, deterring fraudulent activities. Nodes also contribute to the consensus mechanism, ensuring uniformity in the blockchain state."
msgstr ""

#: src/ch03-04-nodes.md:48
msgid "### Nodes and Clients"
msgstr ""

#: src/ch03-04-nodes.md:50
msgid "The relationship between nodes and clients in the Starknet ecosystem is characterized by a client-server model:"
msgstr ""

#: src/ch03-04-nodes.md:52
msgid ""
"- **Client Requests and Node Responses**: Clients initiate by sending requests, like transaction submissions or state queries. Nodes process these, validating transactions, updating the network "
"state, and furnishing clients with the requested data.\n"
"\n"
"- **Client Experience**: Clients receive node responses, updating their local view with the latest network information. This loop enables user interaction with Starknet DApps, with nodes "
"maintaining network integrity and clients offering a user-friendly interface."
msgstr ""

#: src/ch03-04-nodes.md:56
msgid "### Nodes and the Mempool"
msgstr ""

#: src/ch03-04-nodes.md:58
msgid "The mempool acts as a holding area for unprocessed transactions:"
msgstr ""

#: src/ch03-04-nodes.md:60
msgid ""
"- **Transaction Validation and Mempool Storage**: Upon receiving a transaction, nodes validate it. Valid transactions are added to the mempool and broadcast to other network nodes.\n"
"\n"
"- **Transaction Selection and Block Inclusion**: Nodes select transactions from the mempool for processing, incorporating them into blocks that are added to the blockchain."
msgstr ""

#: src/ch03-04-nodes.md:64
#, fuzzy
msgid "## Node Implementations in Starknet"
msgstr "## Entendiendo RPC en Starknet"

#: src/ch03-04-nodes.md:66
msgid "Starknet's node implementations bring unique strengths:"
msgstr ""

#: src/ch03-04-nodes.md:68
msgid ""
"- **[Pathfinder](https://github.com/eqlabs/pathfinder)**: By Equilibrium, Pathfinder is a Rust-written full node. It excels in high performance, scalability, and aligns with the Starknet Cairo "
"specification.\n"
"\n"
"- **[Juno](https://github.com/NethermindEth/juno)**: Nethermind's Juno, another full node in Golang, is known for user-friendliness, ease of deployment, and Ethereum tool compatibility.\n"
"\n"
"- **[Papyrus](https://github.com/starkware-libs/papyrus)**: StarkWare's Papyrus, a Rust-based full node, focuses on security and robustness. It's integral to the upcoming Starknet Sequencer, "
"expected to boost network throughput."
msgstr ""

#: src/ch03-04-nodes.md:74
msgid "These implementations are under continuous improvement, with new features and enhancements. The choice of implementation depends on user or developer preferences and requirements."
msgstr ""

#: src/ch03-04-nodes.md:76
msgid "Key characteristics of each node implementation are summarized below:"
msgstr ""

#: src/ch03-04-nodes.md:78
msgid ""
"| Node Implementation | Language | Strengths                                                     |\n"
"| ------------------- | -------- | ------------------------------------------------------------- |\n"
"| Pathfinder          | Rust     | High performance, scalability, Cairo specification adherence  |\n"
"| Papyrus             | Rust     | Security, robustness, Starknet Sequencer foundation           |\n"
"| Juno                | Golang   | User-friendliness, ease of deployment, Ethereum compatibility |"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:1
#, fuzzy
msgid "# Implementing a Pathfinder Node"
msgstr "## Implementaci√≥n del Token ERC20"

#: src/ch03-04-01-pathfinder-node.md:3
msgid "### Hardware Recommendations for Pathfinder Node"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:5
msgid "To ensure optimal performance and reliability, the following hardware is recommended for running a Pathfinder node:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:7
msgid ""
"- **CPU**: Intel Core i7-9700 or AMD Ryzen 7 3700X\n"
"- **Memory**: 32GB\n"
"- **Storage**: 1TB SSD\n"
"- **Network**: Gigabit Ethernet"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:12
msgid "### Estimated Costs for Recommended Hardware"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:14
msgid "The approximate pricing in USD for the recommended hardware is:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:16
msgid ""
"- **CPU**: $300\n"
"- **Memory**: $100\n"
"- **Storage**: $100\n"
"- **Network Hardware**: $50"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:21
msgid "Total estimated cost: Approximately $550."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:23
msgid "## Running Pathfinder Node Using Docker"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:25
msgid "For those who prefer a self-managed setup of all dependencies, refer to the comprehensive [Installation from Source](doc/install-from-source.md) guide."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:27
msgid "### Prerequisites"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:29
msgid "- Ensure [Docker is installed](https://docs.docker.com/get-docker/). For Ubuntu, use `sudo snap install docker`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:31
#, fuzzy
msgid "### Setup and Execution"
msgstr "### Leer Funciones"

#: src/ch03-04-01-pathfinder-node.md:33
msgid "1. **Prepare Data Directory**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:35
msgid "Create a data directory, `$HOME/pathfinder`, to store persistent files used by `pathfinder`:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:37
msgid ""
"```bash\n"
"mkdir -p $HOME/pathfinder\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:41
msgid "2. **Start Pathfinder Node**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:43
msgid "Run the `pathfinder` node using Docker with the following command:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:45 src/ch03-04-01-pathfinder-node.md:103
msgid ""
"```bash\n"
"sudo docker run \\\n"
"  --name pathfinder \\\n"
"  --restart unless-stopped \\\n"
"  --detach \\\n"
"  -p 9545:9545 \\\n"
"  --user \"$(id -u):$(id -g)\" \\\n"
"  -e RUST_LOG=info \\\n"
"  -e PATHFINDER_ETHEREUM_API_URL=\"https://goerli.infura.io/v3/<project-id>\" \\\n"
"  -v $HOME/pathfinder:/usr/share/pathfinder/data \\\n"
"  eqlabs/pathfinder\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:58
msgid "3. **Monitoring Logs**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:60
msgid "To view the node logs, use:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:62
#, fuzzy
msgid ""
"```bash\n"
"sudo docker logs -f pathfinder\n"
"```"
msgstr ""
"```bash\n"
"vercel login\n"
"```"

#: src/ch03-04-01-pathfinder-node.md:66
msgid "4. **Stopping Pathfinder Node**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:68
msgid "To stop the node, use:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:70
msgid ""
"```bash\n"
"sudo docker stop pathfinder\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:74
msgid "This setup ensures the Pathfinder node operates efficiently with automatic restarts and background running capabilities."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:76
#, fuzzy
msgid "### Updating the Pathfinder Docker Image"
msgstr "### Actualizaci√≥n del Componente Wallet"

#: src/ch03-04-01-pathfinder-node.md:78
msgid "When a new Pathfinder release is available, the node will log a message like:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:80
msgid ""
"```\n"
"WARN New pathfinder release available! Please consider updating your node! release=0.4.5\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:84
msgid "#### Update Steps"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:86
msgid "1. Pull the Latest Docker Image:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:88
msgid ""
"```bash\n"
"sudo docker pull eqlabs/pathfinder\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:92
msgid "2. Stop and Remove the Current Container:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:94
msgid ""
"```bash\n"
"sudo docker stop pathfinder\n"
"sudo docker rm pathfinder\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:99
msgid "3. Re-create the Container with the New Image:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:101
msgid "Use the same command as before to start the node"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:116
msgid "### Docker Image Availability"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:118
msgid "The `:latest` docker image corresponds with the latest [Pathfinder release](https://github.com/eqlabs/pathfinder/releases), not the `main` branch."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:120
#, fuzzy
msgid "### Using Docker Compose"
msgstr "### Componente de Balance"

#: src/ch03-04-01-pathfinder-node.md:122
msgid "Alternatively, **`docker-compose`** can be used."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:124
msgid "1. Setup:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:126
msgid "Create the folder `pathfinder` where your `docker-compose.yaml` is."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:128
msgid ""
"```bash\n"
"mkdir -p pathfinder\n"
"# replace the value by of PATHFINDER_ETHEREUM_API_URL by the HTTP(s) URL pointing to your Ethereum node's endpoint\n"
"cp example.pathfinder-var.env pathfinder-var.env\n"
"docker-compose up -d\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:135
msgid "2. Check logs:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:137
#, fuzzy
msgid ""
"```bash\n"
"docker-compose logs -f\n"
"```"
msgstr ""
"```bash\n"
"vercel login\n"
"```"

#: src/ch03-04-01-pathfinder-node.md:141
msgid "## Database Snapshots"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:143
msgid ""
"Re-syncing the whole history for either the mainnet or testnet networks might take a long time. To speed up the process you can use database snapshot files that contain the full state and history "
"of the network up to a specific block."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:145
msgid "The database files are hosted on Cloudflare R2. There are two ways to download the files:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:147
msgid ""
"- Using the [Rclone](https://rclone.org/) tool\n"
"- Via the HTTPS URL: we've found this to be less reliable in general"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:150
msgid "### Rclone setup"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:152
msgid "We recommend using RClone. Add the following to your RClone configuration file (`$HOME/.config/rclone/rclone.conf`):"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:154
msgid ""
"```ini\n"
"[pathfinder-snapshots]\n"
"type = s3\n"
"provider = Cloudflare\n"
"env_auth = false\n"
"access_key_id = 7635ce5752c94f802d97a28186e0c96d\n"
"secret_access_key = 529f8db483aae4df4e2a781b9db0c8a3a7c75c82ff70787ba2620310791c7821\n"
"endpoint = https://cbf011119e7864a873158d83f3304e27.r2.cloudflarestorage.com\n"
"acl = private\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:165
msgid "You can then download a compressed database using the command:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:167
msgid ""
"```shell\n"
"rclone copy -P pathfinder-snapshots:pathfinder-snapshots/testnet_0.9.0_880310.sqlite.zst .\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:171
msgid "### Uncompressing database snapshots"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:173
msgid "**To avoid issues please check that the SHA2-256 checksum of the compressed file you've downloaded matches the value we've published.**"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:175
msgid "We're storing database snapshots as SQLite database files compressed with [zstd](https://github.com/facebook/zstd). You can uncompress the files you've downloaded using the following command:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:177
msgid ""
"```shell\n"
"zstd -T0 -d testnet_0.9.0_880310.sqlite.zst -o goerli.sqlite\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:181
msgid "This produces uncompressed database file `goerli.sqlite` that can then be used by pathfinder."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:183
msgid "### Available database snapshots"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid ""
"| Network     | Block  | Pathfinder version required | Filename                              | Download URL                                                                                        | "
"Compressed size | SHA2-256 checksum of compressed file                               |\n"
"| ----------- | ------ | --------------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------------- | "
"--------------- | ------------------------------------------------------------------ |\n"
"| testnet     | 880310 | >= 0.9.0                    | `testnet_0.9.0_880310.sqlite.zst`     | [Download](https://pub-1fac64c3c0334cda85b45bcc02635c32.r2.dev/testnet_0.9.0_880310.sqlite.zst)     | "
"102.36 GB       | `55f7e30e4cc3ba3fb0cd610487e5eb4a69428af1aacc340ba60cf1018b58b51c` |\n"
"| mainnet     | 309113 | >= 0.9.0                    | `mainnet_0.9.0_309113.sqlite.zst`     | [Download](https://pub-1fac64c3c0334cda85b45bcc02635c32.r2.dev/mainnet_0.9.0_309113.sqlite.zst)     | "
"279.85 GB       | `0430900a18cd6ae26465280bbe922ed5d37cfcc305babfc164e21d927b4644ce` |\n"
"| integration | 315152 | >= 0.9.1                    | `integration_0.9.1_315152.sqlite.zst` | [Download](https://pub-1fac64c3c0334cda85b45bcc02635c32.r2.dev/integration_0.9.1_315152.sqlite.zst) | "
"8.45 GB         | `2ad5ab46163624bd6d9aaa0dff3cdd5c7406e69ace78f1585f9d8f011b8b9526` |"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:191
#, fuzzy
msgid "## Configuration"
msgstr "## Proceso de Compilaci√≥n"

#: src/ch03-04-01-pathfinder-node.md:193
msgid "The `pathfinder` node options can be configured via the command line as well as environment variables."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:195
msgid "The command line options are passed in after the `docker run` options, as follows:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:197
msgid ""
"```bash\n"
"sudo docker run --name pathfinder [...] eqlabs/pathfinder:latest <pathfinder options>\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:201
msgid "Using `--help` will display the `pathfinder` options, including their environment variable names:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:203
#, fuzzy
msgid ""
"```bash\n"
"sudo docker run --rm eqlabs/pathfinder:latest --help\n"
"```"
msgstr ""
"```bash\n"
"    starkli declare --help\n"
"```"

#: src/ch03-04-01-pathfinder-node.md:207
msgid "### Pending Support"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:209
msgid ""
"Block times on `mainnet` can be prohibitively long for certain applications. As a workaround, Starknet added the concept of a `pending` block which is the block currently under construction. This "
"is supported by pathfinder, and usage is documented in the [JSON-RPC API](#json-rpc-api) with various methods accepting `\"block_id\"=\"pending\"`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:211
msgid "Note that `pending` support is disabled by default and must be enabled by setting `poll-pending=true` in the configuration options."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:213
msgid "### Logging"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:215
msgid ""
"Logging can be configured using the `RUST_LOG` environment variable.\n"
"We recommend setting it when you start the container:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:218
msgid ""
"```bash\n"
"sudo docker run --name pathfinder [...] -e RUST_LOG=<log level> eqlabs/pathfinder:latest\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:222
msgid "The following log levels are supported, from most to least verbose:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:224
msgid ""
"```bash\n"
"trace\n"
"debug\n"
"info  # default\n"
"warn\n"
"error\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:232
msgid "### Network Selection"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:234
msgid "The Starknet network can be selected with the `--network` configuration option."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:236
msgid "If `--network` is not specified, network selection will default to match your Ethereum endpoint:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:238
msgid ""
"- Starknet mainnet for Ethereum mainnet,\n"
"- Starknet testnet for Ethereum Goerli"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:241
msgid "#### Custom networks & gateway proxies"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:243
msgid ""
"You can specify a custom network with `--network custom` and specifying the `--gateway-url`, `feeder-gateway-url` and `chain-id` options.\n"
"Note that `chain-id` should be specified as text e.g. `SN_GOERLI`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:246
msgid "This can be used to interact with a custom Starknet gateway, or to use a gateway proxy."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:248
msgid "## JSON-RPC API"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:250
msgid ""
"You can interact with Starknet using the JSON-RPC API. Pathfinder supports the official Starknet RPC API and in addition supplements this with its own pathfinder specific extensions such as "
"`pathfinder_getProof`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:252
msgid ""
"Currently pathfinder supports `v0.3`, `v0.4`, and `v0.5` versions of the Starknet JSON-RPC specification.\n"
"The `path` of the URL used to access the JSON-RPC server determines which version of the API is served:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:255
msgid ""
"- the `v0.3.0` API is exposed on the `/rpc/v0.3` and `/rpc/v0_3` path\n"
"- the `v0.4.0` API is exposed on the `/`, `/rpc/v0.4` and `/rpc/v0_4` path\n"
"- the `v0.5.1` API is exposed on the `/rpc/v0.5` and `/rpc/v0_5` path\n"
"- the pathfinder extension API is exposed on `/rpc/pathfinder/v0.1`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:260
msgid "Note that the pathfinder extension is versioned separately from the Starknet specification itself."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:262
msgid "### pathfinder extension API"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:264
msgid "You can find the API specification [here](doc/rpc/pathfinder_rpc_api.json)."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:266
msgid "## Monitoring API"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:268
msgid "Pathfinder has a monitoring API which can be enabled with the `--monitor-address` configuration option."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:270
msgid "### Health"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:272
msgid "`/health` provides a method to check the health status of your `pathfinder` node, and is commonly useful in Kubernetes docker setups. It returns a `200 OK` status if the node is healthy."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:274
#, fuzzy
msgid "### Readiness"
msgstr "### Leer Funciones"

#: src/ch03-04-01-pathfinder-node.md:276
msgid ""
"`pathfinder` does several things before it is ready to respond to RPC queries. In most cases this startup time is less than a second, however there are certain scenarios where this can be "
"considerably longer. For example, applying an expensive database migration after an upgrade could take several minutes (or even longer) on testnet. Or perhaps our startup network checks fail many "
"times due to connection issues."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:278
msgid ""
"`/ready` provides a way of checking whether the node's JSON-RPC API is ready to be queried. It returns a `503 Service Unavailable` status until all startup tasks complete, and then `200 OK` from "
"then on."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:280
#, fuzzy
msgid "### Metrics"
msgstr "### Units"

#: src/ch03-04-01-pathfinder-node.md:282
msgid "`/metrics` provides a [Prometheus](https://prometheus.io/) metrics scrape endpoint. Currently the following metrics are available:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:284
#, fuzzy
msgid "#### RPC related counters"
msgstr "### Leer Funciones"

#: src/ch03-04-01-pathfinder-node.md:286
msgid ""
"- `rpc_method_calls_total`,\n"
"- `rpc_method_calls_failed_total`,"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:289
msgid "You **must** use the label key `method` to retrieve a counter for a particular RPC method, for example:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:291
msgid ""
"```\n"
"rpc_method_calls_total{method=\"starknet_getStateUpdate\"}\n"
"rpc_method_calls_failed_total{method=\"starknet_chainId\"}\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:296
msgid "You may also use the label key `version` to specify a particular version of the RPC API, for example:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:298
msgid ""
"```\n"
"rpc_method_calls_total{method=\"starknet_getEvents\", version=\"v0.3\"}\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:302
msgid "#### Feeder Gateway and Gateway related counters"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:304
msgid ""
"- `gateway_requests_total`\n"
"- `gateway_requests_failed_total`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:307
msgid "Labels:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:309
msgid ""
"- `method`, to retrieve a counter for a particular sequencer request type\n"
"- `tag`\n"
"  - works with: `get_block`, `get_state_update`\n"
"  - valid values:\n"
"    - `pending`\n"
"    - `latest`\n"
"- `reason`\n"
"  - works with: `gateway_requests_failed_total`\n"
"  - valid values:\n"
"    - `decode`\n"
"    - `starknet`\n"
"    - `rate_limiting`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:322
#, fuzzy
msgid "Valid examples:"
msgstr "# Ejemplos"

#: src/ch03-04-01-pathfinder-node.md:324
msgid ""
"```\n"
"gateway_requests_total{method=\"get_block\"}\n"
"gateway_requests_total{method=\"get_block\", tag=\"latest\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\", tag=\"pending\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\", tag=\"pending\", reason=\"starknet\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\", reason=\"rate_limiting\"}\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:333
msgid "These **will not work**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:335
msgid ""
"- `gateway_requests_total{method=\"get_transaction\", tag=\"latest\"}`, `tag` is not supported for that `method`\n"
"- `gateway_requests_total{method=\"get_transaction\", reason=\"decode\"}`, `reason` is only supported for failures."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:338
msgid "### Sync related metrics"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:340
msgid ""
"- `current_block` currently sync'd block height of the node\n"
"- `highest_block` height of the block chain\n"
"- `block_time` timestamp difference between the current block and its parent\n"
"- `block_latency` delay between current block being published and sync'd locally\n"
"- `block_download` time taken to download current block's data excluding classes\n"
"- `block_processing` time taken to process and store the current block"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:347
#, fuzzy
msgid "### Build info metrics"
msgstr "# Construyendo un Proyecto Scarb"

#: src/ch03-04-01-pathfinder-node.md:349
msgid "- `pathfinder_build_info` reports curent version as a `version` property"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:351
#, fuzzy
msgid "## Build from source"
msgstr "# Construyendo un Proyecto Scarb"

#: src/ch03-04-01-pathfinder-node.md:353
msgid "See the [guide](https://github.com/eqlabs/pathfinder/blob/main/doc/install-from-source.md)."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:355
msgid "The above guide is inspired by [Pathfinder](https://github.com/eqlabs/pathfinder)"
msgstr ""

#: src/ch03-05-layer-3.md:1
msgid "# Layer 3 (App Chains)"
msgstr ""

#: src/ch03-05-layer-3.md:3
msgid ""
"Appchains let you create a blockchain designed precisely for your\n"
"application‚Äôs needs. These specialized blockchains allow customization\n"
"in various aspects, such as hash functions and consensus algorithms.\n"
"Moreover, they inherit the security features of the Layer 1 or Layer 2\n"
"blockchains they are built upon."
msgstr ""

#: src/ch03-05-layer-3.md:11
msgid ""
"Layer 3 blockchains can exist on top of Layer 2 blockchains. You can\n"
"even build additional layers (Layer 4 and so on) on top of Layer 3 for\n"
"more complex solutions. A sample layout is shown in the following\n"
"diagram."
msgstr ""

#: src/ch03-05-layer-3.md:16
msgid "<img alt=\"Example of an environment with a Layers 3 and 4\" src=\"img/ch03-layer-3-ecosystem.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr ""

#: src/ch03-05-layer-3.md:18
msgid "<span class=\"caption\">Example of an environment with a Layers 3 and 4</span>"
msgstr ""

#: src/ch03-05-layer-3.md:20
msgid "In this example ecosystem, Layer 3 options include:"
msgstr ""

#: src/ch03-05-layer-3.md:22
msgid ""
"- The Public Starknet (L2), which is a general-purpose blockchain for\n"
"  decentralized applications.\n"
"\n"
"- A L3 Starknet optimized for cost-sensitive applications.\n"
"\n"
"- Customized L3 Starknet systems designed for enhanced performance,\n"
"  using specific storage structures or data compression techniques.\n"
"\n"
"- StarkEx systems used by platforms like dYdX and Sorare, offering\n"
"  proven scalability through data availability solutions like Validium\n"
"  or Rollup.\n"
"\n"
"- Privacy-focused Starknet instances, which could also function as a\n"
"  Layer 4, for conducting transactions without including them in\n"
"  public Starknets."
msgstr ""

#: src/ch03-05-layer-3.md:38
msgid "## Benefits of Layer 3"
msgstr ""

#: src/ch03-05-layer-3.md:40
msgid ""
"Layer 3 app chains (with\n"
"[Madara](https://github.com/keep-starknet-strange/madara) as an apt\n"
"sequencer or other option), offer a variety of advantages due to its\n"
"modularity and flexibility. Here‚Äôs an overview of the key benefits:"
msgstr ""

#: src/ch03-05-layer-3.md:45
msgid ""
"- **Quick Iteration**: App chains enable rapid protocol changes,\n"
"  freeing you from the constraints of the public Layer 2 roadmap. For\n"
"  example, you could rapidly deploy new DeFi algorithms tailored to\n"
"  your user base.\n"
"\n"
"- **Governance Independence**: You maintain complete control over\n"
"  feature development and improvements, avoiding the need for\n"
"  decentralized governance consensus. This enables, for example, quick\n"
"  implementation of user-suggested features.\n"
"\n"
"- **Cost Efficiency**: Layer 3 offers substantial cost reductions,\n"
"  potentially up to 1 million times compared to Layer 1, making it\n"
"  economically feasible to run more complex applications.\n"
"\n"
"- **Security**: While there may be some trade-offs, such as reduced\n"
"  censorship resistance, the core security mechanisms remain strong.\n"
"\n"
"- **Congestion Avoidance**: App chains are shielded from network\n"
"  congestion, providing a more stable transaction environment, crucial\n"
"  for real-time applications like gaming.\n"
"\n"
"- **Privacy Enhancements**: Layer 3 can serve as a testing ground for\n"
"  privacy-centric features, which could include anonymous transactions\n"
"  or encrypted messaging services.\n"
"\n"
"- **Innovation Platform**: App chains act as experimental fields where\n"
"  novel features can be developed and tested. For instance, they could\n"
"  serve as a testbed for new consensus algorithms before these are\n"
"  considered for Layer 2."
msgstr ""

#: src/ch03-05-layer-3.md:75
msgid ""
"In summary, Layer 3 provides the flexibility, cost-efficiency, and\n"
"environment conducive for innovation, without significant compromise on\n"
"security."
msgstr ""

#: src/ch03-05-layer-3.md:79
msgid "## Madara as a Sequencer for Layer 3 App Chains"
msgstr ""

#: src/ch03-05-layer-3.md:81
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a\n"
"specialized sequencer developed to execute transactions and group them\n"
"into batches. Created by the StarkWare Exploration Team, it functions as\n"
"a starting point for building Layer 3 Starknet appchains. This expands\n"
"the possibilities for innovation within the Starknet ecosystem."
msgstr ""

#: src/ch03-05-layer-3.md:87
msgid ""
"Madara‚Äôs flexibility allows for the creation of Layer 3 appchains\n"
"optimized for various needs, for example:"
msgstr ""

#: src/ch03-05-layer-3.md:90
msgid ""
"- Cost-Efficiency: Create an appchain for running a decentralized\n"
"  exchange (DEX) with lower fees compared to the public Starknet.\n"
"\n"
"- Performance: Build an appchain to operate a DEX with faster\n"
"  transaction times.\n"
"\n"
"- Privacy: Design an appchain to facilitate anonymous transactions or\n"
"  encrypted messaging services."
msgstr ""

#: src/ch03-05-layer-3.md:99
msgid ""
"For more information on Madara, refer to the subchapter with the same\n"
"title."
msgstr ""

#: src/ch03-06-solidity-verifier.md:1
#, fuzzy
msgid "# Solidity Verifier"
msgstr "Solidity Verifier üöß"

#: src/ch03-06-solidity-verifier.md:3
msgid "Before exploring this chapter, review the Starknet Architecture chapter for foundational knowledge. Familiarity with concepts such as Sequencers, Provers, SHARP, and Sharp Jobs is assumed."
msgstr ""

#: src/ch03-06-solidity-verifier.md:5
msgid "Starknet's Solidity Verifier plays a pivotal role in the rollup landscape, ensuring the truth of transactions and smart contracts."
msgstr ""

#: src/ch03-06-solidity-verifier.md:7
msgid "## Quick Overview: SHARP and Sharp Jobs"
msgstr ""

#: src/ch03-06-solidity-verifier.md:9
msgid "> **NOTE:** For a more detailed explanation of SHARP and Sharp Jobs, refer to the Provers subchapter in the Starknet Architecture chapter. This is a brief review."
msgstr ""

#: src/ch03-06-solidity-verifier.md:11
msgid ""
"SHARP, or Shared Prover, in Starknet, aggregates various Cairo programs from distinct users. These programs, each with unique logic, run together, producing a common proof for all, optimizing cost "
"and efficiency."
msgstr ""

#: src/ch03-06-solidity-verifier.md:13
#, fuzzy
msgid "<img alt=\"Sharp workflow\" src=\"img/ch03-06-shared-prover.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:15
#, fuzzy
msgid "<span class=\"caption\">Sharp Workflow</span>"
msgstr "<span class=\"caption\">Starknet-js en tu dapp</span>"

#: src/ch03-06-solidity-verifier.md:17
msgid "Furthermore, SHARP supports combining multiple proofs into one, enhancing its efficiency by allowing parallel proof processing and verification."
msgstr ""

#: src/ch03-06-solidity-verifier.md:19
msgid "SHARP verifies numerous Starknet transactions, like transfers, trades, and state updates. It also confirms smart contract executions."
msgstr ""

#: src/ch03-06-solidity-verifier.md:21
msgid ""
"To illustrate SHARP: Think of commuting by bus. The bus driver, the prover, transports passengers, the Cairo programs. The driver checks only the tickets of passengers alighting at the upcoming "
"stop, much like SHARP. The prover forms a single proof for all Cairo programs in a batch, but verifies only the proofs of programs executing in the succeeding block."
msgstr ""

#: src/ch03-06-solidity-verifier.md:23
msgid ""
"**Sharp Jobs**. Known as Shared Prover Jobs, Sharp Jobs let multiple users present their Cairo programs for combined execution, distributing the proof generation cost. This shared approach makes "
"Starknet more economical for users, enabling them to join ongoing jobs and leverage economies of scale."
msgstr ""

#: src/ch03-06-solidity-verifier.md:25
#, fuzzy
msgid "## Solidity Verifiers"
msgstr "Solidity Verifier üöß"

#: src/ch03-06-solidity-verifier.md:27
msgid "A Solidity verifier is an L1 smart contract, crafted in Solidity, designed to validate STARK proofs from SHARP (Shared Prover)."
msgstr ""

#: src/ch03-06-solidity-verifier.md:29
msgid "### Previous Architecture: Monolithic Verifier"
msgstr ""

#: src/ch03-06-solidity-verifier.md:31
msgid ""
"Historically, the Solidity Verifier was a monolithic contract, both initiated and executed by the same contract. For illustration, the operator would invoke the `update state` function on the main "
"contract, providing the state to be modified and confirming its validity. Subsequently, the main contract would present the proof to both the verifier and the validium committee. Once they "
"validated the proof, the state would be updated in the main contract."
msgstr ""

#: src/ch03-06-solidity-verifier.md:33
#, fuzzy
msgid "<img alt=\"Previous Architecture\" src=\"img/ch03-06-prehistoric-architecture.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-06-solidity-verifier.md:35
#, fuzzy
msgid "<span class=\"caption\">Previous Architecture</span>"
msgstr "<span class=\"caption\">Starknet-js en tu dapp</span>"

#: src/ch03-06-solidity-verifier.md:37
msgid "However, this architecture faced several constraints:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:39
msgid ""
"- Batching transactions frequently surpassed the original geth32kb transaction size limit (later adjusted to 128kb) due to accumulating excessive transactions.\n"
"- The gas required often outstripped the block size (e.g., 8 Mgas), as the block couldn't accommodate a complete batch of proof.\n"
"- A prospective constraint was that the verifier wouldn't support proof bundling, which is fundamental for SHARP."
msgstr ""

#: src/ch03-06-solidity-verifier.md:43
#, fuzzy
msgid "### Current Architecture: Multiple Smart Contracts"
msgstr "## Introducci√≥n a los Smart Contracts de Starknet"

#: src/ch03-06-solidity-verifier.md:45
msgid "The current verifier utilizes multiple smart contracts rather than being a singular, monolithic structure."
msgstr ""

#: src/ch03-06-solidity-verifier.md:47
msgid "Here are some key smart contracts associated with the verifier:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:49
msgid ""
"- [`GpsStatementVerifier`](https://etherscan.io/address/0x47312450b3ac8b5b8e247a6bb6d523e7605bdb60): This is the primary contract of the Sharp verifier. It verifies a proof and then registers the "
"related facts using `verifyProofAndRegister`. It acts as an umbrella for various layouts, each named `CpuFrilessVerifier`. Every layout has a unique combination of built-in resources."
msgstr ""

#: src/ch03-06-solidity-verifier.md:51
#, fuzzy
msgid "<img alt=\"Verifier Layouts\" src=\"img/ch03-06-verifier-layouts.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-06-solidity-verifier.md:53
msgid "The system routes each proof to its relevant layout."
msgstr ""

#: src/ch03-06-solidity-verifier.md:55
msgid ""
"- [`MemoryPageFactRegistry`](https://etherscan.io/address/0xfd14567eaf9ba941cb8c8a94eec14831ca7fd1b4): This registry maintains facts for memory pages, primarily used to register outputs for data "
"availability in rollup mode. The Fact Registry is a separate smart contract ensuring the verification and validity of attestations or facts. The verifier function is separated from the main "
"contract to ensure each segment works optimally within its limits. The main proof segment relies on other parts, but these parts operate independently.\n"
"\n"
"- [`MerkleStatementContract`](https://etherscan.io/address/0x5899efea757e0dbd6d114b3375c23d7540f65fa4): This contract verifies merkle paths.\n"
"\n"
"- [`FriStatementContract`](https://etherscan.io/address/0x3e6118da317f7a433031f03bb71ab870d87dd2dd): It focuses on verifying the FRI layers."
msgstr ""

#: src/ch03-06-solidity-verifier.md:61
msgid "### Sharp Verifier Contract Map"
msgstr ""

#: src/ch03-06-solidity-verifier.md:63
msgid ""
"The Sharp Verifier Contract Map contains roughly 40 contracts, detailing various components of the Solidity verifier. The images below display the contracts and their Ethereum Mainnet addresses."
msgstr ""

#: src/ch03-06-solidity-verifier.md:65
#, fuzzy
msgid "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-1.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:67
#, fuzzy
msgid "<span class=\"caption\">Sharp Verifier Contract Map</span>"
msgstr "<span class=\"caption\">Starknet-js en tu dapp</span>"

#: src/ch03-06-solidity-verifier.md:69
#, fuzzy
msgid "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-2.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:71
#, fuzzy
msgid "<span class=\"caption\">Sharp Verifier Contract Map (Continued)</span>"
msgstr "<span class=\"caption\">Starknet-js en tu dapp</span>"

#: src/ch03-06-solidity-verifier.md:73
msgid "These contracts function as follows:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:75
msgid ""
"- **Proxy**: This contract facilitates upgradability. It interacts with the `GpsStatementVerifier` contract using the `delegate_call` method. Notably, the state resides in the "
"`GpsStatementVerifier` contract, not in the proxy.\n"
"- **CallProxy**: Positioned between the `Proxy` and the `GpsStatementVerifier` contracts, it functions like a typical proxy. However, it avoids the `delegate_call` method and calls the function in "
"the implementation contract directly.\n"
"- **CairoBootloaderProgram**: Comprising numerical Cairo programs, it validates the Cairo program of a statement. The bootloader manages the logic executing Cairo programs to generate proof and "
"program hash.\n"
"- **PedersenHashPoints (X & Y Column)**: These lookup tables store vast amounts of data. Validation functions consult them to compute the Pedersen hash.\n"
"- **EcdsaPoints (X & Y Column)**: Similar to the Pedersen hash, these tables assist in calculating the elliptic curve.\n"
"- **CpuFrilessVerifier/CpuOods/CpuConstantPoly (0 - 7)**: These verifier contracts vary in layout as shown in the `GpsStatementVerifier` layout image. Each layout encompasses resources, built-ins, "
"constraints, and more, designed for a specific task. Each has unique parameters for its constructor.\n"
"- **PoseidonPoseidon**: These contracts back the new Poseidon built-in and contain Poseidon-specific lookup tables."
msgstr ""

#: src/ch03-06-solidity-verifier.md:83
#, fuzzy
msgid "### Constructor Parameters of Key Contracts"
msgstr "## Introducci√≥n a los Smart Contracts de Starknet"

#: src/ch03-06-solidity-verifier.md:85
msgid ""
"When constructing the primary verifier contracts, specific parameters are employed to facilitate functionality. These parameters reference other auxiliary contracts, decentralizing the logic and "
"ensuring the main contract remains under the 24kb deployment limit."
msgstr ""

#: src/ch03-06-solidity-verifier.md:87
msgid "Below is a visual representation of these parameters in relation to key contracts `CpuFrilessVerifiers` and `GpsStatementVerifier`:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:89
#, fuzzy
msgid ""
"<img alt=\"Constructor Parameters\" src=\"img/ch03-06-constructor-params.png\" class=\"center\" style=\"width: 50%;\" />\n"
"<span class=\"caption\">Constructor Parameters</span>"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:92
msgid "#### CpuFrilessVerifier Constructor Parameters"
msgstr ""

#: src/ch03-06-solidity-verifier.md:94
msgid "`CpuFrilessVerifiers` is designed to handle a diverse range of tasks. Its parameters encompass:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:96
msgid ""
"- **Auxiliary Polynomial Contracts:** These include `CpuConstraintPoly`, `PedersenHashPointsxColumn`, `PedersenHashPointsYColumn`, `EcdsaPointsXColumn`, and `EcdsaPointsYColumn`.\n"
"- **Poseidon-Related Contracts:** Several `PoseidonPoseidonFullRoundKey` and `PoseidonPoseidonPartialRoundKey` contracts.\n"
"- **Sampling and Memory:** The contract uses `CpuOods` for out-of-domain sampling and `MemoryPageFactRegistry` for memory-related tasks.\n"
"- **Verification:** It integrates with `MerkleStatementContract` for merkle verification and `FriStatementContract` for Fri-related tasks.\n"
"- **Security:** The `num_security_bits` and `min_proof_of_work_bits` contracts ensure secure operation."
msgstr ""

#: src/ch03-06-solidity-verifier.md:102
msgid "**NOTE:** For instances like `CpuFrilessVerifier0`, specific contracts (e.g., `CpuConstraintPoly0`, `PoseidonPoseidonFullRoundKeyColumn0`, `CpuOods0`) become particularly relevant."
msgstr ""

#: src/ch03-06-solidity-verifier.md:104
msgid "#### GpsStatementVerifier Constructor Parameters"
msgstr ""

#: src/ch03-06-solidity-verifier.md:106
msgid "The `GpsStatementVerifier` functions as the hub of verifier operations, necessitating various parameters for effective functioning:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:108
msgid ""
"- **Bootloader:** It references the `CairoBootloaderProgram` to initiate the system.\n"
"- **Memory Operations:** This is facilitated by the `MemoryPageFactRegistry` contract.\n"
"- **Sub-Verifiers:** It integrates a series of sub-verifiers (`CpuFrilessVerifier0` through `CpuFrilessVerifier7`) to decentralize tasks.\n"
"- **Verification:** The hashes, `hashed_supported_cairo_verifiers` and `simple_bootloader_program_hash`, are essential for validation processes."
msgstr ""

#: src/ch03-06-solidity-verifier.md:113
#, fuzzy
msgid "### Interconnection of Contracts"
msgstr "## Interacci√≥n con el Contrato"

#: src/ch03-06-solidity-verifier.md:115
msgid "The `GpsStatementVerifier` serves as the primary verifier contract, optimized for minimal logic to fit within deployment size constraints. To function effectively:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:117
msgid ""
"- It relies on smaller verifier contracts, which are already deployed and contain varied verification logic.\n"
"- These smaller contracts, in turn, depend on other contracts, established during their construction."
msgstr ""

#: src/ch03-06-solidity-verifier.md:120
msgid "In essence, while the diverse functionalities reside in separate contracts for clarity and size efficiency, they are all interlinked within the `GpsStatementVerifier`."
msgstr ""

#: src/ch03-06-solidity-verifier.md:122
msgid ""
"For future enhancements or adjustments, the proxy and callproxy contracts facilitate upgradability, allowing seamless updates to the `GpsStatementVerifier` without compromising its foundational "
"logic."
msgstr ""

#: src/ch03-06-solidity-verifier.md:124
msgid "### Sharp Verification Flow"
msgstr ""

#: src/ch03-06-solidity-verifier.md:126
#, fuzzy
msgid "<img alt=\"Sharp Verification Flow\" src=\"img/ch03-06-new-sharp-flow.png\" class=\"center\" style=\"width: 50%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-06-solidity-verifier.md:128
#, fuzzy
msgid "<span class=\"caption\">Sharp Verification Flow</span>"
msgstr "<span class=\"caption\">Starknet-js en tu dapp</span>"

#: src/ch03-06-solidity-verifier.md:130
msgid ""
"1. The Sharp dispatcher transmits all essential transactions for verification, including:\n"
"   a. `MemoryPages` (usually many).\n"
"   b. `MerkleStatements` (typically between 3 and 5).\n"
"   c. `FriStatements` (generally ranging from 5 to 15).\n"
"\n"
"2. The Sharp dispatcher then forwards the proof using `verifyProofAndRegister`.\n"
"\n"
"3. Applications, such as the Starknet monitor, validate the status. Once verification completes, they send an `updateState` transaction."
msgstr ""

#: src/ch03-06-solidity-verifier.md:141
msgid ""
"Starknet transformed the Solidity Verifier from a single unit to a flexible, multi-contract system, highlighting its focus on scalability and efficiency. Using SHARP and refining verification "
"steps, Starknet makes sure the Solidity Verifier stays a strong cornerstone in its setup."
msgstr ""

#: src/ch03-07-decentralization.md:1
msgid "# Decentralization üöß"
msgstr ""

#: src/ch03-08-smart-contracts.md:1
#, fuzzy
msgid "# Smart Contracts"
msgstr "## Contracts"

#: src/ch03-08-smart-contracts.md:3
msgid "Starknet contracts, are programs written in cairo and can run on the starknet virtual machine, they have access to the starknet state, and can interact with other contracts."
msgstr ""

#: src/ch03-08-smart-contracts.md:5
msgid "This Chapter will introduce you to starknet smart contracts, their components, smart contract declaration, deployment and interaction using starkli."
msgstr ""

#: src/ch03-08-smart-contracts.md:7
#, fuzzy
msgid "## Smart Contract Example"
msgstr "## Implementaci√≥n del Contrato ERC20"

#: src/ch03-08-smart-contracts.md:9
msgid ""
"Having explained what starknet smart contracts are, we'll be writing a moderately simple contract called a Piggy Bank contract, this example will demonstrate how to write a smart contract using the "
"factory pattern and also how to integrate the starknet component system into your smart contracts."
msgstr ""

#: src/ch03-08-smart-contracts.md:11
msgid ""
"The piggy bank contract is a factory contract model that allows users to create their own personalized savings contract. At the point of creation, users are to specify their savings target, which "
"could be towards a specific time or a specific amount, and a child contract is created and personalized to their savings target."
msgstr ""

#: src/ch03-08-smart-contracts.md:13
msgid ""
"The factory contract keeps tabs on all the child contracts created and also maps a user to his personalized contract. The user, after creating a personalized savings contract, can then deposit and "
"save towards his target. But if, for any reason, the user has to withdraw from his savings contract before meeting the savings target, then a fine worth 10% of the withdrawal amount would be paid "
"by the user."
msgstr ""

#: src/ch03-08-smart-contracts.md:15
msgid ""
"The contract uses a combination of functions and an ownership component to track and maintain the above explained functionality. Event‚Äôs are also emitted on each function call that modifies the "
"contract's state. So a good understanding of the logic and implementation of this contract example would give you mastery of the components system in Cairo, the factory standard model, emitting "
"events, and a whole lot of other methods useful in writing smart contracts on starknet."
msgstr ""

#: src/ch03-08-smart-contracts.md:17
msgid ""
"Please note that during the course of this journey, I‚Äôll be using interchangeably the terms child contract and personalized contract. Please note that the term child contract in this case refers to "
"a personalized piggy bank contract created from the factory contract."
msgstr ""

#: src/ch03-08-smart-contracts.md:19
#, fuzzy
msgid "### Piggy Bank Child Contract:"
msgstr "### Declarando su Contrato"

#: src/ch03-08-smart-contracts.md:21
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Drop, Serde, starknet::Store)]\n"
"enum target {\n"
"    blockTime: u128,\n"
"    amount: u128,\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn name(self: @TContractState) -> felt252;\n"
"    fn symbol(self: @TContractState) -> felt252;\n"
"    fn decimals(self: @TContractState) -> u8;\n"
"    fn total_supply(self: @TContractState) -> u256;\n"
"    fn balanceOf(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"    fn transferFrom(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256\n"
"    ) -> bool;\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait piggyBankTrait<TContractState> {\n"
"    fn deposit(ref self: TContractState, _amount: u128);\n"
"    fn withdraw(ref self: TContractState, _amount: u128);\n"
"    fn get_balance(self: @TContractState) -> u128;\n"
"    fn get_Target(self: @TContractState) -> (u128 , piggyBank::targetOption) ;\n"
"    // fn get_owner(self: @TContractState) -> ContractAddress;\n"
"    fn viewTarget(self: @TContractState) -> target;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod piggyBank {\n"
"    use core::option::OptionTrait;\n"
"    use core::traits::TryInto;\n"
"    use starknet::{get_caller_address, ContractAddress, get_contract_address, Zeroable, get_block_timestamp};\n"
"    use super::{IERC20Dispatcher, IERC20DispatcherTrait, target};\n"
"    use core::traits::Into;\n"
"    use piggy_bank::ownership_component::ownable_component;\n"
"    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n"
"\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token: IERC20Dispatcher,\n"
"        manager: ContractAddress,\n"
"        balance: u128,\n"
"        withdrawalCondition: target,\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage\n"
"    }\n"
"\n"
"    #[derive(Drop, Serde)]\n"
"    enum targetOption {\n"
"        targetTime,\n"
"        targetAmount,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Deposit: Deposit,\n"
"        Withdraw: Withdraw,\n"
"        PaidProcessingFee: PaidProcessingFee,\n"
"        OwnableEvent: ownable_component::Event\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Deposit {\n"
"        #[key]\n"
"        from: ContractAddress,\n"
"        #[key]\n"
"        Amount: u128,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Withdraw {\n"
"        #[key]\n"
"        to: ContractAddress,\n"
"        #[key]\n"
"        Amount: u128,\n"
"        #[key]\n"
"        ActualAmount: u128,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct PaidProcessingFee {\n"
"        #[key]\n"
"        from: ContractAddress,\n"
"        #[key]\n"
"        Amount: u128,\n"
"    }\n"
"\n"
"    mod Errors {\n"
"        const Address_Zero_Owner: felt252 = 'Invalid owner';\n"
"        const Address_Zero_Token: felt252 = 'Invalid Token';\n"
"        const UnAuthorized_Caller: felt252 = 'UnAuthorized caller';\n"
"        const Insufficient_Balance: felt252 = 'Insufficient balance';\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, _owner: ContractAddress, _token: ContractAddress, _manager: ContractAddress, target: targetOption, targetDetails: u128) {\n"
"        assert(!_owner.is_zero(), Errors::Address_Zero_Owner);\n"
"        assert(!_token.is_zero(), Errors::Address_Zero_Token);\n"
"        self.ownable.owner.write(_owner);\n"
"        self.token.write(super::IERC20Dispatcher{contract_address: _token});\n"
"        self.manager.write(_manager);\n"
"        match target {\n"
"            targetOption::targetTime => self.withdrawalCondition.write(target::blockTime(targetDetails.into())),\n"
"            targetOption::targetAmount => self.withdrawalCondition.write(target::amount(targetDetails)),\n"
"        }\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl piggyBankImpl of super::piggyBankTrait<ContractState> {\n"
"        fn deposit(ref self: ContractState, _amount: u128) {\n"
"            let (caller, this, currentBalance) = self.getImportantAddresses();\n"
"            self.balance.write(currentBalance + _amount);\n"
"\n"
"            self.token.read().transferFrom(caller, this, _amount.into());\n"
"\n"
"            self.emit(Deposit { from: caller, Amount: _amount});\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, _amount: u128) {\n"
"            self.ownable.assert_only_owner();\n"
"            let (caller, this, currentBalance) = self.getImportantAddresses();\n"
"            assert(self.balance.read() >= _amount, Errors::Insufficient_Balance);\n"
"\n"
"            let mut new_amount: u128 = 0;\n"
"            match self.withdrawalCondition.read() {\n"
"                target::blockTime(x) => new_amount = self.verifyBlockTime(x, _amount),\n"
"                target::amount(x) => new_amount = self.verifyTargetAmount(x, _amount),\n"
"            };\n"
"\n"
"            self.balance.write(currentBalance - _amount);\n"
"            self.token.read().transfer(caller, new_amount.into());\n"
"\n"
"            self.emit(Withdraw { to: caller, Amount: _amount, ActualAmount: new_amount});\n"
"        }\n"
"\n"
"        fn get_balance(self: @ContractState) -> u128 {\n"
"            self.balance.read()\n"
"        }\n"
"\n"
"        fn get_Target(self: @ContractState) -> (u128 , targetOption) {\n"
"            let condition = self.withdrawalCondition.read();\n"
"            match condition {\n"
"                target::blockTime(x) => {return (x, targetOption::targetTime);},\n"
"                target::amount(x) => {return (x, targetOption::targetAmount);},\n"
"            }\n"
"        }\n"
"\n"
"        fn viewTarget(self: @ContractState) -> target {\n"
"            self.withdrawalCondition.read()\n"
"        }\n"
"\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl Private of PrivateTrait {\n"
"        fn verifyBlockTime(ref self: ContractState, blockTime: u128, withdrawalAmount: u128) -> u128 {\n"
"            if (blockTime <= get_block_timestamp().into()) {\n"
"                return withdrawalAmount;\n"
"            } else {\n"
"                return self.processWithdrawalFee(withdrawalAmount);\n"
"            }\n"
"        }\n"
"\n"
"        fn verifyTargetAmount(ref self: ContractState, targetAmount: u128, withdrawalAmount: u128) -> u128 {\n"
"            if (self.balance.read() < targetAmount) {\n"
"                return self.processWithdrawalFee(withdrawalAmount);\n"
"            } else {\n"
"                return withdrawalAmount;\n"
"            }\n"
"        }\n"
"\n"
"        fn processWithdrawalFee(ref self: ContractState, withdrawalAmount: u128) -> u128 {\n"
"            let withdrawalCharge: u128 = ((withdrawalAmount * 10) / 100);\n"
"            self.balance.write(self.balance.read() - withdrawalCharge);\n"
"            self.token.read().transfer(self.manager.read(), withdrawalCharge.into());\n"
"            self.emit(PaidProcessingFee{from: get_caller_address(), Amount: withdrawalCharge});\n"
"            return withdrawalAmount - withdrawalCharge;\n"
"        }\n"
"\n"
"        fn getImportantAddresses(self: @ContractState) -> (ContractAddress, ContractAddress, u128) {\n"
"            let caller: ContractAddress = get_caller_address();\n"
"            let this: ContractAddress = get_contract_address();\n"
"            let currentBalance: u128 = self.balance.read();\n"
"            (caller, this, currentBalance)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch03-08-smart-contracts.md:223
msgid "### Piggy Bank Factory"
msgstr ""

#: src/ch03-08-smart-contracts.md:225
msgid ""
"```rust\n"
"use starknet::{ContractAddress, ClassHash};\n"
"use piggy_bank::piggy_bank::piggyBank::targetOption;\n"
"use array::ArrayTrait;\n"
"\n"
"#[starknet::interface]\n"
"trait IPiggyBankFactory<TContractState> {\n"
"    fn createPiggyBank(ref self: TContractState, savingsTarget: targetOption, targetDetails: u128) -> ContractAddress;\n"
"    fn updatePiggyBankHash(ref self: TContractState, newClasHash: ClassHash);\n"
"    fn getAllPiggyBank(self: @TContractState) -> Array<ContractAddress>;\n"
"    fn getPiggyBanksNumber(self: @TContractState) -> u128;\n"
"    fn getPiggyBankAddr(self: @TContractState, userAddress: ContractAddress) -> ContractAddress;\n"
"    fn get_owner(self: @TContractState) -> ContractAddress;\n"
"    fn get_childClassHash(self: @TContractState) -> ClassHash;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod piggyFactory{\n"
"    use core::starknet::event::EventEmitter;\n"
"use piggy_bank::ownership_component::IOwnable;\n"
"    use core::serde::Serde;\n"
"    use starknet::{ContractAddress, ClassHash, get_caller_address, Zeroable};\n"
"    use starknet::syscalls::deploy_syscall;\n"
"    use dict::Felt252DictTrait;\n"
"    use super::targetOption;\n"
"    use piggy_bank::ownership_component::ownable_component;\n"
"    component!(path: ownable_component, storage: ownable, event: OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"    impl OwnableInternalImpl = ownable_component::InternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        piggyBankHash: ClassHash,\n"
"        totalPiggyBanksNo: u128,\n"
"        AllBanksRecords: LegacyMap<u128, ContractAddress>,\n"
"        piggyBankOwner: LegacyMap::<ContractAddress, ContractAddress>,\n"
"        TokenAddr: ContractAddress,\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        BankCreated: BankCreated,\n"
"        HashUpdated: HashUpdated,\n"
"        OwnableEvent: ownable_component::Event\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct BankCreated {\n"
"        #[key]\n"
"        for: ContractAddress,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct HashUpdated {\n"
"        #[key]\n"
"        by: ContractAddress,\n"
"        #[key]\n"
"        oldHash: ClassHash,\n"
"        #[key]\n"
"        newHash: ClassHash,\n"
"    }\n"
"\n"
"    mod Errors {\n"
"        const Address_Zero_Owner: felt252 = 'Invalid owner';\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, piggyBankClassHash: ClassHash, tokenAddr: ContractAddress,  _owner: ContractAddress) {\n"
"        self.piggyBankHash.write(piggyBankClassHash);\n"
"        self.ownable.owner.write(_owner);\n"
"        self.TokenAddr.write(tokenAddr);\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl piggyFactoryImpl of super::IPiggyBankFactory<ContractState> {\n"
"        fn createPiggyBank(ref self: ContractState, savingsTarget: targetOption, targetDetails: u128) -> ContractAddress {\n"
"            // Contructor arguments\n"
"            let mut constructor_calldata = ArrayTrait::new();\n"
"            get_caller_address().serialize(ref constructor_calldata);\n"
"            self.TokenAddr.read().serialize(ref constructor_calldata);\n"
"            self.ownable.owner().serialize(ref constructor_calldata);\n"
"            savingsTarget.serialize(ref constructor_calldata);\n"
"            targetDetails.serialize(ref constructor_calldata);\n"
"\n"
"            // Contract deployment\n"
"            let (deployed_address, _) = deploy_syscall(\n"
"                self.piggyBankHash.read(), 0, constructor_calldata.span(), false\n"
"            )\n"
"                .expect('failed to deploy counter');\n"
"            self.totalPiggyBanksNo.write(self.totalPiggyBanksNo.read() + 1);\n"
"            self.AllBanksRecords.write(self.totalPiggyBanksNo.read(), deployed_address);\n"
"            self.piggyBankOwner.write(get_caller_address(), deployed_address);\n"
"            self.emit(BankCreated{for: get_caller_address()});\n"
"\n"
"            deployed_address\n"
"        }\n"
"\n"
"        fn updatePiggyBankHash(ref self: ContractState, newClasHash: ClassHash) {\n"
"            self.ownable.assert_only_owner();\n"
"            self.piggyBankHash.write(newClasHash);\n"
"            self.emit(HashUpdated{by: self.ownable.owner(), oldHash: self.piggyBankHash.read(), newHash: newClasHash});\n"
"        }\n"
"\n"
"        fn getAllPiggyBank(self: @ContractState) -> Array<ContractAddress> {\n"
"            let mut piggyBanksAddress = ArrayTrait::new();\n"
"            let mut i: u128  = 1;\n"
"            loop {\n"
"                if i > self.totalPiggyBanksNo.read() {\n"
"                    break;\n"
"                }\n"
"                piggyBanksAddress.append(self.AllBanksRecords.read(i));\n"
"                i += 1;\n"
"            };\n"
"            piggyBanksAddress\n"
"        }\n"
"\n"
"        fn getPiggyBanksNumber(self: @ContractState) -> u128 {\n"
"            self.totalPiggyBanksNo.read()\n"
"        }\n"
"        fn getPiggyBankAddr(self: @ContractState, userAddress: ContractAddress) -> ContractAddress {\n"
"            assert(!userAddress.is_zero(), Errors::Address_Zero_Owner);\n"
"            self.piggyBankOwner.read(userAddress)\n"
"        }\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.ownable.owner()\n"
"        }\n"
"\n"
"        fn get_childClassHash(self: @ContractState) -> ClassHash {\n"
"            self.piggyBankHash.read()\n"
"        }\n"
"\n"
"    }\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:1
#, fuzzy
msgid "# Deploying and Interacting With a Smart Contract"
msgstr "# Compilar, Desplegar e Interactuar con un Contrato"

#: src/ch03-08-01-deploymet-and-interaction.md:3
msgid "In this section we will be focussing on declaring, deploying and interacting with the piggy bank contract we wrote in the previous section."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:5
msgid "## Requirements:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:7
msgid "To declare and deploy the piggy bank contract, it‚Äôs required that you have the following available; don't worry, we‚Äôll point you to resources or links to get them sorted out."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:9
msgid ""
"1. Starkli: Starkli is a CLI tool that connects us to the Starknet blockchain. Installation steps can be found [here](ch02-02-starkli-scarb-katana.md).\n"
"\n"
"2. Starknet testnet RPC: You need your personalized gateway to access the starknet network. Starkli utilizes this API gateway to communicate with the starknet network: you can get one from Blast "
"[here](https://blastapi.io/public-api/starknet).\n"
"\n"
"3. Deployer Account: To interact with the starknet network via Starkli, you need a cli account/ wallet. You can easily set that up by going through [this page](ch04-03-deploy-hello-account.md).\n"
"\n"
"4. Sufficient gas fees to cover the declaration and deployment steps: you can get starknet Sepolia Eth either by bridging your Sepolia Eth on Ethereum to Starknet [here](https://www.yetanotherswap."
"com/bridge)."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:17
msgid "Once you‚Äôve been able to sort all that out, let's proceed with declaring and deploying the piggy bank contract."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:19
#, fuzzy
msgid "## Contract Declaration:"
msgstr "## Interacciones del Contrato"

#: src/ch03-08-01-deploymet-and-interaction.md:21
msgid ""
"The first step in deploying a starknet smart contract is to build the contract. To do this, we cd into the root directory of the piggy bank project, and then in our terminal, we run the'scarb "
"build` command. This command creates a new folder in our root directory folder, then generates two json files for each contract; the first is the compiled_contract_class.json file, while the second "
"is the contract_clas.json file."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:23
#, fuzzy
msgid "<img alt=\"Building the piggy bank repo\" src=\"img/ch03-08-01-scarb-build.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:25
msgid ""
"The next step is to declare the contract. A contract declaration in Starknet is a transaction that returns a class hash, which would be used to deploy a new instance of a contract. Being a "
"transaction, declaration requires that the account being used for the declaration have sufficient gas fees to cover the cost of that transaction."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:27
msgid ""
"Also, it is important to understand that since we are deploying a factory contract, it's required that we declare the child contract as well as the factory contract, then deploy just the factory "
"contract after which pass in the child contract class hash as a constructor argument to the factory contract, and from this instance of the clash hash, new child contracts would be deployed."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:29
msgid ""
"```shell\n"
"starkli declare target/dev/piggy_bank_piggyBank.contract_class.json --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:33
msgid ""
"To declare the piggy bank child contract, we use the above command (remember to replace the account keystore and account file name and path as its found on your own system). Next, we‚Äôre prompted to "
"input the password set while preparing our CLI wallet, after which the contract is compiled, and we get a similar message below:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:35
#, fuzzy
msgid "<img alt=\"Declaring the piggy bank contract\" src=\"img/ch03-08-01-starkli-declare.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:37
msgid ""
"From the above snippet, our class hash is: `0x05f58aecd2781660741534140776b6a12bcc6d46ebda92ac851c1bad55d74006`. With this class hash, other contracts would be deployed. Next would be to declare "
"our factory contract."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:39
msgid ""
"```shell\n"
"starkli declare target/dev/piggy_bank_piggyFactory.contract_class.json --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/deployer/account0_account.json --"
"keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:43
msgid ""
"This time, we get a response similar to the previous declaration containing a class hash: `0x026323e14ce298448d12e2504cb872f7ec6049a389230c2c0b3d9d99507e303d`\n"
"These two class hashes could be found on any explorer. By pasting the clash hash on the search bar, we get details regarding the contract declaration."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:46
#, fuzzy
msgid "## Contract Deployment:"
msgstr "## Interacciones del Contrato"

#: src/ch03-08-01-deploymet-and-interaction.md:48
msgid ""
"Since we‚Äôve deployed the two contracts and also now have the class hash for the two contracts, our next step would be to deploy our factory contract and also pass in the class hash of the child "
"contract to it so it can customize and create new instances of the class hash for users. To deploy the factory contract, we use a sample command as shown below:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:50
msgid ""
"```shell\n"
"starkli deploy 0x026323e14ce298448d12e2504cb872f7ec6049a389230c2c0b3d9d99507e303d 0x05f58aecd2781660741534140776b6a12bcc6d46ebda92ac851c1bad55d74006 "
"0x049D36570D4e46f48e99674bd3fcc84644DdD6b96F7C741B1562B82f9e004dC7 0x076957612bA0927c9C3F6156Ffaa1A52Bc330256869d85A8A0D0999B3e4c6387 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --"
"account ~/.starkli-wallets/deployer/argent_sepolia_account.json --keystore ~/.starkli-wallets/deployer/argent_sepolia_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:54
msgid "I understand this might look confusing, so let's use a simpler command structure to describe it:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:56
msgid ""
"```shell\n"
"starkli deploy <FACTORY CLASS HASH> <CHILD CONTRACT CLASS HASH> <ETH CONTRACT ADDRESS> <ADMIN CONTRACT ADDRESS> --rpc <RPC FROM BLAST> --account ~/.starkli-wallets/deployer/account0_account.json --"
"keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:60
msgid ""
"From the above snippet, we first state the method we intend to use (deploy), then we pass in the class hash to be deployed (`<FACTORY CLASS HASH>`). Finally, we pass in the constructor argument in "
"order of their appearance in our contract (`<CHILD CONTRACT CLASS HASH>` `<ETH CONTRACT ADDRESS>` `<ADMIN CONTRACT ADDRESS>`)"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:62
#, fuzzy
msgid "<img alt=\"Deploying the piggy bank factory\" src=\"img/ch03-08-01-starkli-deploy.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:64
msgid "From the above snippet, our newly deployed contract address is `0x0137a70c3cda7037631f43e3c6a76ea30cf6ba53dbabaebb164b427dab8a8d16`"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:66
msgid "## Creating a Personalized Piggy Bank"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:68
msgid ""
"To create a personal piggy bank, we interact with the factory contract. We'll be calling the `createPiggyBank` function and passing in the following arguments; a savings target type; we pass in 1 "
"if we want to save towards a target amount; or we pass in 0 if we‚Äôll be saving towards a target time. Finally, we pass in a target amount or a target time (epoch time). In this demo, we‚Äôll be "
"saving towards a target amount, so we‚Äôll be passing in 1 and a target amount (0.0001 eth).\n"
"To interact with our piggy factory onchan, we use an invoke method as shown in the below command;"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:71
msgid ""
"```shell\n"
"starkli invoke 0x0137a70c3cda7037631f43e3c6a76ea30cf6ba53dbabaebb164b427dab8a8d16 createPiggyBank 1 100000000000000000 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/."
"starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:75
msgid ""
"After sending the above command, a transaction hash is returned to us. This hash, when scanned on an explorer, contains all the details of our invoke transaction and the status of the transaction, "
"whether or not it has been accepted on L1."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:77
#, fuzzy
msgid "<img alt=\"Creating a child contract\" src=\"img/ch03-08-01-starkli-create-child.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:79
msgid ""
"Our transaction hash is `0x077a2d9f64f19da764957e88440bc4cca50f792c62bccd163ee114b8b9e59a67`. Next, we need to get the contract address of our personalized piggy bank, so we make another call to "
"our factory contract to get our piggy bank‚Äôs address. We use the below code to achieve this, we call the `getPiggyBankAddr` function, then pass in our contract address as an argument to that "
"function."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:81
msgid ""
"```shell\n"
"starkli call 0x04f4c7a6a7de241e138f1c20b81d939a6e5807fdf8ea8845a86a61493e8de4ff getPiggyBankAddr 0x076957612bA0927c9C3F6156Ffaa1A52Bc330256869d85A8A0D0999B3e4c6387 --rpc https://starknet-sepolia."
"public.blastapi.io/rpc/v0_6\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:85
msgid ""
"After calling this function using the command above, we get a response on our terminal containing the address of the child piggy bank personalized to the address we passed in as an argument, the "
"first argument is the address of the factory contract while the second is the function name while the third is the address of the user which we intend to fetch his piggy bank address."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:87
#, fuzzy
msgid "<img alt=\"Get child contract address\" src=\"img/ch03-08-01-starkli-get-child-addr.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:89
msgid "## Interacting With Our Personalized Pigy Bank:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:91
msgid ""
"At this point, we have been able to create a piggy bank contract customized specifically to our savings target, and we have the address for that contract. We are now left with interacting with our "
"contract by depositing Eth into it and also withdrawing from it."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:93
msgid ""
"But before we jump into depositing Eth into our contract, its important to note that Ether on starknet is actually a regular ERC20 token, so we‚Äôll need to grant approval to our Piggy contract to be "
"able to spend our Eth. We can achieve this by using the below command to call the approve function on the Eth contract address."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:95
msgid ""
"```shell\n"
"starkli invoke 0x049D36570D4e46f48e99674bd3fcc84644DdD6b96F7C741B1562B82f9e004dC7 approve 0x044a5cc1518cd4f4dc4b40c5d2e72de2a82c5c7c7e2c0f840182b79aacb9773b u256:100000000000000000 --rpc https://"
"starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:99
msgid ""
"The first address is the address of the erc20 token then the second is the address of our personalized piggybank address.\n"
"After running the above code, we get a transaction hash containing details about our approval transaction:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:102
#, fuzzy
msgid "<img alt=\"Approving the child contract\" src=\"img/ch03-08-01-starkli-approve.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:104
msgid "The next step would be to deposit into our piggy bank contract using this command;"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:106
msgid ""
"```shell\n"
"starkli invoke 0x044a5cc1518cd4f4dc4b40c5d2e72de2a82c5c7c7e2c0f840182b79aacb9773b deposit 1000000000000000 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/"
"deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:110
msgid ""
"As with other invoke function calls we‚Äôve made, we also get a transaction hash for this transaction. Finally, after repeated calls to deposit ether into our contract, once we have saved up an "
"amount of our choice, we can call the withdraw function to withdraw from our account."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:112
msgid ""
"```shell\n"
"starkli invoke 0x044a5cc1518cd4f4dc4b40c5d2e72de2a82c5c7c7e2c0f840182b79aacb9773b withdraw 1000000000000000 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/"
"deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:116
msgid "Finally, we get a transaction hash containing details regarding our withdrawal `0x0781103066cf3bfa07ce59c1082c802db8a46caa276a293d9fcbe8610b85c1a8`."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:118
#, fuzzy
msgid "<img alt=\"Voyager scan of withdrawal function\" src=\"img/ch03-08-01-voyager-scan.png\" class=\"center\" style=\"width: 100%;\" />"
msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"

#: src/ch03-08-01-deploymet-and-interaction.md:120
msgid ""
"Scanning the above transaction hash on Voyager gives us the details contained in the image above; among other things, it contains a breakdown of how our withdrawal was distributed. Since we didn't "
"deposit up to our target amount before withdrawing, 10% of our withdrawal amount was sent to the factory contract, while the remaining 90% was sent to our address."
msgstr ""

#: src/ch03-08-02-important-methods.md:1
#, fuzzy
msgid "# Important Starknet Methods"
msgstr "## Integrando Starknet React"

#: src/ch03-08-02-important-methods.md:3
msgid ""
"The table below contains important methods used while building starknet smart contracts. It contains the name of the method, a keyword to import such a method, and finally a simple single line "
"usage of each method. Also note that multiple method imports can be chained to make the codebase simpler and also avoid repetition, e.g., `use starknet::{get_contract_address, ContractAddress}."
msgstr ""

#: src/ch03-08-02-important-methods.md:5
msgid "### Table 1.0"
msgstr ""

#: src/ch03-08-02-important-methods.md:7
msgid ""
"<table>\n"
"  <tr>\n"
"   <td><strong>METHODS</strong>\n"
"   </td>\n"
"   <td><strong>IMPORTATION</strong>\n"
"   </td>\n"
"   <td><strong>EXAMPLE USAGE</strong>\n"
"   </td>\n"
"   <td><strong> DESCRIPTION </strong>\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>get_contract_address()\n"
"   </td>\n"
"   <td>use starknet::get_contract_address\n"
"   </td>\n"
"   <td>let ThisContract = get_contract_address();\n"
"   </td>\n"
"   <td>Returns the contract address of the contract containing this method.\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>get_caller_address()\n"
"   </td>\n"
"   <td>use starknet::get_caller_address\n"
"   </td>\n"
"   <td>let user = get_caller_address();\n"
"   </td>\n"
"   <td>Returns the contract address of the user calling a certain function.\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>ContractAddress\n"
"   </td>\n"
"   <td>use starknet::ContractAddress\n"
"   </td>\n"
"   <td>let user: ContractAddress = get_caller_address();\n"
"   </td>\n"
"   <td>Allows for the usage of the contract address data type in a contract.\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>zero()\n"
"   </td>\n"
"   <td>use starknet::ContractAddress\n"
"   </td>\n"
"   <td>let addressZero: ContractAddress  = zero();\n"
"   </td>\n"
"   <td>Returns address zero contract address\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>get_block_info()\n"
"   </td>\n"
"   <td>use starknet::get_block_info\n"
"   </td>\n"
"   <td>let blockInfo = get_block_info();\n"
"   </td>\n"
"   <td>It returns a struct containing the block number, block timestamp, and the sequencer address. \n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>get_tx_info()\n"
"   </td>\n"
"   <td>use starknet::get_tx_info\n"
"   </td>\n"
"   <td>let txInfo = get_tx_info();\n"
"   </td>\n"
"   <td>Returns a struct containing transaction version, max fee, transaction hash, signature, chain ID, nonce, and transaction origin address.\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>get_block_timestamp()\n"
"   </td>\n"
"   <td>use starknet::get_block_timestamp\n"
"   </td>\n"
"   <td>let timeStamp = get_block_timestamp();\n"
"   </td>\n"
"   <td>Returns the block timestamp of the block containing the transaction.\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>get_block_number()\n"
"   </td>\n"
"   <td>use starknet::get_block_number\n"
"   </td>\n"
"   <td>Let blockNumber = get_block_number();\n"
"   </td>\n"
"   <td>Returns the block number of the block containing the transaction.\n"
"   </td>\n"
"  </tr>\n"
"  <tr>\n"
"   <td>ClassHash\n"
"   </td>\n"
"   <td>use starknet::ClassHash\n"
"   </td>\n"
"   <td>let childHash: ClassHash = contractClassHash;\n"
"   </td>\n"
"   <td>Allows for the use of the class Hash datatype to define variables that hold a class hash.\n"
"   </td>\n"
"  </tr>\n"
"</table>"
msgstr ""

#: src/ch04-00-account-abstraction.md:1
msgid "# Account Abstraction"
msgstr ""

#: src/ch04-00-account-abstraction.md:3
msgid "Account Abstraction (AA) represents an approach to managing accounts and transactions in blockchain networks. It involves two key concepts:"
msgstr ""

#: src/ch04-00-account-abstraction.md:5
msgid ""
"1. **Transaction Flexibility**:\n"
"\n"
"   - Smart contracts validate their transactions, moving away from a universal validation model.\n"
"   - Benefits include smart contracts covering gas fees, supporting multiple signers for one account, and using alternative cryptographic signatures.\n"
"\n"
"2. **User Experience Optimization**:\n"
"   - AA enables developers to design flexible security models, such as using different keys for routine and high-value transactions.\n"
"   - It offers alternatives to seed phrases for account recovery, simplifying the user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:14
msgid ""
"Technically, AA replaces Externally Owned Accounts (EOA) with a broader account concept. In this model, accounts are smart contracts, each with its unique rules and behaviors. These rules can "
"govern transaction ordering, signatures, access controls, and more, offering extensive customization."
msgstr ""

#: src/ch04-00-account-abstraction.md:16
msgid "**Key Definitions of AA**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:18
msgid ""
"- **Definition 1**: As described by [Martin Triay at Devcon 6](https://www.youtube.com/watch?v=Osc_gwNW3Fw), AA allows smart contracts to pay for their transactions. This shifts away from "
"traditional Externally Owned Accounts or Smart Wallets.\n"
"- **Definition 2**: [Lightclient at Devcon 6](https://app.devcon.org/schedule/9mvqce) defines AA as validation abstraction. Unlike Ethereum's Layer 1 single validation method, AA permits various "
"signature types, cryptographic methods, and execution processes."
msgstr ""

#: src/ch04-00-account-abstraction.md:21
msgid "## Applications of Account Abstraction"
msgstr ""

#: src/ch04-00-account-abstraction.md:23
msgid "Account Abstraction (AA) enhances the accessibility and security of self-custody in blockchain technology. Here are a few of the features that AA enables:"
msgstr ""

#: src/ch04-00-account-abstraction.md:25
msgid ""
"1. **Hardware Signer**:\n"
"\n"
"   - AA enables transaction signing with keys stored in a smartphone‚Äôs secure enclave, incorporating biometric identity for enhanced security and ease of use.\n"
"\n"
"2. **Social Recovery**:\n"
"\n"
"   - In case of lost or compromised keys, AA allows for secure key replacement, removing the need for seed phrases and simplifying the user experience.\n"
"\n"
"3. **Key Rotation**:\n"
"\n"
"   - If a key is compromised, it can be easily replaced without needing to transfer assets.\n"
"\n"
"4. **Session Keys**:\n"
"\n"
"   - AA facilitates a _sign in once_ feature for web3 applications, allowing transactions on your behalf and minimizing constant approvals.\n"
"\n"
"5. **Custom Transaction Validation Schemes**:\n"
"   - AA supports various signature schemes and security rules, enabling tailored security measures for individual needs."
msgstr ""

#: src/ch04-00-account-abstraction.md:44
msgid "AA also bolsters security in several ways:"
msgstr ""

#: src/ch04-00-account-abstraction.md:46
msgid ""
"1. **Improved Key Management**:\n"
"\n"
"   - Multiple devices can be linked to your wallet, ensuring account access even if one device is lost.\n"
"\n"
"2. **Diverse Signature and Validation Schemes**:\n"
"\n"
"   - AA accommodates additional security measures like two-factor authentication for substantial transactions, catering to individual security needs.\n"
"\n"
"3. **Custom Security Policies**:\n"
"   - Security can be customized for different user types or devices, incorporating best practices from banking and web2 sectors."
msgstr ""

#: src/ch04-00-account-abstraction.md:57
msgid "## Ethereum Account System"
msgstr ""

#: src/ch04-00-account-abstraction.md:59
msgid "Understanding Ethereum's current account system is important to appreciating the benefits of Account Abstraction (AA). Ethereum's account system comprises two types:"
msgstr ""

#: src/ch04-00-account-abstraction.md:61
msgid ""
"1. **Externally Owned Accounts (EOAs)**:\n"
"\n"
"   - Used by individuals, wallets, or entities external to the Ethereum network.\n"
"   - Identified by addresses derived from the public key of a cryptographic signer, which includes a private key and a public key.\n"
"   - The private key signs transactions or messages to prove ownership, while the public key verifies the signature.\n"
"   - Transactions must be signed by the EOA's private key to modify the account state, ensuring security through unique cryptographic identity.\n"
"\n"
"2. **Contract Accounts (CAs)**:\n"
"   - Essentially smart contracts on the Ethereum blockchain.\n"
"   - Lack private keys and are activated by transactions or messages from EOAs.\n"
"   - Their behavior is defined by their code."
msgstr ""

#: src/ch04-00-account-abstraction.md:73
msgid "Challenges in the current account model include:"
msgstr ""

#: src/ch04-00-account-abstraction.md:75
msgid ""
"1. **Key Management**:\n"
"\n"
"   - Loss of a private key means irreversible loss of account control and assets.\n"
"   - If stolen, the thief gains complete access to the account and its assets.\n"
"\n"
"2. **User Experience**:\n"
"\n"
"   - The Ethereum account model currently lacks user-friendly key or account recovery options.\n"
"   - Complex interfaces like crypto wallets can deter non-technical users, limiting broader adoption.\n"
"\n"
"3. **Lack of Flexibility**:\n"
"   - The traditional model restricts custom transaction validation schemes, limiting potential security and access control enhancements."
msgstr ""

#: src/ch04-00-account-abstraction.md:88
msgid "AA aims to address these issues, presenting opportunities for improved security, scalability, and user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:90
msgid "## Why Isn‚Äôt Account Abstraction Implemented in Ethereum‚Äôs Layer 1 Yet?"
msgstr ""

#: src/ch04-00-account-abstraction.md:92
msgid ""
"Ethereum's Layer 1 (L1) currently lacks support for Account Abstraction (AA) at the protocol level, not due to a lack of interest or recognition of its value, but rather because of the complexity "
"involved in its integration."
msgstr ""

#: src/ch04-00-account-abstraction.md:94
msgid "Key challenges to implementing AA in Ethereum‚Äôs L1 include:"
msgstr ""

#: src/ch04-00-account-abstraction.md:96
msgid ""
"- **Entrenched Nature of Externally Owned Accounts (EOAs)**:\n"
"\n"
"  - EOAs are integral to Ethereum's core protocol.\n"
"  - Modifying them to support AA is a daunting task, especially as Ethereum's value and usage continue to grow.\n"
"\n"
"- **Limitations of the Ethereum Virtual Machine (EVM)**:\n"
"  - The EVM, Ethereum's smart contract runtime environment, faces limitations that obstruct AA implementation.\n"
"  - Despite several AA proposals since Ethereum's inception, they have been delayed due to prioritization of other critical updates and improvements."
msgstr ""

#: src/ch04-00-account-abstraction.md:105
msgid "However, the rise of Layer 2 (L2) solutions offers a new avenue for AA:"
msgstr ""

#: src/ch04-00-account-abstraction.md:107
msgid ""
"- **Layer 2 Solutions**:\n"
"  - Focused on scalability and performance, L2 solutions are more accommodating for AA.\n"
"  - Platforms like Starknet and ZKSync, inspired by EIP4337, are pioneering native AA implementations."
msgstr ""

#: src/ch04-00-account-abstraction.md:111
msgid "Due to the ongoing delays and complexities of integrating AA into Ethereum‚Äôs L1, many advocates, have shifted their focus:"
msgstr ""

#: src/ch04-00-account-abstraction.md:113
msgid ""
"- **Shift to Layer 2 Advocacy**:\n"
"  - Instead of waiting for EOAs to phase out and AA to integrate into Ethereum's core, proponents now support the adoption of AA through L2 solutions.\n"
"  - This approach aims to deliver AA benefits to users more quickly and maintain Ethereum's competitive edge in the fast-evolving crypto space."
msgstr ""

#: src/ch04-00-account-abstraction.md:119
msgid ""
"In this subchapter, we've looked at Account Abstraction (AA) in Ethereum. AA makes transactions more flexible and improves how users manage their accounts. It's set to solve problems like key "
"management and user experience in Ethereum, but its integration into Ethereum's main layer has been slow due to technical hurdles and established systems."
msgstr ""

#: src/ch04-00-account-abstraction.md:121
msgid "Layer 2 solutions, however, are opening doors for AA. Starknet is a key player here."
msgstr ""

#: src/ch04-00-account-abstraction.md:123
msgid "Next, we'll get practical. You'll learn to code AA contracts in Starknet."
msgstr ""

#: src/ch04-01-accounts.md:1
msgid "# Account Contracts"
msgstr ""

#: src/ch04-01-accounts.md:3
msgid "With a clearer understanding of the AA concept, let's proceed to code it in Starknet."
msgstr ""

#: src/ch04-01-accounts.md:5
msgid "## Account Contract Interface"
msgstr ""

#: src/ch04-01-accounts.md:7
msgid ""
"Account contracts, being a type of smart contracts, are distinguished by specific methods. A smart contract becomes an account contract when it follows the public interface outlined in SNIP-6 "
"([Starknet Improvement Proposal-6: Standard Account Interface](https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md)). This standard draws inspiration from SRC-6 and "
"SRC-5, similar to Ethereum's ERCs, which establish application conventions and contract standards."
msgstr ""

#: src/ch04-01-accounts.md:9
msgid ""
"```rust\n"
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"/// @title SRC-6 Standard Account\n"
"trait ISRC6 {\n"
"    /// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    /// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"\n"
"    /// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"/// @title SRC-5 Standard Interface Detection\n"
"trait ISRC5 {\n"
"    /// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:49
msgid "From the proposal, an account contract should have the `__execute__`, `__validate__`, and `is_valid_signature` methods from the `ISRC6` trait."
msgstr ""

#: src/ch04-01-accounts.md:51
msgid "The provided functions serve these purposes:"
msgstr ""

#: src/ch04-01-accounts.md:53
msgid ""
"- `__validate__`: Validates a list of calls intended for execution based on the contract's rules. Instead of a boolean, it returns a short string like 'VALID' within a `felt252` to convey "
"validation results. In Cairo, this short string is the ASCII representation of a single felt. If verification fails, any felt other than 'VALID' can be returned. Often, `0` is chosen.\n"
"- `is_valid_signature`: Confirms the authenticity of a transaction's signature. It takes a transaction data hash and a signature, and compares it against a public key or another method chosen by "
"the contract's author. The result is a short 'VALID' string within a `felt252`.\n"
"- `__execute__`: After validation, `__execute__` carries out a series of contract calls (as `Call` structs). It gives back an array of `Span<felt252>` structs, showing the return values of those "
"calls."
msgstr ""

#: src/ch04-01-accounts.md:57
msgid ""
"Moreover, the `SNIP-5` (Standard Interface Detection) trait needs to be\n"
"defined with a function called `supports_interface`. This function\n"
"verifies whether a contract supports a specific interface, receiving an\n"
"interface ID and returning a boolean."
msgstr ""

#: src/ch04-01-accounts.md:62
msgid ""
"```rust\n"
"    trait ISRC5 {\n"
"        fn supports_interface(interface_id: felt252) -> bool;\n"
"    }\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:68
msgid ""
"In essence, when a user dispatches an `invoke` transaction, the protocol initiates by invoking the `__validate__` method. This verifies the associated signer's authenticity. For security reasons, "
"particularly to safeguard the Sequencer from Denial of Service (DoS) attacks [1], there are constraints on the operations within the `__validate__` method. If the signature is verified, the method "
"yields a `'VALID'` `felt252` value. If not, it returns 0."
msgstr ""

#: src/ch04-01-accounts.md:70
msgid ""
"After the protocol verifies the signer, it proceeds to invoke the `__execute__` function, passing an array of all desired operations‚Äîreferred to as \"calls\"‚Äîas an argument. Each of these calls "
"specifies a target smart contract address (`to`), the method to be executed (`selector`), and the arguments this method requires (`calldata`)."
msgstr ""

#: src/ch04-01-accounts.md:72
msgid ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"\n"
"    ....\n"
"\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    ....\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:90
msgid ""
"Executing a `Call` may yield a return value from the target smart contract. Whether it's a felt252, boolean, or a more intricate data structure like a struct or array, Starknet protocol serializes "
"the return using `Span<felt252>`. Since `Span` captures a segment of an Array [2], the `__execute__` function outputs an array of `Span<felt252>` elements. This array signifies the serialized "
"feedback from every operation in the multicall."
msgstr ""

#: src/ch04-01-accounts.md:92
msgid ""
"The `is_valid_signature` method isn't mandated or employed by the Starknet protocol. Instead, it's a convention within the Starknet developer community. Its purpose is to facilitate user "
"authentication in web3 applications. For instance, consider a user attempting to log into an NFT marketplace using their digital wallet. The web application prompts the user to sign a message, then "
"it uses the `is_valid_signature` function to confirm the authenticity of the associated wallet address."
msgstr ""

#: src/ch04-01-accounts.md:94
msgid ""
"To ensure other smart contracts recognize the compliance of an account contract with the SNIP-6 public interface, developers should incorporate the `supports_interface` method from the `ISRC5` "
"introspection trait. This method requires the Interface ID of SNIP-6 as its argument."
msgstr ""

#: src/ch04-01-accounts.md:96
msgid ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    // Implementations for __execute__, __validate__, and is_valid_signature go here.\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:112
msgid ""
"The `interface_id` corresponds to the aggregated hash of the trait's selectors, as detailed in Ethereum's ERC165 [3]. Developers can either compute the ID using the `src5-rs` utility [4] or rely on "
"the pre-calculated ID: `1270010605630597976495846281167968799381097569185364931397797212080166453709`."
msgstr ""

#: src/ch04-01-accounts.md:114
msgid "The fundamental structure for the account contract, aligning with the SNIP-G Interface standard, looks like this:"
msgstr ""

#: src/ch04-01-accounts.md:116
msgid ""
"```rust\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:134
msgid "## Expanding the Interface"
msgstr ""

#: src/ch04-01-accounts.md:136
msgid ""
"While the components mentioned earlier lay the foundation for an account contract in alignment with the SNIP-6 standard, developers can introduce more features to enhance the contract's "
"capabilities."
msgstr ""

#: src/ch04-01-accounts.md:138
msgid ""
"For example, integrate the `__validate_declare__` function if the contract declares other contracts and handles the corresponding gas fees. This offers a way to authenticate the contract "
"declaration. For those keen on counterfactual smart contract deployment, the `__validate_deploy__` function can be included."
msgstr ""

#: src/ch04-01-accounts.md:140
msgid ""
"Counterfactual deployment lets developers set up an account contract without depending on another account contract for gas fees. This method is valuable when there's no desire to link a new account "
"contract with its deploying address, ensuring a fresh start."
msgstr ""

#: src/ch04-01-accounts.md:142
msgid "This approach involves:"
msgstr ""

#: src/ch04-01-accounts.md:144
msgid ""
"1. Locally determining the potential address of our account contract without actual deployment, feasible with the Starkli [5] tool.\n"
"2. Transferring sufficient ETH to the predicted address to cover the deployment costs.\n"
"3. Sending a `deploy_account` transaction to Starknet containing our contract's compiled code. The sequencer then activates the account contract at the estimated address, compensating its gas fees "
"from the transferred ETH. No `declare` action is needed beforehand."
msgstr ""

#: src/ch04-01-accounts.md:148
msgid "For better compatibility with tools like Starkli later on, expose the signer's `public_key` through a view function in the public interface. Below is the augmented account contract interface:"
msgstr ""

#: src/ch04-01-accounts.md:150
msgid ""
"```rust\n"
"/// @title IAccountAddon - Extended account contract interface\n"
"trait IAccountAddon {\n"
"    /// @notice Validates if a declare transaction can proceed\n"
"    /// @param class_hash Hash of the smart contract under declaration\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"\n"
"    /// @notice Validates if counterfactual deployment can proceed\n"
"    /// @param class_hash Hash of the account contract under deployment\n"
"    /// @param salt Modifier for account address\n"
"    /// @param public_key Account signer's public key\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"\n"
"    /// @notice Fetches the signer's public key\n"
"    /// @return Public key\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:171
msgid "In conclusion, a comprehensive account contract incorporates the **SNIP-5**, **SNIP-6**, and the Addon interfaces."
msgstr ""

#: src/ch04-01-accounts.md:173
msgid ""
"```rust\n"
"// Cheat sheet\n"
"\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"trait IAccountAddon {\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    fn public_key() -> felt252;\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-01-accounts.md:200
msgid "## Recap"
msgstr ""

#: src/ch04-01-accounts.md:202
msgid "We've broken down the distinctions between account contracts and basic smart contracts, particularly focusing on the methods laid out in SNIP-6."
msgstr ""

#: src/ch04-01-accounts.md:204
msgid ""
"- Introduced the `ISRC6` trait, spotlighting essential functions:\n"
"\n"
"  - `__validate__`: Validates transactions.\n"
"  - `is_valid_signature`: Verifies signatures.\n"
"  - `__execute__`: Executes contract calls.\n"
"\n"
"- Discussed the `ISRC5` trait and highlighted the importance of the `supports_interface` function in confirming interface support.\n"
"\n"
"- Detailed the `Call` struct to represent a single contract call, explaining its components: `to`, `selector`, and `calldata`.\n"
"\n"
"- Touched on advanced features for account contracts, such as the `__validate_declare__` and `__validate_deploy__` functions."
msgstr ""

#: src/ch04-01-accounts.md:216
msgid "Coming up, we'll craft a basic account contract and deploy it on Starknet, offering hands-on insight into their functionality and interactions."
msgstr ""

#: src/ch04-02-hello-account.md:1
#, fuzzy
msgid "# Hello World! Account Contract"
msgstr "# ¬°Hola, Mundo!"

#: src/ch04-02-hello-account.md:3
msgid ""
"This section guides you through the creation of the simplest possible account contract, adhering to the SNIP-6 standard. The account contract will be the simplest implementation of an account "
"contract, with the following features:"
msgstr ""

#: src/ch04-02-hello-account.md:5
msgid ""
"- Signature validation for transactions will be not enforced. In other words, every transaction will be considered valid no matter who signed it; there will be no pivate key.\n"
"- It will make a single call and not multicall in the execution phase.\n"
"- It will only implement the SNIP-6 standard which is the minimum to be considered an account contract."
msgstr ""

#: src/ch04-02-hello-account.md:9
msgid "We will deployed using `starknet.py` and use it to deploy other contracts."
msgstr ""

#: src/ch04-02-hello-account.md:11 src/ch04-03-standard-account.md:5
#, fuzzy
msgid "## Setting Up Your Project"
msgstr "## Configurando un Nuevo Proyecto de React"

#: src/ch04-02-hello-account.md:13 src/ch04-03-standard-account.md:7
msgid ""
"For deploying an account contract to Starknet's testnet or mainnet, use Scarb version 2.3.1, which is compatible with the Sierra 1.3.0 target supported by both networks. For the latest information, "
"review the [Starknet Release Notes](https://docs.starknet.io/documentation/starknet_versions/version_notes/). As of November 2023, Scarb version 2.3.1 is the recommended choice."
msgstr ""

#: src/ch04-02-hello-account.md:15 src/ch04-03-standard-account.md:9
msgid "To check your current Scarb version, run:"
msgstr ""

#: src/ch04-02-hello-account.md:21 src/ch04-03-standard-account.md:15
msgid "To install or update Scarb, refer to the Basic Installation instructions in Chapter 2, covering macOS and Linux environments:"
msgstr ""

#: src/ch04-02-hello-account.md:27 src/ch04-03-standard-account.md:21
#, fuzzy
msgid "## Starting a New Scarb Project"
msgstr "## Iniciando un Nuevo Proyecto en Starknet"

#: src/ch04-02-hello-account.md:29 src/ch04-03-standard-account.md:23
msgid "Begin by creating a new project (more details in the Scarb subchapter in Chapter 2):"
msgstr ""

#: src/ch04-02-hello-account.md:31
#, fuzzy
msgid ""
"```bash\n"
"scarb new hello_account\n"
"```"
msgstr ""
"```bash\n"
"scarb build\n"
"```"

#: src/ch04-02-hello-account.md:35 src/ch04-03-standard-account.md:29
msgid "Check the generated project structure:"
msgstr ""

#: src/ch04-02-hello-account.md:37
msgid ""
"```bash\n"
"$ tree .\n"
".\n"
"‚îî‚îÄ‚îÄ hello_account\n"
"    ‚îú‚îÄ‚îÄ Scarb.toml\n"
"    ‚îî‚îÄ‚îÄ src\n"
"        ‚îî‚îÄ‚îÄ lib.cairo\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:46 src/ch04-03-standard-account.md:40
msgid "By default, Scarb sets up for vanilla Cairo. Add Starknet capacities by editing `Scarb.toml` to include the `starknet` dependency:"
msgstr ""

#: src/ch04-02-hello-account.md:48
msgid ""
"```bash\n"
"[package]\n"
"name = \"hello_account\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"casm-add-pythonic-hints = true\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:62
msgid "Replace the code in `src/lib.cairo` with the Hello World account contract:"
msgstr ""

#: src/ch04-02-hello-account.md:64
msgid ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"// IERC6 obtained from Open Zeppelin's cairo-contracts/src/account/interface.cairo\n"
"#[starknet::interface]\n"
"trait ISRC6<TState> {\n"
"    fn __execute__(self: @TState, calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(self: @TState, calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(self: @TState, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod HelloAccount {\n"
"    use starknet::VALIDATED;\n"
"    use starknet::account::Call;\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {} // Empty storage. No public key is stored.\n"
"\n"
"    #[external(v0)]\n"
"    impl SRC6Impl of super::ISRC6<ContractState> {\n"
"        fn is_valid_signature(\n"
"            self: @ContractState, hash: felt252, signature: Array<felt252>\n"
"        ) -> felt252 {\n"
"            // No signature is required so any signature is valid.\n"
"            VALIDATED\n"
"        }\n"
"        fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"            let hash = 0;\n"
"            let mut signature: Array<felt252> = ArrayTrait::new();\n"
"            signature.append(0);\n"
"            self.is_valid_signature(hash, signature)\n"
"        }\n"
"        fn __execute__(self: @ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"            let sender = get_caller_address();\n"
"            assert(sender.is_zero(), 'Account: invalid caller');\n"
"            let Call{to, selector, calldata } = calls.at(0);\n"
"            let _res = starknet::call_contract_syscall(*to, *selector, calldata.span()).unwrap();\n"
"            let mut res = ArrayTrait::new();\n"
"            res.append(_res);\n"
"            res\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:111 src/ch04-03-standard-account.md:78
msgid "Compile your project to ensure the setup is correct:"
msgstr ""

#: src/ch04-02-hello-account.md:117
msgid "## SNIP-6 Standard"
msgstr ""

#: src/ch04-02-hello-account.md:119 src/ch04-03-standard-account.md:86
msgid "To define an account contract, implement the `ISRC6` trait:"
msgstr ""

#: src/ch04-02-hello-account.md:121
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISRC6<TState> {\n"
"    fn __execute__(self: @TState, calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(self: @TState, calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(self: @TState, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:130
msgid ""
"The `__execute__` and `__validate__` functions are designed for exclusive use by the Starknet protocol to enhance account security. Despite their public accessibility, only the Starknet protocol "
"can invoke these functions, identified by using the zero address. In this minimal account contract we will not enforce this restriction, but we will do it in the next examples."
msgstr ""

#: src/ch04-02-hello-account.md:132
#, fuzzy
msgid "## Validating Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-02-hello-account.md:134
msgid "The `is_valid_signature` function is responsible for this validation, returning `VALIDATED` if the signature is valid. The `VALIDATED` constant is imported from the `starknet` module."
msgstr ""

#: src/ch04-02-hello-account.md:136
msgid ""
"```rust\n"
"use starknet::VALIDATED;\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:140
msgid ""
"Notice that the `is_valid_signature` function accepts all the transactions as valid. We are not storing a public key in the contract, so we cannot validate the signature. We will add this "
"functionality in the next examples."
msgstr ""

#: src/ch04-02-hello-account.md:142
msgid ""
"```rust\n"
"fn is_valid_signature(\n"
"            self: @ContractState, hash: felt252, signature: Array<felt252>\n"
"        ) -> felt252 {\n"
"            // No signature is required so any signature is valid.\n"
"            VALIDATED\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:151
msgid ""
"The `__validate__` function calls the `is_valid_signature` function with a dummy hash and signature. The `__validate__` function is called by the Starknet protocol to validate the transaction. If "
"the transaction is not valid, the execution of the transaction is aborted."
msgstr ""

#: src/ch04-02-hello-account.md:153
msgid ""
"```rust\n"
"fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"            let hash = 0;\n"
"            let mut signature: Array<felt252> = ArrayTrait::new();\n"
"            signature.append(0);\n"
"            self.is_valid_signature(hash, signature)\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:162
msgid "In other words we have implemented a contract that accepts all the transactions as valid. We will add the signature validation in the next examples."
msgstr ""

#: src/ch04-02-hello-account.md:164
#, fuzzy
msgid "## Executing Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-02-hello-account.md:166
msgid ""
"The `__execute__` function is responsible for executing the transaction. In this minimal account contract we will only execute a single call. We will add the multicall functionality in the next "
"examples."
msgstr ""

#: src/ch04-02-hello-account.md:168
msgid ""
"```rust\n"
"fn __execute__(self: @ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"            let Call{to, selector, calldata } = calls.at(0);\n"
"            let _res = starknet::call_contract_syscall(*to, *selector, calldata.span()).unwrap();\n"
"            let mut res = ArrayTrait::new();\n"
"            res.append(_res);\n"
"            res\n"
"        }\n"
"```"
msgstr ""

#: src/ch04-02-hello-account.md:178
msgid ""
"The `__execute__` function calls the `call_contract_syscall` function from the `starknet` module. This function executes the call and returns the result. The `call_contract_syscall` function is a "
"Starknet syscall, which means that it is executed by the Starknet protocol. The Starknet protocol is responsible for executing the call and returning the result. The Starknet protocol will also "
"validate the call, so we do not need to validate the call in the `__execute__` function."
msgstr ""

#: src/ch04-02-hello-account.md:180
#, fuzzy
msgid "## Deploying the Contract"
msgstr "## Implementaci√≥n del Contrato ERC20"

#: src/ch04-02-hello-account.md:182
msgid "[TODO]"
msgstr ""

#: src/ch04-03-standard-account.md:1
msgid "# Standard Account Contract"
msgstr ""

#: src/ch04-03-standard-account.md:3
msgid ""
"This section guides you through the creation of a standard account contract, adhering to the SNIP-6 and SRC-5 standards. Previously, we created a simple account contract that lacked signature "
"validation and multicall execution. This time, we'll implement a more robust account contract that includes these features and adheres to the standards of an account contract."
msgstr ""

#: src/ch04-03-standard-account.md:25
#, fuzzy
msgid ""
"```bash\n"
"scarb new aa\n"
"```"
msgstr ""
"```bash\n"
"scarb build\n"
"```"

#: src/ch04-03-standard-account.md:31
msgid ""
"```bash\n"
"$ tree .\n"
".\n"
"‚îî‚îÄ‚îÄ aa\n"
"    ‚îú‚îÄ‚îÄ Scarb.toml\n"
"    ‚îî‚îÄ‚îÄ src\n"
"        ‚îî‚îÄ‚îÄ lib.cairo\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:42
msgid ""
"```bash\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.3.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:56
msgid "Replace the code in `src/lib.cairo` with an account contract scaffold:"
msgstr ""

#: src/ch04-03-standard-account.md:58
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        public_key: felt252\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:69
msgid "To validate signatures, store the public key associated with the signer's private key."
msgstr ""

#: src/ch04-03-standard-account.md:71
msgid ""
"```rust\n"
"#[storage]\n"
"struct Storage {\n"
"    public_key: felt252\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:84
msgid "## Implementing SNIP-6 Standard"
msgstr ""

#: src/ch04-03-standard-account.md:88
msgid ""
"```rust\n"
"trait ISRC6 {\n"
"  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:96
msgid ""
"The `#[external(v0)]` attribute marks functions with unique selectors for external interaction. The Starknet protocol exclusively uses `__execute__` and `__validate__`, whereas `is_valid_signature` "
"is available for web3 applications to validate signatures."
msgstr ""

#: src/ch04-03-standard-account.md:98
msgid ""
"The `trait IAccount<T>`\\*\\* with `#[starknet::interface]` attribute groups publicly accessible functions, like `is_valid_signature`. Functions `__execute__` and `__validate__`, though public, are "
"accessible only indirectly."
msgstr ""

#: src/ch04-03-standard-account.md:100
msgid ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::Call;\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl for super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 { ... }\n"
"  }\n"
"\n"
"  // These functions are protocol-specific and not intended for direct external use.\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl for ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 { ... }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:132
msgid "## Restricted Function Access for Security"
msgstr ""

#: src/ch04-03-standard-account.md:134
msgid ""
"The `__execute__` and `__validate__` functions are designed for exclusive use by the Starknet protocol to enhance account security. Despite their public accessibility, only the Starknet protocol "
"can invoke these functions, identified by using the zero address."
msgstr ""

#: src/ch04-03-standard-account.md:136
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use starknet::get_caller_address;\n"
"  use zeroable::Zeroable;\n"
"\n"
"  // Enforces Starknet protocol-only access to specific functions\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Executes protocol-specific operations\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
"    }\n"
"\n"
"    // Validates protocol-specific operations\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol(); // Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
"    }\n"
"  }\n"
"\n"
"  // Defines a private function to check for protocol-level access\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    fn only_protocol(self: @ContractState) {\n"
"      // ... (access validation logic)\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:169
msgid "## Enhanced Security Through Protocol-Exclusive Functions"
msgstr ""

#: src/ch04-03-standard-account.md:171
msgid ""
"Starknet enhances the security of accounts by restricting the callability of certain functions. The `__execute__` and `__validate__` functions, though publicly visible, are callable solely by the "
"Starknet protocol. This protocol asserts its unique calling rights by using a designated zero address‚Äîa special value that signifies protocol-level operations."
msgstr ""

#: src/ch04-03-standard-account.md:173
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use starknet::get_caller_address;\n"
"  use zeroable::Zeroable;\n"
"\n"
"  // Implements function access control for Starknet protocol\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function is a protocol-exclusive operation\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Validates the caller as the Starknet protocol\n"
"      // ... (execution logic)\n"
"    }\n"
"\n"
"    // The __validate__ function ensures the integrity of protocol-level calls\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol(); // Ensures the caller is the Starknet protocol\n"
"      // ... (validation logic)\n"
"    }\n"
"  }\n"
"\n"
"  // A private function, only_protocol, to enforce protocol-level access\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // only_protocol checks the caller's address against the zero address\n"
"    fn only_protocol(self: @ContractState) {\n"
"      // If the caller is not the zero address, access is denied\n"
"      // This guarantees that only the Starknet protocol can call the function\n"
"      // ... (access control logic)\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:209
msgid "The `is_valid_signature` function, by contrast, is not bounded by `only_protocol`, maintaining its availability for broader use."
msgstr ""

#: src/ch04-03-standard-account.md:211
#, fuzzy
msgid "## Transaction Signature Validation"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-03-standard-account.md:213
msgid "To verify transaction signatures, the account contract stores the public key of the signer. The `constructor` method initializes this public key during the contract's deployment."
msgstr ""

#: src/ch04-03-standard-account.md:215
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Persistent storage for account-related data\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252  // Stores the public key for signature validation\n"
"  }\n"
"\n"
"  // Sets the public key during contract deployment\n"
"  #[constructor]\n"
"  fn constructor(ref self: ContractState, public_key: felt252) {\n"
"    self.public_key.write(public_key);  // Records the signer's public key\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:233
msgid ""
"The `is_valid_signature` function outputs `VALID` for an authentic signature and `0` for an invalid one. Additionally, the `is_valid_signature_bool` internal function provides a Boolean result for "
"the signature's validity."
msgstr ""

#: src/ch04-03-standard-account.md:235
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import relevant cryptographic and data handling modules\n"
"  use array::ArrayTrait;\n"
"  use ecdsa::check_ecdsa_signature;\n"
"  use array::SpanTrait;  // Facilitates the use of the span() method\n"
"\n"
"  // External function to validate the transaction signature\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
"      // Converts the signature array into a span for processing\n"
"      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
"      if is_valid { 'VALID' } else { 0 }  // Returns 'VALID' or '0' based on signature validity\n"
"    }\n"
"  }\n"
"\n"
"  // Private function to check the signature validity and return a Boolean\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Validates the signature using a span of elements\n"
"    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
"      // Checks if the signature has the correct length\n"
"      let is_valid_length = signature.len() == 2_u32;\n"
"\n"
"      // If the signature length is incorrect, returns false\n"
"      if !is_valid_length {\n"
"        return false;\n"
"      }\n"
"\n"
"      // Verifies the signature using the stored public key\n"
"      check_ecdsa_signature(\n"
"        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
"      )\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:277
msgid "In the `__validate__` function, the `is_valid_signature_bool` method is utilized to confirm the integrity of transaction signatures."
msgstr ""

#: src/ch04-03-standard-account.md:279
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import modules for transaction information retrieval\n"
"  use box::BoxTrait;\n"
"  use starknet::get_tx_info;\n"
"\n"
"  // Protocol implementation for transaction validation\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Validates the signature of a transaction\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();  // Ensures protocol-only access\n"
"\n"
"      // Retrieves transaction information and unpacks it\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      // Validates the signature and asserts its correctness\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');  // Stops execution if the signature is invalid\n"
"      'VALID'  // Indicates a valid signature\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:309
msgid "## Unified Signature Validation for Contract Operations"
msgstr ""

#: src/ch04-03-standard-account.md:311
msgid ""
"The `__validate_declare__` function is responsible for validating the signature\n"
"of the `declare` function. On the other hand, `__validate_deploy__` facilitates\n"
"counterfactual deployment,a method to deploy an account contract without\n"
"associating it to a specific deployer address."
msgstr ""

#: src/ch04-03-standard-account.md:316
msgid ""
"To streamline the validation process, we'll unify the behavior of the three\n"
"validation functions `__validate__`,`__validate_declare__` and `__validate_deploy__`.\n"
"The core logic from `__validate__` is abstracted to `validate_transaction` private\n"
"function, which is then invoked by the other two validation functions."
msgstr ""

#: src/ch04-03-standard-account.md:321
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Protocol implementation for the account contract\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"\n"
"    // Validates general contract function calls\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      self.validate_transaction()  // Centralized validation logic\n"
"    }\n"
"\n"
"    // Validates the 'declare' function signature\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      self.validate_transaction()  // Reuses the validation logic\n"
"    }\n"
"\n"
"    // Validates counterfactual contract deployment\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
"      // Even though public_key is provided, it uses the one stored from the constructor\n"
"      self.validate_transaction()  // Applies the same validation logic\n"
"    }\n"
"  }\n"
"\n"
"  // Private trait implementation that contains shared validation logic\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Abstracted core logic for validating transactions\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();  // Extracts transaction information\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      // Validates the transaction signature using an internal boolean function\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');  // Ensures signature correctness\n"
"      'VALID'  // Returns 'VALID' if the signature checks out\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:367
msgid ""
"It's important to note that the `__validate_deploy__` function receives the public key\n"
"as an argument. While this key is captured during the constructor phase before this function\n"
"is invoked, it remains crucial to provide it when initiating the transaction.\n"
"Alternatively, the public key can be directly utilized within the `__validate_deploy__` function,\n"
"bypassing the constructor."
msgstr ""

#: src/ch04-03-standard-account.md:373
#, fuzzy
msgid "## Efficient Multicall Transaction Execution"
msgstr "### Interacci√≥n de Contrato con Multicall"

#: src/ch04-03-standard-account.md:375
msgid ""
"The `__execute__` function within the `Account` module of a Starknet contract is designed to process an array of `Call` structures. This multicall feature consolidates several user operations into "
"a single transaction, significantly improving the user experience by enabling batched operations."
msgstr ""

#: src/ch04-03-standard-account.md:377
msgid ""
"````rust\n"
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Protocol implementation to handle execution of calls\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function processes an array of calls\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Ensures Starknet protocol level access\n"
"      self.execute_multiple_calls(calls) // Invokes batch processing of calls\n"
"    }\n"
"    // ... Additional implementation details\n"
"  }\n"
"}\n"
"````"
msgstr ""

#: src/ch04-03-standard-account.md:395
msgid "Each `Call` represents the details required for executing a single operation by the smart contract:"
msgstr ""

#: src/ch04-03-standard-account.md:397
msgid ""
"```rust\n"
"// Data structure encapsulating a contract call\n"
"#[derive(Drop, Serde)]\n"
"struct Call {\n"
"  to: ContractAddress,       // The target contract address\n"
"  selector: felt252,         // The function selector\n"
"  calldata: Array<felt252>   // The parameters for the function call\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:407
msgid "The contract defines a private function `execute_single_call` to handle individual calls. It utilizes the `call_contract_syscall` to directly invoke a function on another contract:"
msgstr ""

#: src/ch04-03-standard-account.md:409
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Import syscall for contract function invocation\n"
"  use starknet::call_contract_syscall;\n"
"\n"
"  // Private trait implementation for individual call execution\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Executes a single call to another contract\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call; // Destructures the Call struct\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap_syscall() // Performs the contract call\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:428
msgid "For the execution of multiple calls, `execute_multiple_calls` iterates over the array of Call structures, invoking `execute_single_call` for each and collecting the responses:"
msgstr ""

#: src/ch04-03-standard-account.md:430
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Private trait implementation for batch call execution\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Handles an array of calls and accumulates the results\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new(); // Initializes the result array\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let response = self.execute_single_call(call); // Executes each call individually\n"
"            res.append(response); // Appends the result of the call to the result array\n"
"          },\n"
"          Option::None(_) => {\n"
"            break (); // Exits the loop when no more calls are left\n"
"          },\n"
"        };\n"
"      };\n"
"      res // Returns the array of results\n"
"    }\n"
"  }\n"
"  // ... Additional implementation details\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:457
msgid ""
"In summary, the `__execute__` function orchestrates the execution of multiple calls within a single transaction. It leverages these internal functions to handle each call efficiently and return the "
"collective results:"
msgstr ""

#: src/ch04-03-standard-account.md:459
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // External function definition within the protocol implementation\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // The __execute__ function takes an array of Call structures and processes them\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Verifies that the function caller is the Starknet protocol\n"
"      self.execute_multiple_calls(calls) // Delegates to a function for processing multiple calls\n"
"    }\n"
"    // ... Additional implementation details may follow\n"
"  }\n"
"  // ... Further module code may be present\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:477
msgid ""
"The `__execute__` function first ensures that it is being called by the Starknet protocol itself, a security measure to prevent unauthorized access. It then calls the `execute_multiple_calls` "
"function to handle the actual execution of the calls."
msgstr ""

#: src/ch04-03-standard-account.md:479
msgid "## Ensuring Compatibility with Transaction Versioning"
msgstr ""

#: src/ch04-03-standard-account.md:481
msgid ""
"Starknet incorporates a versioning system for transactions to maintain backward compatibility while introducing new functionalities. The account contract tutorial showcases support for the latest "
"transaction versions through a specific module, ensuring smooth operation of both legacy and updated transaction structures."
msgstr ""

#: src/ch04-03-standard-account.md:483
msgid ""
"To accommodate the evolution of Starknet and its enhanced functionalities,\n"
"a versioning system was introduced for transactions. This ensures backward compatibility,\n"
"allowing both old and new transaction structures to operate concurrently."
msgstr ""

#: src/ch04-03-standard-account.md:487
msgid ""
"- Version 1 for `invoke` transactions\n"
"- Version 1 for `deploy_account` transactions\n"
"- Version 2 for `declare` transactions"
msgstr ""

#: src/ch04-03-standard-account.md:491
msgid "These supported versions are logically grouped in a module called `SUPPORTED_TX_VERSION`:"
msgstr ""

#: src/ch04-03-standard-account.md:493
msgid ""
"```rust\n"
"// Module defining supported transaction versions\n"
"mod SUPPORTED_TX_VERSION {\n"
"  // Constants representing the supported versions\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;  // Supported version for deploy_account transactions\n"
"  const DECLARE: felt252 = 2;         // Supported version for declare transactions\n"
"  const INVOKE: felt252 = 1;          // Supported version for invoke transactions\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // The rest of the account contract module code\n"
"  ...\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:509
msgid ""
"To handle the version checking, the account contract includes a private function `only_supported_tx_version`. This function compares the version of an incoming transaction against the specified "
"supported versions, halting execution with an error if a discrepancy is found."
msgstr ""

#: src/ch04-03-standard-account.md:511
msgid "The critical contract functions such as `__execute__`, `__validate__`, `__validate_declare__`, and `__validate_deploy__` implement this version check to confirm transaction compatibility."
msgstr ""

#: src/ch04-03-standard-account.md:513
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Importing constants from the SUPPORTED_TX_VERSION module\n"
"  use super::SUPPORTED_TX_VERSION;\n"
"\n"
"  // Protocol implementation for Starknet functions\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    // Function to execute multiple calls with version check\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol(); // Checks if the function caller is the Starknet protocol\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE); // Ensures the transaction is the supported version\n"
"      self.execute_multiple_calls(calls) // Processes the calls if version check passes\n"
"    }\n"
"\n"
"    // Each of the following functions also includes the version check to ensure compatibility\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  // Private implementation for checking supported transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to assert the transaction version is supported\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves transaction details\n"
"      let version = tx_info.version; // Extracts the version from the transaction\n"
"      assert(\n"
"        version == supported_tx_version,\n"
"        'Account: Unsupported tx version' // Error message for unsupported versions\n"
"      );\n"
"    }\n"
"    // ... Additional private functions\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:567
msgid ""
"By integrating transaction version control, the contract ensures it operates consistently with the network's current standards, providing a clear path for upgrading and maintaining compatibility "
"with Starknet's evolving ecosystem."
msgstr ""

#: src/ch04-03-standard-account.md:569
#, fuzzy
msgid "## Handling Simulated Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-03-standard-account.md:571
msgid ""
"Starknet's simulation feature allows developers to estimate the gas cost of transactions without actually committing them to the network. This is particularly useful during development and testing "
"phases. The `estimate-only` flag available in tools like Starkli triggers the simulation process. To differentiate between actual transaction execution and simulation, Starknet uses a version "
"offset strategy."
msgstr ""

#: src/ch04-03-standard-account.md:573
msgid ""
"Simulated transactions are assigned a version number that is the sum of \\(2^{128}\\) and the version number of the actual transaction type. For example, if the latest version of a `declare` "
"transaction is 2, then a simulated `declare` transaction would have a version number of \\(2^{128} + 2\\). The same logic applies to other transaction types like `invoke` and `deploy_account`."
msgstr ""

#: src/ch04-03-standard-account.md:575
msgid "Here's how the `only_supported_tx_version` function is adjusted to accommodate both actual and simulated transaction versions:"
msgstr ""

#: src/ch04-03-standard-account.md:577
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant representing the version offset for simulated transactions\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // This is 2^128\n"
"\n"
"  // Private trait implementation updated to validate transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to check for supported transaction versions, accounting for simulations\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves the transaction metadata\n"
"      let version = tx_info.version; // Extracts the version for comparison\n"
"\n"
"      // Validates whether the transaction version matches either the supported actual version or the simulated version\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version' // Assertion message for version mismatch\n"
"      );\n"
"    }\n"
"    // Additional private functions may follow\n"
"  }\n"
"  // Remaining contract code may continue here\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:604
msgid ""
"The code snippet showcases the account contract's capability to recognize and process both actual and simulated versions of transactions by incorporating the large numerical offset. This ensures "
"that the system can seamlessly operate with and adjust to the estimation process without affecting the actual transaction processing logic."
msgstr ""

#: src/ch04-03-standard-account.md:606
#, fuzzy
msgid "## SRC-5 Standard and Contract Introspection"
msgstr "## Interacciones del Contrato"

#: src/ch04-03-standard-account.md:608
msgid ""
"Contract introspection is a feature that allows Starknet contracts to self-report the interfaces they support, in compliance with the SRC-5 standard. The `supports_interface` function is a "
"fundamental part of this introspection process, enabling contracts to communicate their capabilities to others."
msgstr ""

#: src/ch04-03-standard-account.md:610
msgid ""
"For a contract to be SRC-5 compliant, it must return `true` when the `supports_interface` function is called with a specific `interface_id`. This unique identifier is chosen to represent the SRC-6 "
"standard's interface, which the contract claims to support. The identifier is a large integer specifically chosen to minimize the chance of accidental collisions with other identifiers."
msgstr ""

#: src/ch04-03-standard-account.md:612
msgid "In the account contract, the `supports_interface` function is part of the public interface, allowing other contracts to query its support for the SRC-6 standard:"
msgstr ""

#: src/ch04-03-standard-account.md:614
msgid ""
"```rust\n"
"// SRC-5 trait defining the introspection method\n"
"trait ISRC5 {\n"
"  // Function to check interface support\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// Extension of the account contract's interface for SRC-5 compliance\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  // ... Additional methods\n"
"  // Method to validate interface support\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant identifier for the SRC-6 trait\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  // Public interface implementation for the account contract\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    // ... Other function implementations\n"
"    // Implementation of the interface support check\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      // Compares the provided interface ID with the SRC-6 trait ID\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  // ... Additional account contract code\n"
"}\n"
"// SRC-5 trait defining the introspection method\n"
"trait ISRC5 {\n"
"  // Function to check interface support\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// Extension of the account contract's interface for SRC-5 compliance\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  // ... Additional methods\n"
"  // Method to validate interface support\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant identifier for the SRC-6 trait\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  // Public interface implementation for the account contract\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    // ... Other function implementations\n"
"    // Implementation of the interface support check\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      // Compares the provided interface ID with the SRC-6 trait ID\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  // ... Additional account contract code\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:679
msgid ""
"By implementing this function, the account contract declares its ability to interact with other contracts expecting SRC-6 features, thus adhering to the standards of the Starknet protocol and "
"enhancing interoperability within the network."
msgstr ""

#: src/ch04-03-standard-account.md:681
msgid "## Public Key Accessibility"
msgstr ""

#: src/ch04-03-standard-account.md:683
msgid ""
"For enhanced transparency and debugging purposes, it's recommended to make the public key\n"
"of the account contract's signer accessible. This allows users to verify the correct deployment\n"
"of the account contract by comparing the stored public key with the signer's public key offline."
msgstr ""

#: src/ch04-03-standard-account.md:687
msgid ""
"```rust\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    ...\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:704
#, fuzzy
msgid "## Final Implementation"
msgstr "### Componente de Balance"

#: src/ch04-03-standard-account.md:706
msgid "We now have a fully functional account contract. Here's the final implementation;"
msgstr ""

#: src/ch04-03-standard-account.md:708
msgid ""
"```rust\n"
"use starknet::account::Call;\n"
"\n"
"mod SUPPORTED_TX_VERSION {\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;\n"
"  const DECLARE: felt252 = 2;\n"
"  const INVOKE: felt252 = 1;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"  fn public_key(self: @T) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::{Call, IAccount, SUPPORTED_TX_VERSION};\n"
"  use starknet::{get_caller_address, call_contract_syscall, get_tx_info, VALIDATED};\n"
"  use zeroable::Zeroable;\n"
"  use array::{ArrayTrait, SpanTrait};\n"
"  use ecdsa::check_ecdsa_signature;\n"
"  use box::BoxTrait;\n"
"\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[constructor]\n"
"  fn constructor(ref self: ContractState, public_key: felt252) {\n"
"    self.public_key.write(public_key);\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
"      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
"      if is_valid { VALIDATED } else { 0 }\n"
"    }\n"
"\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.execute_multiple_calls(calls)\n"
"    }\n"
"\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    fn only_protocol(self: @ContractState) {\n"
"      let sender = get_caller_address();\n"
"      assert(sender.is_zero(), 'Account: invalid caller');\n"
"    }\n"
"\n"
"    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
"      let is_valid_length = signature.len() == 2_u32;\n"
"\n"
"      if !is_valid_length {\n"
"        return false;\n"
"      }\n"
"\n"
"      check_ecdsa_signature(\n"
"        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
"      )\n"
"    }\n"
"\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');\n"
"      VALIDATED\n"
"    }\n"
"\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call;\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap()\n"
"    }\n"
"\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new();\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let _res = self.execute_single_call(call);\n"
"            res.append(_res);\n"
"          },\n"
"          Option::None(_) => {\n"
"            break ();\n"
"          },\n"
"        };\n"
"      };\n"
"      res\n"
"    }\n"
"\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let version = tx_info.version;\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version'\n"
"      );\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-standard-account.md:853
#, fuzzy
msgid "## Account Contract Creation Summary"
msgstr "Abstracci√≥n de Cuenta"

#: src/ch04-03-standard-account.md:855
msgid ""
"- **SNIP-6 Implementation**\n"
"\n"
"  - Implements the `ISRC6` trait, defining the account contract's structure.\n"
"\n"
"- **Protocol-Only Function Access**\n"
"\n"
"  - Restricts `__validate__` and `__execute__` to StarkNet protocol access.\n"
"  - Makes `is_valid_signature` available for external calls.\n"
"  - Adds a `only_protocol` private function to enforce access rules.\n"
"\n"
"- **Signature Validation Process**\n"
"\n"
"  - Stores a public key to verify the signer's transactions.\n"
"  - Initializes with a `constructor` to set the public key.\n"
"  - Validates signatures with `is_valid_signature`, returning `VALID` or `0`.\n"
"  - Uses `is_valid_signature_bool` to return a true or false validation result.\n"
"\n"
"- **Declare and Deploy Function Validation**\n"
"\n"
"  - Sets up `__validate_declare__` to check the `declare` function's signature.\n"
"  - Designs `__validate_deploy__` for counterfactual deployments.\n"
"  - Abstracts core validation to `validate_transaction`.\n"
"\n"
"- **Transaction Execution Logic**\n"
"\n"
"  - Enables multicall capability with `__execute__`.\n"
"  - Handles calls individually with `execute_single_call` and in batches with `execute_multiple_calls`.\n"
"\n"
"- **Transaction Version Compatibility**\n"
"\n"
"  - Ensures compatibility with StarkNet updates using a versioning system.\n"
"  - Defines supported transaction types in `SUPPORTED_TX_VERSION`.\n"
"  - Checks transaction versions with `only_supported_tx_version`.\n"
"\n"
"- **Simulated Transaction Handling**\n"
"\n"
"  - Adapts `only_supported_tx_version` to recognize both actual and simulated versions.\n"
"\n"
"- **Contract Self-Identification**\n"
"\n"
"  - Allows self-identification with the SRC-5 standard via `supports_interface`.\n"
"\n"
"- **Public Key Visibility**\n"
"\n"
"  - Provides public key access for transparency.\n"
"\n"
"- **Complete Implementation**\n"
"  - Presents the final account contract code."
msgstr ""

#: src/ch04-03-standard-account.md:904
msgid "Next, we will deploy the account using Starkli to the testnet and interact with other smart contracts."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:1
#, fuzzy
msgid "# Deploying Account Contracts"
msgstr "## Implementaci√≥n del Contrato ERC20"

#: src/ch04-03-01-deploy-standard-account.md:3
msgid "After building our account contract, we'll now deploy it using Starkli on the testnet and interact with other contracts."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:5
msgid ""
"Ensure you've installed [starkli](https://github.com/xJonathanLEI/starkli) and [scarb](https://docs.swmansion.com/scarb/download.html). Review the Basic Installation subchapter in Chapter 2 if you "
"haven't."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:7
#, fuzzy
msgid "## Account Contract Configuration Files"
msgstr "## Interacciones del Contrato"

#: src/ch04-03-01-deploy-standard-account.md:9
msgid "Starkli requires two key configuration files:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:11
msgid ""
"- `keystore.json`: A secure file that holds the private key.\n"
"- `account.json`: An open file with the account's public details like public key, class hash, and address."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:14
msgid "Optionally, Starkli can use:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:16
msgid "- `envars.sh`: A script to set environment variables for Starkli commands."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:18
msgid "For multiple wallets, keep a clean directory structure. Each wallet should have its own folder with the three files inside. Group these under a `~/.starkli-wallets` directory."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:20
msgid "Here's a suggested structure:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:22
msgid ""
"```bash\n"
"tree ~/.starkli-wallets\n"
"\n"
".starkli-wallets\n"
"‚îú‚îÄ‚îÄ wallet-a\n"
"‚îÇ   ‚îú‚îÄ‚îÄ account.json\n"
"‚îÇ   ‚îú‚îÄ‚îÄ envars.sh\n"
"‚îÇ   ‚îî‚îÄ‚îÄ keystore.json\n"
"‚îî‚îÄ‚îÄ wallet-b\n"
"    ‚îú‚îÄ‚îÄ account.json\n"
"    ‚îú‚îÄ‚îÄ envars.sh\n"
"    ‚îî‚îÄ‚îÄ keystore.json\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:36
msgid "This setup promotes better organization."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:38
msgid "We'll make a custom folder in `.starkli-wallets` for our contract wallet:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:40
#, fuzzy
msgid ""
"```bash\n"
"mkdir ~/.starkli-wallets/custom\n"
"```"
msgstr ""
"```bash\n"
"    mkdir ~/.starkli-wallets/deployer -p\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:44
msgid "Next, we use Starkli to create `keystore.json` and `account.json`, then write `envars.sh` by hand."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:46
msgid "## Creating the Keystore File with Starkli"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:48
msgid "Starkli simplifies creating a `keystore.json` file. This encrypted file holds your private key and sits in the `custom` directory. You can create this with one command:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:50
#, fuzzy
msgid ""
"```bash\n"
"starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:54
msgid "When you run this, you'll enter a password to secure the file. The resulting `keystore.json` is essential for setting up the `envars.sh` file, which stores environment variables."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:56
msgid "Create `envars.sh` like this:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:58
#, fuzzy
msgid ""
"```bash\n"
"touch ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"    mkdir ~/.starkli-wallets/deployer -p\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:62
msgid "Open the file and insert:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:64
#, fuzzy
msgid ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:69
msgid "Activate the variable by sourcing the file:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:71 src/ch04-03-01-deploy-standard-account.md:170 src/ch04-03-01-deploy-standard-account.md:236
#, fuzzy
msgid ""
"```bash\n"
"source ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"    mkdir ~/.starkli-wallets/deployer -p\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:75
msgid "Now, your environment is ready for the next step: creating the `account.json` file."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:77
#, fuzzy
msgid "## Generating the Account Configuration File"
msgstr "## Interacci√≥n con el Contrato"

#: src/ch04-03-01-deploy-standard-account.md:79
msgid ""
"Our account contract's signature validation mirrors that in [Open Zeppelin's default account contract](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.7.0-rc.0/src/account/account."
"cairo), using a single signer and a STARK-compatible elliptic curve. Despite building our contract independently, we'll use Starkli's command for Open Zeppelin accounts to create our configuration:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:81
#, fuzzy
msgid ""
"```bash\n"
"starkli account oz init ~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:85
msgid ""
"After entering your keystore password, `account.json` is created. This file includes a class hash for OpenZeppelin's contract, not ours. Since the class hash influences the deployment address, the "
"shown address won't match our contract."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:87
#, fuzzy
msgid "Here's what account.json looks like:"
msgstr "As√≠ es como podr√≠a verse un descriptor t√≠pico:"

#: src/ch04-03-01-deploy-standard-account.md:89
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"open_zeppelin\",\n"
"    \"version\": 1,\n"
"    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
"    \"legacy\": false\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"undeployed\",\n"
"    \"class_hash\": \"0x4c6d6cf894f8bc96bb9c525e6853e5483177841f7388f74a46cfda6f028c755\",\n"
"    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:106
msgid "To deploy our unique contract, we must compile our project to obtain the correct class hash and update `account.json` accordingly."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:108
#, fuzzy
msgid "## Finding the Class Hash"
msgstr "### Actualizaci√≥n del Componente Wallet"

#: src/ch04-03-01-deploy-standard-account.md:110
msgid "Previously, we set up a `aa` directory for our account contract's Cairo code. If you don't have it, clone the repository:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:112
msgid ""
"```bash\n"
"git clone git@github.com:starknet-edu/aa-workshop.git aa\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:116
msgid "To compile the contract with Scarb, enter the project directory:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:118
#, fuzzy
msgid ""
"```bash\n"
"cd aa\n"
"scarb build\n"
"```"
msgstr ""
"```bash\n"
"scarb build\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:123
msgid "The compiled contract lies in `target/dev`. Use Starkli to get the class hash:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:125
#, fuzzy
msgid ""
"```bash\n"
"starkli class-hash target/dev/aa_Account.sierra.json\n"
"```"
msgstr ""
"```bash\n"
"    starkli declare target/dev/contracts_Ownable.sierra.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:129
msgid "Next, edit `account.json` to insert the correct class hash:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:131
#, fuzzy
msgid ""
"```bash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:135
msgid "Ensure the `class_hash` is updated:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:137
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"open_zeppelin\",\n"
"    \"version\": 1,\n"
"    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
"    \"legacy\": false\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"undeployed\",\n"
"    \"class_hash\": \"0x03480253c19b447b1d7e7a6422acf80b73866522de03126fa55796a712d9f092\",\n"
"    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:154
msgid "To point to the updated `account.json`, modify `envars.sh`:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:156
#, fuzzy
msgid ""
"```bash\n"
"code ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"    mkdir ~/.starkli-wallets/deployer -p\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:160
msgid "Add the account path:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:162
#, fuzzy
msgid ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
"    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:168
msgid "Source `envars.sh` to apply the changes:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:174
#, fuzzy
msgid "Now, we're ready to declare the contract on the testnet."
msgstr "Una vez configurado, estar√° listo para implementar sus contratos inteligentes en Starknet Testnet."

#: src/ch04-03-01-deploy-standard-account.md:176
#, fuzzy
msgid "## Establishing an RPC Provider"
msgstr "### Elegir un Proveedor de RPC"

#: src/ch04-03-01-deploy-standard-account.md:178
msgid "For transactions on Starknet, an RPC provider is essential. This guide uses [Infura](https://www.infura.io/) but a personal node is a viable alternative."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:180
msgid "Steps for Infura:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:182
msgid ""
"- Create an account.\n"
"- Start a new project for Starknet Goerli.\n"
"- Obtain the RPC URL.\n"
"- Add this URL to `envars.sh`:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:187
#, fuzzy
msgid ""
"```bash\n"
"aa $ code ~/.starkli-wallets/custom/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"    mkdir ~/.starkli-wallets/deployer -p\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:191
msgid "The file should now include:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:193
msgid ""
"```bash\n"
"#!/bin/bash\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"export STARKNET_RPC=https://starknet-goerli.infura.io/v3/your-api-key\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:200
msgid "Replace `your-api-key` with the actual API key provided by Infura."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:202
#, fuzzy
msgid "## Declaring the Account Contract"
msgstr "### Declarando su Contrato"

#: src/ch04-03-01-deploy-standard-account.md:204
msgid ""
"You'll need a funded account to pay gas fees. Configure Starkli with a [Braavos](https://braavos.app/) or [Argent X](https://www.argent.xyz/argent-x/) wallet as the deployer. Instructions are "
"available [here](https://medium.com/starknet-edu/starkli-the-new-starknet-cli-86ea914a2933)."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:206
msgid "After setting up, your Starkli wallet structure will be:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:208
msgid ""
"```bash\n"
"tree .\n"
"\n"
".\n"
"‚îú‚îÄ‚îÄ custom\n"
"‚îÇ¬†¬† ‚îú‚îÄ‚îÄ account.json\n"
"‚îÇ¬†¬† ‚îú‚îÄ‚îÄ envars.sh\n"
"‚îÇ¬†¬† ‚îî‚îÄ‚îÄ keystore.json\n"
"‚îî‚îÄ‚îÄ deployer\n"
"    ‚îú‚îÄ‚îÄ account.json\n"
"    ‚îú‚îÄ‚îÄ envars.sh\n"
"    ‚îî‚îÄ‚îÄ keystore.json\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:222
msgid "Source the deployer's environment file in the `aa` directory to use it:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:224
#, fuzzy
msgid ""
"```bash\n"
"source ~/.starkli-wallets/deployer/envars.sh\n"
"```"
msgstr ""
"```bash\n"
"    mkdir ~/.starkli-wallets/deployer -p\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:228
msgid "Declare the contract with the deployer covering gas:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:230
#, fuzzy
msgid ""
"```bash\n"
"starkli declare target/dev/aa_Account.sierra.json\n"
"```"
msgstr ""
"```bash\n"
"    starkli declare target/dev/contracts_Ownable.sierra.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:234
msgid "After reaching \"Accepted on L2,\" status (less than a minute) switch back to the account's environment:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:240
msgid "Deploy the account with Starkli:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:242
#, fuzzy
msgid ""
"```bash\n"
"starkli account deploy ~/.starkli-wallets/custom/account.json\n"
"```"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:246
msgid "Starkli will wait for you to fund the address displayed with at least the estimated fee from Starknet's [faucet](https://faucet.goerli.starknet.io/)."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:248
msgid "Once funded, press **`ENTER`** to deploy:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:250
msgid ""
"```bash\n"
"...\n"
"Deployment transaction confirmed\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:255
msgid "Your account contract is now live on the Starknet testnet."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:257
#, fuzzy
msgid "## Using the Account Contract"
msgstr "### Declarando su Contrato"

#: src/ch04-03-01-deploy-standard-account.md:259
msgid "To test our account contract, we can send 100 gwei to the wallet `0x070a...52d1` by calling the `transfer` function of the WETH smart contract on Starknet's testnet."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:261
msgid "Invoke the transfer with Starkli (more details on Starkli's in Chapter 2):"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:263
msgid ""
"```bash\n"
"starkli invoke eth transfer 0x070a012... u256:100\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:267
msgid "A successful invoke confirms that our account contract has authenticated the signature, executed the transfer, and managed the gas fees."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:269
msgid "Here's a summary of all the steps from declaration to interaction:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:271
msgid ""
"```bash\n"
"# Quick Guide: Declare, Deploy, and Interact with a Custom Account Contract\n"
"\n"
"# [1] Set up environment variables in envars.sh\n"
"export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
"export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
"export STARKNET_RPC=https://starknet-goerli.infura.io/v3/your-api-key\n"
"\n"
"# [2] Generate keystore.json\n"
"starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
"\n"
"# [3] Initialize account.json\n"
"starkli account oz init ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [4] Build the contract with Scarb\n"
"scarb build\n"
"\n"
"# [5] Get the class hash\n"
"starkli class-hash target/dev/aa_Account.sierra.json\n"
"\n"
"# [6] Update account.json with the real class hash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [7] Set deployer wallet environment\n"
"source ~/.starkli-wallets/deployer/envars.sh\n"
"\n"
"# [8] Declare the contract using the deployer\n"
"starkli declare target/dev/aa_Account.sierra.json\n"
"\n"
"# [9] Switch to the custom wallet\n"
"source ~/.starkli-wallets/custom/envars.sh\n"
"\n"
"# [10] Deploy the contract\n"
"starkli account deploy ~/.starkli-wallets/custom/account.json\n"
"\n"
"# [11] Test the contract by transferring ETH\n"
"starkli invoke eth transfer 0x070a012... u256:100\n"
"\n"
"# [bonus] Recommended directory structure\n"
".\n"
"‚îú‚îÄ‚îÄ account.json\n"
"‚îú‚îÄ‚îÄ envars.sh\n"
"‚îî‚îÄ‚îÄ keystore.json\n"
"```"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:316
msgid "## Summary"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:318
msgid "We've successfully deployed and used our custom account contract on Starknet with Starkli. Here's what we accomplished:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:320
msgid ""
"- Set environment variables in `envars.sh`.\n"
"- Created `keystore.json` to securely store the private key.\n"
"- Initialized `account.json` as the account descriptor file.\n"
"- Used Braavos smart wallet to set up the deployer environment.\n"
"- Declared and deployed our account contract to the Starknet testnet.\n"
"- Conducted a transfer to another wallet."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:327
msgid ""
"We matched the Open Zeppelin's contract in terms of signature methods for the `constructor` and `__declare_deploy__` functions, which allowed us to use Starkli's Open Zeppelin preset. Should there "
"be a need for signature modification, Starknet JS SDK would be the tool of choice."
msgstr ""

#: src/ch04-05-examples.md:1
msgid "# Examples"
msgstr "# Ejemplos"

#: src/ch04-05-examples.md:3
msgid ""
"Here, we will explore numerous examples, elucidating the principles and\n"
"techniques to effectively design and implement Account contracts."
msgstr ""

#: src/ch04-05-examples.md:6
msgid ""
"Before delving into the examples, we would like to issue a disclaimer:\n"
"the contracts discussed in this chapter are for illustrative and\n"
"educational purposes, and they have not undergone formal auditing. This\n"
"signifies that, while we strive to provide accurate and informative\n"
"content, the implementation of these contracts in a live environment\n"
"should be approached with due diligence. We encourage users to\n"
"thoroughly test and validate these contracts before their deployment on\n"
"the mainnet."
msgstr ""

#: src/ch04-05-examples.md:15
msgid ""
"The goal of this chapter is not only to furnish a library of contract\n"
"examples but also to foster collaboration and knowledge sharing among\n"
"the Starknet community. We believe that the exchange of ideas and\n"
"constructive feedback is instrumental in advancing our collective\n"
"understanding and expertise."
msgstr ""

#: src/ch04-05-examples.md:21
msgid ""
"If you‚Äôve developed or come across an innovative contract that could\n"
"serve as a valuable learning resource for others, we invite you to\n"
"contribute. Here are a few guidelines for your contribution:"
msgstr ""

#: src/ch04-05-examples.md:25
msgid ""
"1.  **Open a PR:** To submit a contract example or suggest changes to\n"
"    existing ones, simply open a Pull Request. Ensure that your PR\n"
"    contains a thorough explanation of the contract, its use cases, and\n"
"    its functionality.\n"
"\n"
"2.  **Code Standards:** Please ensure that the submitted code is\n"
"    well-documented and adheres to the standard code conventions of\n"
"    Starknet. This will facilitate the review process and enhance the\n"
"    readability and comprehensibility of the contract.\n"
"\n"
"3.  **Detailed Explanation:** Accompany your code with a detailed\n"
"    explanation of the contract logic. Wherever possible, use diagrams,\n"
"    flowcharts, or pseudocode to illustrate complex mechanisms or\n"
"    workflows."
msgstr ""

#: src/ch04-05-examples.md:40
msgid ""
"As we expand this repertoire of contract examples, we hope to equip the\n"
"Starknet community with a robust toolset and inspire further exploration\n"
"and innovation in the realm of custom account contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:1
msgid "# MultiCaller Account"
msgstr ""

#: src/ch04-05-01-multicaller.md:3
msgid ""
"[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme)\n"
"is a powerful technique that allows multiple constant smart contract\n"
"function calls to be aggregated into a single call, resulting in a\n"
"consolidated output. With Starknet‚Äôs account abstraction feature,\n"
"multicalls can be seamlessly integrated into account contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:9
msgid "## Why Multicalls?"
msgstr ""

#: src/ch04-05-01-multicaller.md:11
msgid "Multicalls come handy in several scenarios. Here are some examples:"
msgstr ""

#: src/ch04-05-01-multicaller.md:13
msgid ""
"1.  **Token Swapping on Decentralized Exchanges**: In a typical token\n"
"    swap operation on a decentralized exchange (DEX), you first need to\n"
"    approve the spending of the tokens and then initiate the swap.\n"
"    Executing these operations separately could be cumbersome from a\n"
"    user experience perspective. With multicall, these calls can be\n"
"    combined into a single transaction, simplifying the user‚Äôs task.\n"
"\n"
"2.  **Fetching Blockchain Data**: When you want to query the prices of\n"
"    two different tokens from the blockchain, it‚Äôs beneficial to have\n"
"    them both come from the same block for consistency. Multicall\n"
"    returns the latest block number along with the aggregated results,\n"
"    providing this consistency."
msgstr ""

#: src/ch04-05-01-multicaller.md:26
msgid ""
"The benefits of multicall transactions can be realized more in the\n"
"context of account abstraction."
msgstr ""

#: src/ch04-05-01-multicaller.md:29
#, fuzzy
msgid "## Multicall Account Abstraction Creation."
msgstr "### Interacci√≥n de Contrato con Multicall"

#: src/ch04-05-01-multicaller.md:31
msgid "[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme)"
msgstr ""

#: src/ch04-05-01-multicaller.md:33 src/ch04-05-01-multicaller.md:324
msgid "This is because multicall is a feature of Account Abstraction that lets you bundle multiple user operations into a single transaction for a smoother UX."
msgstr ""

#: src/ch04-05-01-multicaller.md:35 src/ch04-05-01-multicaller.md:326
msgid "The Call data type is a struct that has all the data you need to execute a single user operation."
msgstr ""

#: src/ch04-05-01-multicaller.md:37
msgid ""
"There are different traits that a smart contract must implement to be considered an account contract. Let's create account abstraction from the scratch following the SNIP-6 and SRC-5 standards."
msgstr ""

#: src/ch04-05-01-multicaller.md:39
#, fuzzy
msgid "### Project Setup."
msgstr "### Configuraci√≥n de Smart Wallet"

#: src/ch04-05-01-multicaller.md:41
msgid ""
"In order to be able to compile an account contract to Sierra, a prerequisite to deploy it to testnet or mainnet, you‚Äôll need to make sure to have a version of Scarb that includes a Cairo compiler "
"that targets Sierra 1.3 as it‚Äôs the latest version supported by Starknet‚Äôs testnet. At this point in time Scarb 0.7 is used."
msgstr ""

#: src/ch04-05-01-multicaller.md:43
msgid ""
"```\n"
"~ $ scarb --version\n"
">>>\n"
"scarb 0.7.0 (58cc88efb 2023-08-23)\n"
"cairo: 2.2.0 (https://crates.io/crates/cairo-lang-compiler/2.2.0)\n"
"sierra: 1.3.0\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:51
msgid "Create a new project with Scarb using the new command."
msgstr ""

#: src/ch04-05-01-multicaller.md:53
msgid ""
"```dotnetcli\n"
"~ $ scarb new aa\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:57 src/ch04-05-02-multisig.md:60
msgid "The command creates a folder with the same name that includes a configuration file for Scarb."
msgstr ""

#: src/ch04-05-01-multicaller.md:59
msgid ""
"```dotnetcli\n"
"~ $ cd aa\n"
"aa $ tree .\n"
">>>\n"
".\n"
"‚îú‚îÄ‚îÄ Scarb.toml\n"
"‚îî‚îÄ‚îÄ src\n"
"    ‚îî‚îÄ‚îÄ lib.cairo\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:69
msgid "Scarb configures the project for vanilla Cairo instead of Starknet smart contracts by default."
msgstr ""

#: src/ch04-05-01-multicaller.md:71
msgid ""
"```dotnetcli\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:82
msgid "There is a need to make some changes to the configuration file to activate the Starknet plugin in the compiler so we can work with smart contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:84
msgid ""
"```dotnetcli\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \"2.2.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:97
msgid "Let's now replace the content of the sample Cairo code that comes with a new project with the scaffold of our account contract."
msgstr ""

#: src/ch04-05-01-multicaller.md:99
msgid ""
"```\n"
"#[starknet::contract]\n"
"mod Account {}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:104
msgid "Given that one of the most important features of our account contract is to validate signatures, there is a need to store the public key associated with the private key of the signer."
msgstr ""

#: src/ch04-05-01-multicaller.md:106
msgid ""
"```dotnetcli\n"
"#[starknet::contract]\n"
"mod Account {\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:117 src/ch04-05-02-multisig.md:131
msgid "To make sure everything is wired up correctly, let‚Äôs compile our project."
msgstr ""

#: src/ch04-05-01-multicaller.md:119
msgid ""
"```dotnetcli\n"
"aa $ scarb build\n"
">>>\n"
"Compiling aa v0.1.0 (/Users/david/apps/sandbox/aa/Scarb.toml)\n"
"Finished release target(s) in 2 seconds\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:126
msgid "Welldone, It works, time to move to the interesting part of our tutorial."
msgstr ""

#: src/ch04-05-01-multicaller.md:128 src/ch04-05-02-multisig.md:144 src/ch04-05-03-auto-payments.md:85
msgid "## SNIP-6"
msgstr ""

#: src/ch04-05-01-multicaller.md:130
msgid "Remember that for a smart contract to be considered an account contract, it must implement the trait defined by SNIP-6."
msgstr ""

#: src/ch04-05-01-multicaller.md:132
msgid ""
"```dotnetcli\n"
"trait ISRC6 {\n"
"  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:140
msgid ""
"There is a need to eventually annotate the implementation of this trait with the `external` attribute, the contract state will be the first argument provided to each method. We can define the type "
"of the contract state with the generic `T`."
msgstr ""

#: src/ch04-05-01-multicaller.md:142
msgid ""
"```dotnetcli\n"
"trait ISRC6<T> {\n"
"  fn __execute__(ref self: T, calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(self: @T, calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:150
msgid ""
"The **execute** function is the only one that receives a reference to the contract state because it‚Äôs the only one likely to either modify its internal state or to modify the state of another smart "
"contract and thus to require the payment of gas fees for its execution. The other two functions, **validate** and **is_valid_signature**, are read-only and shouldn‚Äôt require the payment of gas "
"fees. For this reason they are both receiving a snapshot of the contract state instead."
msgstr ""

#: src/ch04-05-01-multicaller.md:152
msgid ""
"The question now becomes, how should we use this trait in our account contract. Should we annotate the trait with the **interface** attribute and then create an implementation like the code shown "
"below?"
msgstr ""

#: src/ch04-05-01-multicaller.md:154
msgid ""
"```dotnetcli\n"
"#[starnet::interface]\n"
"trait ISRC6<T> {\n"
"  fn __execute__(ref self: T, calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(self: @T, calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  #[external(v0)]\n"
"  impl ISRC6Impl of super::ISRC6<ContractState> {...}\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:170
msgid "Or should we use it instead `without` the interface attribute?"
msgstr ""

#: src/ch04-05-01-multicaller.md:172
msgid ""
"```dotnetcli\n"
"trait ISRC6<T> {\n"
"  fn __execute__(ref self: T, calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(self: @T, calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  #[external(v0)]\n"
"  impl ISRC6Impl of super::ISRC6<ContractState> {...}\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:187
msgid "What happens without defining the trait explicitly?"
msgstr ""

#: src/ch04-05-01-multicaller.md:189
msgid ""
"```dotnetcli\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ISRC6Impl of ISRC6Trait {...}\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:199
msgid "From a technical view, both are all valid alternatives but they all fail to capture the right intention."
msgstr ""

#: src/ch04-05-01-multicaller.md:201
msgid ""
"Every function inside an implementation annotated with the external attribute will have its own selector that other people and smart contracts can use to interact with my account contract. But the "
"thing is, even though they can use the derived selectors to call those functions, but one will be recommended for users to use and for the Starknet protocol."
msgstr ""

#: src/ch04-05-01-multicaller.md:203
msgid ""
"The functions **execute** and **validate** are meant to be used only by the Starknet protocol even if the functions are publicly accessible via its selectors. The only function that is made public "
"for web3 apps to use for signature validation is **is_valid_signature**."
msgstr ""

#: src/ch04-05-01-multicaller.md:205
msgid ""
"Furthermore, a separate trait annotated with the interface attribute will be created and group all the functions in an account contract that users are expected to interact with. On the other hand, "
"the trait will be auto generated, for all those functions that users are not expected to use directly even though they are public."
msgstr ""

#: src/ch04-05-01-multicaller.md:207
msgid ""
"```dotnetcli\n"
"use starknet::account::Call;\n"
"\n"
"#[starnet::interface]\n"
"trait IAccount<T> {\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  use super::Call;\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 { ... }\n"
"  }\n"
"\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 { ... }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:238
msgid "# Protecting Protocol-Only Functions"
msgstr ""

#: src/ch04-05-01-multicaller.md:240
msgid ""
"Although there might be legitimate use cases for other smart contracts to directly interact with the functions **execute** and **validate** of an account contract, these will rather be restricted "
"to be callable only by the Starknet protocol in case there‚Äôs an attack vector that has not been foresee."
msgstr ""

#: src/ch04-05-01-multicaller.md:242
msgid "To create private functions, this simply create a new implementation that is not annotated with the external attribute so no public selectors are created."
msgstr ""

#: src/ch04-05-01-multicaller.md:244
msgid ""
"```dotnetcli\n"
"#[starknet::contract]\n"
"mod Account {\n"
" use starknet::get_caller_address;\n"
" use zeroable::Zeroable;\n"
" ...\n"
"\n"
" #[generate_trait]\n"
" impl PrivateImpl of PrivateTrait {\n"
"   fn only_protocol(self: @ContractState) {\n"
"     let sender = get_caller_address();\n"
"     assert(sender.is_zero(), 'Account: invalid caller');\n"
"   }\n"
" }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:261
msgid "# Validate Declare and Deploy"
msgstr ""

#: src/ch04-05-01-multicaller.md:263
msgid ""
"**validate_declare** is used to validate the signature of a declare transaction while **validate_deploy** is used for the same purpose but for the deploy_account transaction. The latter is often "
"referred to as ‚Äúcounterfactual deployment‚Äù."
msgstr ""

#: src/ch04-05-01-multicaller.md:265
msgid ""
"```dotnetcli\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    ...\n"
"\n"
"    fn validate_transaction(self: @ContractState) -> felt252 {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let tx_hash = tx_info.transaction_hash;\n"
"      let signature = tx_info.signature;\n"
"\n"
"      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
"      assert(is_valid, 'Account: Incorrect tx signature');\n"
"      'VALID'\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:307
#, fuzzy
msgid "# Execute Transactions"
msgstr "Transacciones"

#: src/ch04-05-01-multicaller.md:309
msgid "Looking at the signature of the **execute** function it is noticed that an array of calls are being passed instead of a single element."
msgstr ""

#: src/ch04-05-01-multicaller.md:311
msgid ""
"```dotnetcli\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
"    ...\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:328
msgid ""
"```dotnetcli\n"
"#[derive(Drop, Serde)]\n"
"struct Call {\n"
"  to: ContractAddress,\n"
"  selector: felt252,\n"
"  calldata: Array<felt252>\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:337
msgid "Instead of trying to face the multicall head on, let‚Äôs first create a private function that deals with a single call that we can then reuse by iterating over the array of calls."
msgstr ""

#: src/ch04-05-01-multicaller.md:339
msgid ""
"```\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  use starknet::call_contract_syscall;\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    ...\n"
"    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
"      let Call{to, selector, calldata} = call;\n"
"      call_contract_syscall(to, selector, calldata.span()).unwrap_syscall()\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:356
msgid "Destructure the `Call` struct and then we use the low level syscall `call_contract_syscall` to invoke a function on another smart contract without the help of a dispatcher."
msgstr ""

#: src/ch04-05-01-multicaller.md:358
msgid "However, with the single `call` function, multi call function can be built by iterating over a `Call` array and returning the responses as an array as well."
msgstr ""

#: src/ch04-05-01-multicaller.md:360
msgid ""
"```dotnetcli\n"
"...\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    ...\n"
"    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      let mut res = ArrayTrait::new();\n"
"      loop {\n"
"        match calls.pop_front() {\n"
"          Option::Some(call) => {\n"
"            let _res = self.execute_single_call(call);\n"
"            res.append(_res);\n"
"          },\n"
"          Option::None(_) => {\n"
"            break ();\n"
"          },\n"
"        };\n"
"      };\n"
"      res\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:387
msgid "Finally, let's go back to the **execute** function and make use of the functions that was just created."
msgstr ""

#: src/ch04-05-01-multicaller.md:389
msgid ""
"```dotnetcli\n"
"...\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol();\n"
"      self.execute_multiple_calls(calls)\n"
"    }\n"
"    ...\n"
"  }\n"
"  ...\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:407
#, fuzzy
msgid "## Supported Transaction Versions"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-05-01-multicaller.md:409
msgid ""
"As Starknet evolved, changes have been required to the structure of the transactions to accommodate more advanced functionality. To avoid creating breaking changes whenever a transaction structure "
"needs to be updated, a ‚Äúversion‚Äù field was added to all transactions so older and newer transactions can co-exist."
msgstr ""

#: src/ch04-05-01-multicaller.md:411
msgid ""
"Maintaining different transaction versions is complex and because this is just a tutorial, I‚Äôll restrict my account contract to only support the newest version of each type of transaction and those "
"are:"
msgstr ""

#: src/ch04-05-01-multicaller.md:413
msgid ""
"- Version 1 for invoke transactions\n"
"- Version 1 for deploy_account transactions\n"
"- Version 2 for declare transactions"
msgstr ""

#: src/ch04-05-01-multicaller.md:417
msgid "The supported transaction versions will be discussed below in a module for logical grouping."
msgstr ""

#: src/ch04-05-01-multicaller.md:419
msgid ""
"```dotnetcli\n"
"...\n"
"\n"
"mod SUPPORTED_TX_VERSION {\n"
"  const DEPLOY_ACCOUNT: felt252 = 1;\n"
"  const DECLARE: felt252 = 2;\n"
"  const INVOKE: felt252 = 1;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account { ... }\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:432
msgid ""
"Now create a private function that will check if the executed transaction is of the latest version and hence supported by your account contract. If not, you should abort the transaction execution "
"with an **assert**."
msgstr ""

#: src/ch04-05-01-multicaller.md:434
msgid ""
"```\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  use super::SUPPORTED_TX_VERSION;\n"
"\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  #[generate_trait]\n"
"  impl ProtocolImpl of ProtocolTrait {\n"
"    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.execute_multiple_calls(calls)\n"
"    }\n"
"\n"
"    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
"      self.validate_transaction()\n"
"    }\n"
"\n"
"    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
"      self.only_protocol();\n"
"      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
"      self.validate_transaction()\n"
"    }\n"
"  }\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    ...\n"
"\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let version = tx_info.version;\n"
"      assert(\n"
"        version == supported_tx_version,\n"
"        'Account: Unsupported tx version'\n"
"      );\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:488
#, fuzzy
msgid "## Simulated Transactions"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-05-01-multicaller.md:490
msgid ""
"It‚Äôs possible to request the Sequencer to estimate the amount of gas required to execute a transaction without actually executing it. Starkli for example provides the flag estimate-only that you "
"can append to any transaction to instruct the Sequencer to only simulate the transaction and return the estimated cost."
msgstr ""

#: src/ch04-05-01-multicaller.md:492
msgid ""
"To differentiate a regular transaction from a transaction simulation while protecting against replay attacks, the version of a transaction simulation is the same value as the normal transaction but "
"offset by the value 2^128. For example, the version of a simulated declare transaction is 2^128 + 2 because the latest version of a regular declare transaction is 2."
msgstr ""

#: src/ch04-05-01-multicaller.md:494
msgid "With that in mind, we can modify the function only_supported_tx_version to account for simulated transactions."
msgstr ""

#: src/ch04-05-01-multicaller.md:496
msgid ""
"```dotnetcli\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
"\n"
"  ...\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    ...\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let version = tx_info.version;\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version'\n"
"      );\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:523
#, fuzzy
msgid "## Introspection"
msgstr "Introducci√≥n"

#: src/ch04-05-01-multicaller.md:525
msgid "Previously mentioned the standard SRC-5 is for introspection."
msgstr ""

#: src/ch04-05-01-multicaller.md:527
msgid ""
"```dotnetcli\n"
"trait ISRC5 {\n"
"  fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:534
msgid ""
"For an account contract to self identify as such, it must return true when passed the interface_id 1270010605630597976495846281167968799381097569185364931397797212080166453709. The reason why that "
"particular number is used is explained in the previous article so go check it out for more details."
msgstr ""

#: src/ch04-05-01-multicaller.md:536
msgid "Because this is a public function that I do expect people and other smart contracts to call on my account contract, will add this function to its public interface."
msgstr ""

#: src/ch04-05-01-multicaller.md:538
msgid ""
"```dotnetcli\n"
"...\n"
"\n"
"#[starnet::interface]\n"
"trait IAccount<T> {\n"
"  ...\n"
"  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
"\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of super::IAccount<ContractState> {\n"
"    ...\n"
"    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
"      interface_id == SRC6_TRAIT_ID\n"
"    }\n"
"  }\n"
"  ...\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:565
msgid "## Exposing the Public Key"
msgstr ""

#: src/ch04-05-01-multicaller.md:567
msgid ""
"Although not required, it is a good idea to expose the public key associated with the account contract‚Äôs signer. One use case is to easily and safely debug the correct deployment of the account "
"contract by reading the stored public key and comparing it (offline) to the public key of my signer."
msgstr ""

#: src/ch04-05-01-multicaller.md:569
msgid ""
"```dotnetcli\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"\n"
"  #[external(v0)]\n"
"  impl AccountImpl of IAccount<ContractState> {\n"
"    ...\n"
"    fn public_key(self: @ContractState) -> felt252 {\n"
"      self.public_key.read()\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:587
msgid "Finally, we have a fully functional account contract."
msgstr ""

#: src/ch04-05-01-multicaller.md:591
msgid ""
"The account contract created now might look complex but it‚Äôs actually one of the simplests that can be created. The account contracts created by Braavos and Argent X are much more complex as they "
"support features like social recovery, multisig, hardware signer, email/password signer, etc."
msgstr ""

#: src/ch04-05-01-multicaller.md:593
msgid ""
"Both Braavos and Argent have open sourced their Cairo 0 version of their account contracts but Argent is the first one to also open source their Cairo version. OpenZeppelin (OZ) is also developing "
"their own implementation of a Cairo account contract but it‚Äôs still a work in progress. This inspiration was deduced from OZ‚Äôs implementation when creating this tutorial."
msgstr ""

#: src/ch04-05-01-multicaller.md:595
msgid ""
"SNIP-6 is referenced multiple times as a standard to follow for an account contract but so far it‚Äôs only a proposal under discussion that could change. This will not only affect the interface of "
"your account contract but also the ID used for introspection."
msgstr ""

#: src/ch04-05-01-multicaller.md:599
msgid ""
"While multicall provides significant benefits in terms of UX and data\n"
"consistency, it‚Äôs important to note that it may not significantly reduce\n"
"gas fees compared to individual calls. However, the primary advantage of\n"
"using multicall is that it ensures results are derived from the same\n"
"block, providing a much-improved user experience."
msgstr ""

#: src/ch04-05-01-multicaller.md:607
#, fuzzy
msgid ""
"- If you‚Äôve learned something, or not, please take a moment to provide\n"
"  feedback through [this 3-question\n"
"  survey](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=).\n"
"\n"
"- If you discover any errors or have additional suggestions, don‚Äôt\n"
"  hesitate to open an [issue on our GitHub\n"
"  repository](https://github.com/starknet-edu/starknetbook/issues).\n"
"\n"
"  ## Reference\n"
"\n"
"- [1] OpenZeppelin, 2023: https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.7.0-rc.0/src/account/account.cairo\n"
"- [2] David Barreto, 2023: https://medium.com/starknet-edu/account-abstraction-on-starknet-part-ii-24d52874e0bd"
msgstr ""
"- Si ha aprendido algo, o no, t√≥mese un momento para brindar comentarios a trav√©s de [esta encuesta de 3 preguntas](https://a.sprig.com/"
"WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=).\n"
"\n"
"- Si descubre alg√∫n error o tiene sugerencias adicionales, no dude en abrir un [problema en nuestro repositorio de GitHub](https://github.com/starknet-edu/starknetbook/issues)."

#: src/ch04-05-02-multisig.md:1
msgid "# Multisignature (multisig) Account."
msgstr ""

#: src/ch04-05-02-multisig.md:3
msgid ""
"Multisig, refers to a system where multiple signatures are required to authorize a transaction. This is commonly used in the context of cryptocurrency wallets, where funds can only be spent if a "
"certain number of private keys agree to the transaction."
msgstr ""

#: src/ch04-05-02-multisig.md:5
msgid ""
"Multisignature (multisig) technology is an integral part of the modern\n"
"blockchain landscape. It enhances security by requiring multiple\n"
"signatures to confirm a transaction, hence reducing the risk of\n"
"fraudulent transactions and increasing control over asset management."
msgstr ""

#: src/ch04-05-02-multisig.md:10
msgid ""
"In Starknet, the concept of multisig accounts is abstracted at the\n"
"protocol level, allowing developers to implement custom account\n"
"contracts that embody this concept. In this chapter, we‚Äôll delve into\n"
"the workings of a multisig account and see how it‚Äôs created in Starknet\n"
"using an account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:16
msgid "## Why Multisig."
msgstr ""

#: src/ch04-05-02-multisig.md:18
msgid "There are several reasons why someone might choose to use a multisig wallet:"
msgstr ""

#: src/ch04-05-02-multisig.md:20
msgid "### Enhanced security:"
msgstr ""

#: src/ch04-05-02-multisig.md:22
msgid ""
"Multisig contract account are much more secure than traditional single-signature contract accounts. With a single-signature contract account, if your private key is lost or stolen, your funds are "
"gone. With a multisig contract account, even if one private key is compromised, the funds are still safe. This is because at least two (or more) private keys are required to authorize a transaction."
msgstr ""

#: src/ch04-05-02-multisig.md:24
msgid "### Disaster recovery:"
msgstr ""

#: src/ch04-05-02-multisig.md:26
msgid ""
"Multisig contract account can be used to protect against the loss of a private key. If one private key is lost, the other keys can still be used to recover the funds. This can be helpful in the "
"event of a natural disaster, hardware failure, or other unforeseen event."
msgstr ""

#: src/ch04-05-02-multisig.md:28
msgid "### Transparency and accountability:"
msgstr ""

#: src/ch04-05-02-multisig.md:30
msgid ""
"Multisig contract account can be used to increase transparency and accountability in organizations. For example, a company might use a multisig wallet to store its funds, and require the signatures "
"of two or more executives to authorize any spending. This can help to prevent fraud and ensure that everyone is aware of how the company's money is being spent."
msgstr ""

#: src/ch04-05-02-multisig.md:32
msgid "The benefits of Multisig contract account can be realized more in the context of account abstraction."
msgstr ""

#: src/ch04-05-02-multisig.md:34
#, fuzzy
msgid "### Multisig Account Abstraction Creation."
msgstr "### Interacci√≥n de Contrato con Multicall"

#: src/ch04-05-02-multisig.md:36
msgid ""
"Account abstraction enables built-in multisig functionality within accounts.\n"
"Each account can be programmed to demand multiple signatures before transaction execution.\n"
"This eliminates the need for separate multisig smart contracts, simplifying their use."
msgstr ""

#: src/ch04-05-02-multisig.md:40
msgid ""
"A multisig account must have different traits that a smart contract must implement to be considered an account contract. In this book we will create an account contract from scratch following the "
"SNIP-6 and SRC-5 standards."
msgstr ""

#: src/ch04-05-02-multisig.md:42
#, fuzzy
msgid "## Project Setup"
msgstr "### Configuraci√≥n de Smart Wallet"

#: src/ch04-05-02-multisig.md:44
msgid ""
"In order to be able to compile an account contract to Sierra, a prerequisite to deploy it to testnet or mainnet, you‚Äôll need to make sure to have a version of [Scarb](https://docs.swmansion.com/"
"scarb/download.html) that includes a Cairo compiler that targets Sierra 1.3 as it‚Äôs the latest version supported by Starknet‚Äôs testnet. At this point in time is Scarb 2.4.4 is used."
msgstr ""

#: src/ch04-05-02-multisig.md:46
msgid ""
"```cairo\n"
"mac@Macs-MacBook-Pro-2 Desktop % scarb --version\n"
"scarb 2.4.4 (0c8def3aa 2023-10-31)\n"
"cairo: 2.4.4 (https://crates.io/crates/cairo-lang-compiler/2.4.4)\n"
"sierra: 1.3.0\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:54
msgid "With Scarb we can create a new project using the new command."
msgstr ""

#: src/ch04-05-02-multisig.md:56
#, fuzzy
msgid ""
"```cairo\n"
"~ $ scarb new multisign\n"
"```"
msgstr ""
"```bash\n"
"scarb build\n"
"```"

#: src/ch04-05-02-multisig.md:62
msgid ""
"```cairo\n"
"~ $ cd multisign\n"
"aa $ tree .\n"
">>>\n"
".\n"
"‚îú‚îÄ‚îÄ Scarb.toml\n"
"‚îî‚îÄ‚îÄ src\n"
"    ‚îî‚îÄ‚îÄ lib.cairo\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:72
msgid "By default, Scarb configures our project for vanilla Cairo instead of Starknet smart contracts."
msgstr ""

#: src/ch04-05-02-multisig.md:74
msgid ""
"```cairo\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \"multisign\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:86
msgid "We need to make some changes to the configuration file to activate the Starknet plugin in the compiler so we can work with smart contracts."
msgstr ""

#: src/ch04-05-02-multisig.md:88
#, fuzzy
msgid ""
"```cairo\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \" multisign \"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"\n"
"starknet = \">=2.4.4\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"\n"
"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch04-05-02-multisig.md:108
msgid "We can now replace the content of the sample Cairo code that comes with a new project with the scaffold of our account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:110
msgid ""
"```cairo\n"
"\n"
"#[starknet::contract]\n"
"mod Multisign {}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:117
msgid "Given that one of the most important features of our account contract is to validate signatures, we need to store the public key associated with the private key of the signer."
msgstr ""

#: src/ch04-05-02-multisig.md:119
msgid ""
"```cairo\n"
"#[starknet::contract]\n"
"mod Multisign {\n"
"\n"
"  #[storage]\n"
"  struct Storage {\n"
"    public_key: felt252\n"
"  }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:133
msgid ""
"```cairo\n"
"mac@Macs-MacBook-Pro-2 multisign % scarb build\n"
">>>\n"
"   Compiling multisign v0.1.0 (/Users/mac/multisig/Scarb.toml)\n"
"    Finished release target(s) in 2 seconds\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:142
msgid "It works, time to move to the interesting part of our tutorial."
msgstr ""

#: src/ch04-05-02-multisig.md:146
msgid "Recall that for a smart contract to be considered an account contract, it must implement the trait defined by SNIP-6."
msgstr ""

#: src/ch04-05-02-multisig.md:148
msgid ""
"```cairo\n"
"trait ISRC6 {\n"
"  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:157
msgid ""
"Because we will eventually annotate the implementation of this trait with the external attribute, the contract state will be the first argument provided to each method. We can define the type of "
"the contract state with the generic T."
msgstr ""

#: src/ch04-05-02-multisig.md:159
msgid ""
"```cairo\n"
"\n"
"trait ISRC6<T> {\n"
"  fn __execute__(ref self: T, calls: Array<Call>) -> Array<Span<felt252>>;\n"
"  fn __validate__(self: @T, calls: Array<Call>) -> felt252;\n"
"  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:169
msgid ""
"The **execute** function is the only one that receives a reference to the contract state because it‚Äôs the only one likely to either modify its internal state or to modify the state of another smart "
"contract and thus to require the payment of gas fees for its execution. The other two functions, **validate** and is_valid_signature, are read-only and shouldn‚Äôt require the payment of gas fees. "
"For this reason they are both receiving a snapshot of the contract state instead."
msgstr ""

#: src/ch04-05-02-multisig.md:171
msgid "Let's now define the trait for our multisig account explicitly."
msgstr ""

#: src/ch04-05-02-multisig.md:173
msgid ""
"```cairo\n"
"\n"
"\n"
"#[starknet::interface]\n"
"trait TestMultisign<T> {\n"
"\tfn __execute__(ref self: T, calls: Array<account::Call>) -> Array<Span<felt252>>;\n"
"\tfn __validate__(self: @T, calls: Array<account::Call>) -> felt252;\n"
"\tfn is_valid_signature( self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
"\tfn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:186
msgid "Each function inside an implementation annotated with the external attribute will have its own selector that other people and smart contracts can use to interact with my account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:188
msgid ""
"The functions **execute** and **validate** are meant to be used only by the Starknet protocol even if the functions are publicly accessible via its selectors. The only function that I want to make "
"public for web3 apps to use for signature validation is is_valid_signature."
msgstr ""

#: src/ch04-05-02-multisig.md:190
msgid ""
"In addition, we will create a separate trait annotated with the interface attribute that will group all the functions in the account contract that is expected to interact with. On the other hand, "
"we will auto generate the trait for all those functions that users will not see to use directly even though they are public."
msgstr ""

#: src/ch04-05-02-multisig.md:192
msgid ""
"```cairo\n"
"use starknet::account;\n"
"\n"
"// @title SRC-6 Standard Account\n"
"#[starknet::interface]\n"
"trait ISRC6<T> {\n"
"\t// @notice Execute a transaction through the account\n"
"\t// @param calls The list of calls to execute\n"
"\t// @return The list of each call's serialized return value\n"
"\tfn __execute__(\n"
"\t\tref self: T,\n"
"\t\tcalls: Array<account::Call>\n"
"\t) -> Array<Span<felt252>>;\n"
"\n"
"\t// @notice Assert whether the transaction is valid to be executed\n"
"\t// @param calls The list of calls to execute\n"
"\t// @return The string 'VALID' represented as a felt when is valid\n"
"\tfn __validate__(self: @T, calls: Array<account::Call>) -> felt252;\n"
"\n"
"\t// @notice Assert whether a given signature for a given hash is valid\n"
"\t// @dev signatures must be deserialized\n"
"\t// @param hash The hash of the data\n"
"\t// @param signature The signature to be validated\n"
"\t// @return The string 'VALID' represented as a felt when is valid\n"
"\tfn is_valid_signature(\n"
"\t\tself: @T,\n"
"\t\thash: felt252,\n"
"\t\tsignature: Array<felt252>\n"
"\t) -> felt252;\n"
"}\n"
"\n"
"// @title SRC-5 Iterface detection\n"
"#[starknet::interface]\n"
"trait ISRC5<T> {\n"
"\t// @notice Query if a contract implements an interface\n"
"\t// @param interface_id The interface identifier, as specified in SRC-5\n"
"\t// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"\tfn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// @title Multisign Account\n"
"#[starknet::contract]\n"
"mod Multisign {\n"
"\tuse super::ISRC6;\n"
"\tuse super::ISRC5;\n"
"\tuse starknet::account;\n"
"\n"
"\tconst SRC6_INTERFACE_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\tconst MAX_SIGNERS_COUNT: usize = 32;\n"
"\n"
"\t#[storage]\n"
"\tstruct Storage {\n"
"\t\tsigners: LegacyMap<felt252, felt252>,\n"
"\t\tthreshold: usize,\n"
"\t\toutside_nonce: LegacyMap<felt252, felt252>\n"
"\t}\n"
"\n"
"\t// @notice Contructor of the account\n"
"\t// @dev Asserts threshold in relation with signers-len\n"
"\t// @param threshold Initial threshold\n"
"\t// @param signers Array of inital signers' public-keys\n"
"\t#[constructor]\n"
"\tfn constructor(\n"
"\t\tref self: ContractState,\n"
"\t\tthreshold: usize,\n"
"\t\tsigners: Array<felt252>) {\n"
"\t\tassert_threshold(threshold, signers.len());\n"
"\n"
"\t\tself.add_signers(signers.span(), 0);\n"
"\t\tself.threshold.write(threshold);\n"
"\t}\n"
"\n"
"\t#[external(v0)]\n"
"\timpl SRC6 of ISRC6<ContractState> {\n"
"\t\tfn __execute__(\n"
"\t\t\tref self: ContractState,\n"
"\t\t\tcalls: Array<account::Call>\n"
"\t\t) -> Array<Span<felt252>> {\n"
"\t\t\tassert_only_protocol();\n"
"\t\t\texecute_multi_call(calls.span())\n"
"\t\t}\n"
"\n"
"\t\tfn __validate__(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tcalls: Array<account::Call>\n"
"\t\t) -> felt252 {\n"
"\t\t\tassert_only_protocol();\n"
"\t\t\tassert(calls.len() > 0, 'validate/no-calls');\n"
"\t\t\tself.assert_valid_calls(calls.span());\n"
"\t\t\tstarknet::VALIDATED\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signature(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsignature: Array<felt252>\n"
"\t\t) -> felt252 {\n"
"\t\t\tif self.is_valid_signature_span(hash, signature.span()) {\n"
"\t\t\t\tstarknet::VALIDATED\n"
"\t\t\t} else {\n"
"\t\t\t\t0\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t#[external(v0)]\n"
"\timpl SRC5 of ISRC5<ContractState> {\n"
"\t\tfn supports_interface(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tinterface_id: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tinterface_id == SRC6_INTERFACE_ID\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t#[generate_trait]\n"
"\timpl Private of PrivateTrait {\n"
"\t\tfn add_signers(\n"
"\t\t\tref self: ContractState,\n"
"\t\t\tmut signers: Span<felt252>,\n"
"\t\t\tlast: felt252\n"
"\t\t) {\n"
"\t\t\tmatch signers.pop_front() {\n"
"\t\t\t\tOption::Some(signer_ref) => {\n"
"\t\t\t\t\tlet signer = *signer_ref;\n"
"\t\t\t\t\tassert(signer != 0, 'signer/zero-signer');\n"
"\t\t\t\t\tassert(!self.is_signer_using_last(signer, last),\n"
"\t\t\t\t\t\t'signer/is-already-signer');\n"
"\t\t\t\t\tself.signers.write(last, signer);\n"
"\t\t\t\t\tself.add_signers(signers, signer);\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => ()\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfn is_signer_using_last(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tlast: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tif signer == 0 {\n"
"\t\t\t\treturn false;\n"
"\t\t\t}\n"
"\n"
"\t\t\tlet next = self.signers.read(signer);\n"
"\t\t\tif next != 0 {\n"
"\t\t\t\treturn true;\n"
"\t\t\t}\n"
"\t\t\tlast == signer\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signature_span(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsignature: Span<felt252>\n"
"\t\t) -> bool {\n"
"\t\t\tlet threshold = self.threshold.read();\n"
"\t\t\tassert(threshold != 0, 'Uninitialized');\n"
"\t\t\tlet mut signatures = deserialize_signatures(signature)\n"
"\t\t\t\t.expect('signature/invalid-len');\n"
"\t\t\tassert(threshold == signatures.len(), 'signature/invalid-len');\n"
"\t\t\tlet mut last: u256 = 0;\n"
"\t\t\tloop {\n"
"\t\t\t\tmatch signatures.pop_front() {\n"
"\t\t\t\t\tOption::Some(signature_ref) => {\n"
"\t\t\t\t\t\tlet signature = *signature_ref;\n"
"\t\t\t\t\t\tlet signer_uint = signature.signer.into();\n"
"\t\t\t\t\t\tassert(signer_uint > last, 'signature/not-sorted');\n"
"\t\t\t\t\t\tif !self.is_valid_signer_signature(\n"
"\t\t\t\t\t\t\t\thash,\n"
"\t\t\t\t\t\t\t\tsignature.signer,\n"
"\t\t\t\t\t\t\t\tsignature.signature_r,\n"
"\t\t\t\t\t\t\t\tsignature.signature_s,\n"
"\t\t\t\t\t\t\t) {\n"
"\t\t\t\t\t\t\tbreak false;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tlast = signer_uint;\n"
"\t\t\t\t\t},\n"
"\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\tbreak true;\n"
"\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signer_signature(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tsignature_r: felt252,\n"
"\t\t\tsignature_s: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tassert(self.is_signer(signer), 'signer/not-a-signer');\n"
"\t\t\tecdsa::check_ecdsa_signature(hash, signer, signature_r, signature_s)\n"
"\t\t}\n"
"\n"
"\t\tfn is_signer(self: @ContractState, signer: felt252) -> bool {\n"
"\t\t\tif signer == 0 {\n"
"\t\t\t\treturn false;\n"
"\t\t\t}\n"
"\t\t\tlet next = self.signers.read(signer);\n"
"\t\t\tif next != 0 {\n"
"\t\t\t\treturn true;\n"
"\t\t\t}\n"
"\t\t\tself.get_last() == signer\n"
"\t\t}\n"
"\n"
"\t\tfn get_last(self: @ContractState) -> felt252 {\n"
"\t\t\tlet mut curr = self.signers.read(0);\n"
"\t\t\tloop {\n"
"\t\t\t\tlet next = self.signers.read(curr);\n"
"\t\t\t\tif next == 0 {\n"
"\t\t\t\t\tbreak curr;\n"
"\t\t\t\t}\n"
"\t\t\t\tcurr = next;\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfn assert_valid_calls(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tcalls: Span<account::Call>\n"
"\t\t) {\n"
"\t\t\tassert_no_self_call(calls);\n"
"\n"
"\t\t\tlet tx_info = starknet::get_tx_info().unbox();\n"
"\t\t\tassert(\n"
"\t\t\t\tself.is_valid_signature_span(\n"
"\t\t\t\t\ttx_info.transaction_hash,\n"
"\t\t\t\t\ttx_info.signature\n"
"\t\t\t\t),\n"
"\t\t\t\t'call/invalid-signature'\n"
"\t\t\t)\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn assert_threshold(threshold: usize, signers_len: usize) {\n"
"\t\tassert(threshold != 0, 'threshold/is-zero');\n"
"\t\tassert(signers_len != 0, 'signers_len/is-zero');\n"
"\t\tassert(signers_len <= MAX_SIGNERS_COUNT,\n"
"\t\t\t\t'signers_len/too-high');\n"
"\t\tassert(threshold <= signers_len, 'threshold/too-high');\n"
"\t}\n"
"\n"
"\t#[derive(Copy, Drop, Serde)]\n"
"\tstruct SignerSignature {\n"
"\t\tsigner: felt252,\n"
"\t\tsignature_r: felt252,\n"
"\t\tsignature_s: felt252\n"
"\t}\n"
"\n"
"\tfn deserialize_signatures(\n"
"\t\tmut serialized: Span<felt252>\n"
"\t) -> Option<Span<SignerSignature>> {\n"
"\t\tlet mut signatures = ArrayTrait::new();\n"
"\t\tloop {\n"
"\t\t\tif serialized.len() == 0 {\n"
"\t\t\t\tbreak Option::Some(signatures.span());\n"
"\t\t\t}\n"
"\t\t\tmatch Serde::deserialize(ref serialized) {\n"
"\t\t\t\tOption::Some(s) => { signatures.append(s) },\n"
"\t\t\t\tOption::None => { break Option::None; },\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn assert_only_protocol() {\n"
"\t\tassert(starknet::get_caller_address().is_zero(), 'caller/non-zero');\n"
"\t}\n"
"\n"
"\tfn assert_no_self_call(\n"
"\t\tmut calls: Span<account::Call>\n"
"\t) {\n"
"\t\tlet self = starknet::get_contract_address();\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tassert(*call.to != self, 'call/call-to-self');\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak ;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn execute_multi_call(mut calls: Span<account::Call>) -> Array<Span<felt252>> {\n"
"\t\tassert(calls.len() != 0, 'execute/no-calls');\n"
"\t\tlet mut result: Array<Span<felt252>> = ArrayTrait::new();\n"
"\t\tlet mut idx = 0;\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tmatch starknet::call_contract_syscall(\n"
"\t\t\t\t\t\t*call.to,\n"
"\t\t\t\t\t\t*call.selector,\n"
"\t\t\t\t\t\tcall.calldata.span()\n"
"\t\t\t\t\t) {\n"
"\t\t\t\t\t\tResult::Ok(retdata) => {\n"
"\t\t\t\t\t\t\tresult.append(retdata);\n"
"\t\t\t\t\t\t\tidx += 1;\n"
"\t\t\t\t\t\t},\n"
"\t\t\t\t\t\tResult::Err(err) => {\n"
"\t\t\t\t\t\t\tlet mut data = ArrayTrait::new();\n"
"\t\t\t\t\t\t\tdata.append('call/multicall-faild');\n"
"\t\t\t\t\t\t\tdata.append(idx);\n"
"\t\t\t\t\t\t\tlet mut err = err;\n"
"\t\t\t\t\t\t\tloop {\n"
"\t\t\t\t\t\t\t\tmatch err.pop_front() {\n"
"\t\t\t\t\t\t\t\t\tOption::Some(v) => {\n"
"\t\t\t\t\t\t\t\t\t\tdata.append(v);\n"
"\t\t\t\t\t\t\t\t\t},\n"
"\t\t\t\t\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t};\n"
"\t\t\t\t\t\t\tpanic(data);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t}\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t};\n"
"\t\tresult\n"
"\t}\n"
"}\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:524
msgid "## Exploring Multisig Functions"
msgstr ""

#: src/ch04-05-02-multisig.md:526
msgid ""
"Let‚Äôs take a closer look at the various functions associated with\n"
"multisig functionality in the provided contract."
msgstr ""

#: src/ch04-05-02-multisig.md:529
#, fuzzy
msgid "### `add_signers` Function"
msgstr "### Leer Funciones"

#: src/ch04-05-02-multisig.md:531
msgid ""
"This is an internal function designed to add the public keys of the\n"
"account owners to a permanent storage. Ideally, a multisig account\n"
"structure should permit adding and deleting owners as per the agreement\n"
"of the account owners. However, each change should be a transaction\n"
"requiring the threshold number of signatures."
msgstr ""

#: src/ch04-05-02-multisig.md:537
msgid ""
"```cairo\n"
"\n"
"\n"
"\t#[generate_trait]\n"
"\timpl Private of PrivateTrait {\n"
"\t\tfn add_signers(\n"
"\t\t\tref self: ContractState,\n"
"\t\t\tmut signers: Span<felt252>,\n"
"\t\t\tlast: felt252\n"
"\t\t) {\n"
"\t\t\tmatch signers.pop_front() {\n"
"\t\t\t\tOption::Some(signer_ref) => {\n"
"\t\t\t\t\tlet signer = *signer_ref;\n"
"\t\t\t\t\tassert(signer != 0, 'signer/zero-signer');\n"
"\t\t\t\t\tassert(!self.is_signer_using_last(signer, last),\n"
"\t\t\t\t\t\t'signer/is-already-signer');\n"
"\t\t\t\t\tself.signers.write(last, signer);\n"
"\t\t\t\t\tself.add_signers(signers, signer);\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => ()\n"
"\t\t\t}\n"
"\t\t}\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:561
#, fuzzy
msgid "### `is_signer_using_last` Function"
msgstr "### Leer Funciones"

#: src/ch04-05-02-multisig.md:563
msgid ""
"This function allows the owners of the account to submit\n"
"transactions. Upon submission, the function checks the validity of the\n"
"signer, ensures the caller is one of the account owners, and adds\n"
"the transaction to the transactions map. It also increments the current\n"
"transaction index."
msgstr ""

#: src/ch04-05-02-multisig.md:569
msgid ""
"```cairo\n"
"\n"
"fn is_signer_using_last(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tlast: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tif signer == 0 {\n"
"\t\t\t\treturn false;\n"
"\t\t\t}\n"
"\n"
"\t\t\tlet next = self.signers.read(signer);\n"
"\t\t\tif next != 0 {\n"
"\t\t\t\treturn true;\n"
"\t\t\t}\n"
"\t\t\tlast == signer\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signature_span(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsignature: Span<felt252>\n"
"\t\t) -> bool {\n"
"\t\t\tlet threshold = self.threshold.read();\n"
"\t\t\tassert(threshold != 0, 'Uninitialized');\n"
"\t\t\tlet mut signatures = deserialize_signatures(signature)\n"
"\t\t\t\t.expect('signature/invalid-len');\n"
"\t\t\tassert(threshold == signatures.len(), 'signature/invalid-len');\n"
"\t\t\tlet mut last: u256 = 0;\n"
"\t\t\tloop {\n"
"\t\t\t\tmatch signatures.pop_front() {\n"
"\t\t\t\t\tOption::Some(signature_ref) => {\n"
"\t\t\t\t\t\tlet signature = *signature_ref;\n"
"\t\t\t\t\t\tlet signer_uint = signature.signer.into();\n"
"\t\t\t\t\t\tassert(signer_uint > last, 'signature/not-sorted');\n"
"\t\t\t\t\t\tif !self.is_valid_signer_signature(\n"
"\t\t\t\t\t\t\t\thash,\n"
"\t\t\t\t\t\t\t\tsignature.signer,\n"
"\t\t\t\t\t\t\t\tsignature.signature_r,\n"
"\t\t\t\t\t\t\t\tsignature.signature_s,\n"
"\t\t\t\t\t\t\t) {\n"
"\t\t\t\t\t\t\tbreak false;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tlast = signer_uint;\n"
"\t\t\t\t\t},\n"
"\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\tbreak true;\n"
"\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:624
msgid "### `is_valid_signer_signature` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:626
msgid ""
"Similarly, the **_`is_valid_signer_signature`_** function provides a way to record\n"
"confirmations for each signer. An account owner, who did not submit\n"
"the transaction, can confirm it, increasing its confirmation count."
msgstr ""

#: src/ch04-05-02-multisig.md:630
msgid ""
"```cairo\n"
"\n"
"fn is_valid_signer_signature(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tsignature_r: felt252,\n"
"\t\t\tsignature_s: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tassert(self.is_signer(signer), 'signer/not-a-signer');\n"
"\t\t\tecdsa::check_ecdsa_signature(hash, signer, signature_r, signature_s)\n"
"\t\t}\n"
"\n"
"\t\tfn is_signer(self: @ContractState, signer: felt252) -> bool {\n"
"\t\t\tif signer == 0 {\n"
"\t\t\t\treturn false;\n"
"\t\t\t}\n"
"\t\t\tlet next = self.signers.read(signer);\n"
"\t\t\tif next != 0 {\n"
"\t\t\t\treturn true;\n"
"\t\t\t}\n"
"\t\t\tself.get_last() == signer\n"
"\t\t}\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:657
msgid "### _`execute_multi_call`_ Function"
msgstr ""

#: src/ch04-05-02-multisig.md:659
msgid ""
"The _execute_multi_call_ function serves as the final step in the transaction\n"
"process. It checks the validity of the transaction, whether it has been\n"
"previously executed, and if the threshold number of signatures has been\n"
"reached. The transaction is executed if all the checks pass."
msgstr ""

#: src/ch04-05-02-multisig.md:664
msgid ""
"```cairo\n"
"\tfn execute_multi_call(mut calls: Span<account::Call>) -> Array<Span<felt252>> {\n"
"\t\tassert(calls.len() != 0, 'execute/no-calls');\n"
"\t\tlet mut result: Array<Span<felt252>> = ArrayTrait::new();\n"
"\t\tlet mut idx = 0;\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tmatch starknet::call_contract_syscall(\n"
"\t\t\t\t\t\t*call.to,\n"
"\t\t\t\t\t\t*call.selector,\n"
"\t\t\t\t\t\tcall.calldata.span()\n"
"\t\t\t\t\t) {\n"
"\t\t\t\t\t\tResult::Ok(retdata) => {\n"
"\t\t\t\t\t\t\tresult.append(retdata);\n"
"\t\t\t\t\t\t\tidx += 1;\n"
"\t\t\t\t\t\t},\n"
"\t\t\t\t\t\tResult::Err(err) => {\n"
"\t\t\t\t\t\t\tlet mut data = ArrayTrait::new();\n"
"\t\t\t\t\t\t\tdata.append('call/multicall-faild');\n"
"\t\t\t\t\t\t\tdata.append(idx);\n"
"\t\t\t\t\t\t\tlet mut err = err;\n"
"\t\t\t\t\t\t\tloop {\n"
"\t\t\t\t\t\t\t\tmatch err.pop_front() {\n"
"\t\t\t\t\t\t\t\t\tOption::Some(v) => {\n"
"\t\t\t\t\t\t\t\t\t\tdata.append(v);\n"
"\t\t\t\t\t\t\t\t\t},\n"
"\t\t\t\t\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t};\n"
"\t\t\t\t\t\t\tpanic(data);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t}\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t};\n"
"\t\tresult\n"
"\t}\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:711
#, fuzzy
msgid "## Protecting Protocol-Only Functions"
msgstr "## Invocar una Funci√≥n de Escritura"

#: src/ch04-05-02-multisig.md:713
msgid ""
"There maybe other use cases for other smart contracts to directly interact with the functions **execute** and **validate** of my account contract, I would rather restrict them to be callable only "
"by the Starknet protocol in case there‚Äôs an attack vector that I‚Äôm failing to foresee."
msgstr ""

#: src/ch04-05-02-multisig.md:715
msgid ""
"When the Starknet protocol calls a function it uses the zero address as the caller. We can use this fact to create a private function named only_protocol. To create private functions we simply "
"create a new implementation that is not annotated with the external attribute so no public selectors are created."
msgstr ""

#: src/ch04-05-02-multisig.md:717
msgid ""
"```cairo\n"
"fn assert_only_protocol() {\n"
"\t\tassert(starknet::get_caller_address().is_zero(), 'caller/non-zero');\n"
"\t}\n"
"\n"
"\tfn assert_no_self_call(\n"
"\t\tmut calls: Span<account::Call>\n"
"\t) {\n"
"\t\tlet self = starknet::get_contract_address();\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tassert(*call.to != self, 'call/call-to-self');\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak ;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn execute_multi_call(mut calls: Span<account::Call>) -> Array<Span<felt252>> {\n"
"\t\tassert(calls.len() != 0, 'execute/no-calls');\n"
"\t\tlet mut result: Array<Span<felt252>> = ArrayTrait::new();\n"
"\t\tlet mut idx = 0;\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tmatch starknet::call_contract_syscall(\n"
"\t\t\t\t\t\t*call.to,\n"
"\t\t\t\t\t\t*call.selector,\n"
"\t\t\t\t\t\tcall.calldata.span()\n"
"\t\t\t\t\t) {\n"
"\t\t\t\t\t\tResult::Ok(retdata) => {\n"
"\t\t\t\t\t\t\tresult.append(retdata);\n"
"\t\t\t\t\t\t\tidx += 1;\n"
"\t\t\t\t\t\t},\n"
"\t\t\t\t\t\tResult::Err(err) => {\n"
"\t\t\t\t\t\t\tlet mut data = ArrayTrait::new();\n"
"\t\t\t\t\t\t\tdata.append('call/multicall-faild');\n"
"\t\t\t\t\t\t\tdata.append(idx);\n"
"\t\t\t\t\t\t\tlet mut err = err;\n"
"\t\t\t\t\t\t\tloop {\n"
"\t\t\t\t\t\t\t\tmatch err.pop_front() {\n"
"\t\t\t\t\t\t\t\t\tOption::Some(v) => {\n"
"\t\t\t\t\t\t\t\t\t\tdata.append(v);\n"
"\t\t\t\t\t\t\t\t\t},\n"
"\t\t\t\t\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t};\n"
"\t\t\t\t\t\t\tpanic(data);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t}\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t};\n"
"\t\tresult\n"
"\t}\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:783
msgid "Notice that the function is_valid_signature is not protected by the **only_protocol** function because we do want to allow anyone to use it."
msgstr ""

#: src/ch04-05-02-multisig.md:785
#, fuzzy
msgid "## Signature Validation"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-05-02-multisig.md:787
msgid ""
"To validate the signature of a transaction we will need to use the public key associated with the signer of the account contract. We have already defined public_key to be part of the storage of our "
"account but we need to capture its value during deployment using the constructor."
msgstr ""

#: src/ch04-05-02-multisig.md:789
msgid ""
"```cairo\n"
"\n"
"#[storage]\n"
"\t#[starknet::contract]\n"
"mod Multisign {\n"
"\tuse super::ISRC6;\n"
"\tuse super::ISRC5;\n"
"\tuse starknet::account;\n"
"\n"
"\tconst SRC6_INTERFACE_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\tconst MAX_SIGNERS_COUNT: usize = 32;\n"
"\n"
"\t#[storage]\n"
"\tstruct Storage {\n"
"\t\tsigners: LegacyMap<felt252, felt252>,\n"
"\t\tthreshold: usize,\n"
"\t\toutside_nonce: LegacyMap<felt252, felt252>\n"
"\t}\n"
"\n"
"\t// @notice Contructor of the account\n"
"\t// @dev Asserts threshold in relation with signers-len\n"
"\t// @param threshold Initial threshold\n"
"\t// @param signers Array of inital signers' public-keys\n"
"\t#[constructor]\n"
"\tfn constructor(\n"
"\t\tref self: ContractState,\n"
"\t\tthreshold: usize,\n"
"\t\tsigners: Array<felt252>) {\n"
"\t\tassert_threshold(threshold, signers.len());\n"
"\n"
"\t\tself.add_signers(signers.span(), 0);\n"
"\t\tself.threshold.write(threshold);\n"
"\t}\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:824
msgid ""
"The logic of the function is_valid_signature can be implemented , if the signature is valid, it should return the short string ‚ÄòVALID‚Äô and if not it should return the value 0. Returning zero is "
"just a convention, we can return any felt as long as it is not the felt that represents the short string ‚ÄòVALID‚Äô."
msgstr ""

#: src/ch04-05-02-multisig.md:826
msgid ""
"The logic of returning a felt252 value instead of a boolean maybe confusing. That‚Äôs why there is a need to create an internal function called is_valid_signature_bool that will perform the same "
"logic but will return a boolean instead of a felt252 depending on the result of validating a signature."
msgstr ""

#: src/ch04-05-02-multisig.md:828
msgid ""
"```cairo\n"
"fn is_valid_signature_span(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsignature: Span<felt252>\n"
"\t\t) -> bool {\n"
"\t\t\tlet threshold = self.threshold.read();\n"
"\t\t\tassert(threshold != 0, 'Uninitialized');\n"
"\t\t\tlet mut signatures = deserialize_signatures(signature)\n"
"\t\t\t\t.expect('signature/invalid-len');\n"
"\t\t\tassert(threshold == signatures.len(), 'signature/invalid-len');\n"
"\t\t\tlet mut last: u256 = 0;\n"
"\t\t\tloop {\n"
"\t\t\t\tmatch signatures.pop_front() {\n"
"\t\t\t\t\tOption::Some(signature_ref) => {\n"
"\t\t\t\t\t\tlet signature = *signature_ref;\n"
"\t\t\t\t\t\tlet signer_uint = signature.signer.into();\n"
"\t\t\t\t\t\tassert(signer_uint > last, 'signature/not-sorted');\n"
"\t\t\t\t\t\tif !self.is_valid_signer_signature(\n"
"\t\t\t\t\t\t\t\thash,\n"
"\t\t\t\t\t\t\t\tsignature.signer,\n"
"\t\t\t\t\t\t\t\tsignature.signature_r,\n"
"\t\t\t\t\t\t\t\tsignature.signature_s,\n"
"\t\t\t\t\t\t\t) {\n"
"\t\t\t\t\t\t\tbreak false;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tlast = signer_uint;\n"
"\t\t\t\t\t},\n"
"\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\tbreak true;\n"
"\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"fn is_valid_signer_signature(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tsignature_r: felt252,\n"
"\t\t\tsignature_s: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tassert(self.is_signer(signer), 'signer/not-a-signer');\n"
"\t\t\tecdsa::check_ecdsa_signature(hash, signer, signature_r, signature_s)\n"
"\t\t}\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:876
msgid ""
"Private function can be used to validate a transaction signature as required by the **validate** function. In contrast to the function is_valid_signature we will use an assert to stop the "
"transaction execution in case the signature is found to be invalid.\n"
"Here‚Äôs a little casting problem. The function is_valid_signature_bool expects the signature to be passed as an Array but the signature variable inside the **validate** function is a Span. Because "
"it is easier (and cheaper) to derive a Span from an Array than the opposite, I‚Äôll change the function signature of is_valid_signature_bool to expect a Span instead of an Array."
msgstr ""

#: src/ch04-05-02-multisig.md:879
msgid ""
"This little change will require deriving a Span from the signature variable inside the function is_valid_signature before calling is_valid_signature_bool which we can easily do with the span() "
"method available on the ArrayTrait."
msgstr ""

#: src/ch04-05-02-multisig.md:883
msgid ""
"In conclusion, account abstraction and multisig converge to create a more secure, flexible, and user-centric approach to account management in blockchain ecosystems.\n"
"Additional benefits of this relationship include:"
msgstr ""

#: src/ch04-05-02-multisig.md:886
msgid "Social recovery: Account abstraction enables social recovery mechanisms for multisig accounts, allowing for account recovery in case of key loss."
msgstr ""

#: src/ch04-05-02-multisig.md:888
msgid "Fee payment delegation: Account contracts can be configured to pay transaction fees, reducing friction for multisig transactions."
msgstr ""

#: src/ch04-05-02-multisig.md:890
msgid ""
"As account abstraction gains traction, multisig is poised to become a more accessible and versatile tool for safeguarding assets and enhancing control in Starknet protocol.\n"
"This chapter is an introduction to the concept of multisig accounts in\n"
"Starknet and illustrated how they can be implemented using an account contract. However, it‚Äôs important to note that this is a simplified example, and a production-grade multisig contract should "
"contain\n"
"additional checks and validations for robustness and security."
msgstr ""

#: src/ch04-05-03-auto-payments.md:1
msgid "# Auto-Payments üöß"
msgstr ""

#: src/ch04-05-03-auto-payments.md:3
msgid ""
"As blockchain adoption increases, there will be a greater need for products with a superior user experience and core functionality that support real use cases. In a few simple steps, we can set up "
"automatic recurring payments today directly on our mobile banking applications. In fact, online bill pay is growing rapidly, and customers especially younger ones have come to expect the ability to "
"set up recurring payments and take advantage of other conveniences associated with using auto-payments. About 3 in 10 surveyed users have changed the way they pay their bills in the past two years "
"and finding a more convenient way to pay was the most frequently cited reason. However, this is not a trivial task on a blockchain like Ethereum, the largest blockchain network by on-chain payment "
"volumes. For certain types of digital wallets, such as a self-custodial wallet where the user has sole control over the wallet and private keys, automated programmable payments that can pull "
"payments automatically from a user‚Äôs account at recurring intervals requires engineering work."
msgstr ""

#: src/ch04-05-03-auto-payments.md:5
msgid ""
"The concept and one of the leading Ethereum developer proposals known as Account Abstraction to explore how smart contracts can be implemented to enable automated programmable payments. We propose "
"a new solution towards a real-world application of auto payments to demonstrate how to write a smart contract for a self-custodial wallet that can pull funds automatically, instead of requiring the "
"user's active participation each time to instruct and push payments on a blockchain."
msgstr ""

#: src/ch04-05-03-auto-payments.md:7
msgid ""
"Consider a hypothetical scenario: today is the 25th of February. Alex is going away on vacation to the Alps, and she will be returning on March 10th. She must pay her mortgage, TV subscription and "
"utility bills by the 5th of every month. She does not have enough money to pay before she goes on vacation, but she will have enough money when she gets her paycheck on the 1st of March. How is "
"Alex going to enjoy her vacation without missing her payments?"
msgstr ""

#: src/ch04-05-03-auto-payments.md:9
msgid ""
"All Alex needs to do is set up recurring payments to automatically pay for her recurring bills. However, this is not as straightforward to execute on a blockchain. To see why this is the case, let "
"us consider the Ethereum network. We will begin by setting up some terminology that will help us better understand the issue at hand."
msgstr ""

#: src/ch04-05-03-auto-payments.md:11
#, fuzzy
msgid "## Accounts on Ethereum"
msgstr "### Account"

#: src/ch04-05-03-auto-payments.md:13
msgid ""
"Ethereum has two types of accounts:\n"
"Externally Owned Accounts (EOA) and Contract Accounts. EOAs have a private and public key pairing which helps them initiate transactions. On the other hand, Contract Accounts are smart contracts "
"that rely on predefined codes to trigger particular transactions.\n"
"In that view, accounts abstraction refers to the process of unifying both contracts under a single merged type that makes it easier for users to interact with blockchain-based applications. This "
"mechanism would enable user accounts to behave like smart contracts, unlocking many new use cases. For instance, users could set up delegate accounts that process automatic periodic payments on "
"users' behalf. Account abstraction can also unlock a broader range of innovative features that simplify the Web 3 experience for average users, including gasless transactions or changing the "
"account signer at every particular interval to increase security."
msgstr ""

#: src/ch04-05-03-auto-payments.md:17
msgid "## Auto Payments on Ethereum"
msgstr ""

#: src/ch04-05-03-auto-payments.md:19
msgid ""
"Let us revisit Alex‚Äôs situation. Suppose Alex owns a user account which is where her paychecks are deposited and from where she would like to pay her mortgage, TV subscription and utility bills. "
"Today, to pay her bills, Alex has to initiate a transaction that transfers tokens from her EOA to a user account belonging to the recipient, that is, to whomever she is paying her bills. In more "
"detail, Alex‚Äôs EOA has an associated secret or private key known only to Alex. This private key is used by Alex in the generation of an Elliptic Curve Digital Signature Algorithm (ECDSA) signature "
"that is crucial for the creation of a valid transaction. And this already brings us to the problem at hand. If Alex is away on holiday, who will generate this signature to create the transaction "
"that will make her payment?"
msgstr ""

#: src/ch04-05-03-auto-payments.md:21
msgid ""
"One solution is for Alex to use what is known as a custodial wallet. With a custodial wallet, another party controls Alex‚Äôs private key. In other words, Alex trusts a third party to secure her "
"funds and return them if she wanted to trade or send them somewhere else. The upside here is that Alex can set up an auto payment connected to her custodial wallet. Since the custodian, who is the "
"party that manages her wallet, has access to her private key, they will be able to generate the signature needed to create the transactions for her scheduled auto payments. And this can happen "
"while Alex is away on holiday. The downside is that while a custodial wallet lessens Alex‚Äôs personal responsibility, it requires Alex‚Äôs trust in the custodian who holds her funds."
msgstr ""

#: src/ch04-05-03-auto-payments.md:23
msgid ""
"With a self-custodial wallet, one where the user has total control over her wallet, Alex has sole control of her private key. While there is no need to trust a third party when using a self-"
"custodial wallet, this also means that Alex will not be able to set up an auto payment as she must be the one using her key to generate the signature needed for the payment transaction."
msgstr ""

#: src/ch04-05-03-auto-payments.md:25
msgid ""
"Another way to understand this is through the terminology of pull and push payments. A pull payment is a payment transaction that is triggered by the payee, while a push payment on the other hand "
"is a payment transaction that is triggered by the payer. Ethereum supports push payments but doesn‚Äôt natively support pull payments ‚Äì auto payments are an example of pull payments."
msgstr ""

#: src/ch04-05-03-auto-payments.md:27
msgid "Alt text"
msgstr ""

#: src/ch04-05-03-auto-payments.md:29
#, fuzzy
msgid "## Account Abstraction"
msgstr "Abstracci√≥n de Cuenta"

#: src/ch04-05-03-auto-payments.md:31
msgid ""
"Account abstraction (AA) is a proposal that attempts to combine user accounts and smart contracts into just one Ethereum account type by making user accounts function like smart contracts. As we "
"will see ahead, AA allows us to design a neat solution for auto payments. But more generally, the motivating rationale behind AA is quite simple but fundamental: Ethereum transactions today have "
"several rigid requirements hardcoded into the Ethereum protocol. For instance, transactions on the Ethereum blockchain today are valid only if they have a valid ECDSA signature, a valid nonce and "
"sufficient account balance to cover the cost of computation."
msgstr ""

#: src/ch04-05-03-auto-payments.md:33
msgid "AA proposes having more flexibility in the process for validating a transaction on the blockchain:"
msgstr ""

#: src/ch04-05-03-auto-payments.md:35
msgid ""
"- It enables multi-owner accounts via multisig signature verification.\n"
"- It enables the use of post-quantum signatures for the verification of transactions.\n"
"- It also allows for a so-called public account from which anyone could make a transaction, by removing signature verification entirely."
msgstr ""

#: src/ch04-05-03-auto-payments.md:39
msgid ""
"Essentially, AA allows for programmable validity to verify and validate any blockchain transaction. This means that instead of hard coding validity conditions into the Ethereum protocol that will "
"apply to all transactions in a generalized way, validity conditions can instead be programmed in a customizable way into a smart contract on a per-account basis. With AA, a user deploys an account "
"contract with any of the features described above, among others."
msgstr ""

#: src/ch04-05-03-auto-payments.md:41
msgid "And, most importantly for us in the use case described, AA enables auto payments as we can set up validity rules that no longer include signature verification. We will elaborate on this next."
msgstr ""

#: src/ch04-05-03-auto-payments.md:43
msgid "## Delegable Accounts ‚Äì Account Abstraction Enables Auto Payments"
msgstr ""

#: src/ch04-05-03-auto-payments.md:45
msgid ""
"Our solution for auto payments is to leverage AA and create a new type of account contract ‚Äì a delegable account. Our main idea is to extend programmable validity rules for transactions to include "
"a pre-approved allow list. In essence, AA allows us to delegate the ability to instruct the user‚Äôs account to initiate a push payment to a pre-approved auto payment smart contract."
msgstr ""

#: src/ch04-05-03-auto-payments.md:47
msgid ""
"First, a merchant deploys an auto payment smart contract. When a user with a delegable account visits the merchant‚Äôs website, they will see a request to approve auto payments ‚Äì similar to Visa "
"acceptance for billers today. Here, the user can see the actions that the auto payment contract will do in the user‚Äôs name. For example, it can only charge the user once per month, or it cannot "
"charge more than a maximum amount. Crucially, because this is a smart contract, a user can be confident that the auto payment contract cannot execute in a way other than how it is written."
msgstr ""

#: src/ch04-05-03-auto-payments.md:49
msgid "If the user agrees to approve auto payments, the wallet will add the auto payment contract‚Äôs address to the list of allowed contracts on the user‚Äôs delegable account."
msgstr ""

#: src/ch04-05-03-auto-payments.md:51
#, fuzzy
msgid "## Implementing Auto-payment on Starknet"
msgstr "## Implementaci√≥n de Smart Contracts en Starknet"

#: src/ch04-05-03-auto-payments.md:53
msgid "For a smart contract to be considered an account contract it must at least implement the interface defined by SNIP-6. Additional methods might be required for advanced account functionality."
msgstr ""

#: src/ch04-05-03-auto-payments.md:55
msgid ""
"```\n"
"// Cheat sheet\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"trait IAccountAddon {\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-03-auto-payments.md:77
msgid ""
"Much has been said about the need to improve the user experience (UX) of web3 if we want to increase adoption. Account Abstraction (AA) is one of the most powerful tools on Starknet to improve UX "
"as it enables users to sign transactions with FaceID or TouchID, to execute multiple operations in a single transaction and to allow for third party services to perform operations on behalf of the "
"user with fine grain control. No wonder why Visa has been so interested in exploring Starknet for auto payments."
msgstr ""

#: src/ch04-05-03-auto-payments.md:79
msgid ""
"With Account Abstraction, and in contrast to Externally Owned Accounts (EOA), the signer is decoupled from the account. The signer is the piece of code that signs transactions using a private key "
"and elliptic curve cryptography to uniquely identify a user. The account is a smart contract on Starknet that defines how signature verification is performed, executes the transactions signed by "
"the user and ultimately owns the user‚Äôs assets (aka tokens) on L2."
msgstr ""

#: src/ch04-05-03-auto-payments.md:81
msgid ""
"Note: Using an Elliptic Curve Digital Signature Algorithtm (ECDSA) is not the only way to authenticate a signer, other mechanisms are possible but they come with tradeoffs of performance, cost and "
"ecosystem support. ECDSA remains the most widely used algorithm on Starknet and different curves are supported."
msgstr ""

#: src/ch04-05-03-auto-payments.md:83
msgid "The contract will be create account, declared and deploy it to testnet using Starkli and then use it to interact with Starknet."
msgstr ""

#: src/ch04-05-03-auto-payments.md:87
msgid "For a smart contract to be considered an account (aka account contract) it must adhere to a specific public interface defined by the Starknet Improvement Proposal number 6 (SNIP-6)."
msgstr ""

#: src/ch04-05-03-auto-payments.md:89
msgid ""
"```\n"
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"/// @title SRC-6 Standard Account\n"
"trait ISRC6 {\n"
"    /// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    /// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    /// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"/// @title SRC-5 Standard Interface Detection\n"
"trait ISRC5 {\n"
"    /// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-03-auto-payments.md:124
msgid "As you can see in the proposal, an account contract must implement at least the methods **execute**, **validate** and is_valid_signature."
msgstr ""

#: src/ch04-05-03-auto-payments.md:126
msgid ""
"The methods **execute** and **validate** are meant to be called by the Starknet protocol during different stages of the lifecycle of a transaction. This doesn‚Äôt mean that only the Starknet protocol "
"can use those methods, as a matter of fact, anyone can call those methods even if the contract account doesn‚Äôt belong to them. Something to keep an eye on when securing our account."
msgstr ""

#: src/ch04-05-03-auto-payments.md:128
msgid ""
"When a user sends an invoke transaction, the first thing that the protocol does is to call the **validate** method to check the signature of the transaction. In other words, to authenticate the "
"signer associated with the account. There are restrictions on what you can do inside the **validate** method to protect the Sequencer against Denial of Service (DoS) attacks [3]."
msgstr ""

#: src/ch04-05-03-auto-payments.md:130
msgid ""
"Notice that if the signature verification is successful, the **validate** method should return the short string VALID as opposed to a boolean. In Cairo, a short string is simply the ASCII "
"representation of a single felt and not a real string. This is why the return type of the method is felt252. If the signature verification fails, you can stop execution with an assert or return "
"literally any other felt that is not the aforementioned short string."
msgstr ""

#: src/ch04-05-03-auto-payments.md:132
msgid ""
"If the protocol is able to authenticate the signer, it will then call the function **execute** passing as an argument an array of all the operations or ‚Äúcalls‚Äù the user wants to perform as a "
"multicall. Each one of these calls define a target smart contract, a method to call (the ‚Äúselector‚Äù) and the arguments expected by the method."
msgstr ""

#: src/ch04-05-03-auto-payments.md:134
msgid ""
"The execution of each Call might result in a value being returned from the target smart contract. This value could be a simple scalar like a felt252 or a boolean, or a complex data structure like a "
"struct or an array. In any case, the Starknet protocol serializes the response using a Span of felt252 elements. Remember that Span represents a snapshot of an Array [4]. This is why the return "
"type of the **execute** method is an Array of Spans which represents a serialized response from each call in the multicall."
msgstr ""

#: src/ch04-05-03-auto-payments.md:136
msgid ""
"The method is_valid_signature is not defined or used by the Starknet protocol. It was instead an agreement between builders in the Starknet community as a way to allow web3 apps to perform user "
"authentication. Think of a user trying to authenticate to an NFT marketplace using their wallet. The web app will ask the user to sign a message and then it will call the function "
"is_valid_signature to verify that the connected wallet address belongs to the user."
msgstr ""

#: src/ch04-05-03-auto-payments.md:138
msgid ""
"To allow other smart contracts to know if your account contract adheres to the SNIP-6 interface, you should implement the method supports_interface from the SRC5 introspection standard. The "
"interface_id for the SNIP-6 interface is the combined hash of the trait‚Äôs selectors as defined by Ethereum‚Äôs ERC165 [5]. You can calculate the id yourself by using the src5-rs utility [6] or you "
"can take my word for it that the id is 1270010605630597976495846281167968799381097569185364931397797212080166453709.\n"
"Additional Interface"
msgstr ""

#: src/ch04-05-03-auto-payments.md:141
msgid ""
"Although the interface defined by the SNIP-6 is enough to guarantee that a smart contract is in fact an account contract, it is the minimum requirement and not the whole story. For an account to be "
"able to declare other smart contracts and pay for the associated gas fees it will need to also implement the method **validate_declare**. If we also want to be able to deploy our account contract "
"using the counterfactual deployment method then it also needs to implement the **validate_deploy** method."
msgstr ""

#: src/ch04-05-03-auto-payments.md:143
msgid ""
"Counterfactual deployment is a mechanism to deploy an account contract without relying on another account contract to pay for the related gas fees. This is important if we don‚Äôt want to associate a "
"new account contract with its deployer address and instead have a ‚Äúpristine‚Äù beginning."
msgstr ""

#: src/ch04-05-03-auto-payments.md:145
msgid ""
"This deployment process starts by calculating locally the would-be-address of our account contract without actually deploying it yet. This is possible to do with tools like Starkli [7]. Once we "
"know the address, we then send enough ETH to that address to cover the costs of deploying our account contract. Once the address is funded we can finally send a deploy_account transaction to "
"Starknet with the compiled code of our account contract. The Sequencer will deploy the account contract to the precalculated address and pay itself gas fees with the ETH we sent there. There‚Äôs no "
"need to declare an account contract before deploying it."
msgstr ""

#: src/ch04-05-03-auto-payments.md:147
msgid ""
"To allow tools like Starkli to easily integrate with our smart contract in the future, it is recommended to expose the public_key of the signer as a view function as part of the public interface. "
"With all this in mind, the extended interface of an account contract is shown below."
msgstr ""

#: src/ch04-05-03-auto-payments.md:149
msgid ""
"```\n"
"/// @title IAccount Additional account contract interface\n"
"trait IAccountAddon {\n"
"    /// @notice Assert whether a declare transaction is valid to be executed\n"
"    /// @param class_hash The class hash of the smart contract to be declared\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    /// @notice Assert whether counterfactual deployment is valid to be executed\n"
"    /// @param class_hash The class hash of the account contract to be deployed\n"
"    /// @param salt Account address randomizer\n"
"    /// @param public_key The public key of the account signer\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    /// @notice Exposes the signer's public key\n"
"    /// @return The public key\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"
msgstr ""

#: src/ch04-05-03-auto-payments.md:168
msgid "In summary, a fully fledged account contract should implement the SNIP-5, SNIP-6 and the Addon interface."
msgstr ""

#: src/ch04-05-03-auto-payments.md:170
msgid "## References"
msgstr ""

#: src/ch04-05-03-auto-payments.md:172
msgid "[1] Auto Payments for Self-Custodial Wallets"
msgstr ""

#: src/ch04-05-03-auto-payments.md:174
msgid "[2] SNIP-6 Standard Account Interface"
msgstr ""

#: src/ch04-05-03-auto-payments.md:176
msgid "[3] Starknet Docs: Limitations on the validate function"
msgstr ""

#: src/ch04-05-03-auto-payments.md:178
msgid "[4] Cairo Book: The Span data type"
msgstr ""

#: src/ch04-05-03-auto-payments.md:180
msgid "[5] ERC-165: Standard Interface Detection"
msgstr ""

#: src/ch04-05-03-auto-payments.md:182
msgid "[6] Github: src5-rs"
msgstr ""

#: src/ch04-05-03-auto-payments.md:184
msgid "[7] Github: starkli"
msgstr ""

#: src/ch04-05-04-alternative-signature-schemes.md:1
msgid "# Alternative Signature Schemes üöß"
msgstr ""

#: src/ch04-05-06-web-wallet.md:1
msgid "# Web Wallet: Web2 Simplicity with self-custody"
msgstr ""

#: src/ch04-05-06-web-wallet.md:3
msgid ""
"Web Wallet, developed by Argent ([documentation](https://docs.argent.xyz/starknet/web-wallet-sdk)), is a tool that uses the full power and capacity of Account Abstraction. It's a self-custodial, "
"browser-based wallet that simplifies blockchain interactions. Unlike traditional wallets that often involve seed phrases and wallet downloads, Web Wallet utilizes a simple email and password setup. "
"This approach blends the ease of web2 interfaces with the advanced capabilities of web3, making Starknet more accessible and user-friendly."
msgstr ""

#: src/ch04-05-06-web-wallet.md:5
#, fuzzy
msgid "Key Features:"
msgstr "## Caracter√≠sticas Clave"

#: src/ch04-05-06-web-wallet.md:7
msgid ""
"- **Simplified Seed Phrases**: Web Wallet eliminates the need for seed phrases. Access your wallet easily using your email and password. Accounts are easily recoverable if lost.\n"
"- **No Downloads Needed**: Access Starknet directly from your browser using your email. No need to download an application or extension to create a wallet.\n"
"- **Multi-Device Support**: Web Wallet can be used across various devices seamlessly, like any standard web2 application."
msgstr ""

#: src/ch04-05-06-web-wallet.md:11
msgid "## dApps Integration Guide"
msgstr ""

#: src/ch04-05-06-web-wallet.md:13
msgid "To integrate Web Wallet in a dApp, start by installing `starknetkit`:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:15
#, fuzzy
msgid ""
"```bash\n"
"yarn add starknetkit\n"
"```"
msgstr ""
"```bash\n"
"yarn start\n"
"```"

#: src/ch04-05-06-web-wallet.md:19
msgid "Import necessary methods such as **`connect`** and **`disconnect`**:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:21
msgid ""
"```js\n"
"import { connect, disconnect } from \"starknetkit\";\n"
"```"
msgstr ""

#: src/ch04-05-06-web-wallet.md:25
msgid "Create a wallet connection using the `connect` method:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:27
msgid ""
"```js\n"
"const connection = await connect({ webWalletUrl: \"https://web.argent.xyz\" });\n"
"```"
msgstr ""

#: src/ch04-05-06-web-wallet.md:31
msgid "Below is an example function that establishes a connection, then sets the connection, provider, and address states:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:33
#, fuzzy
msgid ""
"```js\n"
"const connectWallet = async () => {\n"
"  const connection = await connect({ webWalletUrl: \"https://web.argent.xyz\" });\n"
"\n"
"  if (connection && connection.isConnected) {\n"
"    setConnection(connection);\n"
"    setProvider(connection.account);\n"
"    setAddress(connection.selectedAddress);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"

#: src/ch04-05-06-web-wallet.md:45
msgid "> **NOTE:** Web Wallet is currently available only on the mainnet. For testnet access, contact the Argent team."
msgstr ""

#: src/ch04-05-06-web-wallet.md:47
#, fuzzy
msgid "## Transaction Signing Process"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-05-06-web-wallet.md:49
msgid "Signing transactions with Web Wallet follows a process akin to the Argent X browser extension:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:51
msgid ""
"```js\n"
"const tx = await connection.account.execute({\n"
"  //let's assume this is an erc20 contract\n"
"  contractAddress: \"0x...\",\n"
"  selector: \"transfer\",\n"
"  calldata: [\n"
"    \"0x...\",\n"
"    // ...\n"
"  ],\n"
"});\n"
"```"
msgstr ""

#: src/ch04-05-06-web-wallet.md:63
msgid "Users will see a transaction confirmation request. Upon approval, the dApp receives a transaction hash:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:65
msgid "<img src=\"./img/ch04-05-05-web-wallet-tx-page.jpg\" width=\"100%\" alt=\"webwalllet signing page\">"
msgstr ""

#: src/ch04-05-06-web-wallet.md:67
msgid ""
"If the user's wallet is already funded it will ask the user to confirm the transaction. The dapp will get feedback if the user has confirmed or rejected the transaction request. If confirmed, the "
"dapp will get a transaction hash."
msgstr ""

#: src/ch04-05-06-web-wallet.md:69
msgid "### Addressing Unfunded Wallets"
msgstr ""

#: src/ch04-05-06-web-wallet.md:71
msgid ""
"When users lack funds, they are guided through simple \"Add Funds\" steps. This includes access to on-ramps for easy funding. The process is streamlined with minimal KYC requirements, ensuring a "
"user-friendly experience. Once complete, the wallet is funded and prepared for deployment."
msgstr ""

#: src/ch04-05-06-web-wallet.md:73
#, fuzzy
msgid "### Preparing for First Transaction"
msgstr "## Seguimiento de Transacciones"

#: src/ch04-05-06-web-wallet.md:75
msgid ""
"Once the wallet is funded, it's set for the initial transaction. Wallet deployment occurs simultaneously with this first transaction, typically unnoticed by the user. It's important to note that a "
"wallet may be connected but not yet deployed."
msgstr ""

#~ msgid "Note: If you don't specify the rpc provider, Starkli will use Goerli, which will be deprecated soon."
#~ msgstr "Nota: Si no especifica el proveedor rpc, Starkli utilizar√° Goerli, que pronto quedar√° obsoleto."

#~ msgid ""
#~ "With the smart contract compiled, we‚Äôre ready to declare it using\n"
#~ "Starkli. Then we can set the STARKNET_RPC environment variable to make command invocations easier:"
#~ msgstr ""
#~ "Con el smart contract compilado, estamos listos para declararlo usando\n"
#~ "Starkli. Luego podemos configurar la variable de entorno STARKNET_RPC para facilitar la invocaci√≥n de comandos:"

#~ msgid ""
#~ "```bash\n"
#~ "    export STARKNET_RPC=\"https://starknet-sepolia.infura.io/v3/<API_KEY>\"\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    export STARKNET_RPC=\"https://starknet-sepolia.infura.io/v3/<API_KEY>\"\n"
#~ "```"

#, fuzzy
#~ msgid "### `is_valid_signature_span` Function"
#~ msgstr "### Llamar a una Funci√≥n de Lectura"

#~ msgid "Compile, Deploy, Interact"
#~ msgstr "Compilar, Desplegar, Interactuar"

#~ msgid "Starkli: A CLI interface üöß"
#~ msgstr "Starkli: Una interfaz CLI üöß"

#~ msgid "### Why Choose Cairo?"
#~ msgstr "### ¬øPor qu√© elegir Cairo?"

#~ msgid ""
#~ "Cairo is designed for _Provable Computation,_ a new paradigm that lets\n"
#~ "programs prove their correctness without re-running them. Here‚Äôs why it\n"
#~ "stands out:"
#~ msgstr ""
#~ "Cairo est√° dise√±ado para _Computaci√≥n Demostrable_, un nuevo paradigma que permite\n"
#~ "que los programas demuestran su correcci√≥n sin volver a ejecutarlos. He aqu√≠ por qu√©\n"
#~ "destaca:"

#~ msgid ""
#~ "- Purpose-Built: Designed specifically for smart contracts.\n"
#~ "\n"
#~ "- No EVM Limits: Goes beyond what the Ethereum Virtual Machine can do.\n"
#~ "\n"
#~ "- Flexibility: Uses traits for more flexibility than inheritance."
#~ msgstr ""
#~ "- **Purpose-Built: :** Dise√±ado espec√≠ficamente para smart contracts.\n"
#~ "\n"
#~ "- **Sin l√≠mites de EVM:** Va m√°s all√° de lo que puede hacer la m√°quina virtual Ethereum.\n"
#~ "\n"
#~ "- **Flexibilidad:** Utiliza rasgos para mayor flexibilidad que la herencia."

#~ msgid "## Learning Resources"
#~ msgstr "## Recursos de aprendizaje"

#~ msgid "For deeper insights into Starknet and Cairo:"
#~ msgstr "Para obtener informaci√≥n m√°s detallada sobre Starknet y Cairo:"

#~ msgid ""
#~ "- [The Starknet Book](https://book.starknet.io): For mastering\n"
#~ "  Starknet\n"
#~ "\n"
#~ "- [The Cairo Book](https://cairo-book.github.io/): For mastering Cairo\n"
#~ "\n"
#~ "- [Starklings](https://github.com/shramee/starklings-cairo1):\n"
#~ "  Practical tutorials and examples"
#~ msgstr ""
#~ "- [El libro de Starknet](https://book.starknet.io): Para masterizar\n"
#~ "   Starknet\n"
#~ "\n"
#~ "- [El libro de Cairo](https://cairo-book.github.io/): Para dominar Cairo\n"
#~ "\n"
#~ "- [Starklings](https://github.com/shramee/starklings-cairo1):\n"
#~ "   Tutoriales pr√°cticos y ejemplos"

#~ msgid ""
#~ "In decentralized technology, Starknet offers a solution to challenges that previous systems encountered. It's based on established _protocols_ and _registries_, following the initial concepts "
#~ "introduced by figures such as Satoshi. Through a specific mathematical method, Starknet seeks a balance between scalability and consensus. As this technology progresses, Starknet adheres to "
#~ "principles of inclusivity, neutrality, and user empowerment. It's poised for continuous adaptation and improvement in the field."
#~ msgstr ""
#~ "En tecnolog√≠a descentralizada, Starknet ofrece una soluci√≥n a los desaf√≠os que encontraron los sistemas anteriores. Se basa en _protocolos_ y _registros_ establecidos, siguiendo los conceptos "
#~ "iniciales introducidos por figuras como Satoshi. A trav√©s de un m√©todo matem√°tico espec√≠fico, Starknet busca el equilibrio entre escalabilidad y consenso. A medida que avanza esta tecnolog√≠a, "
#~ "Starknet se adhiere a principios de inclusi√≥n, neutralidad y empoderamiento del usuario. Est√° preparado para una adaptaci√≥n y mejora continuas en el campo."

#~ msgid "<span class=\"caption\">Activate the Starknet Plugin</span>"
#~ msgstr "<span class=\"caption\">Activar el Plugin de Starknet</span>"

#~ msgid ""
#~ "- [Braavos](https://braavos.app/)\n"
#~ "- [Argent](https://www.argent.xyz/argent-x/)"
#~ msgstr ""
#~ "- [Braavos](https://braavos.app/)\n"
#~ "- [Argent](https://www.argent.xyz/argent-x/)"

#~ msgid "## Find the compiler versions supported"
#~ msgstr "## Encuentre las versiones del compilador compatibles"

#~ msgid ""
#~ "We have to make sure that our Starkli compiler version match Scarb\n"
#~ "compiler version"
#~ msgstr ""
#~ "Tenemos que asegurarnos de que nuestra versi√≥n del compilador Starkli\n"
#~ "coincida con la versi√≥n del compilador Scarb"

#~ msgid "To find the compiler versions supported by Starkli, execute:"
#~ msgstr "Para encontrar las versiones del compilador compatibles con Starkli, ejecute:"

#~ msgid ""
#~ "You‚Äôll see a list of possible compiler versions under the\n"
#~ "`--compiler-version` flag."
#~ msgstr ""
#~ "Ver√° una lista de posibles versiones del compilador bajo el\n"
#~ "indicador `--compiler-version`."

#~ msgid ""
#~ "```bash\n"
#~ "    ...\n"
#~ "    --compiler-version <COMPILER_VERSION>\n"
#~ "              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]\n"
#~ "    ...\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    ...\n"
#~ "    --compiler-version <COMPILER_VERSION>\n"
#~ "              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]\n"
#~ "    ...\n"
#~ "```"

#~ msgid ""
#~ "Note that the Scarb compiler version might not align with Starkli‚Äôs\n"
#~ "supported versions. To check Scarb‚Äôs version:"
#~ msgstr ""
#~ "Tenga en cuenta que es posible que la versi√≥n del compilador Scarb no se alinee con las\n"
#~ "versiones compatibles de Starkli. Para comprobar la versi√≥n de Scarb:"

#~ msgid "You‚Äôll see a list that contains scarb, cairo and sierra version."
#~ msgstr "Ver√°s una lista que contiene las versiones scarb, cairo y sierra."

#~ msgid ""
#~ "```bash\n"
#~ "    scarb <SCARB VERSION>\n"
#~ "    cairo: <COMPILER VERSION>\n"
#~ "    sierra: <SIERRA VERSION>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    scarb <SCARB VERSION>\n"
#~ "    cairo: <COMPILER VERSION>\n"
#~ "    sierra: <SIERRA VERSION>\n"
#~ "```"

#~ msgid ""
#~ "If there‚Äôs a mismatch, it is suggested that you install the version of\n"
#~ "Scarb that uses the compiler version that Starkli supports. You can find\n"
#~ "previous releases on\n"
#~ "[Scarb](https://github.com/software-mansion/scarb/releases)'s GitHub\n"
#~ "repo."
#~ msgstr ""
#~ "Si hay una discrepancia, se sugiere instalar la versi√≥n de Scarb que utiliza la versi√≥n del\n"
#~ "compilador compatible con Starkli. Puede encontrar versiones anteriores en el repositorio\n"
#~ "de GitHub de [Scarb](https://github.com/software-mansion/scarb/releases)."

#~ msgid "To install a specific version, such as `0.6.1`, run:"
#~ msgstr "Para instalar una versi√≥n espec√≠fica, como `0.6.1`, ejecute:"

#~ msgid ""
#~ "```bash\n"
#~ "    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 0.6.1\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 0.6.1\n"
#~ "```"

#~ msgid ""
#~ "1.  Use Braavos or Argent X browser extensions to create your smart\n"
#~ "    wallet.\n"
#~ "\n"
#~ "2.  Follow the provided instructions for your chosen wallet (Argent or\n"
#~ "    Braavos).\n"
#~ "\n"
#~ "3.  Fund your wallet with ETH. Use [Starknet Goerli\n"
#~ "    Faucet](https://faucet.goerli.starknet.io/) as needed."
#~ msgstr ""
#~ "1. Utilice las extensiones de navegador Braavos o Argent X para crear\n"
#~ "   su smart wallet.\n"
#~ "\n"
#~ "2.  Siga las instrucciones proporcionadas para la billetera elegida (Argent o Braavos).\n"
#~ "\n"
#~ "3. Financia tu billetera con ETH. Utilice [Starknet Goerli\n"
#~ "Faucet](https://faucet.goerli.starknet.io/) seg√∫n sea necesario."

#~ msgid "Now you‚Äôre ready to interact with Starknet smart contracts."
#~ msgstr "Ahora est√° listo para interactuar con los smart contracts de Starknet."

#~ msgid "To see the details of your Account Descriptor, run:"
#~ msgstr "Para ver los detalles de su Descriptor de Cuenta, ejecute:"

#~ msgid ""
#~ "With the smart contract compiled, we‚Äôre ready to declare it using\n"
#~ "Starkli. Before declaring your contract, decide on an RPC provider."
#~ msgstr "Con el contrato inteligente compilado, estamos listos para declararlo usando Starkli. Antes de declarar su contrato, decida cu√°l es un proveedor de RPC."

#~ msgid "# Starkli: A CLI interface üöß"
#~ msgstr "# Starkli: Una CLI interface üöß"

#~ msgid ""
#~ "mkdir ~/.dojo && cd ~/.dojo\n"
#~ "    git clone https://github.com/dojoengine/dojo\n"
#~ "    cd dojo\n"
#~ "    cargo install --path ./crates/katana --locked --force"
#~ msgstr ""
#~ "mkdir ~/.dojo && cd ~/.dojo\n"
#~ "    git clone https://github.com/dojoengine/dojo\n"
#~ "    cd dojo\n"
#~ "    cargo install --path ./crates/katana --locked --force"

#~ msgid "Once installed, confirm it with the version command:"
#~ msgstr "Una vez instalado, conf√≠rmalo con el comando de versi√≥n:"

#~ msgid "katana --version"
#~ msgstr "katana --version"

#~ msgid ""
#~ "Updating `katana` to its latest version involves going back to the\n"
#~ "`dojo` directory and running the following commands:"
#~ msgstr "Actualizar `katana` a su √∫ltima versi√≥n implica volver al directorio `dojo` y ejecutar los siguientes comandos:"

#~ msgid ""
#~ "cd ~/.dojo/dojo\n"
#~ "    git pull\n"
#~ "\n"
#~ "    # If you are using a local Starknet node, ensure to stop it first.\n"
#~ "    cargo install --path ./crates/katana --locked --force"
#~ msgstr ""
#~ "cd ~/.dojo/dojo\n"
#~ "    git pull\n"
#~ "\n"
#~ "    # If you are using a local Starknet node, ensure to stop it first.\n"
#~ "    cargo install --path ./crates/katana --locked --force"

#~ msgid ""
#~ "- Starknet.js GitHub Repository:\n"
#~ "  <https://github.com/0xs34n/starknet.js>\n"
#~ "\n"
#~ "- Official Starknet.js Website and documentation:\n"
#~ "  <https://www.starknetjs.com/>"
#~ msgstr ""
#~ "- Repositorio Starknet.js GitHub:\n"
#~ "   <https://github.com/0xs34n/starknet.js>\n"
#~ "\n"
#~ "- Sitio web oficial de Starknet.js y documentaci√≥n:\n"
#~ "   <https://www.starknetjs.com/>"

#~ msgid ""
#~ "Stay tuned for more updates on Starknet.js, including detailed guides,\n"
#~ "examples, and comprehensive documentation."
#~ msgstr "Est√© atento a m√°s actualizaciones sobre Starknet.js, incluidas gu√≠as detalladas, ejemplos y documentaci√≥n completa."

#~ msgid ""
#~ "In this subchapter, readers will find practical examples demonstrating the usage of `starknet-js`. It provides insight into real-world applications and serves as a guide for developers to "
#~ "understand and implement these tools effectively."
#~ msgstr ""
#~ "En este subcap√≠tulo, los lectores encontrar√°n ejemplos pr√°cticos que demuestran el uso de `starknet-js`. Proporciona informaci√≥n sobre aplicaciones del mundo real y sirve como gu√≠a para que los "
#~ "desarrolladores comprendan e implementen estas herramientas de manera efectiva."

#~ msgid "We value the contribution of our developer community:"
#~ msgstr "Valoramos la contribuci√≥n de nuestra comunidad de desarrolladores:"

#~ msgid ""
#~ "- We encourage developers to contribute additional examples.\n"
#~ "- Please inform us if you identify any mistakes or inaccuracies."
#~ msgstr ""
#~ "- Alentamos a los desarrolladores a contribuir con ejemplos adicionales.\n"
#~ "- Inf√≥rmenos si identifica alg√∫n error o inexactitud."

#~ msgid "Your insights and feedback are instrumental in making this resource more comprehensive and accurate."
#~ msgstr "Sus ideas y comentarios son fundamentales para que este recurso sea m√°s completo y preciso."

#~ msgid ""
#~ "Several tools exist in the starknet ecosystem to build the front-end for\n"
#~ "your application. The most popular ones are:"
#~ msgstr ""
#~ "Existen varias herramientas en el ecosistema Starknet para construir el front-end de\n"
#~ "su aplicaci√≥n. Las m√°s populares son:"

#~ msgid ""
#~ "For Vue developers, vue-stark-boil, created by the team at [Don‚Äôt Panic\n"
#~ "DAO](https://github.com/dontpanicdao), is a great option. For a deeper\n"
#~ "understanding of Vue, visit their [website](https://vuejs.org/). The\n"
#~ "vue-stark-boil boilerplate enables various functionalities, such as\n"
#~ "connecting to a wallet, listening for account changes, and calling a\n"
#~ "contract."
#~ msgstr ""
#~ "Para desarrolladores de Vue, vue-stark-boil, creado por el equipo de [Don‚Äôt Panic\n"
#~ "DAO](https://github.com/dontpanicdao), es una gran opci√≥n. Para una m√°s profunda\n"
#~ "Para comprender Vue, visite su [sitio web](https://vuejs.org/). El\n"
#~ "El texto est√°ndar vue-stark-boil permite varias funcionalidades, como\n"
#~ "conectarse a una billetera, escuchar cambios en la cuenta y llamar a un\n"
#~ "contrato."

#~ msgid ""
#~ "To immerse in the real-world application of Starknet React, we recommend\n"
#~ "exploring the comprehensive example dApp project at\n"
#~ "[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)."
#~ msgstr ""
#~ "Para sumergirse en la aplicaci√≥n del mundo real de Starknet React, recomendamos explorar el proyecto dApp de ejemplo completo en\n"
#~ "[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)."

#~ msgid ""
#~ "Embarking on your Starknet React journey necessitates the incorporation\n"
#~ "of vital dependencies. Let‚Äôs start by adding them to your project."
#~ msgstr "Embarcarse en su viaje Starknet React requiere la incorporaci√≥n de dependencias vitales. Comencemos agreg√°ndolos a su proyecto."

#~ msgid ""
#~ "Proceed by swaddling your app within the `StarknetConfig` component.\n"
#~ "This enveloping action offers a degree of configuration, while\n"
#~ "simultaneously providing a React Context for the application beneath to\n"
#~ "utilize shared data and hooks. The `StarknetConfig` component accepts a\n"
#~ "connectors prop, allowing the definition of wallet connection options\n"
#~ "available to the user."
#~ msgstr ""
#~ "Contin√∫e envolviendo su aplicaci√≥n dentro del componente `StarknetConfig`. Esta acci√≥n envolvente ofrece un grado de configuraci√≥n y, al mismo tiempo, proporciona un contexto de React para que "
#~ "la aplicaci√≥n subyacente utilice datos y enlaces compartidos. El componente `StarknetConfig` acepta un accesorio de conector, lo que permite la definici√≥n de opciones de conexi√≥n de billetera "
#~ "disponibles para el usuario."

#~ msgid ""
#~ "const connectors = [\n"
#~ "      new InjectedConnector({ options: { id: \"braavos\" } }),\n"
#~ "      new InjectedConnector({ options: { id: \"argentX\" } }),\n"
#~ "    ];\n"
#~ "\n"
#~ "    return (\n"
#~ "        <StarknetConfig\n"
#~ "          connectors={connectors}\n"
#~ "          autoConnect\n"
#~ "        >\n"
#~ "          <App />\n"
#~ "        </StarknetConfig>\n"
#~ "    )"
#~ msgstr ""
#~ "const connectors = [\n"
#~ "      new InjectedConnector({ options: { id: \"braavos\" } }),\n"
#~ "      new InjectedConnector({ options: { id: \"argentX\" } }),\n"
#~ "    ];\n"
#~ "\n"
#~ "    return (\n"
#~ "        <StarknetConfig\n"
#~ "          connectors={connectors}\n"
#~ "          autoConnect\n"
#~ "        >\n"
#~ "          <App />\n"
#~ "        </StarknetConfig>\n"
#~ "    )"

#~ msgid ""
#~ "Observe the `disconnect` function that terminates the connection when\n"
#~ "invoked. Post connection, access to the connected account is provided\n"
#~ "through the `useAccount` hook, offering insight into the current state\n"
#~ "of connection:"
#~ msgstr ""
#~ "Observe la funci√≥n `disconnect` que finaliza la conexi√≥n cuando se invoca. Despu√©s de la conexi√≥n, el acceso a la cuenta conectada se proporciona a trav√©s del enlace `useAccount`, que ofrece "
#~ "informaci√≥n sobre el estado actual de conexi√≥n:"

#~ msgid ""
#~ "const { data, isError, isLoading, status } = useStarkName({ address });\n"
#~ "    // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')\n"
#~ "\n"
#~ "    if (isLoading) return <p>Loading...</p>\n"
#~ "    return <p>Account: {isError ? address : data}</p>"
#~ msgstr ""
#~ "const { data, isError, isLoading, status } = useStarkName({ address });\n"
#~ "    // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')\n"
#~ "\n"
#~ "    if (isLoading) return <p>Loading...</p>\n"
#~ "    return <p>Account: {isError ? address : data}</p>"

#~ msgid ""
#~ "You also have additional information you can get from this hook ‚Üí\n"
#~ "**error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**,\n"
#~ "**isFetchedAfterMount**, **isRefetching**, **refetch** which can give\n"
#~ "you more precise information on what is happening."
#~ msgstr ""
#~ "Tambi√©n tienes informaci√≥n adicional que puedes obtener en este hook ‚Üí\n"
#~ "**error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**,\n"
#~ "**isFetchedAfterMount**, **isRefetching**, **refetch** que pueden dar\n"
#~ "usted informaci√≥n m√°s precisa sobre lo que est√° sucediendo."

#~ msgid ""
#~ "To improve your dApp User Experience, you can track the user wallet\n"
#~ "changes, especially when the user changes the wallet account (or\n"
#~ "connects/disconnects). But also when the user changes the network. You\n"
#~ "could want to reload correct balances when the user changes the account,\n"
#~ "or to reset the state of your dApp when the user changes the network. To\n"
#~ "do so, you can use a previous hook we already looked at: `useAccount`\n"
#~ "and a new one `useNetwork`."
#~ msgstr ""
#~ "Para mejorar su experiencia de usuario de dApp, puede realizar un seguimiento de los cambios en la billetera del usuario, especialmente cuando el usuario cambia la cuenta de la billetera (o se "
#~ "conecta/desconecta). Pero tambi√©n cuando el usuario cambia de red. Es posible que desee recargar los saldos correctos cuando el usuario cambia de cuenta o restablecer el estado de su dApp cuando "
#~ "el usuario cambia de red. Para hacerlo, puede usar un hook anterior que ya vimos: `useAccount` y uno nuevo `useNetwork`."

#~ msgid ""
#~ "You also have additional information you can get from this hook ‚Üí\n"
#~ "**blockExplorer**, **testnet** which can give you more precise\n"
#~ "information about the current network being used."
#~ msgstr "Tambi√©n tienes informaci√≥n adicional que puedes obtener en este hook ‚Üí **blockExplorer**, **testnet** que pueden brindarle informaci√≥n m√°s precisa sobre la red que se utiliza actualmente."

#~ msgid ""
#~ "After knowing this you have all you need to track user interaction on\n"
#~ "the using account and network. You can use the `useEffect` hook to do\n"
#~ "some work on changes."
#~ msgstr ""
#~ "Despu√©s de saber esto, tendr√° todo lo que necesita para realizar un seguimiento de la interacci√≥n del usuario en la cuenta y la red que lo utiliza. Puede utilizar el hook `useEffect` para "
#~ "trabajar un poco en los cambios."

#~ msgid ""
#~ "const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
#~ "        abi: abi_erc20,\n"
#~ "        address: CONTRACT_ADDRESS,\n"
#~ "        functionName: \"allowance\",\n"
#~ "        args: [owner, spender],\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "    });"
#~ msgstr ""
#~ "const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
#~ "        abi: abi_erc20,\n"
#~ "        address: CONTRACT_ADDRESS,\n"
#~ "        functionName: \"allowance\",\n"
#~ "        args: [owner, spender],\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "    });"

#~ msgid ""
#~ "For ERC20 operations, Starknet React offers a convenient useBalance\n"
#~ "hook. This hook exempts you from passing an ABI and returns a suitably\n"
#~ "formatted balance value."
#~ msgstr "Para operaciones ERC20, Starknet React ofrece un conveniente useBalance como hook de equilibrio. Este hook lo exime de pasar una ABI y devuelve un valor de saldo con el formato adecuado."

#~ msgid ""
#~ "  const { data, isLoading } = useBalance({\n"
#~ "        address,\n"
#~ "        token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "      });\n"
#~ "\n"
#~ "      return (\n"
#~ "        <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
#~ "      )"
#~ msgstr ""
#~ "  const { data, isLoading } = useBalance({\n"
#~ "        address,\n"
#~ "        token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "      });\n"
#~ "\n"
#~ "      return (\n"
#~ "        <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
#~ "      )"

#~ msgid ""
#~ "The useContractWrite hook, designed for write operations, deviates\n"
#~ "slightly from wagmi. The unique architecture of Starknet facilitates\n"
#~ "multicall transactions natively at the account level. This feature\n"
#~ "enhances the user experience when executing multiple transactions,\n"
#~ "eliminating the need to approve each transaction individually. Starknet\n"
#~ "React capitalizes on this functionality through the useContractWrite\n"
#~ "hook. Below is a demonstration of its usage:"
#~ msgstr ""
#~ "El hook useContractWrite, dise√±ado para operaciones de escritura, se desv√≠a ligeramente de wagmi. La arquitectura √∫nica de Starknet facilita las transacciones multillamada de forma nativa a "
#~ "nivel de cuenta. Esta caracter√≠stica mejora la experiencia del usuario al ejecutar m√∫ltiples transacciones, eliminando la necesidad de aprobar cada transacci√≥n individualmente. Starknet React "
#~ "aprovecha esta funcionalidad mediante useContractWritehook. A continuaci√≥n se muestra una demostraci√≥n de su uso:"

#~ msgid ""
#~ "const calls = useMemo(() => {\n"
#~ "        // compile the calldata to send\n"
#~ "        const calldata = stark.compileCalldata({\n"
#~ "          argName: argValue,\n"
#~ "        });\n"
#~ "\n"
#~ "        // return a single object for single transaction,\n"
#~ "        // or an array of objects for multicall**\n"
#~ "        return {\n"
#~ "          contractAddress: CONTRACT_ADDRESS,\n"
#~ "          entrypoint: functionName,\n"
#~ "          calldata,\n"
#~ "        };\n"
#~ "    }, [argValue]);\n"
#~ "\n"
#~ "\n"
#~ "    // Returns a function to trigger the transaction\n"
#~ "    // and state of tx after being sent\n"
#~ "    const { write, isLoading, data } = useContractWrite({\n"
#~ "        calls,\n"
#~ "    });\n"
#~ "\n"
#~ "    function execute() {\n"
#~ "      // trigger the transaction\n"
#~ "      write();\n"
#~ "    }\n"
#~ "\n"
#~ "    return (\n"
#~ "      <button type=\"button\" onClick={execute}>\n"
#~ "        Make a transaction\n"
#~ "      </button>\n"
#~ "    )"
#~ msgstr ""
#~ "const calls = useMemo(() => {\n"
#~ "        // compile the calldata to send\n"
#~ "        const calldata = stark.compileCalldata({\n"
#~ "          argName: argValue,\n"
#~ "        });\n"
#~ "\n"
#~ "        // return a single object for single transaction,\n"
#~ "        // or an array of objects for multicall**\n"
#~ "        return {\n"
#~ "          contractAddress: CONTRACT_ADDRESS,\n"
#~ "          entrypoint: functionName,\n"
#~ "          calldata,\n"
#~ "        };\n"
#~ "    }, [argValue]);\n"
#~ "\n"
#~ "\n"
#~ "    // Returns a function to trigger the transaction\n"
#~ "    // and state of tx after being sent\n"
#~ "    const { write, isLoading, data } = useContractWrite({\n"
#~ "        calls,\n"
#~ "    });\n"
#~ "\n"
#~ "    function execute() {\n"
#~ "      // trigger the transaction\n"
#~ "      write();\n"
#~ "    }\n"
#~ "\n"
#~ "    return (\n"
#~ "      <button type=\"button\" onClick={execute}>\n"
#~ "        Make a transaction\n"
#~ "      </button>\n"
#~ "    )"

#~ msgid ""
#~ "The code snippet begins by compiling the calldata using the\n"
#~ "compileCalldata utility provided by Starknet.js. This calldata, along\n"
#~ "with the contract address and entry point, are passed to the\n"
#~ "useContractWrite hook. The hook returns a write function that is\n"
#~ "subsequently used to execute the transaction. The hook also provides the\n"
#~ "transaction‚Äôs hash and state."
#~ msgstr ""
#~ "El fragmento de c√≥digo comienza compilando los datos de llamada utilizando la utilidad compileCalldata proporcionada por Starknet.js. Estos datos de llamada, junto con con la direcci√≥n del "
#~ "contrato y el punto de entrada, se pasan al hook useContractWrite. El hook devuelve una funci√≥n de escritura que posteriormente se utiliza para ejecutar la transacci√≥n. El hook tambi√©n "
#~ "proporciona el hash y el estado de la transacci√≥n."

#~ msgid ""
#~ "The useTransaction hook allows for the tracking of transaction states\n"
#~ "given a transaction hash. This hook maintains a cache of all\n"
#~ "transactions, thereby minimizing redundant network requests."
#~ msgstr ""
#~ "El gancho useTransaction permite el seguimiento de los estados de las transacciones dado un hash de transacci√≥n. Este enlace mantiene un cach√© de todas las transacciones, minimizando as√≠ las "
#~ "solicitudes de red redundantes."

#~ msgid ""
#~ "const { data, isLoading, error } = useTransaction({ hash: txHash });\n"
#~ "\n"
#~ "    return (\n"
#~ "      <pre>\n"
#~ "        {JSON.stringify(data?.calldata)}\n"
#~ "      </pre>\n"
#~ "    )"
#~ msgstr ""
#~ "const { data, isLoading, error } = useTransaction({ hash: txHash });\n"
#~ "\n"
#~ "    return (\n"
#~ "      <pre>\n"
#~ "        {JSON.stringify(data?.calldata)}\n"
#~ "      </pre>\n"
#~ "    )"

#~ msgid ""
#~ "Through the diligent work of dedicated developers and contributors,\n"
#~ "Starknet React continues to evolve. New features and optimizations are\n"
#~ "regularly added, fostering a dynamic and growing ecosystem of\n"
#~ "decentralized applications."
#~ msgstr ""
#~ "Gracias al trabajo diligente de desarrolladores y colaboradores dedicados, Starknet React contin√∫a evolucionando. Regularmente se agregan nuevas funciones y optimizaciones, lo que fomenta un "
#~ "ecosistema din√°mico y en crecimiento de aplicaciones descentralizadas."

#~ msgid ""
#~ "It‚Äôs a fascinating journey, filled with innovative technology, endless\n"
#~ "opportunities, and a growing community of passionate individuals. As a\n"
#~ "developer, you‚Äôre not only building applications, but contributing to\n"
#~ "the advancement of a global, decentralized network."
#~ msgstr ""
#~ "Es un viaje fascinante, lleno de tecnolog√≠a innovadora, infinitas oportunidades y una comunidad creciente de personas apasionadas. Como desarrollador, no solo crea aplicaciones, sino que tambi√©n "
#~ "contribuye al avance de una red global y descentralizada."

#~ msgid ""
#~ "Have questions or need help? The Starknet community is always ready to\n"
#~ "assist. Join the [Starknet Discord](https://discord.gg/starknet) or\n"
#~ "explore the [StarknetBook‚Äôs GitHub\n"
#~ "repository](https://github.com/starknet-edu/starknetbook) for resources\n"
#~ "and support."
#~ msgstr ""
#~ "¬øTienes alguna pregunta o necesita ayuda? La comunidad Starknet siempre est√° lista para\n"
#~ "asistir. √önase a [Starknet Discord](https://discord.gg/starknet) o\n"
#~ "explore el [GitHub de StarknetBook\n"
#~ "repositorio](https://github.com/starknet-edu/starknetbook) para recursos\n"
#~ "y apoyo."

#~ msgid "## Further Reading"
#~ msgstr "## Otras Lecturas"

#~ msgid ""
#~ "- [Starknet.js](https://starknet.js.org)\n"
#~ "\n"
#~ "- [Starknet React Docs](https://www.apibara.com/starknet-react-docs)\n"
#~ "\n"
#~ "- [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)\n"
#~ "\n"
#~ "- [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"
#~ msgstr ""
#~ "- [Starknet.js](https://starknet.js.org)\n"
#~ "\n"
#~ "- [Starknet React Docs](https://www.apibara.com/starknet-react-docs)\n"
#~ "\n"
#~ "- [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)\n"
#~ "\n"
#~ "- [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"

#, fuzzy
#~ msgid ""
#~ "In this subchapter, readers will find practical examples demonstrating the usage of `starknet-react`. It provides insight into real-world applications and serves as a guide for developers to "
#~ "understand and implement these tools effectively."
#~ msgstr ""
#~ "En este subcap√≠tulo, los lectores encontrar√°n ejemplos pr√°cticos que demuestran el uso de \"starknet-js\" y \"starknet-react\". Proporciona informaci√≥n sobre aplicaciones del mundo real y sirve "
#~ "como gu√≠a para que los desarrolladores comprendan e implementen estas herramientas de manera efectiva."

#~ msgid ""
#~ "```bash\n"
#~ "npm add @starknet-react/core\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npm add @starknet-react/core\n"
#~ "```"

#~ msgid "Starknet React library provides the `create-starknet` script that streamlines the setup of a Starknet application using TypeScript:"
#~ msgstr "La biblioteca Starknet React proporciona el script `create-starknet` que agiliza la configuraci√≥n de una aplicaci√≥n Starknet usando TypeScript:"

#~ msgid ""
#~ "```bash\n"
#~ "npx create-starknet erc20_web --use-npm\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npx create-starknet erc20_web --use-npm\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```sh\n"
#~ "snforge\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel\n"
#~ "```"

#~ msgid "## Forge"
#~ msgstr "## Forge"
