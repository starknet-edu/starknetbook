= Signing and a Standard Account Contract

In this chapter, we build upon our exploration of account contracts in StarkNet by introducing a more complex account contract. This Standard Account Contract includes additional features such as signature validation, providing a more robust example of an account contract in Cairo language. You can find the full code for this contract in the Book repository (todo: add link). You can interact and compile the contract using Scarb (review the Scarb subchapter in Chapter 2 of the Book for more information).

[,Rust]
----
// Import necessary modules and traits
use serde::Serde;
use starknet::ContractAddress;
use array::ArrayTrait;
use array::SpanTrait;
use option::OptionTrait;

// Define the Account contract
#[account_contract]
mod Account {
    use array::ArrayTrait;
    use array::SpanTrait;
    use box::BoxTrait;
    use ecdsa::check_ecdsa_signature;
    use option::OptionTrait;
    use super::Call;
    use starknet::ContractAddress;
    use zeroable::Zeroable;
    use serde::ArraySerde;

    // Define the contract's storage variables
    struct Storage {
        public_key: felt252
    }

    // Constructor function for initializing the contract
    #[constructor]
    fn constructor(public_key_: felt252) {
        public_key::write(public_key_);
    }
    
    // Internal function to validate the transaction signature
    fn validate_transaction() -> felt252 {
        let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
        let signature = tx_info.signature; // Extract signature
        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length

        // Verify ECDSA signature
        assert(
            check_ecdsa_signature(
                message_hash: tx_info.transaction_hash, 
                public_key: public_key::read(),
                signature_r: *signature[0_u32],
                signature_s: *signature[1_u32],
            ),
            'INVALID_SIGNATURE',
        );

        starknet::VALIDATED // Return validation status
    }

    // Validate contract deployment
    #[external]
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key_: felt252
    ) -> felt252 {
        validate_transaction()
    }

    // Validate contract declaration
    #[external]
    fn __validate_declare__(class_hash: felt252) -> felt252 {
        validate_transaction()
    }

    // Validate contract execution
    #[external]
    fn __validate__(
        contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array<felt252>
    ) -> felt252 {
        validate_transaction()
    }

    // Execute a contract call
    #[external]
    #[raw_output]
    fn __execute__(mut calls: Array<Call>) -> Span<felt252> {
        // Validate caller
        assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');

        let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
        assert(tx_info.version != 0, 'INVALID_TX_VERSION');

        assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported
        let Call{to, selector, calldata } = calls.pop_front().unwrap();

        // Call the target contract
        starknet::call_contract_syscall(
            address: to, entry_point_selector: selector, calldata: calldata.span()
        ).unwrap_syscall()
    }
}

// Define the Call struct
#[derive(Drop, Serde)]
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Array<felt252>
}
----

== Understanding ECDSA Signature

The Elliptic Curve Digital Signature Algorithm (ECDSA) is a cryptographic algorithm used by many blockchains to ensure data integrity and authenticate the sender. ECDSA is a variant of the Digital Signature Algorithm (DSA) but uses elliptic curve cryptography which provides better security with shorter keys compared to DSA.

An ECDSA signature consists of two components, often denoted as r and s. Together, they form the signature for a given input. These values are computed using the signer's private key and the hash of the message (in this context, the transaction) being signed.

=== signature_r and signature_s

In the context of the Standard Account Contract, signature_r and signature_s are the two components of the ECDSA signature that are used in the check_ecdsa_signature function to verify the validity of the transaction.

* signature_r (r): This is a randomly generated number used during the signing process. It should be unique for each signature; reusing 'r' with different messages can expose the private key.
* signature_s (s): This is calculated from r, the private key, and the hash of the message. The 's' value is unique to each signature as well.

The check_ecdsa_signature function takes these two values, along with the public key of the signer and the hash of the message, to verify the signature. If the signature is valid, it means that the message was indeed signed by the owner of the private key and has not been tampered with.

[source,rust]
----
        assert(
            check_ecdsa_signature(
                message_hash: tx_info.transaction_hash, 
                public_key: public_key::read(),
                signature_r: *signature[0_u32],
                signature_s: *signature[1_u32],
            ),
            'INVALID_SIGNATURE',
        );
----

In the above code snippet, the check_ecdsa_signature function is used to assert that the transaction signature is valid. If the signature is invalid, the assertion will fail, and 'INVALID_SIGNATURE' will be returned.


== Contract Structure

=== Storage

In our standard account contract, we define one storage variable: public_key. This will help us to validate the signature of the transaction. The public key is stored as a felt252, which is a 252-bit unsigned integer. The public key is written to storage in the constructor function. The public key is read from storage in the validate_transaction function.

[source,rust]
----
struct Storage {
    public_key: felt252
}
----

=== Constructor

The constructor function is used to initialize the contract. In this case, it writes the provided public key to the contract's storage.

[source,rust]
----
#[constructor]
fn constructor(public_key_: felt252) {
    public_key::write(public_key_);
}
----

=== validate_transaction

This internal function is used to validate the transaction signature. It extracts the signature from the transaction info and checks its length. Then, it verifies the ECDSA signature. If the signature is valid, it returns starknet::VALIDATED. Otherwise, it returns an error. This function is called by the __validate_deploy__, __validate_declare__, and __validate__ functions.

This function is optional. You can choose to omit it if you do not need to validate the transaction signature. However, it is recommended to include it in your account contract to ensure that the transaction is valid and you can reuse it for all three validation functions.

[source,rust]
----
fn validate_transaction() -> felt252 {
        let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
        let signature = tx_info.signature; // Extract signature
        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length

        // Verify ECDSA signature
        assert(
            check_ecdsa_signature(
                message_hash: tx_info.transaction_hash, 
                public_key: public_key::read(),
                signature_r: *signature[0_u32],
                signature_s: *signature[1_u32],
            ),
            'INVALID_SIGNATURE',
        );

        starknet::VALIDATED // Return validation status
    }
----

=== Call Struct

The Call struct defines the parameters for a contract call. These parameters include the target contract address (to), the function to call (selector), and the function's arguments (calldata). The Call struct is used in the __execute__ function.

[source,rust]
----
#[derive(Drop, Serde)]
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Array<felt252>
}
----

=== execute

This external function executes a transaction after successful validation. It ensures that the caller is valid, the transaction version is non-zero, and only single calls are supported. Then, it forwards the call to the target contract. In this function the contract creator can add multiple calls to different contracts or to the same contract (multicall). The function returns the output of the target contract.

[source,rust]
----
    #[external]
    #[raw_output]
    fn __execute__(mut calls: Array<Call>) -> Span<felt252> {
        // Validate caller
        assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');

        let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info
        assert(tx_info.version != 0, 'INVALID_TX_VERSION');

        assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported
        let Call{to, selector, calldata } = calls.pop_front().unwrap();

        // Call the target contract
        starknet::call_contract_syscall(
            address: to, entry_point_selector: selector, calldata: calldata.span()
        ).unwrap_syscall()
    }
----

== Declaring and Deploying the Hello World Account Contract

The declaring and deploying process is the same as with other contracts. Before declaring and deploying the Hello World account contract, you must first have an account contract set up to manage the deployment process. To learn more about deploying an account contract, refer to the subchapter on deploying in Chapter 2 of the Book.

Remember to compile using `scarb build` (refer to the Scarb subchapter in Chapter 2 of the Book). Then follow the steps below to declare and deploy the Hello World account contract:

* Export the required environment variables:

[source,bash]
----
export STARKNET_NETWORK=alpha-goerli
export STARKNET_WALLET=starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount
----

* Declare the contract (since the contract is already declared, you can skip this step. If you want to declare it anyway, run the following command but you will receive an error):

[source,bash]
----
starknet declare --contract target/release/starknetbook_chapter_7_Account.json --account vote_admin --max_fee 100000000000000000
----

The class hash is: 0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1

* Deploy the contract:

[source,bash]
----
starknet deploy --class_hash 0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1 --account vote_admin --max_fee 100000000000000000
----

After completing these steps, you will have successfully declared and deployed the Hello World account contract on StarkNet. https://testnet.starkscan.co/contract/0x01e6d7698ca76788c8f9c1091ec3d6d3f7167a9effe520402d832ca9894eba4a#overview[Here is a deployed version].

[NOTE]
====
Elliptic Curve Digital Signature Algorithm (ECDSA) is a popular choice for ensuring data integrity and sender authenticity in blockchain networks, but it's not the only option. Other alternatives include:

* EdDSA (Edwards-curve Digital Signature Algorithm): EdDSA is another form of elliptic curve cryptography that is designed to be faster and more secure than ECDSA. EdDSA uses twisted Edwards curves, which have strong security properties and allow for more efficient computations. An example of EdDSA in use is Monero.

* Schnorr Signatures: Schnorr signatures offer a level of security similar to ECDSA but with shorter signatures. They have the additional property of being linear, which allows for signature aggregation and multi-signatures. This can lead to increased efficiency and privacy. Bitcoin developers have proposed adding Schnorr signatures to the Bitcoin protocol with the Taproot upgrade.

* RSA (Rivest–Shamir–Adleman): RSA is an older cryptographic algorithm that is widely used for secure data transmission. However, RSA requires larger key sizes for equivalent security levels, making it less efficient than elliptic curve techniques. RSA is not commonly used in modern blockchain systems, but it is still used in many traditional secure communication protocols.

* BLS (Boneh-Lynn-Shacham) Signatures: BLS signatures, like Schnorr, allow for signature aggregation, making them useful in systems that require a large number of signatures. This property makes BLS signatures particularly useful for consensus algorithms in distributed systems and blockchains, such as Ethereum 2.0.

* Post-Quantum Cryptography: With the advent of quantum computing, researchers are developing new cryptographic algorithms that are resistant to quantum attacks. One example are the STARKs used in Starknet.

Each of these alternatives has its strengths and weaknesses in terms of security, efficiency, complexity, and mathematical properties.
====

== Summary

In this chapter, we expanded on our understanding of account contracts in StarkNet by examining a more complex "Standard Account Contract". We dove into the various components of the contract and learned how they work together to validate and execute transactions.
