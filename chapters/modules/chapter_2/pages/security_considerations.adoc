[id="functions"]

= Security Considerations in Cairo 1.0

As in any blockchain programming language, in Cairo you need to be aware about smart contracts vulnerabilities to protect your developments against
threats that could damage the trust your users put on your systems. 

This guide will try to explain some of them applied to Starknet and Cairo so that you can prevent them from affecting your contracts.

== 1. Access Control.
An inadecuate function access control could lead to unintended smart contract behaviors. 
In the next example, you have a mint_tokens function without access control which will lead to anyone can mint new tokens.

[source,rust]
----
#[external]
fn mint_tokens(mount: u256) {
    total_supply::write(total_supply::read() + amount);
}
----

**Recommendation.**

Add an addecuate access control to fit your needs (a custom made or using template as those 
from https://docs.openzeppelin.com/contracts-cairo/0.6.1/access[OpenZeppelin,window=_blank].

In our example we could add an owner variable, set owner value in contructor and add an assert 
condition in mint_token to ensure only owner can mint new tokens.
[source,rust]
----
struct Storage {
    owner: ContractAddress,
}

#[constructor]
fn constructor(){
    let sender = get_caller_address();
    owner::write(sender)
}
#[external]
fn mint_tokens(amount: u256) {
    let sender = get_caller_address();
    assert(sender == owner::read());
    total_supply::write(total_supply::read() + amount);
}
----

== 2. Reentrancy.
This is a recursive call between contracts which could happens when a contract A call a contract B and this contract
callback contract A again before this could update relevant variables (like balances or limits). We may need to implement
callback functions in many ERC standars with safeTransfer functions (ERC721, ERC777, ERC1155, ERC223, etc) or in flashloans where 
lender contracts will callback the borrower contract to use and return funds.

In the next example, in a game all whitelisted addresses can mint one NFT sword and execute an on_receive_sword() function to use it
before return to the contract. But this NFT contract is vulnerable and you can mint all NFT swords.

[source,rust]
----
#[constructor]
fn constructor() {
    available_swords::write(100);
    return();
}

#[external]
fn mint_one_sword() {
    let sender = get_caller_address();
    if whitelisted::read(sender)==true {
        // Update sword count
        let sword_count = available_swords::read();
        available_swords::write(sword_count - 1);
        // Mint one sword to caller
        sword::write(sender,1)
        // Callback to sender
        let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword();
        // remove sender from whitelist
        whitelisted::write(sender,false);
    }
    return();
}
----

And caller contract implements on_receive_sword to abuse vulnerable function and mint 10 swords:

[source,rust]
----
#[external]
fn on_receive_sword() {
    let nft_sword_contract = get_caller_address();
    let call_number: felt252 = total_calls::read();
    total_calls::write(call_number + 1)
    if call_number<10 {
        let call = ISwordDispatcher { contract_address: nft_sword_contract }.mint_one_sword();
    }
    return();
}
----

**Recommendation.**

Always follow check-effect-interact pattern to ensure you update relevant data before to callback the caller contract.
In our example, set whitelisted before to call external function.
[source,rust]
----
if whitelisted::read(sender)==true {
    // Update sword count
    let sword_count = available_swords::read();
    available_swords::write(sword_count - 1);
    // Mint one sword to caller
    sword::write(sender,1)
    // remove sender from whitelist (before call external function)
    whitelisted::write(sender,false);
    // Callback to sender (after set all effects)
    let callback = ICallerDispatcher { contract_address: sender }.on_receive_sword();
}
----

== 3.Tx.Origin Authentication.
Solidity's __Tx.Origin__ statement is a global variable who stores the address of transaction initiator while __msg.sender__
is a variable who stores the address of transaction caller. 

In Cairo 1.0, we have __account_contract_address__ and __get_caller_address__ function which implements the same concepts.

So, if we use account_contract_address to authenticate functions on our smart contracts, we may lead to "phishing attacks" from
attacker who build custom smart contracts and tricking users put them in the middle of a transaction call.

For example, we have a Cairo smart contract which let transfer funds to the owner and use account_contract_address to 
authenticate permission:

[source,rust]
----
use starknet::get_caller_address;
use box::BoxTrait;

struct Storage {
    owner: ContractAddress,
}

#[constructor]
fn constructor(){
    // Set contract deployer as the owner
    let contract_deployer = get_caller_address();
    owner::write(contract_deployer)
}

#[external]
fn transferTo(to: ContractAddress, amount: u256) {
    let tx_info = starknet::get_tx_info().unbox();
    let authorizer: ContractAddress = tx_info.account_contract_address;
    assert(authorizer == owner::read());
    balance::write(to + amount);
}
----
So, if an attacker tricks the owner to use a malicious contract, attacker could call function impersonating contract owner.
Example of a custom malicious contract which will transfer funds to an attacker's controled account:
[source,rust]
----
mod malicious_contract {
...
...
    #[external]
    fn transferTo(to: ContractAddress, amount: u256) {
        let callback = ICallerDispatcher { contract_address: sender }.transferTo(ATTACKER_ACCOUNT, amount);
    }
}
----
**Recommendation.**

In **transferTo** function replace __account_contract_address__ (origin) authentication with __get_caller_address__ (sender):

[source,rust]
----
use starknet::get_caller_address;

struct Storage {
    owner: ContractAddress,
}

#[constructor]
fn constructor(){
    // Set contract deployer as the owner
    let contract_deployer = get_caller_address();
    owner::write(owner_adcontract_deployerdress)
}

#[external]
fn transferTo(to: ContractAddress, amount: u256) {
    let authorizer = get_caller_address();
    assert(authorizer == owner::read());
    balance::write(to + amount);
}
----

== To Do:
=== 4. Overflow/Underflow.
=== 5. Storage Collition.
=== 6. Flash Loan Attacks.
=== 7. Oracle Manipulation.
=== 8. Bad Randomness
=== 9. Deny of Services
=== 10. Untrusted Delegate Calls.
=== 11. Public Burn.

== Contributing

[quote, The Starknet Community]
____
*Unleash Your Passion to Perfect StarkNetBook*

StarkNetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others.

Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc[guidelines] and join our vibrant community. Let's fearlessly build Starknet! 
____