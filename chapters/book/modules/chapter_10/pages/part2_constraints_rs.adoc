_Copyright 2019 StarkWare Industries Ltd. Licensed under the Apache
License, Version 2.0 (the "License"). You may not use this file except
in compliance with the License. You may obtain a copy of the License at
https://www.starkware.co/open-source-license/ Unless required by
applicable law or agreed to in writing, software distributed under the
License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License._

== Part 2: Constraints

* https://www.youtube.com/watch?v=fg3mFPXEYQY[Video Lecture (youtube)]
* https://starkware.co/wp-content/uploads/2021/12/STARK101-Part2.pdf[Slides
(PDF)]

In this part, we are going to create a set of constraints over the trace
`a`. The constraints will be expressions in the trace's cells that are
polynomials (rather than
https://en.wikipedia.org/wiki/Rational_function[rational functions]) if
and only if the trace represents a valid computation of the FibonacciSq.
We will get there in three steps:

. Start by specifying the constraints we care about (the *FibonacciSq
constraints*).
. Translate the FibonacciSq constraints into *polynomial constraints*.
. Translate those into *rational functions* that represent polynomials
if and only if the original constraints hold.

== Step 1 - FibonacciSq Constraints

For `a` to be a correct trace of a FibonacciSq sequence that proves our
claim:

. The first element has to be 1, namely latexmath:[a[0] = 1].
. The last element has to be 2338775057, namely
latexmath:[a[1022] = 2338775057].
. The FibonacciSq rule must apply, that is - for every
latexmath:[i<1021], latexmath:[a][i+2]=a[i+1]²+a[i]².

== Step 2 - Polynomial Constraints

Recall that `f` is a polynomial over the trace domain, that evaluates
exactly to `a` over latexmath:[$G \setminus \{g^{1023}\}$] where
latexmath:[$G=\{g^i : 0\leq i\leq 1023\}$] is the "small" group
generated by latexmath:[$g$].

We now rewrite the above three constraints in a form of polynomial
constraints over `f`:

. latexmath:[a[0] = 1] is translated to the polynomial
latexmath:[$f(x) - 1$], which evalutes to 0 for latexmath:[$x = g^0$]
(note that latexmath:[$g^0$] is latexmath:[$1$]).
. latexmath:[a[1022] = 2338775057] is translated to the polynomial
latexmath:[$f(x) - 2338775057$], which evalutes to 0 for
latexmath:[$x = g^{1022}$].
. latexmath:[a][i+2]=a[i+1]²+a[i]² for every latexmath:[$i<1021$] is
translated to the polynomial
latexmath:[$f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2$], which
evaluates to 0 for
latexmath:[$x \in G \backslash \{g^{1021}, g^{1022}, g^{1023}\}$].

== Hands on

First, since this is a separate notebook from Part 1, let's run the
following piece of code to have all the variables here with their
correct values. Note that it may take up to 30 seconds, since it reruns
the polynomial interpolation.

[source,rust]
----
:dep stark101-rs = { path = "stark101" }
:dep sha256 = "1.1.2"
use stark101_rs::{field::FieldElement, channel::Channel, polynomial::{Polynomial, x}};
use stark101_rs::parts::part1();

let (a, g, G, h, H, eval_domain, f, f_eval, f_merkle, channel) = part1();
println!("Success!");
----

....
Success!
....

You will obtain each of the three constraints as a quotient of two
polynomials, making sure the remainder is the zero polynomial.

== Step 3 - Rational Functions (That are in Fact Polynomials)

Each of the constraints above is represented by a polynomial
latexmath:[$u(x)$] that supposedly evaluates to latexmath:[$0$] on
certain elements of the group latexmath:[$G$]. That is, for some
latexmath:[$x_0, \ldots, x_k \in G$], we claim that

[latexmath]
++++
\[u(x_0) = \ldots = u(x_k) = 0\]
++++

(note that for the first two constaints, latexmath:[$k=0$] because they
only refer to one point and for the third latexmath:[$k=1021$]).

This is equivalent to saying that latexmath:[$u(x)$] is divisible, as a
polynomial, by all of latexmath:[$\{(x-x_i)\}_{i=0}^k$], or,
equivalently, by

[latexmath]
++++
\[\prod_{i=0}^k (x-x_i)\]
++++

Therefore, each of the three constraints above can be written as a
rational function of the form:

[latexmath]
++++
\[\frac{u(x)}{\prod_{i=0}^k (x-x_i)}\]
++++

for the corresponding latexmath:[$u(x)$] and
latexmath:[$\{x_i\}_{i=0}^k$]. In this step we will construct these
three rational functions and show that they are indeed polynomials.

== The First Constraint:

In the first constraint, latexmath:[$f(x) - 1$] and
latexmath:[$\{x_i\} = \{1\}$].

We will now construct the *polynomial*
latexmath:[$p_0(x)=\frac{f(x) - 1}{x - 1}$], making sure that
latexmath:[$f(x) - 1$] is indeed divisible by latexmath:[$(x-1)$].

[source,rust]
----
// First constraint. Construct numer0 and denom0.
let numer0: Polynomial = todo!();
let denom0: Polynomial = todo!();
----

Solution:

[source,rust]
----
let numer0: Polynomial = f.clone() - FieldElement::one();
let denom0: Polynomial = x() - FieldElement::one();
----

Convince yourself that latexmath:[$f(x) - 1$] vanishes at
latexmath:[$x=1$] by making sure that evaluating this polynomial at
latexmath:[$1$] yields latexmath:[$0$]:

[source,rust]
----
todo!("You should evaluate f(x) - 1 at x = 1");
----

The fact that latexmath:[$f(x) - 1$] has a root at latexmath:[$1$]
implies that it is divisible by latexmath:[$(x - 1)$]. Run the following
cell to convince yourself that the remainder of `numer0` modulo `denom0`
is latexmath:[$0$], and therefore division indeed yields a polynomial:

[source,rust]
----
numer0.clone() % denom0.clone()
----

....
Polynomial([])
....

Run the following cell to construct `p0`, the polynomial representing
the first constraint, by dividing `numer0` by `denom0`:

[source,rust]
----
let p0: Polynomial = numer0 / denom0;
----

Run test:

[source,rust]
----
assert_eq!(p0(2718), 2509888982);
println!("Success!");
----

....
Success!
....

== The Second Constraint

Construct the polynomial `p1` representing the second constraint,
latexmath:[$p_1(x)= \frac{f(x) - 2338775057}{x - g^{1022}}$], similarly:

[source,rust]
----
// Second constraint.
let p1: Polynomial = todo!();
----

Solution:

[source,rust]
----
let numer1: Polynomial = f.clone() - FieldElement::new(2338775057);
let denom1: Polynomial = x() - g.pow(1022usize);
let p1: Polynomial = numer1 / denom1.clone();
----

Run test:

[source,rust]
----
assert_eq!(p1(5772), 232961446);
println!("Success!");
----

....
Success!
....

== The Third Constraint - Succinctness

The last constraint's rational function is slightly more complicated:

[latexmath]
++++
\[p_2(x) = \frac{f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2}{\prod\limits_{i=0}^{1020} (x-g^i)}\]
++++

whose denominator can be rewritten, so that the entire expression is
easier to compute:

[latexmath]
++++
\[\frac{f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2}{\frac{x^{1024} - 1}{(x-g^{1021})(x-g^{1022})(x-g^{1023})}}\]
++++

This follows from the equality

[latexmath]
++++
\[\prod\limits_{i=0}^{1023} (x-g^i) = x^{1024} - 1\]
++++

Convince yourself of this equality using the function `prod` that takes
a list and computes its product:

[source,rust]
----
// Construct a list `lst` of the linear terms (x-g**i):
let lst: Vec<Polynomial> = todo!();
// Compute the product of `lst` and see that it is indeed the succinct polynomial x**1024 - 1
Polynomial::prod(&lst);
----

....
thread '<unnamed>' panicked at 'not yet implemented', src/lib.rs:134:28
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: core::panicking::panic
   3: <core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once
   4: _run_user_code_14
   5: evcxr::runtime::Runtime::run_loop
   6: evcxr::runtime::runtime_hook
   7: evcxr_jupyter::main
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
....

Solution:

[source,rust]
----
let lst: Vec<Polynomial> = (0..1024).into_iter().map(|i| x() - g.pow(i)).collect();
Polynomial::prod(&lst)
----

....
Polynomial([FieldElement(3221225472), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(0), FieldElement(1)])
....

For more information, see our blog post titled
https://medium.com/starkware/arithmetization-ii-403c3b3f4355[Arithmetization
II].

Let's pause for a moment, and look at a simple example on how
polynomials are composed. After that we will generate the third
constraint.

== Composing Polynomials (a detour)

Create the two polynomials latexmath:[$q(x) = 2x^2 +1$],
latexmath:[$r(x) = x - 3$]:

[source,rust]
----
let q: Polynomial = x().pow(2)*2usize + 1;
let r = x() - 3usize;
----

Composing latexmath:[$q$] on latexmath:[$r$] yields a new polynomial:
latexmath:[$q(r(x)) = 2(x-3)^2 + 1 = 2x^2-12x+19$] Run the following
cell to create a third polynomial `cmp` by composing `q` on `r` and
convince yourself that `cmp` is indeed the composition of `q` and `r`:

[source,rust]
----
let cmp = q(r);
cmp
----

....
Polynomial([FieldElement(19), FieldElement(3221225461), FieldElement(2)])
....

== Back to Polynomial Constraints

Construct the third constraint `p2` in a similar manner to the
construction of `p0` and `p1`, using polynomial composition. Along the
way, verify that latexmath:[$g^{1020}$] is a root of the *numerator*
while latexmath:[$g^{1021}$] is not.

[source,rust]
----
let p2: Polynomial = todo!();
----

Solution:

[source,rust]
----
let numer_1: Polynomial = f(x() * g.pow(2));
let numer_2: Polynomial = f(x() * g).pow(2) * FieldElement::new((-1 + FieldElement::k_modulus() as i128) as usize);
let numer_3: Polynomial = f.pow(2) * FieldElement::new((-1 + FieldElement::k_modulus() as i128) as usize);
let numer2: Polynomial = numer_1 + numer_2 + numer_3;
println!("Numerator at g^1020 is {:?}", numer2.clone()(g.pow(1020)));
println!("Numerator at g^1021 is {:?}", numer2(g.pow(1021usize)));
let denom2 = (x().pow(1024usize) - 1) / ((x() - g.pow(1021)) * (x() - g.pow(1022)) * (x() - g.pow(1023)));

let p2: Polynomial = numer2 / denom2;
----

....
Numerator at g^1020 is FieldElement(0)
Numerator at g^1021 is FieldElement(230576507)
....

Run test:

[source,rust]
----
let p2_degree = p2.degree();
assert_eq!(p2.degree(), 1023, "The degree of the third constraint is {p2_degree} when it should be 1023.");
assert_eq!(p2(31415), 2090051528);
println!("Success!");
----

....
Success!
....

Run the following cell to observe the degrees of the constraint
polynomials `p0`, `p1` and `p2`, all less than latexmath:[$1024$]. This
will be important in the next part.

[source,rust]
----
println!("deg p0 = {}", p0.degree());
println!("deg p1 = {}", p1.degree());
println!("deg p2 = {}", p2.degree());
----

....
deg p0 = 1021
deg p1 = 1021
deg p2 = 1023
....

== Step 4 - Composition Polynomial

Recall that we're translating a problem of checking the validity of
three polynomial constraints to checking that each of the rational
functions latexmath:[$p_0, p_1, p_2$] are polynomials.

Our protocol uses an algorithm called
https://eccc.weizmann.ac.il/report/2017/134/[FRI] to do so, which will
be discussed in the next part. In order for the proof to be succinct
(short), we prefer to work with just one rational function instead of
three. For that, we take a random linear combination of
latexmath:[$p_0, p_1, p_2$] called the *compostion polynomial* (CP for
short):

[latexmath]
++++
\[CP(x) = \alpha_0 \cdot p_0(x) + \alpha_1 \cdot p_1(x) + \alpha_2 \cdot  p_2(x)\]
++++

where latexmath:[$\alpha_0, \alpha_1, \alpha_2$] are random field elements obtained
from the verifier, or in our case - from the channel.

Proving that (the rational function) latexmath:[$CP$] is a polynomial
guarantess, with high probability, that each of latexmath:[$p_0$],
latexmath:[$p_1$], latexmath:[$p_2$] are themselves polynomials.

In the next part, you will generate a proof for an equivalent fact. But
first, let's create `CP` using `Channel.receive_random_field_element` to
obtain latexmath:[$\alpha_i$]:

[source,rust]
----
// Note that alpha0, alpha1, alpha2 have to be drawn from the channel in this order.
fn get_CP(p1: Polynomial, p2: Polynomial, p3: Polynomial, channel: Channel) -> Polynomial {
    todo!();
}
----

Solution:

[source,rust]
----
fn get_CP(p0: Polynomial, p1: Polynomial, p2: Polynomial, channel: &mut Channel) -> Polynomial {
    let alpha0 = channel.receive_random_field_element();
    let alpha1 = channel.receive_random_field_element();
    let alpha2 = channel.receive_random_field_element();
    (p0 * alpha0) + (p1 * alpha1) + (p2 * alpha2)
}
----

Run test:

[source,rust]
----
let mut test_channel: Channel = Channel::new();
let cp_test = get_CP(p0, p1, p2, &mut test_channel);
let cp_test_degree = cp_test.degree();
assert_eq!(cp_test.degree(), 1023, "The degree of cp is {cp_test_degree} when it should be 1023.");
let expected = cp_test(2439804);
assert_eq!(cp_test(2439804), 838767343, "cp(2439804) = {expected:?}, when it should be 838767343");
println!("Success!");
----

....
Success!
....

== Commit on the Composition Polynomial

Lastly, we evaluate latexmath:[$cp$] over the evaluation domain
(`eval_domain`), build a Merkle tree on top of that and send its root
over the channel. This is similar to commiting on the LDE trace, as we
did at the end of part 1.

[source,rust]
----
// Fix this. CP_eval is the evaluation of CP on all the points in domain. For a hint - look at "Evaluate on a Coset" on part 1.
fn cp_eval(p0: Polynomial, p1: Polynomial, p2: Polynomial, domain: Vec<FieldElement>, channel: &mut Channel) {
    let cp = get_CP(p0, p1, p2, channel);
    todo!();
}
----

Solution:

[source,rust]
----
fn cp_eval(p0: Polynomial, p1: Polynomial, p2: Polynomial, domain: Vec<FieldElement>, channel: &mut Channel) -> Vec<FieldElement> {
    let cp = get_CP(p0, p1, p2, channel);
    domain.into_iter().map(|d| cp(d)).collect()
}
----

Construct a Merkle Tree over the evaluation and send its root over the
channel.

[source,rust]
----
let channel = Channel::new();
let cp_merkle = MerkleTree::new(todo!()); // Fix this line
channel.send(cp_merkle.root);
----

Solution:

[source,rust]
----
use stark101_rs::merkle_tree::MerkleTree;
let mut channel = Channel::new();
let cp_merkle: MerkleTree = MerkleTree::new(cp_eval(p0, p1, p2, eval_domain, &mut channel));
channel.send(cp_merkle.root());
----

Test your code:

[source,rust]
----
assert_eq!(cp_merkle.root(), "26db4de93f69af9591eac0bf224a26f5ffd99d07a325b82ee34381069a205a53", "Merkle tree root is wrong.");
println!("Success!");
----

....
Success!
....
